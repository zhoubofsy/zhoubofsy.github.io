<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhoubofsy.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在编写 Solidity 智能合约时，安全性是最重要的考虑因素之一。以下是开发中常见的安全问题及其解决方法： 重入攻击（Reentrancy Attack）https:&#x2F;&#x2F;zhoubofsy.github.io&#x2F;2024&#x2F;11&#x2F;28&#x2F;blockchain&#x2F;ethereum&#x2F;solidity-security-reentrancy-attack&#x2F; 溢出与下溢（Overflow and Underfl">
<meta property="og:type" content="article">
<meta property="og:title" content="solidity编程安全">
<meta property="og:url" content="http://zhoubofsy.github.io/2024/11/28/blockchain/ethereum/solidity-security/index.html">
<meta property="og:site_name" content="Bolog">
<meta property="og:description" content="在编写 Solidity 智能合约时，安全性是最重要的考虑因素之一。以下是开发中常见的安全问题及其解决方法： 重入攻击（Reentrancy Attack）https:&#x2F;&#x2F;zhoubofsy.github.io&#x2F;2024&#x2F;11&#x2F;28&#x2F;blockchain&#x2F;ethereum&#x2F;solidity-security-reentrancy-attack&#x2F; 溢出与下溢（Overflow and Underfl">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-11-28T06:20:13.000Z">
<meta property="article:modified_time" content="2024-12-04T07:00:42.469Z">
<meta property="article:author" content="博">
<meta property="article:tag" content="solidity">
<meta property="article:tag" content="security">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://zhoubofsy.github.io/2024/11/28/blockchain/ethereum/solidity-security/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>solidity编程安全 | Bolog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bolog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2024/11/28/blockchain/ethereum/solidity-security/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          solidity编程安全
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-28 14:20:13" itemprop="dateCreated datePublished" datetime="2024-11-28T14:20:13+08:00">2024-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-04 15:00:42" itemprop="dateModified" datetime="2024-12-04T15:00:42+08:00">2024-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在编写 Solidity 智能合约时，安全性是最重要的考虑因素之一。以下是开发中常见的安全问题及其解决方法：</p>
<h1 id="重入攻击（Reentrancy-Attack）"><a href="#重入攻击（Reentrancy-Attack）" class="headerlink" title="重入攻击（Reentrancy Attack）"></a>重入攻击（Reentrancy Attack）</h1><p><a href="https://zhoubofsy.github.io/2024/11/28/blockchain/ethereum/solidity-security-reentrancy-attack/">https://zhoubofsy.github.io/2024/11/28/blockchain/ethereum/solidity-security-reentrancy-attack/</a></p>
<h1 id="溢出与下溢（Overflow-and-Underflow）"><a href="#溢出与下溢（Overflow-and-Underflow）" class="headerlink" title="溢出与下溢（Overflow and Underflow）"></a>溢出与下溢（Overflow and Underflow）</h1><p><strong>溢出（Overflow）和下溢（Underflow）</strong>是指在处理整数运算时，当结果超出数据类型表示范围时，值会“环绕”到另一端。例如，对于 uint8 类型：</p>
<ul>
<li>溢出： uint8 的最大值是 255，如果执行 255 + 1，值会变为 0。</li>
<li>下溢： uint8 的最小值是 0，如果执行 0 - 1，值会变为 255。</li>
</ul>
<p>在早期的 Solidity 版本中，这种现象常导致严重漏洞，攻击者可以利用这种行为达到意想不到的目的。自 Solidity 0.8 开始，溢出和下溢会触发异常，但了解它们的历史以及如何防范仍然很重要。虽然Solidity 0.8开始增加了溢出检查，这也会导致Gas费用的增加。</p>
<p>在 Solidity 0.8+ 中，每次整数加减运算都会隐式包含溢出检查逻辑，而这种检查需要额外的操作指令，因此会增加运行时消耗的 gas。</p>
<p><strong>Solidity 0.8+</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract OverflowCheck &#123;</span><br><span class="line">    function add(uint256 a, uint256 b) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b; // 含溢出检查</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x00    PUSH1  0x60</span><br><span class="line">0x02    MSTORE</span><br><span class="line">0x03    CALLDATALOAD</span><br><span class="line">0x04    CALLDATALOAD</span><br><span class="line">0x05    ADD         // 加法</span><br><span class="line">0x06    JUMPI       // 检查溢出</span><br><span class="line">0x07    REVERT      // 如果溢出，回滚</span><br><span class="line">0x08    RETURN</span><br></pre></td></tr></table></figure>

<p><strong>Solidity 0.7</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.7.0;</span><br><span class="line"></span><br><span class="line">contract NoOverflowCheck &#123;</span><br><span class="line">    function add(uint256 a, uint256 b) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b; // 无溢出检查</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x00    PUSH1  0x60</span><br><span class="line">0x02    MSTORE</span><br><span class="line">0x03    CALLDATALOAD</span><br><span class="line">0x04    CALLDATALOAD</span><br><span class="line">0x05    ADD         // 直接加法</span><br><span class="line">0x06    RETURN</span><br></pre></td></tr></table></figure>

<ol>
<li>Solidity 0.8 的溢出检查增加了 ~50 gas 的开销。</li>
<li>增加的开销源于额外的汇编指令（JUMPI 和 REVERT）。</li>
<li>如果对 gas 成本敏感，可以使用 unchecked 块绕过检查，但需确保逻辑安全。</li>
</ol>
<h1 id="未检查的外部调用（Unchecked-External-Call）"><a href="#未检查的外部调用（Unchecked-External-Call）" class="headerlink" title="未检查的外部调用（Unchecked External Call）"></a>未检查的外部调用（Unchecked External Call）</h1><p>“未检查的外部调用”漏洞（Unchecked External Call）是 Solidity 智能合约中的一种常见安全问题。如果智能合约与外部地址交互（比如转账或调用另一个合约的函数）时未检查调用的结果，可能会引发意外的后果和漏洞利用。</p>
<h2 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h2><ol>
<li>失败的调用未被检测<br> 如果调用失败但未进行检查，合约可能会继续执行后续逻辑，从而导致不一致状态或意外行为。<br> 示例问题：转账操作失败，但余额已经从发送方扣除。</li>
<li>错误处理被忽略<br> 外部合约调用可能由于异常（例如合约不存在或代码逻辑错误）而失败。如果不检查返回值，调用方将无法正确处理这些失败。</li>
<li>逻辑漏洞导致资金损失<br> 如果未检查调用结果的返回值，攻击者可以通过故意设计失败的合约逻辑，扰乱调用方合约的资金或状态管理。</li>
<li>影响合约的可组合性<br> 在 DeFi 等应用场景中，不同合约之间通常会进行复杂交互。如果未正确检查外部调用的结果，会影响合约间的协作，甚至破坏整个生态系统的安全性。</li>
</ol>
<p><strong>漏洞示例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract UncheckedExternalCall &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    // 存款功能</span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提现功能，发送资金给用户</span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">        // 发送资金，但未检查返回值</span><br><span class="line">        payable(msg.sender).call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        // 更新余额</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>恶意示例代码</strong><br>攻击者可以部署一个恶意合约，故意使 call 失败（例如，使用耗尽 gas 的回退函数），从而导致 balances 状态不一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Malicious &#123;</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">    // 消耗所有 gas，故意让调用失败</span><br><span class="line">        while (true) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>显式检查 call 返回的布尔值，以确保调用成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint256 amount) public &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">    // 检查调用结果</span><br><span class="line">    (bool success, ) = payable(msg.sender).call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">    require(success, &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="随机数生成不安全"><a href="#随机数生成不安全" class="headerlink" title="随机数生成不安全"></a>随机数生成不安全</h1><h2 id="为什么Solidity-中随机数生成不安全？"><a href="#为什么Solidity-中随机数生成不安全？" class="headerlink" title="为什么Solidity 中随机数生成不安全？"></a>为什么Solidity 中随机数生成不安全？</h2><p>在 Solidity 中，常见的随机数生成方式（如依赖区块哈希、时间戳等）容易被攻击者预测或操控：</p>
<ol>
<li>区块哈希依赖（blockhash）： 区块哈希是公开信息，矿工可以选择不挖某些区块，进而影响生成的随机数。</li>
<li>时间戳依赖（block.timestamp）： 矿工可以小幅调整时间戳，使得随机数变为对其有利的值。</li>
<li>合约状态依赖（msg.sender, block.difficulty 等）： 合约状态和交易上下文的信息可以被预测和操控。</li>
</ol>
<p>这些方式在确定性（公开信息和上下文）和可操控性（矿工或攻击者干预）方面不安全。</p>
<h2 id="如何安全生成随机数？"><a href="#如何安全生成随机数？" class="headerlink" title="如何安全生成随机数？"></a>如何安全生成随机数？</h2><ol>
<li>Chainlink VRF:<ul>
<li>可证明公平且可验证的随机数生成器（RNG），它使智能合约能够在不影响安全性或可用性的情况下访问随机值。</li>
<li>建立区块链游戏和NFT</li>
<li>随机分配职责和资源。例如，随机分配法官到案件。</li>
<li>为共识机制选择一个具有代表性的样本。<br> 用法：<a target="_blank" rel="noopener" href="https://docs.chain.link/vrf/v2-5/getting-started">https://docs.chain.link/vrf/v2-5/getting-started</a></li>
</ul>
</li>
<li>Off-chain Randomness (链下随机数)：<ul>
<li>使用链下生成随机数（如通过服务器或 API），然后将结果提交到链上。</li>
<li>缺点：需要信任链下服务，可能会被操控。</li>
<li>改进：通过多方签名或可信执行环境（如 Intel SGX）生成。</li>
</ul>
</li>
<li>Threshold Signature Schemes (TSS)：<ul>
<li>多方合作生成随机数，每方只持有部分秘密信息。</li>
<li>优势：随机数完全由多方参与生成，无法单点操控。</li>
<li>使用场景：像 Chainlink 的去中心化预言机网络。</li>
</ul>
</li>
<li>VDF（Verifiable Delay Function）：<ul>
<li>一种不可预测的随机数生成方式，需要一定时间来计算结果。</li>
<li>优势：矿工无法提前操控随机数。</li>
<li>实现：Ethereum 2.0 的随机数生成设计中引入了 VDF。</li>
</ul>
</li>
</ol>
<h1 id="智能合约升级问题"><a href="#智能合约升级问题" class="headerlink" title="智能合约升级问题"></a>智能合约升级问题</h1><p>智能合约在部署后通常无法直接修改，这可能导致升级和维护困难。如果设计不当，可能需要完全重启项目，从而浪费资源并导致用户信任危机。</p>
<h2 id="解决方案-1：代理合约（Proxy-Pattern）"><a href="#解决方案-1：代理合约（Proxy-Pattern）" class="headerlink" title="解决方案 1：代理合约（Proxy Pattern）"></a>解决方案 1：代理合约（Proxy Pattern）</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>通过代理模式将合约分为两部分：</p>
<ol>
<li>代理合约（Proxy）： 存储状态变量，负责将用户请求委托给逻辑合约。</li>
<li>逻辑合约（Logic&#x2F;Implementation）： 包含实际的业务逻辑，可以升级和替换。</li>
</ol>
<p>用户总是与代理合约交互，代理通过 delegatecall 将调用转发到逻辑合约，使用代理合约的存储保持状态一致。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol>
<li>UUPS Proxy<ul>
<li>使用 upgradeTo 方法直接升级逻辑合约。</li>
<li>更加轻量，但需要实现升级逻辑。</li>
</ul>
</li>
<li>Transparent Proxy<ul>
<li>避免管理员调用代理时出现冲突。</li>
<li>管理员可升级逻辑合约，用户调用时自动转发。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Proxy &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    constructor(address _implementation) &#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external &#123;</span><br><span class="line">        (bool success, ) = implementation.delegatecall(msg.data);</span><br><span class="line">        require(success, &quot;Delegatecall failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgrade(address newImplementation) external &#123;</span><br><span class="line">        require(msg.sender == admin, &quot;Only admin can upgrade&quot;);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getData(uint256 _num) public pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encodeWithSignature(&quot;setNumber(uint256)&quot;, _num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v1)</span><br><span class="line">contract LogicV1 &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number) public &#123;</span><br><span class="line">        number = _number;</span><br><span class="line">        privateNum = _number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v2)</span><br><span class="line">contract LogicV2 &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number) public &#123;</span><br><span class="line">        number = _number * 2; // Updated logic</span><br><span class="line">        privateNum = _number * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>无需重新部署存储状态，升级逻辑灵活。</li>
<li>用户无感知升级操作。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>增加代码复杂度。</li>
</ul>
<h2 id="解决方案2：模块化合约（Modular-Contract）"><a href="#解决方案2：模块化合约（Modular-Contract）" class="headerlink" title="解决方案2：模块化合约（Modular Contract）"></a>解决方案2：模块化合约（Modular Contract）</h2><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>将合约分解为多个独立模块，所有模块通过核心合约（Registry 或 Router）进行管理。每个模块可单独替换而不影响整体功能。</p>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface ILOGIC &#123;</span><br><span class="line">    function setNumber(uint256 _number) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Router &#123;</span><br><span class="line">    mapping(string =&gt; address) public modules;</span><br><span class="line">    address public admin;</span><br><span class="line">    </span><br><span class="line">    constructor() &#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function updateModule(string memory moduleName, address moduleAddress) external &#123;</span><br><span class="line">        require(msg.sender == admin, &quot;Only admin can update&quot;);</span><br><span class="line">        modules[moduleName] = moduleAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setNumber(string memory moduleName, uint256 _num) external &#123;</span><br><span class="line">        address module = modules[moduleName];</span><br><span class="line">        require(module != address(0), &quot;Module not found&quot;);</span><br><span class="line">        ILOGIC(module).setNumber(_num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v1)</span><br><span class="line">contract LogicV1 is ILOGIC &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number) public  &#123;</span><br><span class="line">        number = _number;</span><br><span class="line">        privateNum = _number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v2)</span><br><span class="line">contract LogicV2 is ILOGIC &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number) public &#123;</span><br><span class="line">        number = _number * 2; // Updated logic</span><br><span class="line">        privateNum = _number * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>便于扩展新功能或模块。</li>
<li>每个模块的更新不会影响其他部分。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>初始设计复杂度较高。</li>
<li>需要额外存储模块地址。</li>
</ul>
<h2 id="解决方案-3：数据分离（Storage-Contract）"><a href="#解决方案-3：数据分离（Storage-Contract）" class="headerlink" title="解决方案 3：数据分离（Storage Contract）"></a>解决方案 3：数据分离（Storage Contract）</h2><h3 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h3><p>将状态数据和业务逻辑分离为两个独立合约：</p>
<ol>
<li>存储合约（Storage Contract）： 负责存储状态变量。</li>
<li>逻辑合约（Logic Contract）： 包含具体逻辑，可单独升级。</li>
</ol>
<h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><p><em>在上一个实现示例的基础上，进行存储合约和逻辑合约的分离。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface ISTORE &#123;</span><br><span class="line">    function setNumber(uint256 _number) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Store is ISTORE &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line"></span><br><span class="line">    function setNumber(uint256 _number) external &#123;</span><br><span class="line">        number = _number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ILOGIC &#123;</span><br><span class="line">    function setNumber(uint256 _number, ISTORE store) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Router &#123;</span><br><span class="line">    mapping(string =&gt; address) public modules;</span><br><span class="line">    address public admin;</span><br><span class="line">    ISTORE public store;</span><br><span class="line">    </span><br><span class="line">    constructor() &#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        store = new Store();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function updateModule(string memory moduleName, address moduleAddress) external &#123;</span><br><span class="line">        require(msg.sender == admin, &quot;Only admin can update&quot;);</span><br><span class="line">        modules[moduleName] = moduleAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setNumber(string memory moduleName, uint256 _num) external &#123;</span><br><span class="line">        address module = modules[moduleName];</span><br><span class="line">        require(module != address(0), &quot;Module not found&quot;);</span><br><span class="line">        ILOGIC(module).setNumber(_num, store);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v1)</span><br><span class="line">contract LogicV1 &#123;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number, ISTORE store) public  &#123;</span><br><span class="line">        store.setNumber(_number);</span><br><span class="line">        privateNum = _number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v2)</span><br><span class="line">contract LogicV2 is ILOGIC &#123;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number, ISTORE store) public  &#123;</span><br><span class="line">        store.setNumber(_number * 2);</span><br><span class="line">        privateNum = _number * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>清晰的数据和逻辑分离。</li>
<li>升级逻辑时不会影响存储。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>初次部署复杂。</li>
<li>存储和逻辑合约间的交互增加调用成本。</li>
</ul>
<h1 id="ERC20中“approve”无限授权的问题"><a href="#ERC20中“approve”无限授权的问题" class="headerlink" title="ERC20中“approve”无限授权的问题"></a>ERC20中“approve”无限授权的问题</h1><h2 id="竞争环境"><a href="#竞争环境" class="headerlink" title="竞争环境"></a>竞争环境</h2><h3 id="ERC20-的授权与竞争"><a href="#ERC20-的授权与竞争" class="headerlink" title="ERC20 的授权与竞争"></a>ERC20 的授权与竞争</h3><p><strong>假设场景</strong></p>
<p>假设有一个用户 Alice 和一个智能合约 Token，以及一个攻击者 Mallory。Alice 想通过 approve 函数授权 Mallory 代她消费代币。</p>
<p>初始状态：</p>
<p>Alice 的账户余额为 1000 个 Token。<br>Mallory 尚未获得任何授权。<br>Token 合约中的 approve 函数允许 Alice 授权 Mallory一定额度的代币。<br>Alice 执行以下两个交易：</p>
<p>approve(Mallory, 100); —— 授权 100 个代币。<br>想撤销授权后重新授权：approve(Mallory, 200); —— 授权 200 个代币。</p>
<p><strong>第一种竞争：在授权更新中被抢占</strong></p>
<p>在区块链网络中，交易可能存在提交和打包的时间差。</p>
<ol>
<li>交易流程：<ul>
<li>Alice 提交第一笔交易 approve(Mallory, 100)。</li>
<li>此时 Mallory 知道 Alice 即将授权 100，便迅速构造一个调用 transferFrom 的交易，试图转移代币。</li>
<li>在 Alice 提交第二笔交易 approve(Mallory, 200) 之前，Mallory 的交易被矿工打包处理。</li>
</ul>
</li>
<li>结果：<ul>
<li>Mallory 调用了 transferFrom，并转移了 100 个代币。</li>
<li>Alice 的第二笔交易（授权 200）覆盖了第一笔交易。</li>
<li>最终，Mallory不仅得到了 100，还能再次调用 transferFrom 转移额外的 200 个代币。</li>
</ul>
</li>
</ol>
<p><strong>第二种竞争：替代攻击</strong></p>
<p>以太坊允许用户在一笔交易未被确认前，用新的交易替换原交易（这被称为“交易替代”）。攻击者可以利用这种特性引发意外行为。</p>
<ol>
<li>交易流程：<ul>
<li>Alice 提交 approve(Mallory, 100)。</li>
<li>在这笔交易确认前，Alice 提交了一笔新的高 gas 交易 approve(Mallory, 0)。</li>
<li>Mallory发送了一笔高优先级 transferFrom 交易，与 Alice 的两笔交易竞争。</li>
</ul>
</li>
<li>结果：<ul>
<li>如果矿工按照特定顺序处理，Mallory 的 transferFrom 会先于 Alice 的 approve(Mallory, 0)。</li>
<li>最终，Mallory 成功提取了授权的 100 个代币，尽管 Alice 试图撤销授权。</li>
</ul>
</li>
</ol>
<p>尽管区块链中交易的执行是严格顺序的，但“竞争”主要源于交易在网络中传播和排序的行为。以下是两个核心原因：</p>
<ol>
<li>交易的传播和未确认状态：<ul>
<li>在用户提交交易后，交易需要传播到网络中，并等待矿工打包。</li>
<li>在交易被打包前的这段时间，其他用户或智能合约可以通过观察未确认交易，针对交易中暴露的状态进行恶意操作。</li>
</ul>
</li>
<li>矿工的交易排序权：<ul>
<li>矿工可以根据 gas 费优先级或其他策略排序交易。</li>
<li>攻击者可以支付更高的 gas，让他们的交易先执行，从而“抢占”状态更新。</li>
</ul>
</li>
</ol>
<h3 id="解决竞争"><a href="#解决竞争" class="headerlink" title="解决竞争"></a>解决竞争</h3><ol>
<li>增加原子性操作：<ul>
<li><p>将 approve 和 transferFrom 的逻辑合并为一个原子操作，避免多笔交易间的时间窗口。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function safeTransfer(address to, uint256 amount) public &#123;</span><br><span class="line">    approve(to, amount);</span><br><span class="line">    transferFrom(msg.sender, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用 increaseAllowance 和 decreaseAllowance：<ul>
<li>避免覆盖现有授权额度，消除修改竞态。</li>
</ul>
</li>
<li>限时授权：<ul>
<li>设置一个时间锁，授权只能在一段时间后生效。</li>
</ul>
</li>
</ol>
<h2 id="“approve”无限授权"><a href="#“approve”无限授权" class="headerlink" title="“approve”无限授权"></a>“approve”无限授权</h2><p>ERC20中“approve”无限授权的问题，其本质并不是单纯由于区块链上的竞争，而是 ERC20标准的设计缺陷与区块链环境特性结合 导致的。这种问题由两个关键因素共同作用引发：</p>
<ol>
<li><p>ERC20 标准中的设计缺陷</p>
<ul>
<li>在 ERC20 的 approve 方法中，没有提供一种明确的原子操作机制来更新授权额度。</li>
<li>在用户更改授权额度的过程中（如从 100 改为 200），攻击者可以利用时间窗口，通过 transferFrom 操作，在授权额度发生变化的过渡阶段恶意提取代币。</li>
</ul>
<p> <em>这个问题根源在于 approve 和 transferFrom 的设计缺乏配合机制，允许在两个操作之间发生不一致的状态。</em></p>
</li>
<li><p>区块链上的竞争特性</p>
<ul>
<li>交易传播时间差：当用户试图提交新授权（如 approve(Mallory, 200)），旧授权（如 approve(Mallory, 100)）仍然有效，且存在被利用的时间窗口。</li>
<li>矿工排序自由：攻击者可以观察到用户提交的 approve 交易，通过支付更高的 gas 优先让他们的交易 transferFrom 被打包，抢在用户的状态更新之前执行。</li>
</ul>
<p> <em>这两点特性导致 approve 无法原子更新的问题被放大，从而使攻击成为可能。</em></p>
</li>
</ol>
<h3 id="解决“approve”无限授权问题"><a href="#解决“approve”无限授权问题" class="headerlink" title="解决“approve”无限授权问题"></a>解决“approve”无限授权问题</h3><ol>
<li>增加 increaseAllowance 和 decreaseAllowance 方法</li>
</ol>
<p>通过调整现有额度而不是直接覆盖额度，可以避免授权被覆盖的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function increaseAllowance(address spender, uint256 addedValue) public returns (bool) &#123;</span><br><span class="line">    allowance[msg.sender][spender] += addedValue;</span><br><span class="line">    emit Approval(msg.sender, spender, allowance[msg.sender][spender]);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) &#123;</span><br><span class="line">    require(allowance[msg.sender][spender] &gt;= subtractedValue, &quot;Decreased allowance below zero&quot;);</span><br><span class="line">    allowance[msg.sender][spender] -= subtractedValue;</span><br><span class="line">    emit Approval(msg.sender, spender, allowance[msg.sender][spender]);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原子操作结合转账</li>
</ol>
<p>通过单一交易完成授权和转账，避免分离操作引入的时间窗口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function safeTransferFrom(address from, address to, uint256 amount) public &#123;</span><br><span class="line">    require(allowance[from][msg.sender] &gt;= amount, &quot;Allowance exceeded&quot;);</span><br><span class="line">    allowance[from][msg.sender] -= amount;</span><br><span class="line">    balanceOf[from] -= amount;</span><br><span class="line">    balanceOf[to] += amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ERC20 中“approve”无限授权的问题，并不完全是由于区块链竞争特性，而是由 授权更新的非原子性设计 和 区块链上交易排序特性 共同导致的。优化方法可以从改进 ERC20 的逻辑（如 increaseAllowance），有效解决这一问题。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/solidity/" rel="tag"># solidity</a>
              <a href="/tags/security/" rel="tag"># security</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/11/26/blockchain/ethereum/erc20-openzeppelin/" rel="prev" title="OpenZeppelin ERC-20 详解">
      <i class="fa fa-chevron-left"></i> OpenZeppelin ERC-20 详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/11/28/blockchain/ethereum/solidity-security-reentrancy-attack/" rel="next" title="重入攻击">
      重入攻击 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%88Reentrancy-Attack%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">重入攻击（Reentrancy Attack）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E4%B8%8E%E4%B8%8B%E6%BA%A2%EF%BC%88Overflow-and-Underflow%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">溢出与下溢（Overflow and Underflow）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AA%E6%A3%80%E6%9F%A5%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%EF%BC%88Unchecked-External-Call%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">未检查的外部调用（Unchecked External Call）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BD%9C%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">潜在问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">4.</span> <span class="nav-text">随机数生成不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Solidity-%E4%B8%AD%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">为什么Solidity 中随机数生成不安全？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">如何安全生成随机数？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">智能合约升级问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1%EF%BC%9A%E4%BB%A3%E7%90%86%E5%90%88%E7%BA%A6%EF%BC%88Proxy-Pattern%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">解决方案 1：代理合约（Proxy Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.2.</span> <span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8C%96%E5%90%88%E7%BA%A6%EF%BC%88Modular-Contract%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">解决方案2：模块化合约（Modular Contract）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">5.2.2.</span> <span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%EF%BC%88Storage-Contract%EF%BC%89"><span class="nav-number">5.3.</span> <span class="nav-text">解决方案 3：数据分离（Storage Contract）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="nav-number">5.3.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">5.3.2.</span> <span class="nav-text">具体实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ERC20%E4%B8%AD%E2%80%9Capprove%E2%80%9D%E6%97%A0%E9%99%90%E6%8E%88%E6%9D%83%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">ERC20中“approve”无限授权的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89%E7%8E%AF%E5%A2%83"><span class="nav-number">6.1.</span> <span class="nav-text">竞争环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ERC20-%E7%9A%84%E6%8E%88%E6%9D%83%E4%B8%8E%E7%AB%9E%E4%BA%89"><span class="nav-number">6.1.1.</span> <span class="nav-text">ERC20 的授权与竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E7%AB%9E%E4%BA%89"><span class="nav-number">6.1.2.</span> <span class="nav-text">解决竞争</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9Capprove%E2%80%9D%E6%97%A0%E9%99%90%E6%8E%88%E6%9D%83"><span class="nav-number">6.2.</span> <span class="nav-text">“approve”无限授权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E2%80%9Capprove%E2%80%9D%E6%97%A0%E9%99%90%E6%8E%88%E6%9D%83%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.1.</span> <span class="nav-text">解决“approve”无限授权问题</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">博</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">148</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">123</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">博</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'Iv1.9c9e3f90ac2cc9f9',
      clientSecret: '478f8511687999ac85664313c08c94a1420e13f6',
      repo        : 'zhoubofsy.github.io',
      owner       : 'zhoubofsy',
      admin       : ['zhoubofsy'],
      id          : '03eeb5c4c3bc513b2ff02ddc78105824',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
