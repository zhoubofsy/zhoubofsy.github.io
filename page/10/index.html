<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhoubofsy.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Bolog">
<meta property="og:url" content="http://zhoubofsy.github.io/page/10/index.html">
<meta property="og:site_name" content="Bolog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="博">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://zhoubofsy.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Bolog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bolog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2017/01/31/container/docker/docker-frame/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/31/container/docker/docker-frame/" class="post-title-link" itemprop="url">Docker架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-31 14:57:35" itemprop="dateCreated datePublished" datetime="2017-01-31T14:57:35+08:00">2017-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/container/" itemprop="url" rel="index"><span itemprop="name">container</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker历史"><a href="#Docker历史" class="headerlink" title="Docker历史"></a>Docker历史</h1><h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>Docker 1.2</p>
<h1 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1><p>Docker对使用者来说是一个C&#x2F;S模式的架构，S端采用松耦合架构，各模块有机组合并支撑Docker运行。</p>
<p><img src="/images/docker/docker-frame-main.jpg" alt="docker-frame-main"></p>
<p>用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。<br>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。<br>libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。<br>当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。</p>
<h1 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h1><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>Docker Client可以通过以下三种方式和Docker Daemon建立通信：tcp:&#x2F;&#x2F;host:port，unix:&#x2F;&#x2F;path_to_socket和fd:&#x2F;&#x2F;socketfd。Docker Client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。<br>Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。当需要继续发送容器管理请求时，用户必须再次通过docker可执行文件创建Docker Client。</p>
<h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>接受并处理Docker Client发送的请求。该守护进程在后台启动了一个Server，Server负责接受Docker Client发送的请求；接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。</p>
<p><img src="/images/docker/docker-frame-daemon-main.jpg" alt="docker-frame-daemon-main"><br>Docker Daemon的大致可以分为三部分：Docker Server、Engine和Job。</p>
<ul>
<li><p>Docker Server<br>  专门服务于Docker Client的server。接受并调度分发Docker Client发送的请求。<br>  <img src="/images/docker/docker-frame-daemon-server.jpg" alt="docker-frame-daemon-server"><br>  通过包gorilla&#x2F;mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla&#x2F;mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。</p>
</li>
<li><p>Docker Engine<br>  Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。</p>
</li>
<li><p>Docker Job<br>  一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。</p>
</li>
</ul>
<h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。<br>在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。</p>
<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><p>已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。</p>
<p><img src="/images/docker/docker-frame-graph-main.jpg" alt="docker-frame-graph-main"></p>
<ul>
<li>GraphDB<br>  一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。</li>
<li>Repository<br>  关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</li>
</ul>
<h2 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h2><p>通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。<br>在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。</p>
<h3 id="graphdriver"><a href="#graphdriver" class="headerlink" title="graphdriver"></a>graphdriver</h3><p>graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。</p>
<p><img src="/images/docker/docker-frame-graphdriver-main.jpg" alt="docker-frame-graphdriver-main"></p>
<p>在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。</p>
<h3 id="networkdriver"><a href="#networkdriver" class="headerlink" title="networkdriver"></a>networkdriver</h3><p>networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。</p>
<p><img src="/images/docker/docker-frame-networkdriver-main.jpg" alt="docker-frame-networkdriver-main"></p>
<h3 id="execdriver"><a href="#execdriver" class="headerlink" title="execdriver"></a>execdriver</h3><p>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。</p>
<p><img src="/images/docker/docker-frame-execdriver-main.jpg" alt="docker-frame-execdriver-main"></p>
<h2 id="libcontainer"><a href="#libcontainer" class="headerlink" title="libcontainer"></a>libcontainer</h2><p>bcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。</p>
<p><img src="/images/docker/docker-frame-libcontainer-main.jpg" alt="docker-frame-libcontainer-main"></p>
<h2 id="Docker-container"><a href="#Docker-container" class="headerlink" title="Docker container"></a>Docker container</h2><p>Todo…</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p><img src="/images/docker/docker-flow-pull.jpg" alt="docker-flow-pull"></p>
<h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><p><img src="/images/docker/docker-flow-run.jpg" alt="docker-flow-run"></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/docker-source-code-analysis-part1/">Docker源码分析（一）：Docker架构</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2017/01/31/container/k8s/k8s-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/31/container/k8s/k8s-introduce/" class="post-title-link" itemprop="url">Kubernetes介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-31 10:44:57" itemprop="dateCreated datePublished" datetime="2017-01-31T10:44:57+08:00">2017-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/container/" itemprop="url" rel="index"><span itemprop="name">container</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Kubernetes是为生产环境而设计的容器调度管理系统，对于负载均衡、服务发现、高可用、滚动升级、自动伸缩等容器云平台的功能要求有原生支持。由于Kubernetes在K和s间有8个字母，因此常简称K8s。事实上，随着对K8s系统架构与设计理念的了解深入，我们会发现K8s系统正是处处为运行云原生应用而设计考虑；同时，随着对K8s系统使用的加深和加广，也会有越来越多有关云原生应用的设计模式产生出来，使得基于K8s系统设计和开发生产级的复杂云原生应用变得像启动一个单机版容器服务那样简单易用。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>一个K8s集群是由etcd（分布式存储）、Minion&#x2F;node（服务节点）、Master（控制节点）构成的。集群状态都保存在etcd中，Master节点上则运行集群的管理控制模块，多个Master节点以Active&#x2F;Standby方式运行。Minion节点是真正运行应用容器的主机节点，在每个Minion节点上都会运行一个Kubelet代理，控制该节点上的容器、镜像和存储卷等。</p>
<p><img src="/images/k8s/k8s_frame.png" alt="k8s_frame"></p>
<h2 id="Master中模块"><a href="#Master中模块" class="headerlink" title="Master中模块"></a>Master中模块</h2><h3 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h3><pre><code>Kubernetes系统的入口，其封装了核心对象的增删改查操作，以RESTful API接口方式提供给外部客户和内部组件调用。维护的REST对象持久化到Etcd中存储。
</code></pre>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><pre><code>为新建立的Pod进行节点选择(即分配机器)，负责集群的资源调度。组件抽离，可以方便替换成其他调度器。
</code></pre>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul>
<li>Replication Controller(RC)<br>  保证定义的副本数量与实际运行Pod数量一致。</li>
<li>Node Controller<br>  管理维护Minion／node，定期检查Node的健康状态，标识出(失效|未失效)的节点。</li>
<li>Namespace Controller<br>  管理维护Namespace，定期清理无效的Namespace。</li>
<li>Service Controller<br>  Todo…</li>
<li>EndPoints Controller<br>  Todo…</li>
<li>Service Account Controller<br>  Todo…</li>
<li>Persistent Volume Controller<br>  Todo…</li>
<li>Daemon Set Controller<br>  管理维护Daemon Set，负责创建Daemon Pod，保证指定的Node上正常的运行Daemon Pod。</li>
<li>Deployment Controller<br>  Todo…</li>
<li>Job Controller<br>  管理维护Job，为Jod创建一次性任务Pod，保证完成Job指定完成的任务数目</li>
<li>Pod Autoscaler Controller<br>  实现Pod的自动伸缩，定时获取监控数据，进行策略匹配，当满足条件时执行Pod的伸缩动作。</li>
</ul>
<h2 id="Minion中模块"><a href="#Minion中模块" class="headerlink" title="Minion中模块"></a>Minion中模块</h2><h3 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h3><p>负责管控容器，Kubelet会从Kubernetes API Server接收Pod的创建请求，启动和停止容器，监控容器运行状态并汇报给Kubernetes API Server。</p>
<h3 id="Kube-proxy"><a href="#Kube-proxy" class="headerlink" title="Kube proxy"></a>Kube proxy</h3><p>Kube-proxy是K8s集群内部的负载均衡器。它是一个分布式代理服务器，在K8s的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod对多容器的支持是K8最基础的设计理念。Pod是K8s集群中所有业务类型的基础，目前K8s中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application），分别对应控制器为Deployment Controller、Job Controller、Daemon Set Controller、Pet Set Controller</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/horsefoot/article/details/52221706">Kubernetes的系统架构与设计理念</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xkops/p/6165565.html">k8s入门系列之介绍篇</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jianyuan/p/5063530.html">Docker系列(八)Kubernetes介绍</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2017/01/25/container/docker/docker-resource-separation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/25/container/docker/docker-resource-separation/" class="post-title-link" itemprop="url">docker 资源隔离</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-25 14:44:23" itemprop="dateCreated datePublished" datetime="2017-01-25T14:44:23+08:00">2017-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/container/" itemprop="url" rel="index"><span itemprop="name">container</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>docker不是一项新技术，docker是老旧技术的组合，为了更方便使用容器技术，docker提供了简单方便的UI。docker隔离资源主要用到了两种技术namespace、cgroup。</p>
<h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h1><p>namespace是linux内核提供的隔离技术，它包括六种资源隔离，UTS（主机名与域名）、IPC（信号量、消息队列和共享内存）、PID（进程编号）、NET（网络设备、网络栈、端口…）、Mount（文件系统、挂载点）、User（用户和用户组）。</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Sys Params</th>
<th align="center">ker ver</th>
</tr>
</thead>
<tbody><tr>
<td align="center">UTS</td>
<td align="center">CLONE_NEWUTS</td>
<td align="center">2.6.19</td>
</tr>
<tr>
<td align="center">IPC</td>
<td align="center">CLONE_NEWIPC</td>
<td align="center">2.6.19</td>
</tr>
<tr>
<td align="center">PID</td>
<td align="center">CLONE_NEWPID</td>
<td align="center">2.6.24</td>
</tr>
<tr>
<td align="center">NET</td>
<td align="center">CLONE_NEWNET</td>
<td align="center">2.6.29</td>
</tr>
<tr>
<td align="center">Mount</td>
<td align="center">CLONE_NEWNS</td>
<td align="center">2.4.19</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">CLONE_NEWUSER</td>
<td align="center">3.8</td>
</tr>
</tbody></table>
<p>操作系统调用接口：</p>
<ul>
<li>clone()<br>  创建一个独立的进程独立的namespace</li>
<li>setns()<br>  使用已有的一个namespace</li>
<li>unshare()<br>  不启动新进程，在原进程上进行namespace隔离</li>
</ul>
<p>docker run中提供了使用namespace的接口:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run --<span class="built_in">help</span> | grep -i namespace</span></span><br><span class="line">--ipc string                  IPC namespace to use</span><br><span class="line">--pid string                  PID namespace to use</span><br><span class="line">--userns string               User namespace to use</span><br><span class="line">--uts string                  UTS namespace to use</span><br></pre></td></tr></table></figure>

<h2 id="UTS"><a href="#UTS" class="headerlink" title="UTS"></a>UTS</h2><p>提供了主机名和域名的隔离，这样每个容器就可以拥有了独立的主机名和域名，在网络上可以被视作一个独立的节点而非宿主机上的一个进程。<br>docker在run或create时，使用<code>-h</code>或<code>--hostname</code>指定hostname</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>IPC是Unix／linux下进程间通讯的一种方式，包括信号量、消息队列、共享内存。容器内部进程间通信对宿主机来说，实际上是具有相同PID namespace中的进程间通信，因此需要一个唯一的标识符来进行区别。申请IPC资源就申请了这样一个全局唯一的32位ID，所以IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，而与其他的IPC namespace下的进程则互相不可见。</p>
<p>在宿主机上创建IPC（以消息队列为例）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipcmk -Q</span></span><br><span class="line">消息队列 id：32768</span><br></pre></td></tr></table></figure>
<p>在宿主机上查询IPC：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipcs</span></span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息</span><br><span class="line">0xabba8164 32768      root       644        0            0</span><br></pre></td></tr></table></figure>
<p>在容器中查询IPC：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span> -it net_5 ipcs</span></span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line"></span><br><span class="line">------ Semaphore Arrays --------</span><br><span class="line">key        semid      owner      perms      nsems</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h2><p>它对进程PID重新标号，即两个不同namespace下的进程可以有同一个PID。每个PID namespace都有自己的计数程序。内核为所有的PID namespace维护了一个树状结构，最顶层的是系统初始时创建的，我们称之为root namespace。他创建的新PID namespace就称之为child namespace（树的子节点），而原先的PID namespace就是新创建的PID namespace的parent namespace（树的父节点）。通过这种方式，不同的PID namespaces会形成一个等级体系。所属的父节点可以看到子节点中的进程，并可以通过信号等方式对子节点中的进程产生影响。反过来，子节点不能看到父节点PID namespace中的任何内容。<br>    * 每个PID namespace中的第一个进程“PID 1“，都会像传统Linux中的init进程一样拥有特权，起特殊作用。<br>    * 一个namespace中的进程，不可能通过kill或ptrace影响父节点或者兄弟节点中的进程，因为其他节点的PID在这个namespace中没有任何意义。<br>    * 如果你在新的PID namespace中重新挂载&#x2F;proc文件系统，会发现其下只显示同属一个PID namespace中的其他进程。（挂载&#x2F;proc 文件系统尤为重要）<br>    * 在root namespace中可以看到所有的进程，并且递归包含所有子节点中的进程。</p>
<p><img src="/images/docker/docker-resource-separation-pid.png" alt="docker-resource-separation-pid"></p>
<p>以容器的ceph-mon节点为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">宿主机上查看 ceph-mon 进程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps -ef| grep 9184</span></span><br><span class="line">root      9184  3122  0 1月20 ?       00:00:04 docker-containerd-shim be0583fade06df3f6510dd629bde4a636e68c755aa8b0733db6702493b1d0c38 /var/run/docker/libcontainerd/be0583fade06df3f6510dd629bde4a636e68c755aa8b0733db6702493b1d0c38 docker-runc</span><br><span class="line">64045     9200  9184  0 1月20 ?       00:01:03 /usr/bin/ceph-mon --cluster ceph -d -i rhel82 --public-addr 192.168.1.82:6789 --setuser ceph --setgroup ceph</span><br><span class="line">root     21893  9855  0 16:15 pts/5    00:00:00 grep --color=auto 9184</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器中查看 ceph-mon 进程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span> -it ceph-mon ps -ef</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">ceph         1     0  0 Jan20 ?        00:01:03 /usr/bin/ceph-mon --cluster ceph</span><br><span class="line">root        26     0  0 08:15 ?        00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<h2 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h2><p>Pv4和IPv6协议栈、IP路由表、防火墙、&#x2F;proc&#x2F;net目录、&#x2F;sys&#x2F;class&#x2F;net目录、端口（socket）等等。一个物理的网络设备最多存在在一个network namespace中，你可以通过创建veth pair（虚拟网络设备对：有两端，类似管道，如果数据从一端传入另一端也能接收到，反之亦然）在不同的network namespace间创建通道，以此达到通信的目的。</p>
<p>一般情况下，物理网络设备都分配在最初的root namespace（表示系统默认的namespace，在PID namespace中已经提及）中。但是如果你有多块物理网卡，也可以把其中一块或多块分配给新创建的network namespace。需要注意的是，当新创建的network namespace被释放时（所有内部的进程都终止并且namespace文件没有被挂载或打开），在这个namespace中的物理网卡会返回到root namespace而非创建该进程的父进程所在的network namespace。</p>
<p>当我们说到network namespace时，其实我们指的未必是真正的网络隔离，而是把网络独立出来，给外部用户一种透明的感觉，仿佛跟另外一个网络实体在进行通信。为了达到这个目的，容器的经典做法就是创建一个veth pair，一端放置在新的namespace中，通常命名为eth0，一端放在原先的namespace中连接物理网络设备，再通过网桥把别的设备连接进来或者进行路由转发，以此网络实现通信的目的。</p>
<p><img src="/images/docker/docker-resource-separation-network.png" alt="docker-resource-separation-network"></p>
<p>可通过<code>ip netns</code>、<code>brctl</code>管理Network Namespace，docker创建的netns路径为<code>/proc/&#123;进程ID&#125;/ns/net</code>，<code>ip netns</code>访问的默认路径为<code>/var/run/netns/</code>。<br>若需要访问其Network Namespace内部，先创建软连接链至<code>ip netns</code>访问路径，然后使用<code>ip netns exec</code>访问该网络内部。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在ip netns访问路径下创建network namespace的软链接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s /proc/7013/ns/net /var/run/netns/net_5</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 ip netns <span class="built_in">exec</span> 访问指定network namespace的网络</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip netns <span class="built_in">exec</span> net_5 ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default</span><br><span class="line">  link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">  inet 127.0.0.1/8 scope host lo</span><br><span class="line">  valid_lft forever preferred_lft forever</span><br><span class="line">  inet6 ::1/128 scope host</span><br><span class="line">  valid_lft forever preferred_lft forever</span><br><span class="line">15: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">  link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">  inet 172.17.0.3/16 scope global eth0</span><br><span class="line">  valid_lft forever preferred_lft forever</span><br><span class="line">  inet6 fe80::42:acff:fe11:3/64 scope link</span><br><span class="line">  valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<h2 id="Mount"><a href="#Mount" class="headerlink" title="Mount"></a>Mount</h2><p>隔离后，不同mount namespace中的文件结构发生变化也互不影响。你可以通过<code>/proc/[pid]/mounts</code>查看到所有挂载在当前namespace中的文件系统，还可以通过<code>/proc/[pid]/mountstats</code>看到mount namespace中文件设备的统计信息，包括挂载文件的名字、文件系统类型、挂载位置等等。（此处用到了<a href="https://zhoubofsy.github.io/2017/01/24/linux/mount-usage/">mount propagation </a> 技术）</p>
<p><img src="/images/docker/docker-resource-separation-mount.png" alt="docker-resource-separation-mount.png"><br>上图mount挂载方式有待确认。</p>
<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>主要隔离了安全相关的标识符（identifiers）和属性（attributes），包括用户ID、用户组ID、root目录、key（指密钥）以及特殊权限。说得通俗一点，一个普通用户的进程通过clone()创建的新进程在新user namespace中可以拥有不同的用户和用户组。这意味着一个进程在容器外属于一个没有特权的普通用户，但是他创建的容器进程却属于拥有所有权限的超级用户，这个技术为容器提供了极大的自由。</p>
<p>docker通过<code>/proc/&#123;进程ID&#125;/uid_map</code>和<code>/proc/&#123;进程ID&#125;/gid_map</code>把容器中的uid、gid和真实系统的uid、gid给映射在一起，格式为：<code>ID-inside-ns   ID-outside-ns   length</code>。</p>
<ul>
<li>ID-inside-ns 表示在容器内显示的uid或gid</li>
<li>ID-outside-ns 表示在容器外映射的真实的uid或gid</li>
<li>length 表示映射范围，一般为1，表示一一对应(把ID-outside-ns ~（ID-outside-ns+length） 映射到 ID-inside-ns ～（ID-inside-ns+length）上)</li>
</ul>
<h1 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h1><p>Control Groups(cgroups)，是Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源(如 cpu、memory、磁盘IO等等) 的机制，被LXC、docker等很多项目用于实现进程资源控制。</p>
<p>cgroups子系统：</p>
<ul>
<li>cpu<br>  使用调度程序提供对 CPU 的 cgroup 任务访问</li>
<li>cpuset<br>  为cgroup中的任务分配独立CPU（在多核系统）和内存节点</li>
<li>devices<br>  可允许或者拒绝 cgroup 中的任务访问设备</li>
<li>blkio<br>  为块设备设定输入&#x2F;输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）</li>
<li>freezer<br>  挂起或者恢复 cgroup 中的任务</li>
<li>memory<br>  设定 cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告</li>
<li>net_cls<br>  使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包</li>
</ul>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="cpu-shares"><a href="#cpu-shares" class="headerlink" title="cpu-shares"></a>cpu-shares</h3><p>在<code>docker create/run</code>容器时可以通过<code>--cpu-shares</code>参数来指定容器所使用的CPU加权值。默认情况下，每个docker容器的cpu-shares值都是1024。单独一个容器的cpu-shares是没有意义的，只在多个容器分配的资源紧缺时，也就是说在需要对容器使用的资源进行限制时，才会生效。配之后，可通过<code>./cgroup/cpu/docker/&lt;容器ID&gt;/cpu.shares</code>查看。</p>
<h3 id="cpu-period-cpu-quota"><a href="#cpu-period-cpu-quota" class="headerlink" title="cpu-period &amp; cpu-quota"></a>cpu-period &amp; cpu-quota</h3><ul>
<li>cpu-period 用来指定容器对CPU的使用要在多长时间内做一次重新分配</li>
<li>cpu-quota 用来指定在这个周期内，最多可以有多少时间用来跑这个容器<br>在<code>docker create/run</code>时使用，参数为<code>--cpu-period</code>和<code>--cpu-quota</code>单位为微秒，cpu-period的默认值为0.1秒（100000 微秒），cpu-quota的默认值为-1(表示不控制)。配置后，可通过<code>./cgroup/cpu/docker/&lt;容器ID&gt;/cpu.cfs_period_us</code>和<code>./cgroup/cpu/docker/&lt;容器ID&gt;/cpu.cfs_quota_us</code>查看。</li>
</ul>
<h3 id="cpuset"><a href="#cpuset" class="headerlink" title="cpuset"></a>cpuset</h3><p>docker可使用<code>--cpuset-cpus</code>和<code>--cpuset-mems</code>参数控制容器运行限定使用哪些cpu和内存节点。配之后，可通过<code>./cgroup/cpuset/docker/&lt;容器ID&gt;/cpuset.cpus</code>和<code>./cgroup/cpuset/docker/&lt;容器ID&gt;/cpuset.mems</code>查看。</p>
<p>*** 注：对于具有NUMA的服务器很重要 ***</p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>在<code>docker create/run</code>时，可以对内存资源加以限制。</p>
<ul>
<li>kernel-memory<br>  使用参数<code>--kernel-memory</code>，限制内核内存，该内存不会被交换到swap上。</li>
<li>memory<br>  使用参数<code>--memory</code>，设置容器使用的最大内存上限。默认单位为byte，可以使用K、G、M等带单位的字符串。</li>
<li>memory-reservation<br>  使用参数<code>--memory-reservation</code>，启用弹性的内存共享，当宿主机资源充足时，允许容器尽量多地使用内存，当检测到内存竞争或者低内存时，强制将容器的内存降低到memory-reservation所指定的内存大小。不设置此选项时，有可能出现某些容器长时间占用大量内存，导致性能上的损失。</li>
<li>memory-swap<br>  使用参数<code>--memory-swap</code>，设置总内存大小，相当于内存和swap大小的总和，设置-1时，表示swap分区大小是无限的。默认单位为byte，可以使用K、G、M等带单位的字符串。</li>
<li>memory-swappiness<br>  使用参数<code>--memory-swappiness</code>，设置控制进程将物理内存交换到swap分区的倾向，系数越小，就越倾向于使用物理内存。值范围为0-100。当值为100时，表示尽量使用swap分区；当值为0时，表示禁用容器 swap 功能(这点不同于宿主机，宿主机 swappiness 设置为 0 也不保证 swap 不会被使用)</li>
</ul>
<h2 id="Block-Device"><a href="#Block-Device" class="headerlink" title="Block Device"></a>Block Device</h2><h3 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><ul>
<li>device-read-bps<br>  限制此设备上的读速度（bytes per second），单位可以是kb、mb或者gb</li>
<li>device-read-iops<br>  通过每秒读IO次数来限制指定设备的读速度</li>
<li>device-write-bps<br>  限制此设备上的写速度（bytes per second），单位可以是kb、mb或者gb</li>
<li>device-write-iops<br>  通过每秒写IO次数来限制指定设备的写速度</li>
<li>blkio-weight<br>  容器默认磁盘IO的加权值，有效值范围为10-100。要使<code>-–blkio-weight</code>生效，需要保证IO的调度算法为CFQ<br>  <code>echo &quot;cfq&quot; &gt; /sys/block/&lt;设备名&gt;/queue/scheduler</code></li>
<li>blkio-weight-device<br>  针对特定设备的IO加权控制。其格式为DEVICE_NAME:WEIGHT</li>
</ul>
<h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>使用参数<code>--storage-opt</code>，传入<code>dm.basesize=&lt;容量大小&gt;</code>可以设置rootfs大小。如果不设置<code>dm.basesize</code>，默认值为10G，若要使<code>dm.basesize</code>生效，storage driver 必须是 device mapper。<br>设置rootfs大小后，需要重启docker服务，并且<code>--storage-opts</code>参数需要在启动docker服务时使用。<br>以RHEL7.2为例，需要修改<code>/etc/systemd/system/multi-user.target.wants/docker.service</code>中<code>/usr/bin/dockerd</code>的参数。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation?utm_source=tuicool">Docker背后的内核知识——Namespace资源隔离</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/sammyliu/p/5878973.html">理解Docker（3）：Docker 使用 Linux namespace 隔离容器的运行环境</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ilinuxer/p/6188450.html">Linux Namespace 介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006913195">Linux Namespace系列（07）：user namespace (CLONE_NEWUSER) (第一部分)</a></li>
<li><a target="_blank" rel="noopener" href="http://www.07net01.com/2017/01/1778663.html">理解Docker容器网络之Linux Network Namespace</a></li>
<li><a target="_blank" rel="noopener" href="http://coolshell.cn/articles/17010.html">DOCKER基础技术：LINUX NAMESPACE（上）</a></li>
<li><a target="_blank" rel="noopener" href="http://coolshell.cn/articles/17029.html">DOCKER基础技术：LINUX NAMESPACE（下）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-20788636-id-5029770.html">调整docker中rootfs的分区大小</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/horsefoot/article/details/51731543">docker容器资源配额控制</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2017/01/24/linux/mount-usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/24/linux/mount-usage/" class="post-title-link" itemprop="url">mount更多用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-24 10:42:35" itemprop="dateCreated datePublished" datetime="2017-01-24T10:42:35+08:00">2017-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>每一个使用linux或类unix系统的人都会用到的命令mount，它用来挂载／卸载文件系统。这是该命令基本功能，除了基本功能该命令还有其它功能。</p>
<h1 id="更多多多多多多多多多多多多多多多用法"><a href="#更多多多多多多多多多多多多多多多用法" class="headerlink" title="更多多多多多多多多多多多多多多多用法"></a>更多多多多多多多多多多多多多多多用法</h1><h2 id="绑定挂载-bind-mount"><a href="#绑定挂载-bind-mount" class="headerlink" title="绑定挂载(bind mount)"></a>绑定挂载(bind mount)</h2><p>windows的快捷方式、linux的软硬链接，相信你已很熟悉了，下面我来说说mount的绑定挂载<code>--bind</code>。</p>
<p>linux的软硬链接原理:<br><img src="/images/linux/soft_hard_link.jpg" alt="原理图"></p>
<ul>
<li>软连接受应用程序影响，不是所有应用程序都能通过软连接访问资源的</li>
<li>硬链接只能作用在文件上，不能为文件夹创建硬链接</li>
</ul>
<p>bind mount:<br>能成功克服软硬链接的缺点，将文件或文件夹挂载到指定的挂载点上。使对挂载点的操作转移到文件或文件夹上。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"> # </span><span class="language-bash"><span class="built_in">ls</span> -li uts*</span></span><br><span class="line">583819234 -rw-r--r--. 1 root root 4 1月  23 16:55 uts</span><br><span class="line">606248334 -rw-r--r--. 1 root root 2 1月  23 10:44 uts2</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">mount --<span class="built_in">bind</span> ./uts2 ./uts</span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash"><span class="built_in">ls</span> -li uts*</span></span><br><span class="line">606248334 -rw-r--r--. 1 root root 2 1月  23 10:44 uts</span><br><span class="line">606248334 -rw-r--r--. 1 root root 2 1月  23 10:44 uts2</span><br></pre></td></tr></table></figure>
<p>uts的inode变成了，uts2的inode id，所有访问uts的io都会转移到uts2上；并且在mount中能查看到<code>bind mount</code>信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">mount</span></span><br><span class="line">...</span><br><span class="line">/dev/mapper/rhel_rhel82-root on /home/zhoub/uts type xfs (rw,relatime,seclabel,attr2,inode64,noquota)</span><br></pre></td></tr></table></figure>
<p><code>bind mount</code>是用挂载文件或目录信息遮盖了挂载的文件或目录，当不需要时，可以通过<code>umount</code>卸载，恢复原文件或目录的信息。</p>
<h2 id="挂载传播-mount-propagation"><a href="#挂载传播-mount-propagation" class="headerlink" title="挂载传播(mount propagation)"></a>挂载传播(mount propagation)</h2><p>执行<code>clone()</code>时，进程拷贝当前文件系统树，此后，新进程就拥有与原进程相同的文件系统树拷贝，两个文件系统树中的任何挂载操作都不会影响另一个拷贝。尽管每个进程使用单独的文件系统名称空间在理论上非常有意义，但完全隔离也会造成较大限制性。进程克隆了系统的文件系统名称空间之后，已经运行的系统守护进程无法为这个用户自动挂载 CD-ROM，因为在原文件系统名称空间中执行的挂载无法影响用户的拷贝。2006 年引入的挂载传播（mount propagation）解决了这个问题，挂载传播定义了挂载对象之间的关系。</p>
<ul>
<li>共享挂载(share mount)<br>  如果两个挂载对象具有共享关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，反之亦然<br>  <code>mount --make-shared &lt;mount-object&gt;</code><br>  <code>mount --make-rshared &lt;mount-object&gt;</code></li>
<li>从属挂载(slave mount)<br>  如果两个挂载对象形成从属（slave）关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，但是反过来不行；在这种关系中，从属对象是事件的接收者<br>  <code>mount --make-slave &lt;mount-object&gt;</code></li>
<li>私有挂载(private mount)<br>  既不传播也不接收挂载事件<br>  <code>mount --make-private &lt;mount-object&gt;</code></li>
<li>不可绑定挂载(unbindable mount)<br>  与私有挂载相似，但是不允许执行绑定挂载<br>  <code>mount --make-unbindable &lt;mount-object&gt;</code></li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/shengxia1999/article/details/52060354">mount –bind和硬连接的区别</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/">理解 Linux 的硬链接与软链接</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/linux/l-mount-namespaces.html">应用挂载名称空间</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2017/01/22/storage/ceph/librbd-frame-analyse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/22/storage/ceph/librbd-frame-analyse/" class="post-title-link" itemprop="url">librbd 架构分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-22 10:53:20" itemprop="dateCreated datePublished" datetime="2017-01-22T10:53:20+08:00">2017-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ceph为统一存储，包括块存储（rbd）、文件存储（cephfs）、对象存储（radosgw）。正常我们所使用rbd cli使用的是库librbd来操作ceph的。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>ceph-jewel</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>librbd组织结构:<br><img src="/images/ceph/librbd.png" alt="librbd"></p>
<p>librbd架构:<br><img src="/images/ceph/librbd_frame.png" alt="librbd_frame"></p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>*** todo ***</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><p>*** None ***</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2017/01/20/raspbarrypi/rpi3-make-image/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/20/raspbarrypi/rpi3-make-image/" class="post-title-link" itemprop="url">img制作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-20 13:54:34" itemprop="dateCreated datePublished" datetime="2017-01-20T13:54:34+08:00">2017-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rpi/" itemprop="url" rel="index"><span itemprop="name">rpi</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>新买了一个TF卡，Class10的，应该能挺快。原来的卡是class4的，如果用新卡做系统，然后所有软件都重装重配，太麻烦！所以将现有系统，做成镜像（img），然后直接<code>dd</code>到新卡上，然后再执行<code>raspi-conf</code>进行容量扩展就可以正常使用了。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul>
<li>硬件，RaspberryPi3</li>
<li>OS，raspbian jessie</li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="安装需要的软件"><a href="#安装需要的软件" class="headerlink" title="安装需要的软件"></a>安装需要的软件</h2><p>安装<code>dosfstools</code>、<code>parted</code>、<code>kpartx</code>软件及依赖包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install dosfstools parted kpartx</span><br></pre></td></tr></table></figure>

<h2 id="计算镜像大小"><a href="#计算镜像大小" class="headerlink" title="计算镜像大小"></a>计算镜像大小</h2><p>获取<code>/dev/root</code>和<code>/dev/mmcblk0p1</code>占用的空间，然后计算镜像大小，计算公式：1.2 * (size(&#x2F;dev&#x2F;root) + size(&#x2F;dev&#x2F;mmcblk0p1))</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">df</span> -P</span></span><br><span class="line">Filesystem     1024-blocks      Used Available Capacity Mounted on</span><br><span class="line">/dev/root         30690780   1390740  28024812       5% /</span><br><span class="line">/dev/mmcblk0p1       64366     20698     43668      33% /boot</span><br></pre></td></tr></table></figure>
<p><code>df</code>返回的容量单位为KB。</p>
<h2 id="生成空白镜像文件"><a href="#生成空白镜像文件" class="headerlink" title="生成空白镜像文件"></a>生成空白镜像文件</h2><p>使用<code>dd</code>和<code>/dev/zero</code>生成空白镜像文件<code>sudo dd if=/dev/zero of=&#123;镜像文件&#125; bs=1K count=&#123;镜像大小（单位为K）&#125;</code></p>
<h2 id="分区镜像文件并格式化"><a href="#分区镜像文件并格式化" class="headerlink" title="分区镜像文件并格式化"></a>分区镜像文件并格式化</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>使用<code>parted</code>为img文件分区</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标记label，选择MBR or GPT主引导格式，MBR:msdos, GPT:gpt</span></span><br><span class="line">sudo parted &#123;镜像文件&#125; -s -- mklabel msdos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建分区</span></span><br><span class="line">sudo parted &#123;镜像文件&#125; -s -- mkpart primary fat32 &#123;开始扇区&#125;s &#123;结束扇区&#125;s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建分区</span></span><br><span class="line">sudo parted &#123;镜像文件&#125; -s -- mkpart primary ext4 &#123;开始扇区&#125;s -1</span><br></pre></td></tr></table></figure>
<p>开始扇区和结束扇区可是通过<code>sudo fdisk -l /dev/mmcblk0</code>来查看。</p>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>在格式化前，需要先将img文件映射给系统的loop设备，然后在将loop设备映射给device mapper。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">映射loop设备</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> losetup -f --show &#123;镜像文件&#125;</span></span><br><span class="line">/dev/loop0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">device mapper</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> kpartx -va /dev/loop0</span></span><br><span class="line">add map loop0p1 (254:0): 0 257 linear /dev/loop0 256</span><br><span class="line">add map loop0p2 (254:1): 0 18015 linear /dev/loop0 513</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mkfs.vfat /dev/mapper/loop0p1</span></span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mkfs.ext4 /dev/mapper/loop0p2</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="挂载并备份系统"><a href="#挂载并备份系统" class="headerlink" title="挂载并备份系统"></a>挂载并备份系统</h2><p>备份<code>/boot</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mount -f vfat /dev/mapper/loop0p1 /media</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">cp</span> -rfp /boot/* /media/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> umount /media</span></span><br></pre></td></tr></table></figure>

<p>备份<code>/</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mount -t ext4 /dev/mapper/loop0p2 /media</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> rsync -aP --exclude=&#123;镜像文件&#125; --exclude=/media/* --exclude=/sys/* --exclude=/proc/* --exclude=/tmp/* / /media/</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> umount /media</span></span><br></pre></td></tr></table></figure>

<h2 id="卸载打包镜像文件"><a href="#卸载打包镜像文件" class="headerlink" title="卸载打包镜像文件"></a>卸载打包镜像文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭device mapper</span></span><br><span class="line">sudo kpartx -d /dev/loop0</span><br><span class="line"></span><br><span class="line">＃关闭 loop 设备</span><br><span class="line">sudo losetup -d /dev/loop0</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/talkxin/article/details/50456282">制作树莓派最小镜像-img裁剪瘦身</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2017/01/13/linux/filesystem-userspace-usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/13/linux/filesystem-userspace-usage/" class="post-title-link" itemprop="url">FUSE的使用及示例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-13 14:24:21" itemprop="dateCreated datePublished" datetime="2017-01-13T14:24:21+08:00">2017-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>文件系统，是任何OS都不可却少的。想要编写一个属于自己的文件系统很容易，但调试十分不方便。为了方便调试，提高开发效率，可以使用FUSE（Filesystem in userspace）框架进行开发。这是一个内核模块，能够让用户在用户空间实现文件系统并且挂载到某个目录，就像在内核实现的文件系统一样。使用 FUSE 有几个好处：一是因为在用户空间实现，开发和调试都比较方便；二是可以把一些常用的服务以文件系统的形式展现，方便操作，如 ftpfs，sshfs，mailfs 等；另外可以避免一些版权问题，如 Linux 上对 ntfs，zfs 的操作都是通过 FUSE 实现的。当然用户空间的实现也有缺点，最明显的就是由多次在用户态&#x2F;内核态切换带来的性能下降。</p>
<h1 id="FUSE架构"><a href="#FUSE架构" class="headerlink" title="FUSE架构"></a>FUSE架构</h1><p><img src="/images/linux/fuse.png" alt="FUSE Frame"><br>将文件系统需要处理的读、写、创建、删除等函数，以回调的方式注册到FUSE模块中，当用户访问挂载目录时，FUSE模块回调相应的注册接口。</p>
<h1 id="FUSE安装"><a href="#FUSE安装" class="headerlink" title="FUSE安装"></a>FUSE安装</h1><h2 id="ubuntu-16-04-安装"><a href="#ubuntu-16-04-安装" class="headerlink" title="ubuntu 16.04 安装"></a>ubuntu 16.04 安装</h2><p>需要安装<code>libfuse2</code>和<code>libfuse-dev</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libfuse2 libfuse-dev pkg-config</span><br></pre></td></tr></table></figure>
<p>版本:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FUSE library version: 2.9.4</span><br><span class="line">fusermount version: 2.9.4</span><br><span class="line">using FUSE kernel interface version 7.19</span><br></pre></td></tr></table></figure>

<h2 id="OSX-10-11-6-安装"><a href="#OSX-10-11-6-安装" class="headerlink" title="OSX 10.11.6 安装"></a>OSX 10.11.6 安装</h2><p>需要安装<code>Caskroom/cask/osxfuse</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install osxfuse</span><br></pre></td></tr></table></figure>
<p>版本:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OSXFUSE 3.5.4</span><br><span class="line">FUSE library version: 2.9.7</span><br><span class="line">fuse: no mount point</span><br></pre></td></tr></table></figure>

<h1 id="FUSE使用"><a href="#FUSE使用" class="headerlink" title="FUSE使用"></a>FUSE使用</h1><p>FUSE有两种接口，一种是<code>fuse_operations</code>另一种是<code>fuse_lowlevel_ops</code>。</p>
<ul>
<li><code>fuse_operations</code>是较为上层的接口，我们可以使用<code>fuse_main</code>函数将其传入FUSE中<br>  eg:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">fuse_operations</span> cryptfs_ops = &#123;</span><br><span class="line">        .init = cfs_init,</span><br><span class="line">        .destroy = cfs_destroy,</span><br><span class="line">        .open = cfs_open,</span><br><span class="line">        .read = cfs_read,</span><br><span class="line">        .write = cfs_write,</span><br><span class="line">        .release = cfs_release,</span><br><span class="line">        .readdir = cfs_readdir,</span><br><span class="line">        .getattr = cfs_getattr,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>fuse_lowlevel_ops</code>是较底层的接口，我们可以使用<code>fuse_session_loop</code>函数实现<br>  eg:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">fuse_lowlevel_ops</span>  lowlevel_handler =   </span><br><span class="line">&#123;  </span><br><span class="line">        .lookup   = lowlevel_lookup,  </span><br><span class="line">        .getattr  = lowlevel_getattr,  </span><br><span class="line">        .readdir  = lowlevel_readdir,  </span><br><span class="line">        .mkdir    = lowlevel_mkdir,  </span><br><span class="line">        .rmdir    = lowlevel_rmdir,  </span><br><span class="line">        .open     = lowlevel_open,  </span><br><span class="line">        .read     = lowlevel_read,  </span><br><span class="line">        .write    = lowlevel_write,  </span><br><span class="line">        .unlink   = lowlevel_unlink,  </span><br><span class="line">        .rename   = lowlevel_rename,  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<code>fuse_operations</code>使用简单，容易上手。<code>fuse_lowlevel_ops</code>灵活性大，需要有FS开发经验。</li>
</ul>
<h2 id="Helloworld示例"><a href="#Helloworld示例" class="headerlink" title="Helloworld示例"></a>Helloworld示例</h2><p>实现<code>ls ./mp</code>系统提示<code>Hello-world</code>(<code>./mp</code>为挂载目录)<br><code>ls</code>会用到的方法代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fuse.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">cfs_readdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">void</span>* buf, <span class="type">fuse_fill_dir_t</span> filler, <span class="type">off_t</span> offset, <span class="keyword">struct</span> fuse_file_info* fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(prd-&gt;logfile, <span class="string">&quot;cfs_readdir\t path : %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">fflush</span>(prd-&gt;logfile);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">filler</span>(buf, <span class="string">&quot;Hello-world&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">cfs_getattr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="keyword">struct</span> stat *stbuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(prd-&gt;logfile, <span class="string">&quot;cfs_getattr\t path : %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">fflush</span>(prd-&gt;logfile);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        stbuf-&gt;st_mode = <span class="number">0755</span> | S_IFDIR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        stbuf-&gt;st_mode = <span class="number">0644</span> | S_IFREG;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fuse_main</code>将接口注册到FUSE中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">fuse_operations</span> cryptfs_ops = &#123;</span><br><span class="line">    .readdir = cfs_readdir,</span><br><span class="line">    .getattr = cfs_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="built_in">fuse_main</span>(argc, argv, &amp;cryptfs_ops);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="ubuntu-16-04"><a href="#ubuntu-16-04" class="headerlink" title="ubuntu 16.04"></a>ubuntu 16.04</h3><p>编译命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc myfuse.c -o myfuse -DFUSE_USE_VERSION=22 `pkg-config fuse --cflags --libs` -g</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc myfuse.c -o myfuse -DFUSE_USE_VERSION=22 -D_FILE_OFFSET_BITS=64 -I/usr/include/fuse -lfuse -pthread -g </span><br></pre></td></tr></table></figure>
<p>使用后者编译时不需要安装包<code>pkg-config</code>，由于不同操作系统fuse安装位置不一样，所以还是推荐使用<code>pkg-config</code>的方式</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>可使用GDB调试，<code>myfuse</code>会以守护进程方式启动，调试有三种方法。</p>
<ul>
<li>待<code>myfuse</code>进程启动后，使用GDB中的<code>attach</code>方法进行调试</li>
<li>使用GDB调试<code>myfuse</code>，参数中增加<code>-d</code>参数，该参数可以使<code>myfuse</code>不已守护进程方式启动 ( ** Version: 2.9.9上无法实现 ** )</li>
<li>在<code>myfuse</code>中增加调试打印信息进行调试</li>
</ul>
<h3 id="挂载FUSE"><a href="#挂载FUSE" class="headerlink" title="挂载FUSE"></a>挂载FUSE</h3><p>先创建一个目录(<code>mkdir ./mp</code>)，用于挂载<code>myfuse</code>文件系统，然后调用<code>myfuse</code>进行挂载。<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./myfuse ./mp</span><br></pre></td></tr></table></figure>
<p>对于mac系统挂载文件系统需要使用参数<code>-o allow_other</code>，否则挂在后，挂载目录将无权访问。<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./myfuse ./mp -o allow_other</span><br></pre></td></tr></table></figure>
<p>使用<code>mount</code>查看挂载的文件系统。<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount</span></span><br><span class="line">...</span><br><span class="line">/home/xxxx/xxxx/myfuse on /home/xxxx/xxxx/mp type fuse.myfuse (rw,nosuid,nodev,relatime,user_id=1000,group_id=1000)</span><br></pre></td></tr></table></figure>

<p>使用<code>ls ./mp</code>查看挂载点内容，根据实现应提示<code>Hello-world</code><br>eg:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> ./mp/</span></span><br><span class="line">Hello-world</span><br></pre></td></tr></table></figure>

<h3 id="卸载FUSE"><a href="#卸载FUSE" class="headerlink" title="卸载FUSE"></a>卸载FUSE</h3><p>使用<code>umount</code>卸载<code>myfuse</code>文件系统，需要输入挂载点的全路径<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /home/xxxx/xxxx/mp</span><br></pre></td></tr></table></figure>

<h2 id="FUSE-Options说明"><a href="#FUSE-Options说明" class="headerlink" title="FUSE Options说明"></a>FUSE Options说明</h2><p><code>fuse_main</code>函数自带usage信息，只需要将<code>--help</code>参数传入，便能将usage信息打出来。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./myfuse --<span class="built_in">help</span></span></span><br><span class="line">usage: ./myfuse mountpoint [options]</span><br><span class="line"></span><br><span class="line">general options:</span><br><span class="line">    -o opt,[opt...]        mount options</span><br><span class="line">    -h   --help            print help</span><br><span class="line">    -V   --version         print version</span><br><span class="line"></span><br><span class="line">FUSE options:</span><br><span class="line">    -d   -o debug          enable debug output (implies -f)</span><br><span class="line">    -f                     foreground operation</span><br><span class="line">    -s                     disable multi-threaded operation</span><br><span class="line"></span><br><span class="line">    -o allow_other         allow access to other users</span><br><span class="line">    -o allow_root          allow access to root</span><br><span class="line">    -o auto_unmount        auto unmount on process termination</span><br><span class="line">    -o nonempty            allow mounts over non-empty file/dir</span><br><span class="line">    -o default_permissions enable permission checking by kernel</span><br><span class="line">    -o fsname=NAME         set filesystem name</span><br><span class="line">    -o subtype=NAME        set filesystem type</span><br><span class="line">    -o large_read          issue large read requests (2.4 only)</span><br><span class="line">    -o max_read=N          set maximum size of read requests</span><br><span class="line">    </span><br><span class="line">    -o hard_remove         immediate removal (don&#x27;t hide files)</span><br><span class="line">    -o use_ino             let filesystem set inode numbers</span><br><span class="line">    -o readdir_ino         try to fill in d_ino in readdir</span><br><span class="line">    -o direct_io           use direct I/O</span><br><span class="line">    -o kernel_cache        cache files in kernel</span><br><span class="line">    -o [no]auto_cache      enable caching based on modification times (off)</span><br><span class="line">    -o umask=M             set file permissions (octal)</span><br><span class="line">    -o uid=N               set file owner</span><br><span class="line">    -o gid=N               set file group</span><br><span class="line">    -o entry_timeout=T     cache timeout for names (1.0s)</span><br><span class="line">    -o negative_timeout=T  cache timeout for deleted names (0.0s)</span><br><span class="line">    -o attr_timeout=T      cache timeout for attributes (1.0s)</span><br><span class="line">    -o ac_attr_timeout=T   auto cache timeout for attributes (attr_timeout)</span><br><span class="line">    -o noforget            never forget cached inodes</span><br><span class="line">    -o remember=T          remember cached inodes for T seconds (0s)</span><br><span class="line">    -o nopath              don&#x27;t supply path if not necessary</span><br><span class="line">    -o intr                allow requests to be interrupted</span><br><span class="line">    -o intr_signal=NUM     signal to send on interrupt (10)</span><br><span class="line">    -o modules=M1[:M2...]  names of modules to push onto filesystem stack</span><br><span class="line">    -o max_write=N         set maximum size of write requests</span><br><span class="line">    -o max_readahead=N     set maximum readahead</span><br><span class="line">    -o max_background=N    set number of maximum background requests</span><br><span class="line">    -o congestion_threshold=N  set kernel&#x27;s congestion threshold</span><br><span class="line">    -o async_read          perform reads asynchronously (default)</span><br><span class="line">    -o sync_read           perform reads synchronously</span><br><span class="line">    -o atomic_o_trunc      enable atomic open+truncate support</span><br><span class="line">    -o big_writes          enable larger than 4kB writes</span><br><span class="line">    -o no_remote_lock      disable remote file locking</span><br><span class="line">    -o no_remote_flock     disable remote file locking (BSD)</span><br><span class="line">    -o no_remote_posix_lock disable remove file locking (POSIX)</span><br><span class="line">    -o [no_]splice_write   use splice to write to the fuse device</span><br><span class="line">    -o [no_]splice_move    move data while splicing to the fuse device</span><br><span class="line">    -o [no_]splice_read    use splice to read from the fuse device</span><br></pre></td></tr></table></figure>

<h2 id="FUSE-Operations说明"><a href="#FUSE-Operations说明" class="headerlink" title="FUSE Operations说明"></a>FUSE Operations说明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fuse_operations</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> (*getattr) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> stat *);</span><br><span class="line">    <span class="comment">/* 这个函数与 stat() 类似。st_dev 和 st_blksize 域都可以忽略。st_ino 域也会被忽略，除非在执行 mount 时指定了 use_ino 选项 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*readlink) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="comment">/* 这个函数会读取一个符号链接的目标。缓冲区应该是一个以 null 结束的字符串。缓冲区的大小参数包括这个 null 结束字符的空间。如果链接名太长，不能保存到缓冲区中，就应该被截断。成功时的返回值应该是 “0” */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*getdir) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">fuse_dirh_t</span>, <span class="type">fuse_dirfil_t</span>);</span><br><span class="line">    <span class="comment">/* 这个函数会读取一个目录中的内容。这个操作实际上是在一次调用中执行 opendir()、readdir()、...、closedir() 序列。对于每个目录项来说，都应该调用 filldir() 函数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*mknod) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">mode_t</span>, <span class="type">dev_t</span>);</span><br><span class="line">    <span class="comment">/* 这个函数会创建一个文件节点。此处没有 create() 操作；mknod() 会在创建非目录、非符号链接的节点时调用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*mkdir) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">mode_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*rmdir) (<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 这两个函数分别用来创建和删除一个目录 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*unlink) (<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="built_in">int</span> (*rename) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 这两个函数分别用来删除和重命名一个文件 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*symlink) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 这个函数用来创建一个符号链接 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*link) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 这个函数创建一个到文件的硬链接 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*chmod) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">mode_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*chown) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">uid_t</span>, <span class="type">gid_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*truncate) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">off_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*utime) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> utimbuf *);</span><br><span class="line">    <span class="comment">/* 这 4 个函数分别用来修改文件的权限位、属主和用户、大小以及文件的访问/修改时间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*open) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这是文件的打开操作。对 open() 函数不能传递创建或截断标记（O_CREAT、O_EXCL、O_TRUNC）。这个函数应该检查是否允许执行给定的标记的操作。另外，open() 也可能在 fuse_file_info 结构中返回任意的文件句柄，这会传递给所有的文件操作 */</span></span><br><span class="line">    <span class="built_in">int</span> (*read) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">off_t</span>, <span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这个函数从一个打开文件中读取数据。除非碰到 EOF 或出现错误，否则 read() 应该返回所请求的字节数的数据；否则，其余数据都会被替换成 0。一个例外是在执行 mount 命令时指定了 direct_io 选项，在这种情况中 read() 系统调用的返回值会影响这个操作的返回值 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*write) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">off_t</span>,<span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这个函数将数据写入一个打开的文件中。除非碰到 EOF 或出现错误，否则 write() 应该返回所请求的字节数的数据。一个例外是在执行 mount 命令时指定了 direct_io 选项（这于 read() 操作的情况类似） */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*statfs) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> statfs *);</span><br><span class="line">    <span class="comment">/* 这个函数获取文件系统的统计信息。f_type 和 f_fsid 域都会被忽略 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*flush) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这表示要刷新缓存数据。它并不等于 fsync() 函数 —— 也不是请求同步脏数据。每次对一个文件描述符执行 close() 函数时，都会调用 flush()；因此如果文件系统希望在 close() 中返回写错误，并且这个文件已经缓存了脏数据，那么此处就是回写数据并返回错误的好地方。由于很多应用程序都会忽略 close() 错误，因此这通常用处不大 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*release) (<span class="type">const</span> <span class="type">char</span> *, <span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这个函数释放一个打开文件。release() 是在对一个打开文件没有其他引用时调用的 —— 此时所有的文件描述符都会被关闭，所有的内存映射都会被取消。对于每个 open() 调用来说，都必须有一个使用完全相同标记和文件描述符的 release() 调用。对一个文件打开多次是可能的，在这种情况中只会考虑最后一次 release，然后就不能再对这个文件执行更多的读/写操作了。release 的返回值会被忽略 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*fsync) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>, <span class="keyword">struct</span> fuse_file_info *);</span><br><span class="line">    <span class="comment">/* 这个函数用来同步文件内容。如果 datasync 参数为非 0，那么就只会刷新用户数据，而不会刷新元数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*setxattr) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">int</span> (*getxattr) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*listxattr) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*removexattr) (<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* 这些函数分别用来设置、获取、列出和删除扩展属性 */</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更多详细说明，请见<code>fuse.h</code>文件。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="http://blog.jeffli.me/blog/2014/08/30/use-gdb-to-understand-fuse-file-system/">Use GDB to Understand FUSE File System</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/langeldep/article/details/6401567">FUSE API 的两种使用方法</a></li>
<li><a target="_blank" rel="noopener" href="http://ouonline.net/building-your-own-fs-with-fuse-1">使用 fuse 编写文件系统 (1)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/osxfuse/osxfuse/issues/45">cannot umount or mount an sshfs volume after ssh connection cut</a></li>
<li><a target="_blank" rel="noopener" href="http://www.tuicool.com/articles/qAjARfY">Fuse文件系统优化方案</a></li>
<li><a target="_blank" rel="noopener" href="http://www.tuicool.com/articles/6F7Fzi">FUSE源码剖析</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/linux/l-fuse/">使用 FUSE 开发自己的文件系统</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/gerard/ext4fuse/issues/36">ext4fuse issues</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2017/01/07/linux/deploy-vpn-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/07/linux/deploy-vpn-server/" class="post-title-link" itemprop="url">搭建VPN服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-07 20:21:56" itemprop="dateCreated datePublished" datetime="2017-01-07T20:21:56+08:00">2017-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>VPN(virtual private network)虚拟专用网络，目前主要能接触到的协议包括PPTP(点对点隧道协议)和L2TP(2层隧道协议)</p>
<ul>
<li>PPTP(2层VPN) 由微软和3Com等公司组成的PPTP论坛开发的点对点隧道协议，基于PPP协议使用PAP或CHAP之类的加密算法。</li>
<li>L2TP(2层VPN) 是IETF基于L2F (Cisco的第二层转发协议)开发的PPTP的后续版本，是一种工业标准 Internet 隧道协议，其可以为跨越面向数据包的媒体发送点到点协议 (PPP) 框架提供封装。<br>PPTP和L2TP都使用PPP协议对数据进行封装，然后添加附加包头用于数据在互联网络上的传输。PPTP只能在两端点间建立单一隧道。 L2TP支持在两端点间使用多隧道，用户可以针对不同的服务质量创建不同的隧道。L2TP可以提供隧道验证，而PPTP则不支持隧道验证。但是当L2TP 或PPTP与IPSEC共同使用时，可以由IPSEC提供隧道验证，不需要在第2层协议上验证隧道使用L2TP。PPTP要求互联网络为IP网络。L2TP只要求隧道媒介提供面向数据包的点对点的连接，L2TP可以在IP(使用UDP)，桢中继永久虚拟电路 (PVCs),X.25虚拟电路(VCs)或ATM VCs网络上使用。</li>
</ul>
<p>IPSec(3层VPN)，隧道模式隧道是封装、路由与解封装的整个过程。隧道将原始数据包隐藏(或封装)在新的数据包内部。该新的数据包可能会有新的寻址与路由信息，从而使其能够通过网络传输。隧道与数据保密性结合使用时，在网络上窃听通讯的人将无法获取原始数据包数据(以及原始的源和目标)。封装的数据包到达目的地后，会删除封装，原始数据包头用于将数据包路由到最终目的地。</p>
<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><ul>
<li>OS, raspbian jessie</li>
<li>硬件，Raspbarry Pi 3B</li>
<li>ppp，2.4.6</li>
<li>pptpd，1.4.0</li>
<li>openswan，2.6.38</li>
<li>xl2tp，1.3.6</li>
</ul>
<h1 id="PPTP部署"><a href="#PPTP部署" class="headerlink" title="PPTP部署"></a>PPTP部署</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>安装<code>ppp</code>、<code>pptpd</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ppp</span><br><span class="line">sudo apt-get install pptpd</span><br></pre></td></tr></table></figure>

<h2 id="配置pptpd"><a href="#配置pptpd" class="headerlink" title="配置pptpd"></a>配置pptpd</h2><p>在配置文件<code>/etc/pptpd.conf</code>中，增加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localip 192.168.1.101       # 本地ip</span><br><span class="line">remoteip 192.168.1.110-120  # 设置ip分配范围</span><br></pre></td></tr></table></figure>
<p>*** 注：ip地址不要有冲突 ***</p>
<h2 id="配置ppp"><a href="#配置ppp" class="headerlink" title="配置ppp"></a>配置ppp</h2><p>在配置文件<code>/etc/ppp/chap-secrets</code>中，增加用户名密码<br>格式: <code>&#123;用户名&#125;&lt;tab&gt;*&lt;tab&gt;&#123;密码&#125;&lt;tab&gt;*</code></p>
<p>在配置文件<code>/etc/ppp/options</code>中，设置MTU</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-mru        # 关闭MRU协商</span><br><span class="line">mru 1496    # 设置MTU值为1496</span><br></pre></td></tr></table></figure>
<h2 id="ip转发配置"><a href="#ip转发配置" class="headerlink" title="ip转发配置"></a>ip转发配置</h2><p>如果需要通过VPN访问宿主机本地网络，需要开通ip转发功能，在<code>/etc/sysctl.conf</code>中设置<code>net.ipv4.ip_forward=1</code>。并执行<code>sudo sysctl -p</code>使修改生效。</p>
<h2 id="重启pptpd服务"><a href="#重启pptpd服务" class="headerlink" title="重启pptpd服务"></a>重启pptpd服务</h2><p><code>sudo systemctl restart pptpd</code></p>
<h1 id="IPsec-over-L2TP部署"><a href="#IPsec-over-L2TP部署" class="headerlink" title="IPsec over L2TP部署"></a>IPsec over L2TP部署</h1><h2 id="软件安装-1"><a href="#软件安装-1" class="headerlink" title="软件安装"></a>软件安装</h2><p>安装<code>ppp</code>、<code>xl2tpd</code>、<code>openswan</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ppp</span><br><span class="line">sudo apt-get install xl2tpd</span><br><span class="line">sudo apt-get install openswan</span><br></pre></td></tr></table></figure>

<h2 id="IPsec配置及测试"><a href="#IPsec配置及测试" class="headerlink" title="IPsec配置及测试"></a>IPsec配置及测试</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>/etc/ipsec.conf</code>中，增加：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">onn L2TP-PSK-NAT</span><br><span class="line">    rightsubnet=vhost:%priv</span><br><span class="line">    also=L2TP-PSK-noNAT</span><br><span class="line"></span><br><span class="line">conn L2TP-PSK-noNAT</span><br><span class="line">    authby=secret</span><br><span class="line">    pfs=no</span><br><span class="line">    auto=add</span><br><span class="line">    keyingtries=3</span><br><span class="line">    rekey=no</span><br><span class="line">    ikelifetime=8h</span><br><span class="line">    keylife=1h</span><br><span class="line">    type=transport</span><br><span class="line">    left=192.168.3.100      # 本机ip</span><br><span class="line">    leftprotoport=17/1701</span><br><span class="line">    right=%any</span><br><span class="line">    rightprotoport=17/%any</span><br></pre></td></tr></table></figure>

<p>在<code>/etc/ipsec.secrets</code>中增加预共享密钥<code>&#123;本地IP&#125;&lt;tab&gt;%any: PSK&lt;tab&gt;&quot;&#123;密码&#125;&quot;</code><br>eg: <code>192.168.3.100      %any: PSK   &quot;lsjflsdkfj&quot;</code></p>
<p>关闭内核ICMP重定向</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for abspath in /proc/sys/net/ipv4/conf/*</span><br><span class="line">do</span><br><span class="line">    echo 0 &gt; $abspath/accept_redirects</span><br><span class="line">    echo 0 &gt; $abspath/send_redirects</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/sysctl.conf</code>中的配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 0</span><br><span class="line">net.ipv4.conf.all.send_redirects = 0</span><br><span class="line">net.ipv4.conf.default.send_redirects = 0</span><br><span class="line">net.ipv4.conf.all.log_martians = 0</span><br><span class="line">net.ipv4.conf.default.log_martians = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.all.accept_redirects = 0</span><br><span class="line">net.ipv4.conf.default.accept_redirects = 0</span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br></pre></td></tr></table></figure>
<p>执行<code>sudo sysctl -p</code>立即生效</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用<code>ipsec verify</code>验证ipsec配置。在验证前，请先重启ipsec服务<code>sudo systemctl restart ipsec</code></p>
<h2 id="L2TP配置"><a href="#L2TP配置" class="headerlink" title="L2TP配置"></a>L2TP配置</h2><p>在<code>/etc/xl2tpd/xl2tpd.conf</code>中增加</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line"></span><br><span class="line">listen-addr = 192.168.3.100</span><br><span class="line">ipsec saref = yes</span><br><span class="line"></span><br><span class="line">[lns default]</span><br><span class="line">ip range = 192.168.3.120-192.168.3.123</span><br><span class="line">local ip = 192.168.3.100</span><br><span class="line">refuse chap = yes</span><br><span class="line">refuse pap = yes</span><br><span class="line">require authentication = yes</span><br><span class="line">name = l2tp</span><br><span class="line">ppp debug = yes</span><br><span class="line"></span><br><span class="line">pppoptfile = /etc/ppp/options.xl2tpd</span><br><span class="line"></span><br><span class="line">length bit = yes</span><br></pre></td></tr></table></figure>

<h3 id="PPP配置"><a href="#PPP配置" class="headerlink" title="PPP配置"></a>PPP配置</h3><h4 id="options配置"><a href="#options配置" class="headerlink" title="options配置"></a>options配置</h4><p>新建xl2tpd专用options，并增加内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ipcp-accept-local</span><br><span class="line">ipcp-accept-remote</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ms-dns 192.168.3.1</span></span><br><span class="line">ms-dns 8.8.8.8</span><br><span class="line">ms-dns 8.8.4.4</span><br><span class="line"></span><br><span class="line">noccp</span><br><span class="line">auth</span><br><span class="line">crtscts</span><br><span class="line">debug</span><br><span class="line">hide-password</span><br><span class="line">modem</span><br><span class="line">lock</span><br><span class="line">proxyarp</span><br></pre></td></tr></table></figure>
<h4 id="账户配置"><a href="#账户配置" class="headerlink" title="账户配置"></a>账户配置</h4><p>可复用PPTP部署中的PPP配置的账户</p>
<h3 id="重启L2TP服务"><a href="#重启L2TP服务" class="headerlink" title="重启L2TP服务"></a>重启L2TP服务</h3><p><code>sudo systemctl restart xl2tpd</code></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/alexsun/p/5894338.html">树莓派使用pptpd搭建VPN（PPTP）服务器</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/wxlguitar/article/details/51474771">树莓派搭建L2TP&#x2F;IPSec</a></li>
<li><a target="_blank" rel="noopener" href="http://www.linuxidc.com/Linux/2010-08/27616.htm">CentOS安装L2TP&#x2F;IPSEC 与简单故障处理</a></li>
<li><a target="_blank" rel="noopener" href="http://struggle01.blog.51cto.com/6956448/1336029">linux下搭建Ipsec+L2TP VPN服务</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2017/01/04/linux/nettools-vs-iproute2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/04/linux/nettools-vs-iproute2/" class="post-title-link" itemprop="url">net-tools <--> iproute2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-04 12:53:44" itemprop="dateCreated datePublished" datetime="2017-01-04T12:53:44+08:00">2017-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>linux的ip命令和ifconfig类似，ifconfig属于net-tools套件中，ip命令属于iproute2套件中。由于net-tools中的部分命令已经长时间没有更新维护了，所以iproute2的套件大有取代net-tools套件的趋势。</p>
<h1 id="NET-TOOLS-IPROUTE2对比"><a href="#NET-TOOLS-IPROUTE2对比" class="headerlink" title="NET-TOOLS IPROUTE2对比"></a>NET-TOOLS IPROUTE2对比</h1><table>
<thead>
<tr>
<th align="center">net-tools</th>
<th align="center">iproute2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">arp -na</td>
<td align="center">ip neigh</td>
</tr>
<tr>
<td align="center">ifconfig</td>
<td align="center">ip link</td>
</tr>
<tr>
<td align="center">ifconfig -a</td>
<td align="center">ip addr show</td>
</tr>
<tr>
<td align="center">ifconfig –help</td>
<td align="center">ip help</td>
</tr>
<tr>
<td align="center">ifconfig -s</td>
<td align="center">ip -s link</td>
</tr>
<tr>
<td align="center">ifconfig eth0 up</td>
<td align="center">ip link set eth0 up</td>
</tr>
<tr>
<td align="center">ipmaddr</td>
<td align="center">ip maddr</td>
</tr>
<tr>
<td align="center">iptunnel</td>
<td align="center">ip tunnel</td>
</tr>
<tr>
<td align="center">netstat</td>
<td align="center">ss</td>
</tr>
<tr>
<td align="center">netstat -i</td>
<td align="center">ip -s link</td>
</tr>
<tr>
<td align="center">netstat -g</td>
<td align="center">ip maddr</td>
</tr>
<tr>
<td align="center">netstat -l</td>
<td align="center">ss -l</td>
</tr>
<tr>
<td align="center">netstat -r</td>
<td align="center">ip route</td>
</tr>
<tr>
<td align="center">route add</td>
<td align="center">ip route add</td>
</tr>
<tr>
<td align="center">route del</td>
<td align="center">ip route del</td>
</tr>
<tr>
<td align="center">route -n</td>
<td align="center">ip route show</td>
</tr>
<tr>
<td align="center">vconfig</td>
<td align="center">ip link</td>
</tr>
</tbody></table>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="http://os.51cto.com/art/201406/441461.htm">试试Linux下的ip命令，ifconfig已经过时了</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2017/01/04/container/docker/docker-mk-base-image/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/04/container/docker/docker-mk-base-image/" class="post-title-link" itemprop="url">Docker Base Image制作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-04 10:30:32" itemprop="dateCreated datePublished" datetime="2017-01-04T10:30:32+08:00">2017-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/container/" itemprop="url" rel="index"><span itemprop="name">container</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>docker容器的创建依赖于镜像，镜像的创建依赖于目录树，不同的linux发行版，有自己的目录树。本文主要介绍debian族发行版与fedora族发行版base image的创建。如果您想从零创建一个linux发行版base image，请参考LFS（linux from scratch）。</p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul>
<li>OS Version, RHEL7.2</li>
<li>docker Version, 1.12.5</li>
</ul>
<h1 id="debian"><a href="#debian" class="headerlink" title="debian"></a>debian</h1><p>debian类的操作系统包括debian、ubuntu，这一类操作系统的目录树都是用<code>debootstrap</code>来生成的。其中<code>de</code>取debian之意。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可直接使用yum安装<code>yum install debootstrap</code>。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>debian默认的mirror为<a target="_blank" rel="noopener" href="https://deb.debian.org/debian/">https://deb.debian.org/debian/</a></p>
<p>debootstrap格式:<br><code>debootstrap [OPTION...] &lt;版本&gt; &lt;目录树存放位置目录&gt; [&lt;镜像（mirror）位置&gt;]</code></p>
<p>eg: <code>sudo debootstrap jessie my_jessie</code></p>
<h1 id="fedora"><a href="#fedora" class="headerlink" title="fedora"></a>fedora</h1><p>fedora类的操作系统包括fedora、RHEL、CentOS，这一类操作系统的目录树都是用<code>febootstrap</code>来生成的。其中<code>fe</code>取fedora之意。</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p><code>febootstrap</code>并没有存在于RHEL7.2（或CentOS7.2）Repo中，目前可以直接安装6.8 repo中的<code>febootstrap-3.21-4</code>。</p>
<p>febootstrap-3.21-4依赖包如下所示：</p>
<ul>
<li>fakechroot-2.9-24.5.el6_1.1.x86_64</li>
<li>fakechroot-libs-2.9-24.5.el6_1.1.x86_64</li>
<li>fakeroot-1.12.2-22.2.el6.x86_64</li>
<li>fakeroot-libs-1.12.2-22.2.el6.x86_64</li>
<li>febootstrap-supermin-helper-3.21-4.el6.x86_64</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>febootstrap格式:<br><code>febootstrap [OPTION...] &lt;版本&gt; &lt;目录树存放位置目录&gt; [镜像（mirror）位置]</code></p>
<p>eg: <code>febootstrap -i bash 6.8 my_centos6.8 http://mirrors.163.com/centos/6.8/os/x86_64/</code></p>
<h1 id="LFS"><a href="#LFS" class="headerlink" title="LFS"></a>LFS</h1><p>Todo…</p>
<h1 id="镜像导入"><a href="#镜像导入" class="headerlink" title="镜像导入"></a>镜像导入</h1><h2 id="Tar导入方式创建镜像"><a href="#Tar导入方式创建镜像" class="headerlink" title="Tar导入方式创建镜像"></a>Tar导入方式创建镜像</h2><p>无论是debootstrap还是febootstrap生成的目录，其导入docker image的方法是一样的。</p>
<p>格式:<br><code>tar -C &lt;目录树目录&gt; -c . | docker import - &lt;docker image 名称&gt;</code></p>
<p>eg: <code>tar -C ./my_jessie -c . | docker import - my_jessie_base</code></p>
<h2 id="空镜像创建"><a href="#空镜像创建" class="headerlink" title="空镜像创建"></a>空镜像创建</h2><p>格式:<br><code>tar cv --files-from /dev/null | docker import - &lt;docker image 名称&gt;</code></p>
<p>eg: <code>tar cv --files-from /dev/null | docker import - empty_image</code></p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="https://linux.cn/article-5427-1.html">两种方式创建你自己的 Docker 基本映像</a></li>
<li><a target="_blank" rel="noopener" href="http://www.latelee.org/using-gnu-linux/ubuntu-debootstrap.html">ubuntu系统debootstrap的使用</a></li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/ylchou/blog/490412">CentOS下febootstrap自制Docker的CentOS6.6和7.1 Docker镜像</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">博</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">145</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">122</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">博</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
