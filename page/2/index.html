<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhoubofsy.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Bolog">
<meta property="og:url" content="http://zhoubofsy.github.io/page/2/index.html">
<meta property="og:site_name" content="Bolog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="博">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://zhoubofsy.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Bolog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bolog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2021/12/18/storage/ceph/ceph-encode-decode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/18/storage/ceph/ceph-encode-decode/" class="post-title-link" itemprop="url">encode和decode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-18 15:12:12" itemprop="dateCreated datePublished" datetime="2021-12-18T15:12:12+08:00">2021-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">object_t</span> &#123;</span><br><span class="line">  std::string name;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">encode</span><span class="params">(ceph::buffer::list &amp;bl)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ceph::encode;</span><br><span class="line">    <span class="built_in">encode</span>(name, bl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(ceph::buffer::list::const_iterator &amp;bl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ceph::decode;</span><br><span class="line">    <span class="built_in">decode</span>(name, bl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">WRITE_CLASS_ENCODER</span>(<span class="type">object_t</span>)</span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;object.h ***</p>
<p>对于Ceph中的每一种需要存储的资源在进行存储前都要进行<code>encode</code>操作，然后再将其写入硬盘。对于读取同样，在从硬盘获取到数据后需要进行<code>decode</code>操作。而每种需要存储资源如何<code>encode</code>和<code>decode</code>当然要由资源自己来决定。所以在资源的<code>class</code>或<code>struct</code>中要实现<code>encode</code>和<code>decode</code>方法。</p>
<p><code>WRITE_CLASS_ENCODER(object_t)</code>干了些啥呢。。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// see denc.h for ENCODE_DUMP_PATH discussion and definition.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENCODE_DUMP_PATH</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ENCODE_DUMP_PRE()                      \</span></span><br><span class="line"><span class="meta">  unsigned pre_off = bl.length()</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ENCODE_DUMP_POST(cl)                                           \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                  \</span></span><br><span class="line"><span class="meta">    static int i = 0;                                                   \</span></span><br><span class="line"><span class="meta">    i++;                                                                \</span></span><br><span class="line"><span class="meta">    int bits = 0;                                                       \</span></span><br><span class="line"><span class="meta">    for (unsigned t = i; t; bits++)                                     \</span></span><br><span class="line"><span class="meta">      t &amp;= t - 1;                                                       \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (bits &gt; 2)                                                       \</span></span><br><span class="line"><span class="meta">      break;                                                            \</span></span><br><span class="line"><span class="meta">    char fn[PATH_MAX];                                                  \</span></span><br><span class="line"><span class="meta">    snprintf(fn, sizeof(fn), ENCODE_STRINGIFY(ENCODE_DUMP_PATH) <span class="string">&quot;/%s__%d.%x&quot;</span>, #cl, getpid(), i++); \</span></span><br><span class="line"><span class="meta">    int fd = ::open(fn, O_WRONLY|O_TRUNC|O_CREAT|O_CLOEXEC|O_BINARY, 0644);             \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (fd &gt;= 0) &#123;                                                      \</span></span><br><span class="line"><span class="meta">      ::ceph::bufferlist sub;                                           \</span></span><br><span class="line"><span class="meta">      sub.substr_of(bl, pre_off, bl.length() - pre_off);                \</span></span><br><span class="line"><span class="meta">      sub.write_fd(fd);                                                 \</span></span><br><span class="line"><span class="meta">      ::close(fd);                                                      \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ENCODE_DUMP_PRE()</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ENCODE_DUMP_POST(cl)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_CLASS_ENCODER(cl)                                         \</span></span><br><span class="line"><span class="meta">  inline void encode(const cl&amp; c, ::ceph::buffer::list &amp;bl, uint64_t features=0) &#123; \</span></span><br><span class="line"><span class="meta">    ENCODE_DUMP_PRE(); c.encode(bl); ENCODE_DUMP_POST(cl); &#125;            \</span></span><br><span class="line"><span class="meta">  inline void decode(cl &amp;c, ::ceph::bufferlist::const_iterator &amp;p) &#123; c.decode(p); &#125;</span></span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;encoding.h ***</p>
<p>看了上面的代码应该能了解到<code>WRITE_CLASS_ENCODER(object_t)</code>是对<code>encode</code>和<code>decode</code>函数的重载。这是入口，然后再调用其资源自身<code>encode</code>或<code>decode</code>方法。</p>
<p>那么对于一些基础类型（如：int、string等）是如果<code>encode</code>和<code>decode</code>的呢？</p>
<h3 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int types</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_INTTYPE_ENCODER(type, etype)                              \</span></span><br><span class="line"><span class="meta">  inline void encode(type v, ::ceph::bufferlist&amp; bl, uint64_t features=0) &#123; \</span></span><br><span class="line"><span class="meta">    ceph_##etype e;                                                     \</span></span><br><span class="line"><span class="meta">    e = v;                                                              \</span></span><br><span class="line"><span class="meta">    ::ceph::encode_raw(e, bl);                                          \</span></span><br><span class="line"><span class="meta">  &#125;                                                                     \</span></span><br><span class="line"><span class="meta">  inline void decode(type &amp;v, ::ceph::bufferlist::const_iterator&amp; p) &#123;  \</span></span><br><span class="line"><span class="meta">    ceph_##etype e;                                                     \</span></span><br><span class="line"><span class="meta">    ::ceph::decode_raw(e, p);                                           \</span></span><br><span class="line"><span class="meta">    v = e;                                                              \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">uint64_t</span>, le64)</span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">int64_t</span>, le64)</span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">uint32_t</span>, le32)</span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">int32_t</span>, le32)</span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">uint16_t</span>, le16)</span><br><span class="line"><span class="built_in">WRITE_INTTYPE_ENCODER</span>(<span class="type">int16_t</span>, le16)</span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;encoding.h ***</p>
<p>int类型的<code>encode</code>和<code>decode</code>又调用了<code>encode_raw</code>和<code>decode_raw</code>。真是一层套一层啊～（俄罗斯套娃嘛）～</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base types</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode_raw</span><span class="params">(<span class="type">const</span> T&amp; t, bufferlist&amp; bl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bl.<span class="built_in">append</span>((<span class="type">char</span>*)&amp;t, <span class="built_in">sizeof</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">decode_raw</span><span class="params">(T&amp; t, bufferlist::const_iterator &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p.<span class="built_in">copy</span>(<span class="built_in">sizeof</span>(t), (<span class="type">char</span>*)&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_RAW_ENCODER(type)                                         \</span></span><br><span class="line"><span class="meta">  inline void encode(const type &amp;v, ::ceph::bufferlist&amp; bl, uint64_t features=0) &#123; ::ceph::encode_raw(v, bl); &#125; \</span></span><br><span class="line"><span class="meta">  inline void decode(type &amp;v, ::ceph::bufferlist::const_iterator&amp; p) &#123; ::ceph::decode_raw(v, p); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(__u8)</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CHAR_IS_SIGNED</span></span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(__s8)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(<span class="type">char</span>)</span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(ceph_le64)</span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(ceph_le32)</span><br><span class="line"><span class="built_in">WRITE_RAW_ENCODER</span>(ceph_le16)</span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;encoding.h ***</p>
<p>base比较简单，就是无论int几个字节，都是从低到高一个字节一个字节的写下去，再一个字节一个字节的读出来。。。</p>
<h3 id="float类型"><a href="#float类型" class="headerlink" title="float类型"></a>float类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_FLTTYPE_ENCODER(type, itype, etype)                       \</span></span><br><span class="line"><span class="meta">  static_assert(sizeof(type) == sizeof(itype));                         \</span></span><br><span class="line"><span class="meta">  static_assert(std::numeric_limits<span class="string">&lt;type&gt;</span>::is_iec559,                   \</span></span><br><span class="line"><span class="meta">              <span class="string">&quot;floating-point type not using IEEE754 format&quot;</span>);          \</span></span><br><span class="line"><span class="meta">  inline void encode(type v, ::ceph::bufferlist&amp; bl, uint64_t features=0) &#123; \</span></span><br><span class="line"><span class="meta">    ceph_##etype e;                                                     \</span></span><br><span class="line"><span class="meta">    e = *reinterpret_cast<span class="string">&lt;itype *&gt;</span>(&amp;v);                                 \</span></span><br><span class="line"><span class="meta">    ::ceph::encode_raw(e, bl);                                          \</span></span><br><span class="line"><span class="meta">  &#125;                                                                     \</span></span><br><span class="line"><span class="meta">  inline void decode(type &amp;v, ::ceph::bufferlist::const_iterator&amp; p) &#123;  \</span></span><br><span class="line"><span class="meta">    ceph_##etype e;                                                     \</span></span><br><span class="line"><span class="meta">    ::ceph::decode_raw(e, p);                                           \</span></span><br><span class="line"><span class="meta">    *reinterpret_cast<span class="string">&lt;itype *&gt;</span>(&amp;v) = e;                                 \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WRITE_FLTTYPE_ENCODER</span>(<span class="type">float</span>, <span class="type">uint32_t</span>, le32)</span><br><span class="line"><span class="built_in">WRITE_FLTTYPE_ENCODER</span>(<span class="type">double</span>, <span class="type">uint64_t</span>, le64)</span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;encoding.h ***</p>
<p>float类型关键在于<code>reinterpret_cast</code>将一个浮点数转换为整数。<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/reinterpret_cast">更多关于<code>reinterpret_cast</code>的内容</a></p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode</span><span class="params">(std::string_view s, bufferlist&amp; bl, <span class="type">uint64_t</span> features=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __u32 len = s.<span class="built_in">length</span>();</span><br><span class="line">  <span class="built_in">encode</span>(len, bl);</span><br><span class="line">  <span class="keyword">if</span> (len)</span><br><span class="line">    bl.<span class="built_in">append</span>(s.<span class="built_in">data</span>(), len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode</span><span class="params">(<span class="type">const</span> std::string&amp; s, bufferlist&amp; bl, <span class="type">uint64_t</span> features=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">encode</span>(std::<span class="built_in">string_view</span>(s), bl, features);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">decode</span><span class="params">(std::string&amp; s, bufferlist::const_iterator&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __u32 len;</span><br><span class="line">  <span class="built_in">decode</span>(len, p);</span><br><span class="line">  s.<span class="built_in">clear</span>();</span><br><span class="line">  p.<span class="built_in">copy</span>(len, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode_nohead</span><span class="params">(std::string_view s, bufferlist&amp; bl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bl.<span class="built_in">append</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode_nohead</span><span class="params">(<span class="type">const</span> std::string&amp; s, bufferlist&amp; bl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">encode_nohead</span>(std::<span class="built_in">string_view</span>(s), bl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">decode_nohead</span><span class="params">(<span class="type">int</span> len, std::string&amp; s, bufferlist::const_iterator&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  s.<span class="built_in">clear</span>();</span><br><span class="line">  p.<span class="built_in">copy</span>(len, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const char* (encode only, string compatible)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">encode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, bufferlist&amp; bl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">encode</span>(std::<span class="built_in">string_view</span>(s, <span class="built_in">strlen</span>(s)), bl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*** From: src&#x2F;include&#x2F;encoding.h ***</p>
<p>string的<code>encode</code>和<code>decode</code>分两种，一种是有“害的”(head)，一种是无“害的”。有“害的”需要先记录string的长度，再记录string的内容；无“害的”直接记录内容，单再<code>decode</code>过程中需要制定长度。总之这个长度总要有个人来记。好鸡肋！</p>
<hr>
<p>整个的<code>encode</code>和<code>decode</code>的过程用到了一个<code>bufferlist</code>类型，那么这个<code>bufferlist</code>又是个什么结构呢，详细请见<a href="">ceph中的buffer</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2021/09/28/language/cpp/stl-container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/28/language/cpp/stl-container/" class="post-title-link" itemprop="url">STL容器们</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-28 17:03:31" itemprop="dateCreated datePublished" datetime="2021-09-28T17:03:31+08:00">2021-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index"><span itemprop="name">language</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>c++中stl涉及到的容器类（或struct）有很多，具体都是什么原理呢？</p>
<h2 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">__array_traits</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">typedef</span> _Tp _Type[_Nm];</span><br><span class="line">        <span class="keyword">typedef</span> __is_swappable&lt;_Tp&gt; _Is_swappable;</span><br><span class="line">        <span class="keyword">typedef</span> __is_nothrow_swappable&lt;_Tp&gt; _Is_nothrow_swappable;</span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="keyword">constexpr</span> _Tp&amp;</span><br><span class="line">        _S_ref(<span class="type">const</span> _Type&amp; <span class="type">__t</span>, std::<span class="type">size_t</span> __n) <span class="keyword">noexcept</span></span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;_Tp&amp;&gt;(<span class="type">__t</span>[__n]); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="keyword">constexpr</span> _Tp*</span><br><span class="line">        _S_ptr(<span class="type">const</span> _Type&amp; <span class="type">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;_Tp*&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">array</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">typedef</span> _Tp                                     value_type;</span><br><span class="line">        <span class="keyword">typedef</span> value_type*                             pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> value_type*                       const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> value_type&amp;                             reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp;                       const_reference;</span><br><span class="line">        <span class="keyword">typedef</span> value_type*                             iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> value_type*                       const_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> std::<span class="type">size_t</span>                             size_type;</span><br><span class="line">        <span class="keyword">typedef</span> std::<span class="type">ptrdiff_t</span>                          difference_type;</span><br><span class="line">        <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;         reverse_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;   const_reverse_iterator;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Support for zero-sized arrays mandatory.</span></span><br><span class="line">        <span class="keyword">typedef</span> _GLIBCXX_STD_C::__array_traits&lt;_Tp, _Nm&gt; _AT_Type;</span><br><span class="line">        <span class="keyword">typename</span> _AT_Type::_Type                         _M_elems;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No explicit construct/copy/destroy for aggregate type.</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>看这里<code>typename _AT_Type::_Type _M_elems;</code>再看这里<code>typedef _Tp _Type[_Nm];</code>。懂了吗，就是在栈上分配一个大小固定的数组。</p>
<h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h2><p><code>vector</code>也是一个数组，只是不是分配在栈上的，而是分配在堆上的。</p>
<p>看这里有一个<code>_Alloc</code>默认使用的是<code>std::allocator&lt;_Tp&gt;</code>，这就是在堆上分配内存用的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  @brief A standard container which offers fixed time access to</span></span><br><span class="line"><span class="comment">     *  individual elements in any order.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *  @ingroup sequences</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *  @tparam _Tp  Type of element.</span></span><br><span class="line"><span class="comment">     *  @tparam _Alloc  Allocator type, defaults to allocator&lt;_Tp&gt;.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *  Meets the requirements of a &lt;a href=&quot;tables.html#65&quot;&gt;container&lt;/a&gt;, a</span></span><br><span class="line"><span class="comment">     *  &lt;a href=&quot;tables.html#66&quot;&gt;reversible container&lt;/a&gt;, and a</span></span><br><span class="line"><span class="comment">     *  &lt;a href=&quot;tables.html#67&quot;&gt;sequence&lt;/a&gt;, including the</span></span><br><span class="line"><span class="comment">     *  &lt;a href=&quot;tables.html#68&quot;&gt;optional sequence requirements&lt;/a&gt; with the</span></span><br><span class="line"><span class="comment">     *  %exception of @c push_front and @c pop_front.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *  In some terminology a %vector can be described as a dynamic</span></span><br><span class="line"><span class="comment">     *  C-style array, it offers fast and efficient access to individual</span></span><br><span class="line"><span class="comment">     *  elements in any order and saves the user from worrying about</span></span><br><span class="line"><span class="comment">     *  memory and size allocation.  Subscripting ( @c [] ) access is</span></span><br><span class="line"><span class="comment">     *  also provided as with C-style arrays.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">  <span class="keyword">class</span> vector : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">  &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _GLIBCXX_CONCEPT_CHECKS</span></span><br><span class="line">    <span class="comment">// Concept requirements.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::value_type               _Alloc_value_type;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line">    __glibcxx_class_requires(_Tp, _SGIAssignableConcept)</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">    <span class="built_in">static_assert</span>(is_same&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type, _Tp&gt;::value,</span><br><span class="line">        <span class="string">&quot;std::vector must have a non-const, non-volatile value_type&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __cplusplus &gt; 201703L || defined __STRICT_ANSI__</span></span><br><span class="line">    <span class="built_in">static_assert</span>(is_same&lt;<span class="keyword">typename</span> _Alloc::value_type, _Tp&gt;::value,</span><br><span class="line">        <span class="string">&quot;std::vector must have the same value_type as its allocator&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _Vector_base&lt;_Tp, _Alloc&gt;                 _Base;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::_Tp_alloc_type            _Tp_alloc_type;</span><br><span class="line">    <span class="keyword">typedef</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Alloc_traits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> _Tp                                       value_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::pointer                   pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc_traits::const_pointer     const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc_traits::reference         reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc_traits::const_reference   const_reference;</span><br><span class="line">        <span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator;</span><br><span class="line">        <span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;const_pointer, vector&gt;</span><br><span class="line">        const_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;     const_reverse_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;           reverse_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">size_t</span>                                    size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                                 difference_type;</span><br><span class="line">        <span class="keyword">typedef</span> _Alloc                                    allocator_type;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>再看这里定义了三个指针，用的是<code>typedef typename _Base::pointer pointer;</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std _GLIBCXX_VISIBILITY(<span class="keyword">default</span>)</span><br><span class="line">&#123;</span><br><span class="line">_GLIBCXX_BEGIN_NAMESPACE_VERSION</span><br><span class="line">_GLIBCXX_BEGIN_NAMESPACE_CONTAINER</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// See bits/stl_deque.h&#x27;s _Deque_base for an explanation.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_Vector_base</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::<span class="keyword">template</span></span><br><span class="line">      rebind&lt;_Tp&gt;::other _Tp_alloc_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;::pointer</span><br><span class="line">      pointer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_Vector_impl_data</span></span><br><span class="line">    &#123;</span><br><span class="line">      pointer _M_start;</span><br><span class="line">      pointer _M_finish;</span><br><span class="line">      pointer _M_end_of_storage;</span><br><span class="line"></span><br><span class="line">      _Vector_impl_data() _GLIBCXX_NOEXCEPT</span><br><span class="line">      : _M_start(), _M_finish(), _M_end_of_storage()</span><br><span class="line">      &#123; &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>指针分别叫：<code>pointer _M_start;</code>、<code>pointer _M_finish;</code>、<code>pointer _M_end_of_storage;</code> 之前不叫这个的，现在都改了。。。无所谓了，含义没变。。。</p>
<p><code>vector</code>在堆上申请了一块内存，用于存放数组元素。用<code>_M_start</code>表示数组开始的位置，用<code>_M_finish</code>数据结束的位置，用<code>_M_end_of_storage</code> 表示这块内存容量结束的位置。</p>
<ul>
<li>当<code>vector</code>容量不足时，需要进行扩容，扩容会引发内存拷贝。</li>
<li>当向<code>vector</code>插入、删除某些元素时，由于采用连续存储方式，也会引发内存拷贝。</li>
</ul>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>刚刚提到了扩容，如果一个<code>vector</code>容量不足了需要扩容，应该扩多少呢？这个根据<code>reserve()</code>的值来决定。如果你没有设置的话，按你存入的数据量进行扩容。如果你设置了这个值，那么每次扩<code>reserve()</code>个。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>To be countinue…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2021/09/27/language/cpp/variable-in-elf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/27/language/cpp/variable-in-elf/" class="post-title-link" itemprop="url">变量及函数在内存中的位置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-27 15:50:26" itemprop="dateCreated datePublished" datetime="2021-09-27T15:50:26+08:00">2021-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index"><span itemprop="name">language</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从一个CPP文件编译成ELF可执行文件过程中会把不同的变量和函数映射到不同的内存区域。这些不同的区域具有不同的访问权限，有的是只读的，有的是读写的，有的是可执行的。让我们举个简单的例子来了解一下。</p>
<p>示例代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> dst_type,<span class="keyword">typename</span> src_type&gt;</span></span><br><span class="line"><span class="function">dst_type <span class="title">pointer_cast</span><span class="params">(src_type src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">static_cast</span>&lt;dst_type*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;src));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">255</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> const_global_int = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Just a function\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inline_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">pfunc_t</span>)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="type">main_func_t</span>)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">static_func_t</span>)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am Show...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">localshow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am localshow...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> local_uninit_var;</span><br><span class="line">    <span class="type">int</span> local_init_var = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> const_local_int = <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* heap_int = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">pfunc_t</span> pf = func;</span><br><span class="line">    <span class="type">main_func_t</span> mf = main;</span><br><span class="line">    <span class="type">static_func_t</span> sf = static_func;</span><br><span class="line">    <span class="type">static_func_t</span> csf = Simple::Show;</span><br><span class="line">    <span class="type">void</span>* cpf = <span class="built_in">pointer_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;Simple::localshow);</span><br><span class="line">    <span class="type">pfunc_t</span> ipf = inline_func;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_uninit_var: 0x%x\n&quot;</span>, &amp;global_uninit_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_init_var: 0x%x\n&quot;</span>, &amp;global_init_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;static_var: 0x%x\n&quot;</span>, &amp;static_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;const_global_int: 0x%x\n&quot;</span>, &amp;const_global_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local_uninit_var: 0x%x\n&quot;</span>, &amp;local_uninit_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local_init_var: 0x%x\n&quot;</span>, &amp;local_init_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;const_local_int: 0x%x\n&quot;</span>, &amp;const_local_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;heap_int: 0x%x, 0x%x\n&quot;</span>, &amp;heap_int, heap_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;point_func: 0x%x, 0x%x\n&quot;</span>, &amp;pf, pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;point_main_func: 0x%x, 0x%x\n&quot;</span>, &amp;mf, mf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;static_func: 0x%x, 0x%x\n&quot;</span>, &amp;sf, sf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;class_static_func: 0x%x, 0x%x\n&quot;</span>, &amp;csf, csf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;class_local_func: 0x%x, 0x%x\n&quot;</span>, &amp;cpf, cpf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inline_func: 0x%x, 0x%x\n&quot;</span>, &amp;ipf, ipf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于ELF格式中有很多信息，我们只取<code>readelf --sections</code>相关信息<br>ELF结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[Nr] Name              Type             Address           Offset       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">[ 0]                   NULL             0000000000000000  00000000       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">[ 1] .interp           PROGBITS         00000000004002a8  000002a8       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">[ 2] .note.gnu.bu[...] NOTE             00000000004002c4  000002c4       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">[ 3] .note.ABI-tag     NOTE             00000000004002e8  000002e8       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">[ 4] .gnu.hash         GNU_HASH         0000000000400308  00000308       000000000000001c  0000000000000000   A       5     0     8</span><br><span class="line">[ 5] .dynsym           DYNSYM           0000000000400328  00000328       0000000000000090  0000000000000018   A       6     1     8</span><br><span class="line">[ 6] .dynstr           STRTAB           00000000004003b8  000003b8       000000000000007d  0000000000000000   A       0     0     1</span><br><span class="line">[ 7] .gnu.version      VERSYM           0000000000400436  00000436       000000000000000c  0000000000000002   A       5     0     2</span><br><span class="line">[ 8] .gnu.version_r    VERNEED          0000000000400448  00000448       0000000000000040  0000000000000000   A       6     2     8</span><br><span class="line">[ 9] .rela.dyn         RELA             0000000000400488  00000488       0000000000000018  0000000000000018   A       5     0     8</span><br><span class="line">[10] .rela.plt         RELA             00000000004004a0  000004a0       0000000000000078  0000000000000018  AI       5    22     8</span><br><span class="line">[11] .init             PROGBITS         0000000000401000  00001000       000000000000001a  0000000000000000  AX       0     0     4</span><br><span class="line">[12] .plt              PROGBITS         0000000000401020  00001020       0000000000000060  0000000000000010  AX       0     0     16</span><br><span class="line">[13] .text             PROGBITS         0000000000401080  00001080       0000000000000392  0000000000000000  AX       0     0     16</span><br><span class="line">[14] .fini             PROGBITS         0000000000401414  00001414       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">[15] .rodata           PROGBITS         0000000000402000  00002000       000000000000019e  0000000000000000   A       0     0     8</span><br><span class="line">[16] .eh_frame_hdr     PROGBITS         00000000004021a0  000021a0       0000000000000064  0000000000000000   A       0     0     4</span><br><span class="line">[17] .eh_frame         PROGBITS         0000000000402208  00002208       00000000000001b8  0000000000000000   A       0     0     8</span><br><span class="line">[18] .init_array       INIT_ARRAY       0000000000403de8  00002de8       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">[19] .fini_array       FINI_ARRAY       0000000000403df0  00002df0       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">[20] .dynamic          DYNAMIC          0000000000403df8  00002df8       0000000000000200  0000000000000010  WA       6     0     8</span><br><span class="line">[21] .got              PROGBITS         0000000000403ff8  00002ff8       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">[22] .got.plt          PROGBITS         0000000000404000  00003000       0000000000000040  0000000000000008  WA       0     0     8</span><br><span class="line">[23] .data             PROGBITS         0000000000404040  00003040       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">[24] .bss              NOBITS           000000000040404c  0000304c       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">[25] .comment          PROGBITS         0000000000000000  0000304c       000000000000005c  0000000000000001  MS       0     0     1</span><br><span class="line">[26] .debug_aranges    PROGBITS         0000000000000000  000030a8       0000000000000070  0000000000000000           0     0     1</span><br><span class="line">[27] .debug_info       PROGBITS         0000000000000000  00003118       000000000000031a  0000000000000000           0     0     1</span><br><span class="line">[28] .debug_abbrev     PROGBITS         0000000000000000  00003432       00000000000001d9  0000000000000000           0     0     1</span><br><span class="line">[29] .debug_line       PROGBITS         0000000000000000  0000360b       0000000000000114  0000000000000000           0     0     1</span><br><span class="line">[30] .debug_str        PROGBITS         0000000000000000  0000371f       0000000000000235  0000000000000001  MS       0     0     1</span><br><span class="line">[31] .debug_ranges     PROGBITS         0000000000000000  00003954       0000000000000060  0000000000000000           0     0     1</span><br><span class="line">[32] .symtab           SYMTAB           0000000000000000  000039b8       0000000000000750  0000000000000018          33    52     8</span><br><span class="line">[33] .strtab           STRTAB           0000000000000000  00004108       0000000000000298  0000000000000000           0     0     1</span><br><span class="line">[34] .shstrtab         STRTAB           0000000000000000  000043a0       0000000000000151  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>

<p>将上述代码编译运行打印出的结果对应到elf格式中相应的区域如下：</p>
<p><img src="/images/cpp/variable.png" alt="variable"></p>
<ul>
<li>所有代码无聊作何标记全部存储在<code>.text</code>段，换句话说从汇编的角度可以调用任何函数都可以被调用</li>
<li>全局的<code>const</code>常量存放在<code>.rodata</code>段</li>
<li>局部的<code>const</code>常量则存储在栈空间内，而常量的右值<code>127</code>则存放在<code>.text</code>段</li>
<li>已经初始化的全局变量或<code>static</code>变量存放在<code>.data</code>段</li>
<li>未初始化的全局变量存放在<code>bss</code>段</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2021/09/23/language/cpp/smart-pointers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/23/language/cpp/smart-pointers/" class="post-title-link" itemprop="url">C++智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-23 14:54:21" itemprop="dateCreated datePublished" datetime="2021-09-23T14:54:21+08:00">2021-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/language/" itemprop="url" rel="index"><span itemprop="name">language</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>智能指针，从其本质上说，就是要控制对象的销毁时机。换句话讲就是何时调用对象的析构函数。从C++11开始引入三个智能指针（<code>unique_ptr</code>,<code>shared_ptr</code>,<code>weak_ptr</code>），准确的说是四种（还有<code>auto_ptr</code>），但从C++17开始<code>auto_ptr</code>被移除了。所以就剩下上述三种了。所有的智能指针都包含在<code>memory</code>头文件中。</p>
<p>首先，很久以前的C++是没有智能指针的，用户创建在堆上的内存，智能自己显示的释放，如果没有释放就会造成内存泄漏。这种特点导致C++的使用成本很高，为了降低成本，引入了智能指针<code>unique_ptr</code>和<code>shared_ptr</code>。</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><code>unique_ptr</code>采用的是传递所有权的方式来控制对象的销毁时机。如其名字所示，其对象是独享的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple %d\n&quot;</span>, m_a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple func \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">            m_a = n;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">const</span> Simple&amp; p) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Copy Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Simple</span>() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Destroy\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unique_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// unique ptr</span></span><br><span class="line">    <span class="keyword">auto</span> s_ptr = std::<span class="built_in">make_unique</span>&lt;Simple&gt;(<span class="number">1</span>);</span><br><span class="line">    s_ptr-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    std::unique_ptr&lt;Simple&gt; s_copy_ptr = std::<span class="built_in">move</span>(s_ptr);</span><br><span class="line">    s_copy_ptr-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;Simple&gt; s_ptr_2(s_ptr);   // 无法编译通过</span></span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;Simple&gt; s_ptr_2 = s_ptr;  // 无法编译通过</span></span><br><span class="line">    s_ptr-&gt;<span class="built_in">showfunc</span>();</span><br><span class="line">    <span class="comment">//s_ptr-&gt;Show();    // 当所有权变更后就不该再用之前的指针访问对象资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>unique_ptr</code>禁用拷贝构造<br>  由于<code>unique_ptr</code>禁用了拷贝构造函数<code>unique_ptr(const unique_ptr&amp;) = delete;</code>，所以一切试图触发拷贝构造函数的操作都会引发编译错误。</li>
<li><code>unique_ptr</code>所有权一旦变更就不能使用原指针访问对象资源<br>  上述代码中有两处使用了原指针访问对象资源，第一处<code>s_ptr-&gt;showfunc();</code>没有报错，可以正常打印；<code>s_ptr-&gt;Show();</code>中使用到了成员变量<code>m_a</code>所以会导致报错“<code>this</code>空指针”。这是由于<code>std::move</code>的赋值操作触发了<code>unique_ptr</code>中的Move构造函数(<code>unique_ptr(unique_ptr&amp;&amp;) = default;</code>)，从而将<code>s_ptr</code>中的成员清空。所以再次访问原对象指针，就会出错。</li>
</ul>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><img src="/images/cpp/shared_ptr.png" alt="shared_ptr"></p>
<p><code>shared_ptr</code>采用的是引用计数的机制来控制对象的销毁时机。如其名字所示，其对象是共享的。当计数器等于0是，调用对象的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_test_inner</span><span class="params">(std::shared_ptr&lt;Simple&gt; *steal_ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// share ptr</span></span><br><span class="line">    <span class="keyword">auto</span> s_ptr = std::<span class="built_in">make_shared</span>&lt;Simple&gt;(<span class="number">1</span>);</span><br><span class="line">    s_ptr-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Simple&gt; <span class="title">s_copy_ptr</span><span class="params">(s_ptr)</span></span>;</span><br><span class="line">    s_copy_ptr-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    std::shared_ptr&lt;Simple&gt; s_ptr_2 = s_ptr;</span><br><span class="line">    s_ptr_2-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// try steal</span></span><br><span class="line">    *steal_ptr = s_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_test_leak</span>();</span><br><span class="line">    std::shared_ptr&lt;Simple&gt; s_ptr;</span><br><span class="line">    <span class="built_in">shared_test_inner</span>(&amp;s_ptr);</span><br><span class="line">    s_ptr-&gt;<span class="built_in">Show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽可能使用<code>make_shared</code>创建<code>shared_ptr</code>，如果使用<code>std::shared_ptr&lt;Simple&gt; s_ptr(new Simple(1))</code>创建<code>shared_ptr</code>，需要分配两次内存，一次是<code>new Simple(1)</code>；另一次是<code>shared_ptr</code>的引用计数。<code>make_shared</code>只分配一次。</p>
<p>现在创建一个<code>SimpleBack</code>类，然后再让<code>Simple</code>和<code>SimpleBack</code>循环引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleBack</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple %d\n&quot;</span>, m_a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple func \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">            m_a = n;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">const</span> Simple&amp; p) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Copy Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Simple</span>() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Destroy\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::shared_ptr&lt;SimpleBack&gt; m_sb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleBack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        std::shared_ptr&lt;Simple&gt; m_s;</span><br><span class="line">        ~<span class="built_in">SimpleBack</span>() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SimpleBack Destroy\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_test_leak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> s = std::<span class="built_in">make_shared</span>&lt;Simple&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> sb = std::<span class="built_in">make_shared</span>&lt;SimpleBack&gt;();</span><br><span class="line"></span><br><span class="line">    s-&gt;m_sb = sb;</span><br><span class="line">    sb-&gt;m_s = s;</span><br><span class="line">    <span class="comment">// 通过打印语句可以看到 s和sb的析构函数并没有调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过析构函数函数的打印语句可以看出<code>s</code>和<code>sb</code>并没有被析构，这说明<code>s</code>和<code>sb</code>泄漏了。</p>
<p>为了解决<code>shared_ptr</code>在循环依赖中内存泄漏的问题，推出了<code>weak_ptr</code>。</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><code>weak_ptr</code>不会增加引用计数，不能直接操作对象的内存（需要先调用<code>lock</code>接口），需要和<code>shared_ptr</code>配套使用。</p>
<p>将上述代码改成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleBack</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple %d\n&quot;</span>, m_a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello Simple func \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">            m_a = n;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simple</span>(<span class="type">const</span> Simple&amp; p) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Copy Construct\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Simple</span>() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Simple Destroy\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::shared_ptr&lt;SimpleBack&gt; m_sb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleBack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 将循环引用的其中一个改成weak_ptr</span></span><br><span class="line">        std::weak_ptr&lt;Simple&gt; m_s;</span><br><span class="line">        ~<span class="built_in">SimpleBack</span>() &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SimpleBack Destroy\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_test_leak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> s = std::<span class="built_in">make_shared</span>&lt;Simple&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> sb = std::<span class="built_in">make_shared</span>&lt;SimpleBack&gt;();</span><br><span class="line"></span><br><span class="line">    s-&gt;m_sb = sb;</span><br><span class="line">    sb-&gt;m_s = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过析构函数的打印语句可以看出，<code>s</code>和<code>sb</code>的析构函数在<code>shared_test_lead()</code>调用结束后被调用。</p>
<p>那么，<code>weak_ptr</code>的使用是不是也像<code>shared_ptr</code>一样呢？不是的。<code>weak_ptr</code>需要与<code>shared_ptr</code>配合使用，看一个例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">weak_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::weak_ptr&lt;Simple&gt; w;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> s = std::<span class="built_in">make_shared</span>&lt;Simple&gt;(<span class="number">3</span>);</span><br><span class="line">        w = s;</span><br><span class="line">        <span class="keyword">auto</span> s2 = w.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(s2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s2-&gt;<span class="built_in">Show</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;object &#x27;s&#x27; is destroied. \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lock</code><br>  若对象已被析构，则返回一个空的<code>shared_ptr</code>；否则返回实际的<code>shared_ptr</code>。</li>
<li><code>expired</code><br>  若对象已被析构，则返回<code>true</code>；否则返回<code>false</code></li>
</ul>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="http://senlinzhan.github.io/2015/04/24/%E6%B7%B1%E5%85%A5shared-ptr/">谈谈 shared_ptr 的那些坑</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cb3e574eee5f">智能指针的线程安全</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qingdujun/article/details/74858071">C++14 智能指针unique_ptr、shared_ptr、weak_ptr</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Solstice/archive/2013/01/28/2879366.html">为什么多线程读写 shared_ptr 要加锁？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2021/09/12/design/pattern/design-structural-patterns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/12/design/pattern/design-structural-patterns/" class="post-title-link" itemprop="url">设计模式——结构型模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-12 14:28:28" itemprop="dateCreated datePublished" datetime="2021-09-12T14:28:28+08:00">2021-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design/" itemprop="url" rel="index"><span itemprop="name">design</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>书接上文“<a href="https://zhoubofsy.github.io/2021/09/10/design/pattern/design-pattern-creating/">设计模式——创建型模式</a>”，上回说到前人创造出了很多创建型的模式，这回我们说说结构型模式。先以教科书形式介绍一下。</p>
<p>结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。</p>
<ul>
<li>类结构型模式<br>  类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。</li>
<li>对象结构型模式<br>  类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。</li>
</ul>
<p>根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。</p>
<p>能看得懂，但是不够生动。接下来我们让它生动、活泼一下。</p>
<p>在元祖王朝赛博坦帝国的一个边远矿业基地，矿区提纯运输车形态的矿工钢锁被工作调动到了这个位于某个卫星上的矿厂。本来与世无争的钢锁，遇到了一起恐怖事件，由此改变了他的火种（心灵）变形形态（肉体）人生轨迹（命运）。他就是我们今天的主角变形金刚。变形金刚分为两派，一为博派（Autobots），一为狂派（Decepticons），二者都有变形的能力。</p>
<p>让我们抽象一下，是否可以将<code>Transforms</code>的变形能力抽化出来，然后再让博派和狂派分别去实现自己的变形方法。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Autobot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AutobotsTransform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Autobots Transform, Please...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerAdapter</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Autobot *m_a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TransformerAdapter</span>(Autobot *a) &#123;</span><br><span class="line">            m_a = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是“适配器模式”</p>
<hr>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>再教科书一下。。。</p>
<p><img src="/images/patterns/adapter_1.jpg" alt="adapter_1"></p>
<p><img src="/images/patterns/adapter_2.jpg" alt="adapter_2"></p>
<hr>
<p>刚刚收到一个需求，要为每一个变形金刚做一个自己独有的变形特效，而且在变形的过程中要加入背景音乐。所以我们需要修改一下之前的“适配器”设计模式，增加一层背景效果层，然后将背景效果传递给变形金刚，当变形金刚变形的时候将效果播放出来就好了。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Background</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformBackground</span> : <span class="keyword">public</span> Background &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ki ka ka ka......\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Background *bg;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decepticon</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Decepticon</span>(Background* b) &#123;</span><br><span class="line">            bg = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            bg-&gt;<span class="built_in">Display</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Decepticon Transform, Please...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是“桥模式”</p>
<hr>
<h2 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h2><p>再教科书一下。。。</p>
<p><img src="/images/patterns/bridge_1.jpg" alt="bridge_1"></p>
<p>** 优点: **</p>
<ul>
<li>分离抽象接口及其实现部分。</li>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li>
<li>实现细节对客户透明，可以对用户隐藏实现细节。</li>
</ul>
<p><img src="/images/patterns/bridge_2.jpg" alt="bridge_2"></p>
<p>** 缺点：**</p>
<ul>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li>
</ul>
<hr>
<p>又来需求了，现在我们需要变形金刚开口说话，以后还需要变形金刚会开炮。总结一下，变形是一个基本的功能，然后先增加一个说话的功能，如果有需要以后还可以增加开炮的功能。每增加一个功能不修改之前的代码，因为修改已经测试过的代码会给程序的稳定性带来隐患。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Background *bg;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bumblebee</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Bumblebee Transform, Please...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerDecorator</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Transformer* tf;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            tf-&gt;<span class="built_in">transform</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BumblebeeSay</span> : <span class="keyword">public</span> TransformerDecorator &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BumblebeeSay</span>(Transformer* t) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;tf = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;wuwuwuwu...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            TransformerDecorator::<span class="built_in">transform</span>();</span><br><span class="line">            <span class="built_in">say</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这就是“装饰模式”</p>
<hr>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>再教科书一下。。。</p>
<p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。</p>
<p><img src="/images/patterns/decorator_1.jpg" alt="decorator_1"></p>
<ul>
<li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li>
<li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”</li>
</ul>
<p><img src="/images/patterns/decorator_2.jpg" alt="decorator_2"></p>
<ul>
<li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li>
</ul>
<hr>
<p>战争一触即发，为了取得胜利，我们需要快速的生产变形金刚，需要弄一个map，存储已经创建好的，当有战事发生时，从map里直接取出进行战斗。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Background *bg;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bumblebee</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Bumblebee Transform, Please...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerFlyweight</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::map&lt;std::string,Transformer*&gt; members;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Transformer* <span class="title">get</span><span class="params">(std::string key)</span></span>&#123;</span><br><span class="line">            Transformer* tf = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">auto</span> search = members.<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(search != members.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                tf = search-&gt;second;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// new</span></span><br><span class="line">                tf = <span class="keyword">new</span> <span class="built_in">Bumblebee</span>();</span><br><span class="line">                members.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key, tf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tf;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这就是“享元模式”</p>
<hr>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>再教科书一下。。。</p>
<p>享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p>
<p><img src="/images/patterns/flyweight_1.jpg" alt="flyweight_1"></p>
<p>** 优点 **</p>
<ul>
<li>享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。</li>
<li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li>
</ul>
<p><img src="/images/patterns/flyweight_2.jpg" alt="flyweight_2"></p>
<p>** 缺点 **</p>
<ul>
<li>享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li>
</ul>
<hr>
<p>变形金刚出了个Bug，若在每次变形过程中收到攻击，变形金刚将毫无防御能力。所以需要增加一个防护罩，在变形前开启，在变形后关闭，这样增加变形金刚的变形过程中的防御能力。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Background *bg;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bumblebee</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Bumblebee Transform, Please...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerProxy</span> : <span class="keyword">public</span> Transformer &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Transformer *m_tf;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">save_on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;saving...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">save_off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;save done\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TransformerProxy</span>(Transformer *tf) &#123;</span><br><span class="line">            m_tf = tf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">save_on</span>();</span><br><span class="line">            m_tf-&gt;<span class="built_in">transform</span>();</span><br><span class="line">            <span class="built_in">save_off</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是“代理模式”</p>
<hr>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><img src="/images/patterns/proxy_1.jpg" alt="proxy_1"></p>
<p>** 优点 **</p>
<ul>
<li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li>
<li>远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li>
<li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。</li>
<li>保护代理可以控制对真实对象的使用权限。</li>
</ul>
<p><img src="/images/patterns/proxy_2.jpg" alt="proxy_2"></p>
<p>** 缺点 **</p>
<ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。</li>
<li>实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。</li>
</ul>
<hr>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/structural.html">结构型模式</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2021/09/10/design/pattern/design-pattern-creating/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/10/design/pattern/design-pattern-creating/" class="post-title-link" itemprop="url">设计模式——创建型模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-10 11:01:23" itemprop="dateCreated datePublished" datetime="2021-09-10T11:01:23+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design/" itemprop="url" rel="index"><span itemprop="name">design</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>设计模式是前人在工作总结出来的一些设计经验。后人使用这些经验进行设计开发，可以减少设计缺陷。常用的设计模式有23个，这23个设计模式分为三类，分别是“创建型模式”、“<a href="">行为型模式</a>”、“<a href="">结构型模式</a>”。</p>
<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>顾名思义，用来创建生成对象的设计模式。创建型模式包括：“单例模式”、“工厂模式”和“构建者模式”，其中工厂模式又分为“简单工厂模式”、“工厂方法模式”和“抽象工厂模式”。</p>
<p>故事是这样开始的……</p>
<p>在很久很久以前，有个<code>Product</code>他是这样定义的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那时候还没有设计模式，人们创建对象一般都是用<code>new</code>在堆上分配或者直接在栈上定义。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProductA *p = <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">    p-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来，使用这个<code>Product</code>对象的人越来越多，每个人都想new一下，而且<code>Product</code>又不想被频繁的new，于是前人想了个办法将<code>Product</code>的对象定义为一个<code>static</code>的变量，然后每次在<code>new</code>之前判断一下，看是否需要<code>new</code>。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> ProductA *m_p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> ProductA* <span class="title">CreateProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                m_p = <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m_p;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是“单例模式”。</p>
<hr>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>某个类只能有一个实例</li>
<li>它必须自行创建这个实例</li>
<li>它必须自行向整个系统提供这个实例</li>
</ul>
<p><img src="/images/patterns/single_1.jpg" alt="single_1"></p>
<ul>
<li>单例类的构造函数为私有</li>
<li>提供一个自身的静态私有成员变量</li>
<li>提供一个公有的静态工厂方法</li>
</ul>
<p><img src="/images/patterns/single_2.jpg" alt="single_2"></p>
<hr>
<p>后来，前人又开发了<code>ProductB</code>，<code>ProductA</code>和<code>ProductB</code>同属于<code>Product</code>，于是我们的product变成了这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了方便创建对象，前人决定用<code>&quot;PA&quot;</code>代表<code>ProductA</code>、<code>&quot;PB&quot;</code>代表<code>ProductB</code>，再创建一个工厂，用来创建对象，在创建对象时候指定<code>PA</code> 或者<code>PB</code>，工厂根据指定的内容来决定是创建<code>ProductA</code>还是<code>ProductB</code>。</p>
<p>Example：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PD_TYPE</span> &#123;</span><br><span class="line">    PA,</span><br><span class="line">    PB</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProduct</span><span class="params">(PD_TYPE pt)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">SimpleFactory::CreateProduct</span><span class="params">(PD_TYPE pt)</span></span>&#123;</span><br><span class="line">    Product *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span>(pt) &#123;</span><br><span class="line">        <span class="keyword">case</span> PA:</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PB:</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>这就是“简单工厂模式”。</p>
<hr>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul>
<li>根据参数的不同返回不同类的实例</li>
<li>简单工厂模式专门定义一个类来负责创建其他类的实例</li>
<li>被创建的实例通常都具有共同的父类</li>
</ul>
<p><img src="/images/patterns/simple_factory_1.jpg" alt="simple_factory_1"></p>
<p><img src="/images/patterns/simple_factory_2.jpg" alt="simple_factory_2"></p>
<hr>
<p>随着<code>Product</code>种类的不断增加，我们需要不断的修改<code>SimpleFactory::CreateProduct</code>方法，这样会增加<code>SimpleFactory::CreateProduct</code>出错的风险，所以前人按照不同的产品创建了不同的工厂，这样以后在增加新的产品只需要增加对应的工厂就可以了。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MethodFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Product* <span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MethodFactoryPA</span> : <span class="keyword">public</span> MethodFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MethodFactoryPB</span> : <span class="keyword">public</span> MethodFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">MethodFactoryPA::CreateProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">MethodFactoryPB::CreateProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是“工厂方法模式”</p>
<hr>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><img src="/images/patterns/method_factory_1.jpg" alt="method_factory_1"></p>
<p>工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成。</p>
<p><img src="/images/patterns/method_factory_2.jpg" alt="method_factory_2"></p>
<hr>
<p>从现在开始我们要将产品变多<code>ProductA1</code>、<code>ProductA2</code>、<code>ProductB1</code>、<code>ProductB2</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA1</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA2</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB1</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB2</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要求工厂生产<code>ProductA1</code>时，也要生产<code>ProductB1</code>；生产<code>ProductA1</code>时，也要生产<code>ProductB2</code>。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Product* <span class="title">CreateProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Product* <span class="title">CreateProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactoryOne</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProductA</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactoryTwo</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProductA</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Product* <span class="title">CreateProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">AbstractFactoryOne::CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">AbstractFactoryOne::CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">AbstractFactoryTwo::CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">AbstractFactoryTwo::CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是“抽象工厂模式”。</p>
<hr>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><img src="/images/patterns/abstract_factory_1.jpg" alt="abstract_factory_1"></p>
<p>与工厂方法很类似，区别在于工厂方法用于一个产品的构建，抽象工厂适用于多个产品构建</p>
<p><img src="/images/patterns/abstract_factory_2.jpg" alt="abstract_factory_2"></p>
<hr>
<p>抽象工厂模式可以让我们批量生产产品了，但是抽象工厂只能生产固定种类的产品，如果我们要让<code>ProductA1</code>、<code>ProductA2</code>、<code>ProductB1</code>、<code>ProductB2</code>随意组合，生成不同的套餐，然后再进行生产。前人想了这样一个办法。。。</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Product* <span class="title">BuildProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductABuilder</span> : <span class="keyword">public</span> Builder&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Product* <span class="title">BuildProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Builder* builder;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setBuilder</span><span class="params">(Builder* b)</span></span>;</span><br><span class="line">        <span class="function">Product* <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">ProductABuilder::BuildProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Director::setBuilder</span><span class="params">(Builder* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;builder = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Product* <span class="title">Director::build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;builder-&gt;<span class="built_in">BuildProduct</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是“建造者模式”</p>
<hr>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p><img src="/images/patterns/builder_1.jpg" alt="builder_1"></p>
<p><img src="/images/patterns/builder_2.jpg" alt="builder_2"></p>
<p>** To be continue …**</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2020/11/17/storage/spdk-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/17/storage/spdk-introduce/" class="post-title-link" itemprop="url">SPDK简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-17 10:17:29" itemprop="dateCreated datePublished" datetime="2020-11-17T10:17:29+08:00">2020-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SPDK（Storage Performance Development Kit）是Intel发布的存储性能开发工具集</p>
<p>用户使用现在的固态设备，比如Intel® SSD DC P3700 Series Non-Volatile Memory Express（NVMe）驱动，面临一个主要的挑战：因为吞吐量和延迟性能比传统的磁盘好太多，现在总的处理时间中，存储软件占用了更大的比例。换句话说，存储软件栈的性能和效率在整个存储系统中越来越重要。随着存储设备继续发展，它将面临远远超过正在使用的软件体系结构的风险（即存储设备受制于相关软件的不足而不能发挥全部性能）</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul>
<li>用户态运行<br>  避免内核上下文切换和中断将会节省大量的处理开销，允许更多的时钟周期被用来做实际的数据存储。无论存储算法（去冗，加密，压缩，空白块存储）多么复杂，浪费更少的时钟周期总是意味着更好的性能和延迟。这并不是说内核增加了不必要的开销；相反，内核增加了那些可能不适用于专用存储堆栈的通用计算用例的相关开销。SPDK的指导原则是通过消除每一处额外的软件开销来提供最少的延迟和最高的效率。</li>
<li>轮询模式取代中断模式（Polled Mode Drivers, PMDs）<br>  在传统的I&#x2F;O模型中，应用程序提交读写请求后睡眠，一旦I&#x2F;O完成，中断就会将其唤醒。PMDs的工作方式不同，应用程序提交读写请求后继续执行其他工作，以一定的时间间隔回头检查I&#x2F;O是否已经完成。这种方式避免了中断带来的延迟和开销，并使得应用程序提高了I&#x2F;O的效率。<br>  在机械盘时代，中断开销只占整个I&#x2F;O时间的一个很小的百分比，因此给系统带来了巨大的效率提升。然而，在固态设备的时代，持续引入更低延迟的持久化设备，中断开销成为了整个I&#x2F;O时间中不能被忽视的部分。这个问题在更低延迟的设备上只会越来越严重。系统已经能够每秒处理数百万个I&#x2F;O，所以消除数百万个事务的这种开销，能够快速地复制到多个内核中。数据包和数据块被立即分发，等待时间减小到最少，使得延迟更低，一致性延迟更多（抖动更少），吞吐量也得到提高。</li>
<li>无锁机制<br>  在IO路径上避免采用任何锁机制进行同步，降低时延并提升吞吐量</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="/images/spdk/introduction-to-the-storage-performance-development-kit-spdk-fig2.png" alt="introduction-to-the-storage-performance-development-kit-spdk-fig2"></p>
<h3 id="Hardware-Drivers"><a href="#Hardware-Drivers" class="headerlink" title="Hardware Drivers"></a>Hardware Drivers</h3><h4 id="NVMe-Driver"><a href="#NVMe-Driver" class="headerlink" title="NVMe Driver"></a>NVMe Driver</h4><p>SPDK的基础组件，这个高优化无锁的驱动提供了高扩展性，高效性和高性能。</p>
<h4 id="Inter-QuickData-Technology"><a href="#Inter-QuickData-Technology" class="headerlink" title="Inter QuickData Technology"></a>Inter QuickData Technology</h4><p>Intel I&#x2F;O Acceleration Technology（Inter IOAT，英特尔I&#x2F;O加速技术），这是一种基于Xeon处理器平台上的copy offload引擎。通过提供用户空间访问，减少了DMA数据移动的阈值，允许对小尺寸I&#x2F;O或NTB的更好利用。</p>
<h3 id="Back-end-Block-Devices"><a href="#Back-end-Block-Devices" class="headerlink" title="Back-end Block Devices"></a>Back-end Block Devices</h3><h4 id="NVMe-oF-Initiator"><a href="#NVMe-oF-Initiator" class="headerlink" title="NVMe-oF Initiator"></a>NVMe-oF Initiator</h4><p>本地SPDK NVMe驱动和NVMe-oF启动器共享一套共同的API命令。这意味着，比如本地&#x2F;远程复制非常容易实现。</p>
<h4 id="Ceph-RADOS-Block-Device"><a href="#Ceph-RADOS-Block-Device" class="headerlink" title="Ceph RADOS Block Device"></a>Ceph RADOS Block Device</h4><p>Ceph RBD 成为SPDK的后端设备</p>
<h4 id="Blobstore-Block-Device"><a href="#Blobstore-Block-Device" class="headerlink" title="Blobstore Block Device"></a>Blobstore Block Device</h4><p>由SPDK Blobstore分配的块设备，是虚拟机或数据库可以与之交互的虚拟设备。这些设备得到SPDK基础架构的优势，意味着零拷贝和令人难以置信的可扩展性。</p>
<h4 id="Linux-AIO"><a href="#Linux-AIO" class="headerlink" title="Linux AIO"></a>Linux AIO</h4><p>允许SPDK与内核设备（比如机械硬盘）交互。</p>
<h3 id="Storage-Services"><a href="#Storage-Services" class="headerlink" title="Storage Services"></a>Storage Services</h3><h4 id="Block-Device-Abstration-Layer"><a href="#Block-Device-Abstration-Layer" class="headerlink" title="Block Device Abstration Layer"></a>Block Device Abstration Layer</h4><p>这种通用的块设备抽象是连接到各种不同设备驱动和块设备的存储协议的粘合剂。还在块层中提供灵活的API用于额外的用户功能（磁盘阵列，压缩，去冗等等）。</p>
<h4 id="Blobstore"><a href="#Blobstore" class="headerlink" title="Blobstore"></a>Blobstore</h4><p>为SPDK实现一个高精简的文件式语义（非POSIX）。这可以为数据库，容器，虚拟机或其他不依赖于大部分POSIX文件系统功能集（比如用户访问控制）的工作负载提供高性能基础。</p>
<h3 id="Storage-Protocols"><a href="#Storage-Protocols" class="headerlink" title="Storage Protocols"></a>Storage Protocols</h3><h4 id="iSCSI-Target"><a href="#iSCSI-Target" class="headerlink" title="iSCSI Target"></a>iSCSI Target</h4><p>建立了通过以太网的块流量规范，大约是内核LIO效率的两倍。现在的版本默认使用内核TCP&#x2F;IP协议栈。</p>
<h4 id="vhost-scsi-target"><a href="#vhost-scsi-target" class="headerlink" title="vhost-scsi target"></a>vhost-scsi target</h4><p>KVM&#x2F;QEMU的功能利用了SPDK NVMe驱动，使得访客虚拟机访问存储设备时延迟更低，使得I&#x2F;O密集型工作负载的整体CPU负载减低。</p>
<h4 id="NVMe-oF-Target"><a href="#NVMe-oF-Target" class="headerlink" title="NVMe-oF Target"></a>NVMe-oF Target</h4><p>实现了NVMe-oF规范。虽然这取决于RDMA硬件，NVMe-oF的目标可以为每个CPU核提供高达40Gbps的流量。</p>
<h1 id="应用方案"><a href="#应用方案" class="headerlink" title="应用方案"></a>应用方案</h1><p><img src="/images/spdk/spdk_component.png" alt="spdk_component"></p>
<h3 id="网络前端"><a href="#网络前端" class="headerlink" title="网络前端"></a>网络前端</h3><p>网络前端子组件包括DPDK网卡驱动和用户态网络服务UNS（这是一个Linux内核TCP&#x2F;IP协议栈的替代品，能够突破通用TCP&#x2F;IP协议栈的种种性能限制瓶颈）。DPDK在网卡侧提供了一个高性能的发包收包处理框架，在数据从网卡到操作系统用户态之间提供了一条快速通道。</p>
<h3 id="处理框架"><a href="#处理框架" class="headerlink" title="处理框架"></a>处理框架</h3><p>拿到了数据包内容，将iSCSI命令转换为SCSI块级命令。然而，在它将这些命令发到“后端”驱动之前，SPDK提供了一套API框架，让厂商能够插入自己定义的处理逻辑(架构图中绿色的方框)。通过这种机制，存储厂商可在这里实现例如缓存、去重、压缩、加密、RAID计算，或擦除码(Erasure Coding)计算等功能，使这些功能包含在SPDK的处理流程中。</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>SPDK和物理块设备交互(读和写操作)。如前所述，SPDK提供了用户态的PMD，支持NVMe设备、Linux AIO设备(传统机械硬盘)、RAMDISK设备，以及利用到英特尔I&#x2F;O加速技术的新设备(CBDMA)。这一系列后端设备驱动涵盖了不同性能的存储分层，保证SPDK几乎与每种存储应用形成关联。</p>
<h1 id="使用及编译"><a href="#使用及编译" class="headerlink" title="使用及编译"></a>使用及编译</h1><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>SPDK使用了DPDK中的一些功能，编译SPDK需要依赖DPDK，所以需要先编译安装DPDK</p>
<p>编译DPDK</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make config T=x86_64-native-linuxapp-gcc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure>
<p>默认DPDK会安装到<code>/usr/local</code>目录下</p>
<p>编译SPDK</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./configure --with-dpdk=/usr/local</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>nvme设备插入主机会被系统自动识别。若想使用spdk访问该设备必须现将nvme unbind。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lsblk</span></span><br><span class="line">NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda       8:0    0  7.3T  0 disk</span><br><span class="line">└─sda1    8:1    0  7.3T  0 part /</span><br><span class="line">sdb       8:16   0  7.3T  0 disk</span><br><span class="line">sdc       8:32   0  7.3T  0 disk</span><br><span class="line">sdd       8:48   0  3.8G  0 disk</span><br><span class="line">└─sdd1    8:49   0  3.8G  0 part /boot</span><br><span class="line">nvme0n1 259:0    0  1.5T  0 disk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> &lt;spdk_dir&gt;/scripts</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh setup.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0  7.3T  0 disk</span><br><span class="line">└─sda1   8:1    0  7.3T  0 part /</span><br><span class="line">sdb      8:16   0  7.3T  0 disk</span><br><span class="line">sdc      8:32   0  7.3T  0 disk</span><br><span class="line">sdd      8:48   0  3.8G  0 disk</span><br><span class="line">└─sdd1   8:49   0  3.8G  0 part /boot</span><br></pre></td></tr></table></figure>

<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/whl320124/articles/9969395.html">SPDK简介</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6892df050b5a">使用fio测试SPDK</a></li>
<li><a target="_blank" rel="noopener" href="https://rootw.github.io/2018/05/SPDK-all/">【SPDK】一、概述</a></li>
<li><a target="_blank" rel="noopener" href="https://software.intel.com/content/www/us/en/develop/articles/introduction-to-the-storage-performance-development-kit-spdk.html">Introduction to the Storage Performance Development Kit (SPDK)</a></li>
<li><a target="_blank" rel="noopener" href="https://tonydeng.github.io/sdn-handbook/dpdk/spdk.html">SPDK</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2020/11/11/storage/ceph/async-messenger-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/11/storage/ceph/async-messenger-introduce/" class="post-title-link" itemprop="url">AsyncMessenger介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-11 15:05:40" itemprop="dateCreated datePublished" datetime="2020-11-11T15:05:40+08:00">2020-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>说到Ceph的通讯一定绕不开Messenger，无论是客户端到OSD，还是OSD到MON，或者OSD到OSD，都需要Messenger来协助完成各个模块间消息的发送、接收。Messenger有三种实现，分别是SimpleMessenger、AsyncMessenger、XioMessenger，本文以AsyncMessenger为例简单介绍一下其工作原理。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="/images/asyncmessenger/ceph-AsyncMessenger.png" alt="asyncmessenger"></p>
<ul>
<li><code>processors</code>线程数量由<code>cct-&gt;_conf-&gt;ms_async_op_threads</code>决定</li>
<li><code>NetworkStack</code>中<code>workers</code>与<code>processors</code>一一对应。</li>
<li><code>processors</code>收到请求会调创建<code>AsyncConnection</code>，并存入调用<code>AsyncConnection</code>实例的<code>accept</code>方法，<code>accept</code>通过<code>EventCenter</code>将由<code>NetworkStack</code>的<code>workers</code>调用<code>AsyncConnection</code>实例的<code>process</code>方法。(哈哈哈，绕吧，有点儿晕了吧～～～)</li>
<li><code>processors</code>处理完accept请求后，将<code>AsyncConnection</code>实例存入<code>accepting_conns</code>，等待<code>NetworkStack</code>处理完成。</li>
<li><code>AsyncConnection</code>的<code>process</code>被<code>NetworkStack</code>的<code>workers</code>线程调用，并构建<code>Message</code>消息通过<code>dispatch_queue</code>或<code>ms_fast_dispatch</code>发送到<code>fast_dispatchers</code>。</li>
</ul>
<h1 id="Message-格式"><a href="#Message-格式" class="headerlink" title="Message 格式"></a>Message 格式</h1><h2 id="CEPH-MSGR-TAG-MSG"><a href="#CEPH-MSGR-TAG-MSG" class="headerlink" title="CEPH_MSGR_TAG_MSG"></a>CEPH_MSGR_TAG_MSG</h2><p><img src="/images/asyncmessenger/ceph-message_format.png" alt="message_format"></p>
<ul>
<li>tag  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_READY         1  <span class="comment">/* server-&gt;client: ready for messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_RESETSESSION  2  <span class="comment">/* server-&gt;client: reset, try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_WAIT          3  <span class="comment">/* server-&gt;client: wait for racing incoming connection */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_RETRY_SESSION 4  <span class="comment">/* server-&gt;client + cseq: try again with higher cseq */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_RETRY_GLOBAL  5  <span class="comment">/* server-&gt;client + gseq: try again with higher gseq */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_CLOSE         6  <span class="comment">/* closing pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_MSG           7  <span class="comment">/* message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_ACK           8  <span class="comment">/* message ack */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_KEEPALIVE     9  <span class="comment">/* just a keepalive byte! */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_BADPROTOVER  10  <span class="comment">/* bad protocol version */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_BADAUTHORIZER 11 <span class="comment">/* bad authorizer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_FEATURES      12 <span class="comment">/* insufficient features */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_SEQ           13 <span class="comment">/* 64-bit int follows with seen seq number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_KEEPALIVE2     14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_KEEPALIVE2_ACK 15  <span class="comment">/* keepalive reply */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER 16  <span class="comment">/* ceph v2 doing server challenge */</span></span></span><br></pre></td></tr></table></figure>
  ** 我觉得注释处的说明写的很清楚了，此处不做过多说明了。 **</li>
<li>header  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ceph_msg_header</span> &#123;</span><br><span class="line">    __le64 seq;       <span class="comment">/* message seq# for this session */</span></span><br><span class="line">    __le64 tid;       <span class="comment">/* transaction id */</span></span><br><span class="line">    __le16 type;      <span class="comment">/* message type */</span></span><br><span class="line">    __le16 priority;  <span class="comment">/* priority.  higher value == higher priority */</span></span><br><span class="line">    __le16 version;   <span class="comment">/* version of message encoding */</span></span><br><span class="line"></span><br><span class="line">    __le32 front_len; <span class="comment">/* bytes in main payload */</span></span><br><span class="line">    __le32 middle_len;<span class="comment">/* bytes in middle payload */</span></span><br><span class="line">    __le32 data_len;  <span class="comment">/* bytes of data payload */</span></span><br><span class="line">    __le16 data_off;  <span class="comment">/* sender: include full offset;</span></span><br><span class="line"><span class="comment">                 receiver: mask against ~PAGE_MASK */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ceph_entity_name</span> src;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* oldest code we think can decode this.  unknown if zero. */</span></span><br><span class="line">    __le16 compat_version;</span><br><span class="line">    __le16 reserved;</span><br><span class="line">    __le32 crc;       <span class="comment">/* header crc32c */</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure></li>
<li>payload<br>  *** 未知 ***</li>
<li>middle<br>  *** 未知 ***</li>
<li>data<br>  具体传递的数据内容，数据大小由<code>header</code>中的<code>data_len</code>决定。</li>
<li>footer&#x2F;old_footer  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * follows data payload</span></span><br><span class="line"><span class="comment"> * ceph_msg_footer_old does not support digital signatures on messages PLR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ceph_msg_footer_old</span> &#123;</span><br><span class="line">    __le32 front_crc, middle_crc, data_crc;</span><br><span class="line">    __u8 flags;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ceph_msg_footer</span> &#123;</span><br><span class="line">    __le32 front_crc, middle_crc, data_crc;</span><br><span class="line">    <span class="comment">// sig holds the 64 bits of the digital signature for the message PLR</span></span><br><span class="line">    __le64  sig;</span><br><span class="line">    __u8 flags;</span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>
  <code>footer</code>与<code>old_footer</code>之差一个签名<code>sig</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2020/11/08/algorithm/raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/08/algorithm/raft/" class="post-title-link" itemprop="url">Raft</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-08 17:14:04" itemprop="dateCreated datePublished" datetime="2020-11-08T17:14:04+08:00">2020-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>分布式系统在极大提高可用性、容错性的同时，带来了一致性问题（CAP理论）。Raft算法能够解决分布式系统环境下的一致性问题。一致性是分布式系统容错的基本问题。一致性涉及多个服务器状态（Values）达成一致。 一旦他们就状态做出决定，该决定就是最终决定。 当大多数服务器可用时，典型的一致性算法会取得进展。</p>
<p>raft是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。在这里强调了是在工程上，因为在学术理论界，最耀眼的还是大名鼎鼎的Paxos。但Paxos是：少数真正理解的人觉得简单，尚未理解的人觉得很难，大多数人都是一知半解。本人也花了很多时间、看了很多材料也没有真正理解。直到看到raft的论文，两位研究者也提到，他们也花了很长的时间来理解Paxos，他们也觉得很难理解，于是研究出了raft算法。</p>
<h1 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h1><p>raft协议中，一个节点任一时刻处于<code>leader</code>, <code>follower</code>, <code>candidate</code>三个角色之一。</p>
<ul>
<li>leader 接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li>
<li>follower 接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li>
<li>candidate Leader选举过程中的临时角色。</li>
</ul>
<p><img src="/images/raft/election_state.jpg" alt="election_state"></p>
<p>每个节点以<code>follower</code>角色开始，如果<code>follower</code>超时没有收到<code>leader</code>的消息，它会进入<code>candidate</code>角色，并发起选举投票。如果<code>candidate</code>收到的票数超过半数以上，则切换为<code>leader</code>角色。如果发现其他节点比自己更新，则主动切换到<code>follower</code>。总之，系统中最多只有一个<code>leader</code>，如果在一段时间里发现没有<code>leader</code>，则大家通过选举-投票选出<code>leader</code>。<code>leader</code>会不停的给<code>follower</code>发心跳消息，表明自己的存活状态。如果<code>leader</code>故障，那么<code>follower</code>会转换成<code>candidate</code>，重新选出<code>leader</code>。</p>
<p><img src="/images/raft/election_term.png" alt="election_term"></p>
<p>leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫term。term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；另外，term 3展示了一种情况，就是说没有选举出leader就结束了，然后会发起新的选举。</p>
<h2 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h2><h3 id="正常情况下选举"><a href="#正常情况下选举" class="headerlink" title="正常情况下选举"></a>正常情况下选举</h3><p>5个节点一开始的状态都是<code>Follower</code>。<br><img src="/images/raft/election_flow_normal_1.png" alt="election_flow_normal_1"></p>
<p>在一个节点倒计时结束(Timeout) 后，这个节点的状态变成<code>Candidate</code>开始选举，它给其他几个节点发送选举请求(RequestVote)<br><img src="/images/raft/election_flow_normal_2.png" alt="election_flow_normal_2"></p>
<p>其他四个节点都返回成功，这个节点的状态由<code>Candidate</code>变成了<code>Leader</code>，并在每个一小段时间后，就给所有的<code>Follower</code>发送一个 Heartbeat 以保持所有节点的状态，<code>Follower</code>收到<code>Leader</code>的Heartbeat后重设Timeout。<br><img src="/images/raft/election_flow_normal_3.png" alt="election_flow_normal_3"></p>
<p>只要有超过一半的节点投支持票了，<code>Candidate</code>才会被选举为<code>Leader</code>，5个节点的情况下，3个节点 (包括<code>Candidate</code>本身) 投了支持就行。</p>
<h3 id="Leader-出故障情况下的选举"><a href="#Leader-出故障情况下的选举" class="headerlink" title="Leader 出故障情况下的选举"></a>Leader 出故障情况下的选举</h3><p><img src="/images/raft/election_flow_error_leader_1.png" alt="election_flow_error_leader_1"></p>
<p><code>leader</code>出故障挂掉了，其他四个<code>follower</code>将进行重新选主。<br><img src="/images/raft/election_flow_error_leader_2.png" alt="election_flow_error_leader_2"></p>
<p>4个节点的选主过程和5个节点的类似，在选出一个新的<code>leader</code>后，原来的<code>Leader</code>恢复了又重新加入了，这个时候怎么处理？在Raft里，第几轮选举是有记录的，重新加入的<code>Leader</code>是第一轮选举(Term 1)选出来的，而现在的<code>Leader</code>则是Term 2，所有原来的<code>Leader</code>会自觉降级为<code>Follower</code><br><img src="/images/raft/election_flow_error_leader_3.png" alt="election_flow_error_leader_3"><br><img src="/images/raft/election_flow_error_leader_4.png" alt="election_flow_error_leader_4"><br><img src="/images/raft/election_flow_error_leader_5.png" alt="election_flow_error_leader_5"><br><img src="/images/raft/election_flow_error_leader_6.png" alt="election_flow_error_leader_6"></p>
<h3 id="多个Candidate情况下的Leader选举"><a href="#多个Candidate情况下的Leader选举" class="headerlink" title="多个Candidate情况下的Leader选举"></a>多个Candidate情况下的Leader选举</h3><p><img src="/images/raft/election_flow_mult_cand_1.png" alt="election_flow_mult_cand_1"></p>
<p>有两个<code>Follower</code>同时Timeout，都变成了<code>Candidate</code>开始选举，分别给一个<code>Follower</code>发送了投票请求。<br><img src="/images/raft/election_flow_mult_cand_3.png" alt="election_flow_mult_cand_2"></p>
<p>两个<code>Follower</code>分别返回了ok，这时两个<code>Candidate</code>都只有2票，要3票才能被选成<code>Leader</code>。<br><img src="/images/raft/election_flow_mult_cand_3.png" alt="election_flow_mult_cand_3"></p>
<p>两个<code>Candidate</code>会分别给另外一个还没有给自己投票的<code>Follower</code>发送投票请求。<br><img src="/images/raft/election_flow_mult_cand_4.png" alt="election_flow_mult_cand_4"></p>
<p>但是因为<code>Follower</code>在这一轮选举中，都已经投完票了，所以都拒绝了他们的请求。所以在Term 2没有<code>Leader</code>被选出来。<br><img src="/images/raft/election_flow_mult_cand_5.png" alt="election_flow_mult_cand_5"></p>
<p>这时，两个节点的状态是<code>Candidate</code>，两个是<code>Follower</code>，但是他们的倒计时器仍然在运行，最先Timeout的那个节点会进行发起新一轮Term 3的投票。<br><img src="/images/raft/election_flow_mult_cand_6.png" alt="election_flow_mult_cand_6"></p>
<p>两个<code>Follower</code>在Term 3还没投过票，所以返回OK，这时<code>Candidate</code>一共有三票，被选为了<code>Leader</code>。<br><img src="/images/raft/election_flow_mult_cand_7.png" alt="election_flow_mult_cand_7"></p>
<p>如果<code>Leader</code> Heartbeat的时间晚于另外一个<code>Candidate</code> timeout的时间，另外一个<code>Candidate</code>仍然会发送选举请求。<br><img src="/images/raft/election_flow_mult_cand_8.png" alt="election_flow_mult_cand_8"></p>
<p>两个<code>Follower</code>已经投完票了，拒绝了这个<code>Candidate</code>的投票请求。<br><img src="/images/raft/election_flow_mult_cand_9.png" alt="election_flow_mult_cand_9"></p>
<p><code>Leader</code>进行Heartbeat，<code>Candidate</code>收到后状态自动转为<code>Follower</code>，完成选举。<br><img src="/images/raft/election_flow_mult_cand_10.png" alt="election_flow_mult_cand_10"></p>
<h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><p>Raft 在实际应用场景中的一致性更多的是体现在不同节点之间的数据一致性，客户端发送请求到任何一个节点都能收到一致的返回，当一个节点出故障后，其他节点仍然能以已有的数据正常进行。在选主之后的复制日志就是为了达到这个目的。</p>
<p><img src="/images/raft/log_replication_normal.jpg" alt="log_replication_normal"></p>
<h2 id="正常情况下日志复制过程"><a href="#正常情况下日志复制过程" class="headerlink" title="正常情况下日志复制过程"></a>正常情况下日志复制过程</h2><p><img src="/images/raft/log_replication_normal_step_1.png" alt="log_replication_normal_step_1"></p>
<p>客户端发送请求给<code>Leader</code>，储存数据 “sally”，<code>Leader</code>先将数据写在本地日志，这时候数据还是Uncommitted (还没最终确认，红色表示)<br><img src="/images/raft/log_replication_normal_step_2.png" alt="log_replication_normal_step_2"></p>
<p><code>Leader</code>给两个<code>Follower</code>发送AppendEntries请求，数据在<code>Follower</code>上没有冲突，则将数据暂时写在本地日志，<code>Follower</code>的数据也还是Uncommitted。<br><img src="/images/raft/log_replication_normal_step_3.png" alt="log_replication_normal_step_3"></p>
<p><code>Follower</code>将数据写到本地后，返回OK。<code>Leader</code>收到后成功返回，只要收到的成功的返回数量超过半数(包含<code>Leader</code>)，<code>Leader</code>将数据 “sally” 的状态改成Committed。( 这个时候<code>Leader</code>就可以返回给客户端了)<br><img src="/images/raft/log_replication_normal_step_4.png" alt="log_replication_normal_step_4"></p>
<p><code>Leader</code>再次给<code>Follower</code>发送AppendEntries请求，收到请求后，<code>Follower</code>将本地日志里Uncommitted数据改成Committed。这样就完成了一整个复制日志的过程，三个节点的数据是一致的<br><img src="/images/raft/log_replication_normal_step_5.png" alt="log_replication_normal_step_5"></p>
<h2 id="Network-Partition情况下日志复制过程"><a href="#Network-Partition情况下日志复制过程" class="headerlink" title="Network Partition情况下日志复制过程"></a>Network Partition情况下日志复制过程</h2><p>在Network Partition的情况下，部分节点之间没办法互相通信，Raft 也能保证在这种情况下数据的一致性。</p>
<p><img src="/images/raft/log_replication_np_1.png" alt="log_replication_np_1"></p>
<p>Network Partition将节点分成两边，一边有两个节点，一边三个节点。<br><img src="/images/raft/log_replication_np_2.png" alt="log_replication_np_2"></p>
<p>两个节点这边已经有<code>Leader</code>了，来自客户端的数据“bob”通过<code>Leader</code>同步到<code>Follower</code>。<br><img src="/images/raft/log_replication_np_3.png" alt="log_replication_np_3"></p>
<p>因为只有两个节点，少于3个节点，所以“bob”的状态仍是Uncommitted。所以在这里，服务器会返回错误给客户端<br><img src="/images/raft/log_replication_np_4.png" alt="log_replication_np_4"></p>
<p>另外一个Partition有三个节点，进行重新选主。客户端数据“tom”发到新的<code>Leader</code>，通过和上节网络状态下相似的过程，同步到另外两个<code>Follower</code>。<br><img src="/images/raft/log_replication_np_5.png" alt="log_replication_np_5"></p>
<p>因为这个Partition有3个节点，超过半数，所以数据“tom”都Commit了。<br><img src="/images/raft/log_replication_np_6.png" alt="log_replication_np_6"><br><img src="/images/raft/log_replication_np_7.png" alt="log_replication_np_7"><br><img src="/images/raft/log_replication_np_8.png" alt="log_replication_np_8"></p>
<p>网络状态恢复，5个节点再次处于同一个网络状态下。但是这里出现了数据冲突“bob”和“tom”<br><img src="/images/raft/log_replication_np_9.png" alt="log_replication_np_9"></p>
<p>三个节点的<code>Leader</code>广播AppendEntries<br><img src="/images/raft/log_replication_np_10.png" alt="log_replication_np_10"></p>
<p>两个节点Partition的<code>Leader</code>自动降级为<code>Follower</code>，因为这个Partition的数据 “bob” 没有Commit，返回给客户端的是错误，客户端知道请求没有成功，所以<code>Follower</code>在收到AppendEntries请求时，可以把“bob“删除，然后同步”tom”，通过这么一个过程，就完成了在Network Partition情况下的复制日志，保证了数据的一致性。<br><img src="/images/raft/log_replication_np_11.png" alt="log_replication_np_11"><br><img src="/images/raft/log_replication_np_12.png" alt="log_replication_np_12"></p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h2 id="Election-safety"><a href="#Election-safety" class="headerlink" title="Election safety"></a>Election safety</h2><p>选举安全性，即任一任期内最多一个<code>leader</code>被选出。这一点非常重要，在一个复制集中任何时刻只能有一个<code>leader</code>。系统中同时有多余一个<code>leader</code>，被称之为脑裂（brain split），这是非常严重的问题，会导致数据的覆盖丢失。</p>
<ul>
<li>一个节点某一任期内最多只能投一票</li>
<li>只有获得多数票的节点才会成为<code>leader</code></li>
</ul>
<h2 id="log-matching"><a href="#log-matching" class="headerlink" title="log matching"></a>log matching</h2><p>如果两个节点上的某个log entry的log index相同且term相同，那么在该index之前的所有log entry应该都是相同的。在没有异常的情况下，log matching是很容易满足的，但如果出现了node crash，情况就会变得复杂了。</p>
<p><img src="/images/raft/safety_log_matching.png" alt="safety_log_matching"><br>*** 上图的a-f不是6个follower，而是某个follower可能存在的六个状态 ***</p>
<ul>
<li>比<code>leader</code>日志少: a,b</li>
<li>比<code>leader</code>日志多：c,d</li>
<li>某些位置比<code>leader</code>多，某些日志比<code>leader</code>少：e,f</li>
</ul>
<p>当出现了<code>leader</code>与<code>follower</code>不一致的情况，<code>leader</code>强制<code>follower</code>复制自己的log。</p>
<h2 id="leader-completeness"><a href="#leader-completeness" class="headerlink" title="leader completeness"></a>leader completeness</h2><ul>
<li>一个日志被复制到多数节点才算committed</li>
<li>一个节点得到多数的投票才能成为<code>leader</code>，而节点A给节点B投票的其中一个前提是，B的日志不能比A的日志旧</li>
</ul>
<h2 id="State-Machine-Safety"><a href="#State-Machine-Safety" class="headerlink" title="State Machine Safety"></a>State Machine Safety</h2><p>如果节点将某一位置的log entry应用到了状态机，那么其他节点在同一位置不能应用不同的日志。简单点来说，所有节点在同一位置（index in log entries）应该应用同样的日志。</p>
<p><img src="/images/raft/safety_state_machine.png" alt="safety_state_machine"></p>
<ul>
<li>(a)时刻, s1是leader，在term2提交的日志只赋值到了s1 s2两个节点就crash了。</li>
<li>(b)时刻, s5成为了term 3的<code>leader</code>，日志只赋值到了s5，然后crash。</li>
<li>(c)时刻，s1又成为了term 4的<code>leader</code>，开始赋值日志，于是把term2的日志复制到了s3，此刻，可以看出term2对应的日志已经被复制到了多数节点上，因此是committed，可以被状态机应用。</li>
<li>(d)时刻，s1又crash了，s5重新当选，然后将term3的日志复制到所有节点，这就出现了一种奇怪的现象：被复制到大多数节点（或者说可能已经应用）的日志被回滚。</li>
</ul>
<p>因为term4时的<code>leader</code> s1在(c)时刻提交了之前term2任期的日志。某个<code>leader</code>选举成功之后，不会直接提交前任<code>leader</code>时期的日志，而是通过提交当前任期的日志的时候“顺手”把之前的日志也提交了，具体怎么实现了，在log matching部分有详细介绍。那么问题来了，如果<code>leader</code>被选举后没有收到客户端的请求呢，论文中有提到，在任期开始的时候发立即尝试复制、提交一条空的log。</p>
<p>因此，在上图中，不会出现（C）时刻的情况，即term4任期的<code>leader</code> s1不会复制term2的日志到s3。而是如同(e)描述的情况，通过复制-提交term4的日志顺便提交term2的日志。如果term4的日志提交成功，那么term2的日志也一定提交成功，此时即使s1 crash，s5也不会重新当选。</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e4bbe7e276c">共识算法：Raft</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xybaby/p/10124083.html">一文搞懂Raft算法</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32052223">Raft算法详解</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.itpub.net/31556438/viewspace-2637112/">10分钟弄懂Raft算法</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhoubofsy.github.io/2020/11/07/network/rdma/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bolog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/07/network/rdma/" class="post-title-link" itemprop="url">RDMA</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-07 10:27:04" itemprop="dateCreated datePublished" datetime="2020-11-07T10:27:04+08:00">2020-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-09 15:57:18" itemprop="dateModified" datetime="2024-09-09T15:57:18+08:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在数据中心领域，远程直接内存访问（英语：remote direct memory access，RDMA）是一种绕过远程主机操作系统内核访问其内存中数据的技术，由于不经过操作系统，不仅节省了大量CPU资源，同样也提高了系统吞吐量、降低了系统的网络通信延迟，尤其适合在大规模并行计算机集群中有广泛应用。在基于NVMe over Fabric的数据中心中，RDMA可以配合高性能的NVMe SSD构建高性能、低延迟的存储网络。</p>
<p>Red Hat和甲骨文公司等软件供应商已经在其最新产品中支持这些API，截至2013年，工程师也已开始开发基于以太网的RDMA网络适配器。Red Hat Enterprise Linux和Red Hat Enterprise MRG已支持RDMA。微软已在Windows Server 2012中通过SMB Direct支持RDMA。</p>
<h1 id="RDMA-原理"><a href="#RDMA-原理" class="headerlink" title="RDMA 原理"></a>RDMA 原理</h1><p>传统的基于Socket套接字（TCP&#x2F;IP协议栈）的网络通信需要经过操作系统协议栈。数据在系统中搬来搬去，因此占用了大量的CPU和内存资源，也加大了网络延时。RDMA解决了传统Socket通信的痛点，采用了Kernel Bypass的工作方式，减少了CPU和内存的占用，也降低了网络延时。</p>
<p><img src="/images/rdma/rdma_theory.jpg" alt="rdma_theory"></p>
<p>目前RDMA有三种不同的硬件实现，分别是InfiniBand、iWARP（internet wide area RDMA Protocol）、RoCE（RDMA over Coverged Ethernet）。</p>
<p><img src="/images/rdma/rdma_theory_2.jpg" alt="rdma_theory_2"></p>
<ul>
<li>Infiniband<br>  支持RDMA的新一代网络协议。 由于这是一种新的网络技术，因此需要支持该技术的NIC和交换机。</li>
<li>RoCE<br>  一个允许在以太网上执行RDMA的网络协议。 其较低的网络标头是以太网标头，其较高的网络标头（包括数据）是InfiniBand标头。 这支持在标准以太网基础设施(交换机)上使用RDMA。 只有网卡应该是特殊的，支持RoCE。<br>  RoCE v1是一种链路层协议，允许在同一个广播域下的任意两台主机直接访问。<br>  RoCE v2是一种Internet层协议，即可以实现路由功能。</li>
<li>iWARP<br>  一个允许在TCP上执行RDMA的网络协议。 IB和RoCE中存在的功能在iWARP中不受支持。 这支持在标准以太网基础设施(交换机)上使用RDMA。</li>
</ul>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p>** QP(Queue Pair) **</p>
<p>每对QP由Send Queue(SQ)和Receive Queue(RQ)构成，这些队列中管理着各种类型的消息。QP会被映射到应用的虚拟地址空间，使得应用直接通过它访问RNIC网卡。</p>
<p>** CQ(Complete Queue) **</p>
<ol>
<li>完成队列包含了发送到工作队列（WQ）中已完成的工作请求（WR）。每次完成表示一个特定的 WR执行完毕（包括成功完成的WR和不成功完成的WR）。完成队列是一个用来告知应用程序已结束的工作请求的信息（状态、操作码、大小、来源）的机制。</li>
<li>CQ有n个完成队列实体（CQE）。CQE的数量在CQ创建的时候被指定。</li>
<li>当一个CQP被轮询到，它就从CQ中被删除。</li>
<li>CQ是一个CQE的先进选出（FIFO）队列。</li>
<li>CQ能服务于发送队列、接收队列或者同时服务于这两种队列。多个不同QP中的工作请求（WQ）可联系到同一个CQ上。</li>
</ol>
<p>** MR(Memory Region) **</p>
<ol>
<li>内存注册机制允许应用程序申请一些连续的虚拟内存空间或者连续的物理内存空间，将这些内存空间提供给网络适配器作为虚拟的连续缓冲区，缓冲区使用虚拟地址。</li>
<li>内存注册进程锁定了内存页。（为了防止页被替换出去，同时保持物理和虚拟内存的映射）在注册期间，操作系统检查被注册块的许可。注册进程将虚拟地址与物理地址的映射表写入网络适配器。在注册内存时，对应内存区域的权限会被设定。权限包括本地写、远程读、远程写、原子操作、绑定。</li>
<li>每个内存注册（MR）有一个远程的和一个本地的key（r_key，l_key）。本地key被本地的HCA 用来访问本地内存，例如在接收数据操作的期间。远程key提供给远程HCA用来在RDMA操作期间允许远程进程访问本地的系统内存。同一内存缓冲区可以被多次注册（甚至设置不同的操作权限），并且每次注册都会生成不同的key。</li>
</ol>
<p>** HCA **</p>
<ol>
<li>Opening an HCA 打开HCA，准备好HCA供消费者使用。一旦打开了一个HCA设备，只有关闭它以后，才能再次打开。</li>
<li>HCA属性 HCA属性是设备特征，这些属性必须可以被消费者获取。</li>
<li>修改HCA属性 HCA允许修改一组&#x3D;&#x3D;受限制的&#x3D;&#x3D;HCA属性。这些可以修改的属性主要是性能信息和错误计数器管理性息。其他大部分属性或是不可修改的，或是通过General Services Interface &#x2F; Fabric Management Interface进行操作。</li>
<li>关闭HCA 将HCA恢复到初始条件下，同时注销打开HCA时分配的资源。</li>
</ol>
<p>** 寻址 **</p>
<ol>
<li>源端地址 CI(Channel Interface)需要存储每个HCA有效的LID和GID。</li>
<li>目的地址 对于RC服务类型来说，目的地址被保存在本地QP的属性中。</li>
<li>Loopback 由于自寻址的需要，HCA需要支持Loopback。Loopback仅支持于一个HCA中，同一个端口下的QP之间进行。</li>
</ol>
<p>** Protection Domain **</p>
<ol>
<li>PD通过在QP&#x2F;SRQ与MR之间建立联系，获得HCA访问主存的权限。此外，PD还可以用来关联QP和未绑定的内存窗口，用来控制HCA访问主系统内存。</li>
<li>分配保护域 当创建QP，注册MR，分配MW,创建Address Handle时需要分配PD。</li>
<li>释放保护域 如果PD仍然与任何队列对、内存区域、内存窗口、SRQ或地址句柄相关联，则不应释放它。如果尝试这样做，则谓词将立即返回一个错误。</li>
</ol>
<h2 id="RDMA-工作流程"><a href="#RDMA-工作流程" class="headerlink" title="RDMA 工作流程"></a>RDMA 工作流程</h2><ol>
<li>当一个应用执行RDMA读或写请求时，不执行任何数据复制。在不需要任何内核内存参与的条件下，RDMA请求从运行在用户空间中的应用中发送到本地NIC(网卡)。</li>
<li>NIC读取缓冲的内容，并通过网络传送到远程NIC。</li>
<li>在网络上传输的RDMA信息包含目标虚拟地址、内存钥匙和数据本身。请求既可以完全在用户空间中处理(通过轮询用户级完成排列) ，又或者在应用一直睡眠到请求完成时的情况下通过系统中断处理。RDMA操作使应用可以从一个远程应用的内存中读数据或向这个内存写数据。</li>
<li>目标NIC确认内存钥匙，直接将数据写人应用缓存中。用于操作的远程虚拟内存地址包含在RDMA信息中。</li>
</ol>
<h1 id="RDMA-API"><a href="#RDMA-API" class="headerlink" title="RDMA API"></a>RDMA API</h1><p>RDMA API (Verbs)主要有两种操作方式，One-Sided RDMA。包括RDMA Reads, RDMA Writes, RDMA Atomic。这种模式下的RDMA访问完全不需要远端机的任何确认；Two-Sided RDMA。包括RDMA Send, RDMA Receive。这种模式下的RDMA访问需要远端机CPU的参与。</p>
<h2 id="Two-Side-RDMA"><a href="#Two-Side-RDMA" class="headerlink" title="Two-Side RDMA"></a>Two-Side RDMA</h2><ol>
<li>首先，A和B都要创建并初始化好各自的QP，CQ</li>
<li>A和B分别向自己的WQ中注册WQE，对于A，WQ&#x3D;SQ，WQE描述指向一个等到被发送的数据；对于B，WQ&#x3D;RQ，WQE描述指向一块用于存储数据的Buffer。</li>
<li>A的RNIC异步调度轮到A的WQE，解析到这是一个SEND消息，从Buffer中直接向B发出数据。数据流到达B的RNIC后，B的WQE被消耗，并把数据直接存储到WQE指向的存储位置。</li>
<li>AB通信完成后，A的CQ中会产生一个完成消息CQE表示发送完成。与此同时，B的CQ中也会产生一个完成消息表示接收完成。每个WQ中WQE的处理完成都会产生一个CQE。</li>
</ol>
<p>** 双边操作与传统网络的底层Buffer Pool类似，收发双方的参与过程并无差别，区别在零拷贝、Kernel Bypass，实际上对于RDMA，这是一种复杂的消息传输模式，多用于传输短的控制消息。 **</p>
<h3 id="RDMA通信流程"><a href="#RDMA通信流程" class="headerlink" title="RDMA通信流程"></a>RDMA通信流程</h3><ol>
<li>获取RDMA设备列表(ibv_get_device_list)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 获取设备列表 */</span></span><br><span class="line"><span class="type">int</span> num_devices;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_device</span> **<span class="title">dev_list</span> =</span> ibv_get_device_list(&amp;num_devices);</span><br><span class="line"><span class="keyword">if</span> (!dev_list || !num_devices)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to get IB devices\n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>打开一个RDMA设备，获取一个上下文(ibv_open_device ibv_context)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 2 打开设备，获取设备上下文 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_device</span> *<span class="title">ib_dev</span> =</span> dev_list[<span class="number">0</span>];</span><br><span class="line">res.ib_ctx = ibv_open_device(ib_dev);</span><br><span class="line"><span class="keyword">if</span> (!res.ib_ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to open device \n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>释放RDMA设备列表占用的资源(ibv_free_device_list)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 3 释放设备列表占用的资源 */</span></span><br><span class="line">ibv_free_device_list(dev_list);</span><br><span class="line">dev_list = <span class="literal">NULL</span>;</span><br><span class="line">ib_dev = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li>
<li>查询RDMA设备端口信息(ibv_query_port ibv_port_attr)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 4 查询设备端口状态 */</span></span><br><span class="line"><span class="keyword">if</span> (ibv_query_port(res.ib_ctx, <span class="number">1</span>, &amp;res.port_attr))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ibv_query_port on port failed\n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分配一个Protection Domain (ibv_alloc_pd ibv_pd)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 5 创建PD（Protection Domain） */</span></span><br><span class="line">res.pd = ibv_alloc_pd(res.ib_ctx);</span><br><span class="line"><span class="keyword">if</span> (!res.pd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ibv_alloc_pd failed\n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建一个Complete Queue (ibv_create_cq ibv_cq)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 6 创建CQ（Complete Queue） */</span></span><br><span class="line"><span class="type">int</span> cq_size = <span class="number">10</span>;</span><br><span class="line">res.cq = ibv_create_cq(res.ib_ctx, cq_size, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!res.cq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to create CQ with %u entries\n&quot;</span>, cq_size);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注册一块Memory Region (ibv_reg_mr ibv_mr)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 7 注册MR（Memory Region） */</span></span><br><span class="line"><span class="type">int</span> size = MSG_SIZE;</span><br><span class="line">res.buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="keyword">if</span> (!res.buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to malloc %Zu bytes to memory buffer\n&quot;</span>, size);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(res.buf, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mr_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;</span><br><span class="line">res.mr = ibv_reg_mr(res.pd, res.buf, size, mr_flags);</span><br><span class="line"><span class="keyword">if</span> (!res.mr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ibv_reg_mr failed with mr_flags=0x%x\n&quot;</span>, mr_flags);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\n&quot;</span>,</span><br><span class="line">res.buf, res.mr-&gt;lkey, res.mr-&gt;rkey, mr_flags);</span><br></pre></td></tr></table></figure></li>
<li>创建一个Queue Pair (ibv_create_qp ibv_qp)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 创建QP（Queue Pair） */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp_init_attr</span> <span class="title">qp_init_attr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;qp_init_attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(qp_init_attr));</span><br><span class="line">qp_init_attr.qp_type = IBV_QPT_RC;</span><br><span class="line">qp_init_attr.sq_sig_all = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.send_cq = res.cq;</span><br><span class="line">qp_init_attr.recv_cq = res.cq;</span><br><span class="line">qp_init_attr.cap.max_send_wr = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.cap.max_recv_wr = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.cap.max_send_sge = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.cap.max_recv_sge = <span class="number">1</span>;</span><br><span class="line">res.qp = ibv_create_qp(res.pd, &amp;qp_init_attr);</span><br><span class="line"><span class="keyword">if</span> (!res.qp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to create QP\n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;QP was created, QP number=0x%x\n&quot;</span>, res.qp-&gt;qp_num);</span><br></pre></td></tr></table></figure></li>
<li>交换控制信息 (使用Socket)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 9 交换控制信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cm_con_data_t</span> <span class="title">local_con_data</span>;</span>  <span class="comment">// 发送给远程主机的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cm_con_data_t</span> <span class="title">remote_con_data</span>;</span> <span class="comment">// 接收远程主机发送过来的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cm_con_data_t</span> <span class="title">tmp_con_data</span>;</span></span><br><span class="line"></span><br><span class="line">local_con_data.addr = htonll((<span class="type">uintptr_t</span>)res.buf);</span><br><span class="line">local_con_data.rkey = htonl(res.mr-&gt;rkey);</span><br><span class="line">local_con_data.qp_num = htonl(res.qp-&gt;qp_num);</span><br><span class="line">local_con_data.lid = htons(res.port_attr.lid);</span><br><span class="line"><span class="keyword">if</span> (sock_sync_data(server_ip, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">cm_con_data_t</span>), (<span class="type">char</span> *)&amp;local_con_data, (<span class="type">char</span> *)&amp;tmp_con_data) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to exchange connection data between sides\n&quot;</span>);</span><br><span class="line">    rc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> main_exit;</span><br><span class="line">&#125;</span><br><span class="line">remote_con_data.addr = ntohll(tmp_con_data.addr);</span><br><span class="line">remote_con_data.rkey = ntohl(tmp_con_data.rkey);</span><br><span class="line">remote_con_data.qp_num = ntohl(tmp_con_data.qp_num);</span><br><span class="line">remote_con_data.lid = ntohs(tmp_con_data.lid);</span><br><span class="line"><span class="comment">/* save the remote side attributes, we will need it for the post SR */</span></span><br><span class="line">res.remote_props = remote_con_data;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Remote address = 0x%&quot;</span> PRIx64 <span class="string">&quot;\n&quot;</span>, remote_con_data.addr);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Remote rkey = 0x%x\n&quot;</span>, remote_con_data.rkey);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Remote QP number = 0x%x\n&quot;</span>, remote_con_data.qp_num);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Remote LID = 0x%x\n&quot;</span>, remote_con_data.lid);</span><br></pre></td></tr></table></figure></li>
<li>转换QP状态(ibv_modify_qp)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 10 转换QP状态 */</span></span><br><span class="line"><span class="comment">// RESET -&gt; INIT</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp_attr</span> <span class="title">attr</span>;</span></span><br><span class="line"><span class="type">int</span> flags;</span><br><span class="line"><span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">attr.qp_state = IBV_QPS_INIT;</span><br><span class="line">attr.port_num = <span class="number">1</span>; <span class="comment">// IB 端口号</span></span><br><span class="line">attr.pkey_index = <span class="number">0</span>;</span><br><span class="line">attr.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;</span><br><span class="line">flags = IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS;</span><br><span class="line">rc = ibv_modify_qp(res.qp, &amp;attr, flags);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to modify QP state to INIT\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//INIT -&gt; RTR(Ready To Receive)</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">attr.qp_state = IBV_QPS_RTR;</span><br><span class="line">attr.path_mtu = IBV_MTU_256;</span><br><span class="line">attr.dest_qp_num = res.remote_props.qp_num;</span><br><span class="line">attr.rq_psn = <span class="number">0</span>;</span><br><span class="line">attr.max_dest_rd_atomic = <span class="number">1</span>;</span><br><span class="line">attr.min_rnr_timer = <span class="number">0x12</span>;</span><br><span class="line">attr.ah_attr.is_global = <span class="number">0</span>;</span><br><span class="line">attr.ah_attr.dlid = res.remote_props.lid;</span><br><span class="line">attr.ah_attr.sl = <span class="number">0</span>;</span><br><span class="line">attr.ah_attr.src_path_bits = <span class="number">0</span>;</span><br><span class="line">attr.ah_attr.port_num = <span class="number">1</span>;</span><br><span class="line">flags = IBV_QP_STATE | IBV_QP_AV | IBV_QP_PATH_MTU | IBV_QP_DEST_QPN | IBV_QP_RQ_PSN | IBV_QP_MAX_DEST_RD_ATOMIC | IBV_QP_MIN_RNR_TIMER;</span><br><span class="line">rc = ibv_modify_qp(res.qp, &amp;attr, flags);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to modify QP state to RTR\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//RTR -&gt; RTS(Ready To Send)</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">attr.qp_state = IBV_QPS_RTS;</span><br><span class="line">attr.timeout = <span class="number">0x12</span>;</span><br><span class="line">attr.retry_cnt = <span class="number">6</span>;</span><br><span class="line">attr.rnr_retry = <span class="number">0</span>;</span><br><span class="line">attr.sq_psn = <span class="number">0</span>;</span><br><span class="line">attr.max_rd_atomic = <span class="number">1</span>;</span><br><span class="line">flags = IBV_QP_STATE | IBV_QP_TIMEOUT | IBV_QP_RETRY_CNT | IBV_QP_RNR_RETRY | IBV_QP_SQ_PSN | IBV_QP_MAX_QP_RD_ATOMIC;</span><br><span class="line">rc = ibv_modify_qp(res.qp, &amp;attr, flags);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to modify QP state to RTS\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>状态：RESET -&gt; INIT -&gt; RTR -&gt; RTS</li>
<li>要严格按照顺序进行转换</li>
<li>QP刚创建时状态为RESET</li>
<li>INIT之后就可以调用ibv_post_recv提交一个receive buffer了</li>
<li>当QP进入RTR(ready to receive)状态以后，便开始进行接收处理</li>
<li>RTR之后便可以转为RTS(ready to send)，RTS状态下可以调用ibv_post_send</li>
</ul>
</li>
<li>创建发送任务&#x2F;接收任务(ibv_send_wr&#x2F;ibv_recv_wr)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 11 创建发送任务ibv_send_wr */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">sr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">sge</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> *<span class="title">bad_wr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"><span class="comment">/* prepare the scatter/gather entry */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sge, <span class="number">0</span>, <span class="keyword">sizeof</span>(sge));</span><br><span class="line">sge.addr = (<span class="type">uintptr_t</span>)res-&gt;buf;</span><br><span class="line">sge.length = MSG_SIZE;</span><br><span class="line">sge.lkey = res-&gt;mr-&gt;lkey;</span><br><span class="line"><span class="comment">/* prepare the send work request */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sr, <span class="number">0</span>, <span class="keyword">sizeof</span>(sr));</span><br><span class="line">sr.next = <span class="literal">NULL</span>;</span><br><span class="line">sr.wr_id = <span class="number">0</span>;</span><br><span class="line">sr.sg_list = &amp;sge;</span><br><span class="line">sr.num_sge = <span class="number">1</span>;</span><br><span class="line">sr.opcode = opcode;</span><br><span class="line">sr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line"><span class="keyword">if</span> (opcode != IBV_WR_SEND)</span><br><span class="line">&#123;</span><br><span class="line">    sr.wr.rdma.remote_addr = res-&gt;remote_props.addr;</span><br><span class="line">    sr.wr.rdma.rkey = res-&gt;remote_props.rkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该任务会被提交到QP中的SQ（Send Queue）中</li>
<li>发送任务有三种操作：Send,Read,Write。Send操作需要对方执行相应的Receive操作；Read&#x2F;Write直接操作对方内存，对方无感知。</li>
<li>把要发送的数据的内存地址，大小，密钥告诉HCA</li>
<li>Read&#x2F;Write还需要告诉HCA远程的内存地址和密钥</li>
</ul>
</li>
<li>提交发送任务&#x2F;接收任务(ibv_post_send&#x2F;ibv_post_recv)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rc = ibv_post_send(res-&gt;qp, &amp;sr, &amp;bad_wr);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to post SR\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure></li>
<li>轮询任务完成信息(ibv_poll_cq)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 13 轮询任务结果 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> <span class="title">wc</span>;</span></span><br><span class="line"><span class="type">int</span> poll_result;</span><br><span class="line"><span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    poll_result = ibv_poll_cq(res-&gt;cq, <span class="number">1</span>, &amp;wc);</span><br><span class="line">&#125; <span class="keyword">while</span> (poll_result == <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="QP状态转换"><a href="#QP状态转换" class="headerlink" title="QP状态转换"></a>QP状态转换</h3><p><img src="/images/rdma/rdma_qp_status.jpg" alt="rdma_qp_status"></p>
<h4 id="Reset-State"><a href="#Reset-State" class="headerlink" title="Reset State"></a>Reset State</h4><ol>
<li>该状态为QP新创建时的初始状态</li>
<li>在不删除QP的情况下，仅能通过Modify Queue Pair Attributes verb跳出该状态</li>
<li>该状态下向QP提交WR，将会返回错误，远端到来的消息也会直接被忽略</li>
<li>通过利用verbs修改QP属性，可以将任何状态的QP转换为Reset状态。</li>
</ol>
<h4 id="Initialized-State"><a href="#Initialized-State" class="headerlink" title="Initialized State"></a>Initialized State</h4><ol>
<li>仅能从Reset状态进入该状态</li>
<li>在不删除QP的情况下，仅能通过Modify Queue Pair Attributes verb跳出该状态</li>
<li>该状态下，RQ可以接受WR，但不会处理远端到来的消息，并将到来的消息丢弃</li>
<li>该状态下，向SQ发送WR会返回错误。</li>
</ol>
<h4 id="Ready-To-Receive-RTR-State"><a href="#Ready-To-Receive-RTR-State" class="headerlink" title="Ready To Receive(RTR) State"></a>Ready To Receive(RTR) State</h4><ol>
<li>在RTR状态下，RQ可以接受WR，从远端到来的消息也会正常处理</li>
<li>该状态下，向SQ发送WR会返回错误。</li>
</ol>
<h4 id="Ready-To-Send-RTS-State"><a href="#Ready-To-Send-RTS-State" class="headerlink" title="Ready To Send(RTS) State"></a>Ready To Send(RTS) State</h4><ol>
<li>在RTS状态下，请求端和应答端面向连接的服务类型的通道已经建立</li>
<li>仅能由RTR和SQD状态进入该状态</li>
<li>在不删除QP的情况下，仅能通过Modify Queue Pair Attributes verb跳出该状态</li>
<li>该状态下，向QP发送的WR会被正常处理，发送WR的verb也不会返回错误</li>
<li>该状态下，从远端到来的消息也正常处理。</li>
</ol>
<h4 id="Send-Queue-Drain-SQD-State"><a href="#Send-Queue-Drain-SQD-State" class="headerlink" title="Send Queue Drain(SQD) State"></a>Send Queue Drain(SQD) State</h4><ol>
<li>该状态下，向QP发送的WR会被正常处理，发送WR的verb也不会返回错误</li>
<li>该状态下，从远端到来的消息也正常处理</li>
<li>仅能由RTS进入该状态</li>
<li>当转移到该状态时，未处理的消息不能再处理，未处理完的消息必须处理完</li>
<li>当所有应答都已收到时，如果有事件提醒的请求，则会生成一个附加的异步事件<br> a. 消费者可以利用异步事件来确定状态转移的完成<br> b. 为确保安全的修改QP的属性，必须在接收到异步事件后在进行属性的更改。 </li>
<li>该状态下，提交到QP的WR会入队，但不会被处理</li>
<li>在SQ还没有Drained之前，SQD到RTS的状态转换不被允许，在该状况下转移，CI会报告一个立即的错误。</li>
</ol>
<h4 id="Send-Queue-Error-SQE-State"><a href="#Send-Queue-Error-SQE-State" class="headerlink" title="Send Queue Error(SQE) State"></a>Send Queue Error(SQE) State</h4><ol>
<li>该状态适用于除RC QP之外的所有QP</li>
<li>该状态仅会由RTS跳入，当处理SQ的WR时，发生完成错误(Completion Error)，会造成该转移</li>
<li>在该状态下，RQ可以接受WR，从远端到来的消息也会正常处理</li>
<li>发生了完成错误的WR必须通过CQ返回正确的完成错误码</li>
<li>由于SQ中的WR可能部份或全部执行，因此，接收端的状态是未知的</li>
<li>在SQ中导致完成错误的WR的下一条WR，必须通过CQ返回刷新错误(Flush Error)的完成状态</li>
<li>该状态下，可以通过Modify Queue Pair Attributes verb跳到RTS状态、Reset状态、Error状态。</li>
</ol>
<h4 id="Error-State"><a href="#Error-State" class="headerlink" title="Error State"></a>Error State</h4><ol>
<li>QP上的所有正常处理全部停止</li>
<li>由于WR发生完成错误，导致跳入该状态时，必须通过CQ返回完成错误码</li>
<li>该状态下，从远端收到的数据会被丢弃</li>
<li>在QP中导致完成错误的WR的下一条WR，必须通过CQ返回刷新错误(Flush Error)的完成状态。</li>
</ol>
<h2 id="One-Side-RDMA"><a href="#One-Side-RDMA" class="headerlink" title="One-Side RDMA"></a>One-Side RDMA</h2><ol>
<li>首先A、B建立连接，QP已经创建并且初始化。</li>
<li>数据被存档在A的buffer地址VA，注意VA应该提前注册到A的RNIC，并拿到返回的r_key，相当于RDMA操作这块buffer的权限。</li>
<li>A把数据地址VA，key封装到专用的报文传送到B，这相当于A把数据buffer的操作权交给了B。同时A在它的WQ中注册进一个WR，以用于接收数据传输的B返回的状态。</li>
<li>B在收到A的送过来的数据VA和r_key后，RNIC会把它们连同存储地址VB到封装RDMA READ，这个过程A、B两端不需要任何软件参与，就可以将A的数据存储到B的VB虚拟地址。</li>
<li>B在存储完成后，会向A返回整个数据传输的状态信息。</li>
</ol>
<p>** 单边操作传输方式是RDMA与传统网络传输的最大不同，只需提供直接访问远程的虚拟地址，无须远程应用的参与其中，这种方式适用于批量数据传输。 **</p>
<h1 id="参考-鸣谢"><a href="#参考-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/BtB5e6Nsu1g511Eg5XEg/article/details/80045487">RDMA技术原理分析、主流实现对比和解析</a></li>
<li><a target="_blank" rel="noopener" href="http://rinjilee.com/post_wukan/2019-09-28-RDMA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">RDMA学习笔记</a></li>
<li><a target="_blank" rel="noopener" href="http://www.360doc.com/content/19/0126/13/99071_811392560.shtml">详解RDMA架构和技术原理</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110898225">InfiniBand协议学习</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">博</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">145</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">122</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">博</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
